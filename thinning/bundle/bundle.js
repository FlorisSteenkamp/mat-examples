/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// This demo contrasts thinning done via a scale axis transform method and\n// thinning (also called erosion) done by the standard built-in morphology SVG \n// filter.\n//\n// The medial and scale axis transform libraries can be found on GitHub \n// here https://github.com/FlorisSteenkamp/MAT.\n// The demo is also available on GitHub under the examples at\n// https://github.com/FlorisSteenkamp/mat-examples\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst flo_mat_1 = __webpack_require__(/*! flo-mat */ \"./node_modules/flo-mat/node/index.js\");\nconst svg_functions_1 = __webpack_require__(/*! ./src/svg-functions */ \"./src/svg-functions.ts\");\nconst get_thinned_path_1 = __webpack_require__(/*! ./src/get-thinned-path */ \"./src/get-thinned-path.ts\");\nconst get_path_strs_1 = __webpack_require__(/*! ./src/get-path-strs */ \"./src/get-path-strs.ts\");\nconst create_select_options_1 = __webpack_require__(/*! ./src/create-select-options */ \"./src/create-select-options.ts\");\n(function () {\n    // Get the path strings for the letter glyphs.\n    const SVG_PATH_STRS = (0, get_path_strs_1.getPathStrs)();\n    // Get a handle on some SVG elements from the DOM.\n    let $svg = (document.getElementById('svg'));\n    let $svgErode = (document.getElementById('svg-erode'));\n    let $gErode = (document.getElementById('g-erode'));\n    // Get / create some more html elements\n    let $shapeSelect = document.getElementById('shape-select');\n    let $thinSlider = document.getElementById('thin-slider');\n    let $erodeSlider = document.getElementById('erode-slider');\n    (0, create_select_options_1.createSelectOptions)($shapeSelect, SVG_PATH_STRS);\n    // Our path objects\n    let $shapeThinOutline;\n    let $shapeThin;\n    let $shapeErodeOutline;\n    let $shapeErode;\n    // The medial axis transforms\n    let mats;\n    let sats = [];\n    // The scale axis transform parameter\n    let s = 2.5;\n    // The letter shape at its thickest\n    let thickestWidth;\n    // Set slider and select change events\n    $shapeSelect.onchange = onShapeChanged;\n    $thinSlider.oninput = onThinPercentChanged;\n    $erodeSlider.oninput = erodeSliderChanged;\n    onShapeChanged();\n    /**\n     * Called when initially and when a different letter was selected\n     */\n    function onShapeChanged() {\n        // Remove prior SVGs\n        if ($shapeThinOutline) {\n            $shapeThinOutline.remove();\n        }\n        if ($shapeThin) {\n            $shapeThin.remove();\n        }\n        if ($shapeErodeOutline) {\n            $shapeErodeOutline.remove();\n        }\n        if ($shapeErode) {\n            $shapeErode.remove();\n        }\n        // Get new SVG path according to user selection\n        let svgPathStr = SVG_PATH_STRS[$shapeSelect.value];\n        // Get the array of bezier loops from the SVG path string\n        let bezierLoops = (0, flo_mat_1.getPathsFromStr)(svgPathStr);\n        // Get their medial axis transforms\n        mats = (0, flo_mat_1.findMats)(bezierLoops, 10);\n        // Get their scale axis transforms\n        sats = mats.map(mat => (0, flo_mat_1.toScaleAxis)(mat, s));\n        // Get new thickest width\n        thickestWidth = 0;\n        sats.forEach(sat => {\n            let r = sat.cpNode.cp.circle.radius;\n            if (r > thickestWidth) {\n                thickestWidth = r;\n            }\n        });\n        // Add new SVG paths\n        $shapeThinOutline = (0, svg_functions_1.addPath)($svg, svgPathStr, 'shape-path');\n        $shapeErodeOutline = (0, svg_functions_1.addPath)($svgErode, svgPathStr, 'shape-path');\n        $shapeErode = (0, svg_functions_1.addPath)($gErode, svgPathStr, 'shape-path-erode');\n        // Update viewboxes to fit letters to display\n        let bb = $svg.getBBox();\n        let viewBox = `${bb.x} ${bb.y} ${bb.width} ${bb.height}`;\n        $svg.setAttributeNS(null, 'viewBox', viewBox);\n        $svgErode.setAttributeNS(null, 'viewBox', viewBox);\n        onThinPercentChanged();\n        erodeSliderChanged();\n    }\n    /**\n     * Fires when the thinning percentage changed via the slider\n     */\n    function onThinPercentChanged() {\n        // Remove old thin path\n        if ($shapeThin) {\n            $shapeThin.remove();\n        }\n        // Get new thin fraction\n        let thinFraction = ($thinSlider.value) / 100;\n        // Get new path string\n        let pathStr = (0, get_thinned_path_1.getThinnedPath)(sats, thinFraction);\n        // Update SVG path\n        $shapeThin = (0, svg_functions_1.addPath)($svg, pathStr, 'thin');\n    }\n    function erodeSliderChanged() {\n        // Get erosion fraction\n        let erodeFraction = $erodeSlider.value / 100;\n        // Get erosion radius\n        let erodeRadius = thickestWidth * erodeFraction;\n        // Update SVG morphology filter erosion radius\n        let $feErode = document.getElementById('fe-erode');\n        $feErode.setAttributeNS(null, 'radius', erodeRadius.toString());\n    }\n})();\n\n\n//# sourceURL=webpack://thinning-ts/./index.ts?");

/***/ }),

/***/ "./src/create-select-options.ts":
/*!**************************************!*\
  !*** ./src/create-select-options.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSelectOptions = void 0;\n/**\n * Creates HTML select elements for the letters.\n */\nfunction createSelectOptions($select, svgPathStrs) {\n    for (let key of Object.keys(svgPathStrs)) {\n        let $option = document.createElement('option');\n        $option.setAttribute('value', key);\n        $option.innerHTML = '--- ' + key + ' ---';\n        $select.append($option);\n    }\n}\nexports.createSelectOptions = createSelectOptions;\n\n\n//# sourceURL=webpack://thinning-ts/./src/create-select-options.ts?");

/***/ }),

/***/ "./src/get-matching-beziers.ts":
/*!*************************************!*\
  !*** ./src/get-matching-beziers.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMatchingBeziers = void 0;\nconst flo_mat_1 = __webpack_require__(/*! flo-mat */ \"./node_modules/flo-mat/node/index.js\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n/**\n * Returns a correspondence between boundary bezier curves and a medial axis\n * bezier curve. They will later be interpolated to perform the thinning.\n * @param cpNode The CpNode representing the scale axis transform\n * - see the docs http://mat-demo.appspot.com/docs/index.html\n */\nfunction getMatchingBeziers(cpNode) {\n    let medialBezier = (0, flo_bezier3_1.toCubic)((0, flo_mat_1.getCurveToNext)(cpNode));\n    let boundaryBeziers = (0, flo_mat_1.getBoundaryBeziersToNext)(cpNode);\n    if (!boundaryBeziers) {\n        return [];\n    }\n    // If this is a leaf cpNode we return the boundary piece corresponding to \n    // the leaf untouched.\n    if ((0, flo_mat_1.isTerminating)(cpNode)) {\n        // If the cpNode represents a sharp corner the boundary is just a point\n        // and if it is a hole closer it is a dummy and the boundary does not\n        // exist.\n        if ((0, flo_mat_1.isSharp)(cpNode) || cpNode.isHoleClosing) {\n            return [];\n        }\n        // Map the entire boundary piece to the single medial axis point.\n        return boundaryBeziers.map(boundaryBezier => ({ boundaryBezier, medialBezier }));\n    }\n    // Get bezier length function from t=0 to t=1.\n    //let len = length([0,1]);\n    // Filter zero length boundary beziers unless there is only one of them.\n    boundaryBeziers = boundaryBeziers.length > 1\n        //? boundaryBeziers.filter(len)\n        //? boundaryBeziers.filter((ps: number[][]) => length([0,1], ps))\n        ? boundaryBeziers.filter(b => (0, flo_bezier3_1.totalLength)(b))\n        : boundaryBeziers;\n    // If the boundary consists of only one bezier curve then map the single \n    // boundary bezier to the single medial axis bezier.\n    if (boundaryBeziers.length === 1) {\n        return [{\n                boundaryBezier: boundaryBeziers[0],\n                medialBezier\n            }];\n    }\n    // At this stage multiple boundary beziers corresponds to a single medial\n    // axis bezier. We will now split up the medial bezier according to the\n    // relative lengths of the boundary beziers. Each split up medial bezier \n    // will be matched to its corresponding boundary bezier.\n    // Get length of medial bezier\n    let lenMedial = (0, flo_bezier3_1.totalLength)(medialBezier);\n    // Get length of boundary beziers\n    let lenBoundaries = boundaryBeziers.map(b => (0, flo_bezier3_1.totalLength)(b));\n    // Get total length of boundary beziers\n    let lenBoundaryTotal = lenBoundaries.reduce((sum, length_) => sum + length_, 0);\n    // Initialize matched bezier array\n    let matchedBeziers = [];\n    // The cumulative boundary piece length\n    let cumulativeLength = 0;\n    // The prior t parameter value of the medial bezier up to which a piece \n    // has already been matched\n    let priorT = 0;\n    // Create a function that return a piece of the medial bezier between two\n    // specified t parameter values.\n    // Iterate through all boundary beziers\n    for (let i = 0; i < boundaryBeziers.length; i++) {\n        let lenBoundary = lenBoundaries[i];\n        cumulativeLength += lenBoundary;\n        // Get the medial bezier t value corresponding to the relative \n        // cumulative length of the boundary up to this point\n        let t = (0, flo_bezier3_1.getTAtLength)(medialBezier, lenMedial * (cumulativeLength / lenBoundaryTotal));\n        // Clamp at 1 due to floating point roundoff - we should not go past 1.\n        t = Math.min(t, 1);\n        matchedBeziers.push({\n            boundaryBezier: boundaryBeziers[i],\n            medialBezier: (0, flo_bezier3_1.fromTo)(medialBezier, priorT, t)\n        });\n        priorT = t;\n    }\n    return matchedBeziers;\n}\nexports.getMatchingBeziers = getMatchingBeziers;\n\n\n//# sourceURL=webpack://thinning-ts/./src/get-matching-beziers.ts?");

/***/ }),

/***/ "./src/get-path-strs.ts":
/*!******************************!*\
  !*** ./src/get-path-strs.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPathStrs = void 0;\n/**\n * Get the SVG path strings from all the glyph elements in the document.\n */\nfunction getPathStrs() {\n    let $paths = Array.from(document.getElementsByTagName('glyph'));\n    let pathStrs = {};\n    for (let $path of $paths) {\n        let d = $path.getAttribute('d');\n        let char = $path.getAttribute('unicode');\n        pathStrs[char] = d;\n    }\n    return pathStrs;\n}\nexports.getPathStrs = getPathStrs;\n\n\n//# sourceURL=webpack://thinning-ts/./src/get-path-strs.ts?");

/***/ }),

/***/ "./src/get-thinned-path.ts":
/*!*********************************!*\
  !*** ./src/get-thinned-path.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getThinnedPath = void 0;\nconst get_matching_beziers_1 = __webpack_require__(/*! ./get-matching-beziers */ \"./src/get-matching-beziers.ts\");\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n/**\n * Performs linear interpolation between two 2d points and returns the resultant\n * point.\n * @param p1 The first point.\n * @param p2 The second point.\n * @param t The interpolation fraction in [0,1].\n */\nfunction interpolate(p1, p2, t) {\n    return [\n        p1[0] + t * (p2[0] - p1[0]),\n        p1[1] + t * (p2[1] - p1[1])\n    ];\n}\n/**\n * Get interpolated curve between original and thinned boundary.\n * @param cpNode The CpNode representing the medial axis and boundary piece.\n * @param c The thinning factor (from 0 to 1)\n */\nfunction getInterpolatedCurves(cpNode, c) {\n    return (0, get_matching_beziers_1.getMatchingBeziers)(cpNode).map(curve => {\n        let boundaryBezier = (0, flo_bezier3_1.toCubic)(curve.boundaryBezier);\n        return [0, 1, 2, 3].map(i => interpolate(boundaryBezier[i], curve.medialBezier[i], c));\n    });\n}\n/**\n * Returns the thinned SVG path string.\n * @param sats Scale axis transforms of the original shape\n * @param c The thinning fraction (from 0 to 1)\n */\nfunction getThinnedPath(sats, c) {\n    // An array of subpaths that will make up the thinned shape - for single \n    // shapes without holes it will only be a single path.\n    let pathStrs = [];\n    // Iterate through the scale axis transforms representing the shape - for\n    // single shapes without holes there will be only one sat.\n    for (let sat of sats) {\n        // Start node to iterate from - it also represents the maximum radius \n        // maximal disk.\n        let cpStart = sat.cpNode;\n        // We map each bezier curve of the thinned path to a specific simple \n        // closed loop - this is so we can have disjoint subpaths representing\n        // the shape envelopes and holes. There is probably a simpler way.\n        let curvesMap = new Map();\n        // Iterate through all boundary piece curves\n        let cpNode = cpStart;\n        do {\n            // Get the loop that this boundary piece belongs to\n            let loop = cpNode.cp.pointOnShape.curve.loop;\n            // Get the map entry holding all curves for the loop\n            let curves = curvesMap.get(loop);\n            if (!curves) {\n                curves = [];\n                curvesMap.set(loop, curves);\n            }\n            // Push the interpolated, i.e. thinned, curves\n            curves.push(...getInterpolatedCurves(cpNode, c));\n            // Go to next boundary piece\n            cpNode = cpNode.next;\n        } while (cpNode !== cpStart);\n        // Iterate through each set of curves belonging to a specific loop and\n        // create a subpath for it.\n        curvesMap.forEach(curves => {\n            // Add the start point to the subpath\n            let p = curves[0][0];\n            let pathStartStr = `M ${p[0]} ${p[1]} C`;\n            // Add all beziers belonging to the loop to the subpath\n            let pathPartStrs = curves.map(c => `${c[1][0]} ${c[1][1]} ${c[2][0]} ${c[2][1]} ${c[3][0]} ${c[3][1]} `);\n            // Close the subpath\n            let pathEndStr = 'z';\n            // Add the subpath to the array of subpaths\n            pathStrs.push(pathStartStr + pathPartStrs.join('') + pathEndStr);\n        });\n    }\n    // Join the subpaths into a single SVG path and return it\n    return pathStrs.join(\" \");\n}\nexports.getThinnedPath = getThinnedPath;\n\n\n//# sourceURL=webpack://thinning-ts/./src/get-thinned-path.ts?");

/***/ }),

/***/ "./src/svg-functions.ts":
/*!******************************!*\
  !*** ./src/svg-functions.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addPath = void 0;\n// SVG namespace\nconst XMLNS = 'http://www.w3.org/2000/svg';\n/**\n * Adds a path to the given SVG element and give it a shape-path class.\n */\nfunction addPath($elem, pathStr, class_) {\n    // Create SVG path elem.\n    let $path = document.createElementNS(XMLNS, 'path');\n    $path.setAttribute('class', class_);\n    $elem.appendChild($path); // Add the path element to the SVG.\n    $path.setAttribute('d', pathStr);\n    return $path;\n}\nexports.addPath = addPath;\n\n\n//# sourceURL=webpack://thinning-ts/./src/svg-functions.ts?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/fast-two-diff.js":
/*!***************************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/fast-two-diff.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastTwoDiff: () => (/* binding */ fastTwoDiff)\n/* harmony export */ });\n/**\r\n * Returns the difference and exact error of subtracting two floating point\r\n * numbers.\r\n * Uses an EFT (error-free transformation), i.e. a-b === x+y exactly.\r\n * The returned result is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoDiff(a, b) {\r\n    const x = a - b;\r\n    const y = (a - x) - b;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=fast-two-diff.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/fast-two-diff.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/fast-two-sum.js":
/*!**************************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/fast-two-sum.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastTwoSum: () => (/* binding */ fastTwoSum)\n/* harmony export */ });\n/**\r\n * Returns the sum and exact error of adding two floating point numbers.\r\n * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.\r\n * The returned sum is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoSum(a, b) {\r\n    const x = a + b;\r\n    return [b - (x - a), x];\r\n}\r\n// inlined\r\n//const R = a + b; const r = b - (R - a); return [r, R];\r\n\r\n//# sourceMappingURL=fast-two-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/fast-two-sum.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/reduce-significand.js":
/*!********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/reduce-significand.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reduceSignificand: () => (/* binding */ reduceSignificand)\n/* harmony export */ });\n/**\r\n * Truncates a floating point value's significand and returns the result.\r\n * Similar to split, but with the ability to specify the number of bits to keep.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param a a double\r\n * @param bits the number of significand bits to leave intact\r\n */\r\nfunction reduceSignificand(a, bits) {\r\n    const s = 53 - bits;\r\n    const f = 2 ** s + 1;\r\n    const c = f * a;\r\n    const r = c - (c - a);\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=reduce-significand.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/reduce-significand.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/split.js":
/*!*******************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/split.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   split: () => (/* binding */ split)\n/* harmony export */ });\n/**\r\n * === Math.ceil(p/2) where p is the # of significand bits in a double === 53.\r\n */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of splitting a double into 2 26-bit doubles.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * see e.g. [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * @param a A double floating point number\r\n */\r\nfunction split(a) {\r\n    const c = f * a;\r\n    const a_h = c - (c - a);\r\n    const a_l = a - a_h;\r\n    return [a_h, a_l];\r\n}\r\n// inlined - input a, output a_h, a_l\r\n// const c = f * a; const a_h = c - (c - a); const a_l = a - a_h; return [a_h, a_l];\r\n\r\n//# sourceMappingURL=split.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/split.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/two-diff.js":
/*!**********************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/two-diff.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoDiff: () => (/* binding */ twoDiff)\n/* harmony export */ });\n/**\r\n * Returns the exact result of subtracting b from a (as a floating point\r\n * expansion).\r\n * @param a\r\n * @param b\r\n */\r\nfunction twoDiff(a, b) {\r\n    const x = a - b;\r\n    const bvirt = a - x;\r\n    const y = (a - (x + bvirt)) + (bvirt - b);\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-diff.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/two-diff.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/two-product.js":
/*!*************************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/two-product.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoProduct: () => (/* binding */ twoProduct)\n/* harmony export */ });\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the exact result of multiplying two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction twoProduct(a, b) {\r\n    const x = a * b;\r\n    //const [ah, al] = split(a);\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    //const [bh, bl] = split(b);\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //const err1 = x - (ah * bh);\r\n    //const err2 = err1 - (al * bh);\r\n    //const err3 = err2 - (ah * bl);\r\n    //const y = (al * bl) - err3;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-product.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/two-product.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/basic/two-sum.js":
/*!*********************************************************!*\
  !*** ./node_modules/big-float-ts/node/basic/two-sum.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoSum: () => (/* binding */ twoSum)\n/* harmony export */ });\n/**\r\n * Returns the exact result of adding two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the\r\n * following algorithm will produce a nonoverlapping expansion x + y such that\r\n * a + b = x + y, where x is an approximation to a + b and y is the roundoff\r\n * error in the calculation of x.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction twoSum(a, b) {\r\n    const x = a + b;\r\n    const bv = x - a;\r\n    return [(a - (x - bv)) + (b - bv), x];\r\n}\r\n// inlined\r\n//const R = a + b; const _ = R - a; const r = (a - (R - _)) + (b - _); return [r,R]\r\n\r\n//# sourceMappingURL=two-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/basic/two-sum.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-abs.js":
/*!******************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-abs.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eAbs: () => (/* binding */ eAbs)\n/* harmony export */ });\n/* harmony import */ var _e_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-sign.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _e_negative_of_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-negative-of.js */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst sign = _e_sign_js__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst negativeOf = _e_negative_of_js__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\n/**\r\n * Returns the absolute value of the given floating point expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eAbs(e) {\r\n    if (e[e.length - 1] < 0) {\r\n        return negativeOf(e);\r\n    }\r\n    return e;\r\n}\r\n\r\n//# sourceMappingURL=e-abs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-abs.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-calculate.js":
/*!************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-calculate.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eCalculate: () => (/* binding */ eCalculate)\n/* harmony export */ });\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expansion-product.js */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-product.js */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scale-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../basic/two-sum.js */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var _grow_expansion_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grow-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst tp = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst multByDouble = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion;\r\nconst ts = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_3__.twoSum;\r\nconst addDouble = _grow_expansion_js__WEBPACK_IMPORTED_MODULE_4__.growExpansion;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_6__.eCompress;\r\n/**\r\n * Return the result of summing an array of terms, each term being an array of\r\n * floating point expansions to be multiplied together.\r\n *\r\n * * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param terms An array of terms to be summed; A term consists of an\r\n * array of floating point expansions to be multiplied together.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it's really worth it I am not sure.\r\nfunction eCalculate(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        const term = terms[i];\r\n        let product = term[0];\r\n        for (let j = 1; j < term.length; j++) {\r\n            const multiplicant = term[j];\r\n            if (multiplicant.length == 1) {\r\n                if (product.length === 1) {\r\n                    product = tp(product[0], multiplicant[0]);\r\n                }\r\n                else {\r\n                    product = multByDouble(product, multiplicant[0]);\r\n                }\r\n            }\r\n            else if (product.length === 1) {\r\n                product = multByDouble(multiplicant, product[0]);\r\n            }\r\n            else {\r\n                product = mult(multiplicant, product);\r\n            }\r\n        }\r\n        // add\r\n        if (product.length === 1) {\r\n            if (total.length === 1) {\r\n                total = ts(total[0], product[0]);\r\n            }\r\n            else {\r\n                total = addDouble(total, product[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = addDouble(product, total[0]);\r\n            }\r\n            else {\r\n                total = add(total, product);\r\n            }\r\n        }\r\n    }\r\n    //return compress(total);\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=e-calculate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-calculate.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-compare.js":
/*!**********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-compare.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eCompare: () => (/* binding */ eCompare)\n/* harmony export */ });\n/* harmony import */ var _e_diff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-diff.js */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _e_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-sign.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n\r\n/**\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * \"The easiest way to compare two expansions is to subtract one from the other,\r\n * and test the sign of the result. An expansion’s sign can be easily tested\r\n * because of the nonoverlapping property; simply check the sign of the\r\n * expansion's most significant nonzero component...\"\r\n *\r\n * @param a a floating point expansion\r\n * @param b another floating point expansion\r\n */\r\nfunction eCompare(a, b) {\r\n    return (0,_e_sign_js__WEBPACK_IMPORTED_MODULE_0__.eSign)((0,_e_diff_js__WEBPACK_IMPORTED_MODULE_1__.eDiff)(a, b));\r\n}\r\n\r\n//# sourceMappingURL=e-compare.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-compare.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-compress.js":
/*!***********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-compress.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eCompress: () => (/* binding */ eCompress)\n/* harmony export */ });\n/**\r\n * Returns the result of compressing the given floating point expansion.\r\n *\r\n * * primarily for internal library use\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Theorem 23 (Shewchuck): Let e = sum_(i=1)^m(e_i) be a nonoverlapping\r\n * expansion of m p-bit components, where m >= 3. Suppose that the components of\r\n * e are sorted in order of increasing magnitude, except that any of the e_i may\r\n * be zero. Then the following algorithm will produce a nonoverlapping expansion\r\n * (nonadjacent if round-to even tiebreaking is used) such that\r\n * h = sum_(i=1)^n(h_i) = e, where the components h_i are in order of increasing\r\n * magnitude. If h != 0, none of the h_i will be zero. Furthermore, the largest\r\n * component h_n approximates h with an error smaller than ulp(h_n).\r\n */\r\nfunction eCompress(e) {\r\n    //return e;\r\n    const e_ = e.slice();\r\n    const m = e_.length;\r\n    if (m === 1) {\r\n        return e_;\r\n    }\r\n    let Q = e_[m - 1];\r\n    let bottom = m;\r\n    for (let i = m - 2; i >= 0; --i) {\r\n        const a = Q;\r\n        const b = e_[i];\r\n        Q = a + b;\r\n        const bv = Q - a;\r\n        const q = b - bv;\r\n        if (q) {\r\n            e_[--bottom] = Q;\r\n            Q = q;\r\n        }\r\n    }\r\n    let top = 0;\r\n    for (let i = bottom; i < m; ++i) {\r\n        const a = e_[i];\r\n        const b = Q;\r\n        Q = a + b;\r\n        const bv = Q - a;\r\n        const q = b - bv;\r\n        if (q) {\r\n            e_[top++] = q;\r\n        }\r\n    }\r\n    e_[top++] = Q;\r\n    e_.length = top;\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-compress.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-compress.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-diff.js":
/*!*******************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-diff.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eDiff: () => (/* binding */ eDiff)\n/* harmony export */ });\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var _e_negative_of_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-negative-of.js */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst negativeOf = _e_negative_of_js__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\n/**\r\n * Returns the difference between two floating point expansions, i.e. e - f.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n * @param f another floating point expansion\r\n */\r\nfunction eDiff(e, f) {\r\n    const g = negativeOf(f);\r\n    return add(e, g);\r\n}\r\n\r\n//# sourceMappingURL=e-diff.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-diff.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eDivBy2: () => (/* binding */ eDivBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of dividing a floating point expansion by 2.\r\n * * **error free**\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eDivBy2(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(0.5 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-div-by-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-div.js":
/*!******************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-div.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eDiv: () => (/* binding */ eDiv)\n/* harmony export */ });\n/* harmony import */ var _e_estimate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./e-estimate.js */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expansion-product.js */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var _e_diff_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-diff.js */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-to-bitlength.js */ \"./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js\");\n/* harmony import */ var _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../double-representation/bit-length.js */ \"./node_modules/big-float-ts/node/double-representation/bit-length.js\");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst toBitlength = _e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_1__.eToBitlength;\r\nconst bitLength = _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_2__.expBitLength;\r\nconst diff = _e_diff_js__WEBPACK_IMPORTED_MODULE_3__.eDiff;\r\nconst estimate = _e_estimate_js__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\r\n/**\r\n * Returns the result of a/b using Goldschmidt division.\r\n *\r\n * The result will only be exact if b|a, i.e. if b divides a exactly, else the\r\n * result will be rounded to the longest bitlength between a and b.\r\n *\r\n * @param a the numerator\r\n * @param b the denominator\r\n *\r\n * @param expansionLength the bitlength/53 of the final result, e.g. 1 means\r\n * standard double precision, 2 means double-double, etc up to a max of about 20 at\r\n * which point underflow cease precision improvement. If the division is known\r\n * to be exact beforehand (such as in the pseudo remainder sequence algorithm)\r\n * then set expansionLength === 0 and an exact division will be done.\r\n */\r\n// TODO - test this function properly or replace with a better one\r\nfunction eDiv(N, D, expansionLength) {\r\n    let D_ = D;\r\n    let N_ = N;\r\n    let exact = false;\r\n    let resultBitlengthUpperBound = 0;\r\n    if (!expansionLength) {\r\n        const bitlengthN = bitLength(N_);\r\n        const bitlengthD = bitLength(D_);\r\n        // resultBitlengthUpperBound is only valid if the division is known\r\n        // to be exact\r\n        resultBitlengthUpperBound = bitlengthN - bitlengthD + 1;\r\n        expansionLength = (resultBitlengthUpperBound / 53) + 1;\r\n        exact = true;\r\n    }\r\n    let F = [1 / estimate(D_)]; // Initial guess - out by 1/2 upls\r\n    let i = 1;\r\n    while (true) {\r\n        N_ = mult(N_, F);\r\n        // The precision bitlength doubles on each iteration\r\n        if (i > expansionLength) {\r\n            // we now have roughly double the needed precision - we actually \r\n            // only require about the precision and then round properly - this\r\n            // could be implemented in the future.\r\n            if (exact) {\r\n                // We must throw away bits known to be zero. \r\n                // Any bits > expansionLength * 53 must be thrown away as they\r\n                // are wrong - all other bits are exact.\r\n                N_ = toBitlength(N_, resultBitlengthUpperBound);\r\n                // TODO - below is just for testing - remove later\r\n                //if (compare(mult(D, N_), N) !== 0) {\r\n                //    console.log(mult(D, N_))\r\n                //    throw new Error(`division in-exact - probably due to underflow, N: ${N}, D: ${D}, Result: ${N_}, product: ${mult(D, N_)}`); \r\n                //} \r\n                return N_;\r\n            }\r\n            // Returning only significant bits helps with sign determination later on.\r\n            return N_.slice(N_.length - expansionLength, N_.length);\r\n        }\r\n        D_ = mult(D_, F);\r\n        F = diff([2], D_);\r\n        i *= 2;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=e-div.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-div.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-estimate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-estimate.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eEstimate: () => (/* binding */ eEstimate)\n/* harmony export */ });\n/**\r\n * Returns the result of the given floating point expansion rounded to a double\r\n * floating point number.\r\n *\r\n * The result is within 1 ulps of the actual value, e.g. imagine the worst case\r\n * situation where we add (in 4dot4) 1111.1000 + 0.000011111111... The result\r\n * will be 1111.1000 whereas as the correct result should be 1111.1001 and we\r\n * thus lost 1 ulp of accuracy. It does not matter that the expansion contain\r\n * several floats since none is overlapping.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eEstimate(e) {\r\n    let Q = e[0];\r\n    for (let i = 1; i < e.length; i++) {\r\n        Q += e[i];\r\n    }\r\n    return Q;\r\n}\r\n\r\n//# sourceMappingURL=e-estimate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-estimate.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-int-div.js":
/*!**********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-int-div.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eIntDiv: () => (/* binding */ eIntDiv)\n/* harmony export */ });\n/* harmony import */ var _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-long-divide.js */ \"./node_modules/big-float-ts/node/double-expansion/e-long-divide.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst eLongDivide = _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__.eLongDivide;\r\n/**\r\n * Returns the result of the integer division a/b.\r\n *\r\n * * **precondition:** a and b must be integers, b !== 0\r\n */\r\nfunction eIntDiv(a, b) {\r\n    return eLongDivide(a, b).div;\r\n}\r\n\r\n//# sourceMappingURL=e-int-div.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-int-div.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-int-pow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-int-pow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eIntPow: () => (/* binding */ eIntPow)\n/* harmony export */ });\n/* harmony import */ var _e_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-product.js */ \"./node_modules/big-float-ts/node/double-expansion/e-product.js\");\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expansion-product.js */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst prod = _e_product_js__WEBPACK_IMPORTED_MODULE_1__.eProduct;\r\n/**\r\n * Returns a**i, where i is a non-negative integer.\r\n * @param a a floating point expansion\r\n */\r\n// TODO - this algorithm's speed can easily be improved significantly using 'repeated squaring'\r\nfunction eIntPow(a, p) {\r\n    // a^0 === 1\r\n    if (p === 0) {\r\n        return [1];\r\n    }\r\n    // a^1 === a\r\n    if (p === 1) {\r\n        return a;\r\n    }\r\n    if (p === 2) {\r\n        return mult(a, a);\r\n    }\r\n    const as = [];\r\n    for (let i = 0; i < p; i++) {\r\n        as.push(a);\r\n    }\r\n    return prod(as);\r\n}\r\n\r\n//# sourceMappingURL=e-int-pow.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-int-pow.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-is-integer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-is-integer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eIsInteger: () => (/* binding */ eIsInteger)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\nfunction eIsInteger(a) {\r\n    a = (0,_e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress)(a);\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (a[i] % 1 !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=e-is-integer.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-is-integer.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-long-divide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-long-divide.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eLongDivide: () => (/* binding */ eLongDivide)\n/* harmony export */ });\n/* harmony import */ var _e_negative_of_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-negative-of.js */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var _grow_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grow-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var _e_sum_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./e-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sum.js\");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scale-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _e_diff_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./e-diff.js */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst eNegativeOf = _e_negative_of_js__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf;\r\nconst fastExpansionSum = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst eCompress = _e_compress_js__WEBPACK_IMPORTED_MODULE_2__.eCompress;\r\nconst growExpansion = _grow_expansion_js__WEBPACK_IMPORTED_MODULE_3__.growExpansion;\r\nconst eSum = _e_sum_js__WEBPACK_IMPORTED_MODULE_4__.eSum;\r\nconst scaleExpansion = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_5__.scaleExpansion;\r\nconst eDiff = _e_diff_js__WEBPACK_IMPORTED_MODULE_6__.eDiff;\r\nconst sign = Math.sign;\r\nfunction eLongDivide(N, D) {\r\n    N = eCompress(N);\r\n    D = eCompress(D);\r\n    // get the most significant double\r\n    // out by at most 1 ulp, exact if d < MAX_SAFE_INT\r\n    const d = D[D.length - 1];\r\n    // trivial cases\r\n    if (D.length === 1) {\r\n        if (d === 0) {\r\n            throw new Error('division by zero');\r\n        }\r\n        if (d === 1) {\r\n            return { div: N, rem: [0] };\r\n        }\r\n        if (d === -1) {\r\n            return { div: eNegativeOf(N), rem: [0] };\r\n        }\r\n    }\r\n    const signN = sign(N[N.length - 1]);\r\n    if (signN === 0) {\r\n        return { div: [0], rem: [0] };\r\n    }\r\n    const signD = sign(d);\r\n    const divs = [];\r\n    let oldLen = 0;\r\n    while (true) {\r\n        const rems = [];\r\n        // loop from big `n[i]` to small `n[i]`\r\n        for (let i = N.length - 1; i >= 0; i--) {\r\n            const n = N[i];\r\n            // `n % d` is the exact rem (for rem < MAX_SAFE_INTEGER) but is preliminary \r\n            // as it is subject to round-off for rem > MAX_SAFE_INTEGER; thus out by at \r\n            // most 1/2 ulp\r\n            // Due to roundoff (and the fact we'e using `d` and not `D`!), `_div` does \r\n            // not necessarily represent the exact quotient.\r\n            const div = Math.round((n - (n % d)) / d);\r\n            // get the remainder by calculating `rem = n - d*div`\r\n            rems.push(scaleExpansion(D, div)); // exact\r\n            if (div === 0) {\r\n                break;\r\n            }\r\n            divs.push(div);\r\n        }\r\n        N = eCompress(eDiff(N, eSum(rems)));\r\n        if (oldLen === divs.length) {\r\n            break;\r\n        }\r\n        oldLen = divs.length;\r\n    }\r\n    let rem = N;\r\n    let div = [0];\r\n    for (let i = 0; i < divs.length; i++) {\r\n        div = growExpansion(div, divs[i]);\r\n    }\r\n    div = eCompress(div);\r\n    //----------------------\r\n    // fix signs (possibly)\r\n    //----------------------\r\n    //const signDiv = sign(div[div.length-1]);\r\n    const signRem = sign(rem[rem.length - 1]);\r\n    //const signND = signN * signD;\r\n    // We must have:\r\n    // sign(div) === sign(n) * sign(d)\r\n    // sign(rem) === sign(n)\r\n    // At this point: `signN !== 0` and `signD !== 0`\r\n    if (signRem !== 0 && signRem !== signN) {\r\n        if (signN > 0) {\r\n            if (signD > 0) {\r\n                // div = div - 1  (div is positive)\r\n                // rem = rem + D\r\n                div = growExpansion(div, -1);\r\n                rem = fastExpansionSum(rem, D);\r\n            }\r\n            else {\r\n                // div = div + 1  (div is positive)\r\n                // rem = rem - D\r\n                div = growExpansion(div, +1);\r\n                rem = fastExpansionSum(rem, eNegativeOf(D));\r\n            }\r\n        }\r\n        else if (signN < 0) {\r\n            if (signD > 0) {\r\n                // div = div + 1 (div is negative)\r\n                // rem = rem - D\r\n                div = growExpansion(div, +1);\r\n                rem = fastExpansionSum(rem, eNegativeOf(D));\r\n            }\r\n            else {\r\n                // div = div - 1  (div is positive)\r\n                // rem = rem + D\r\n                div = growExpansion(div, -1);\r\n                rem = fastExpansionSum(rem, D);\r\n            }\r\n        }\r\n    }\r\n    return { div, rem };\r\n}\r\n\r\n//# sourceMappingURL=e-long-divide.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-long-divide.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js":
/*!************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eMultBy2: () => (/* binding */ eMultBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying a floating point expansion by 2.\r\n * * **error free**\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eMultBy2(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(2 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-mult-by-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eMultByNeg2: () => (/* binding */ eMultByNeg2)\n/* harmony export */ });\n/**\r\n * Multiply a floating point expansion by -2.\r\n * * **error free**\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eMultByNeg2(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(-2 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-mult-by-neg-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-negative-of.js":
/*!**************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-negative-of.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eNegativeOf: () => (/* binding */ eNegativeOf)\n/* harmony export */ });\n/**\r\n * Returns the negative of the given floating point expansion.\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eNegativeOf(e) {\r\n    const m = e.length;\r\n    const h = new Array(m);\r\n    for (let i = 0; i < m; i++) {\r\n        h[i] = -e[i];\r\n    }\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=e-negative-of.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-negative-of.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-product.js":
/*!**********************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-product.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eProduct: () => (/* binding */ eProduct)\n/* harmony export */ });\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expansion-product.js */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-product.js */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scale-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst tp = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst multByDouble = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_3__.eCompress;\r\n/**\r\n * Return the result of multiplying together an array of floating point\r\n * expansions.\r\n *\r\n * * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param terms an array of multiplicands\r\n */\r\nfunction eProduct(term) {\r\n    let product = term[0];\r\n    for (let j = 1; j < term.length; j++) {\r\n        const multiplicant = term[j];\r\n        if (multiplicant.length == 1) {\r\n            if (product.length === 1) {\r\n                product = tp(product[0], multiplicant[0]);\r\n            }\r\n            else {\r\n                product = multByDouble(product, multiplicant[0]);\r\n            }\r\n        }\r\n        else if (product.length === 1) {\r\n            product = multByDouble(multiplicant, product[0]);\r\n        }\r\n        else {\r\n            product = mult(multiplicant, product);\r\n        }\r\n    }\r\n    return compress(product);\r\n    //return product;\r\n}\r\n\r\n//# sourceMappingURL=e-product.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-product.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-rem.js":
/*!******************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-rem.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eRem: () => (/* binding */ eRem)\n/* harmony export */ });\n/* harmony import */ var _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-long-divide.js */ \"./node_modules/big-float-ts/node/double-expansion/e-long-divide.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst eLongDivide = _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__.eLongDivide;\r\n/**\r\n * Returns a % b\r\n *\r\n * * **precondition:** a and b must be integers, b !== 0\r\n */\r\nfunction eRem(a, b) {\r\n    return eLongDivide(a, b).rem;\r\n}\r\n\r\n//# sourceMappingURL=e-rem.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-rem.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-sign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-sign.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eSign: () => (/* binding */ eSign)\n/* harmony export */ });\n/**\r\n * Returns the sign of the given expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * From Shewchuk: \"A nonoverlapping expansion is desirable because it is easy to\r\n * determine its sign (take the sign of the largest component) ... \"\r\n *\r\n * @param e A floating point expansion with zeroes eliminated.\r\n */\r\nfunction eSign(e) {\r\n    return e[e.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=e-sign.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-sign.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-sum.js":
/*!******************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-sum.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eSum: () => (/* binding */ eSum)\n/* harmony export */ });\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/two-sum.js */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var _grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grow-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst ts = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst addDouble = _grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__.growExpansion;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\n/**\r\n * Returns the result of summing an array of floating point expansions.\r\n *\r\n * * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param terms An array of numbers to be summed; A term is represented by a\r\n * floating point expansion.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it's really worth it I am not sure.\r\nfunction eSum(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        const term = terms[i];\r\n        // add\r\n        if (term.length === 1) {\r\n            if (total.length === 1) {\r\n                total = ts(total[0], term[0]);\r\n            }\r\n            else {\r\n                total = addDouble(total, term[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = addDouble(term, total[0]);\r\n            }\r\n            else {\r\n                total = add(total, term);\r\n            }\r\n        }\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=e-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-sum.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js":
/*!***************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eToBitlength: () => (/* binding */ eToBitlength)\n/* harmony export */ });\n/* harmony import */ var _e_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-sign.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../double-representation/msb-exponent.js */ \"./node_modules/big-float-ts/node/double-representation/msb-exponent.js\");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../basic/reduce-significand.js */ \"./node_modules/big-float-ts/node/basic/reduce-significand.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst sign = _e_sign_js__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_1__.eCompress;\r\n/**\r\n * Returns a floating point expansion accurate to the given number of bits.\r\n * Extraneous bits are discarded.\r\n * @param a a floating point expansion\r\n * @param l the number of accurate bits to keep\r\n */\r\n// TODO - make faster\r\nfunction eToBitlength(a, l) {\r\n    a = compress(a);\r\n    if (sign(a) === 0) {\r\n        return [0];\r\n    }\r\n    const maxMsb = (0,_double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_2__.msbExponent)(a[a.length - 1]);\r\n    let msb = maxMsb;\r\n    let i = a.length - 1; // start at most significant byte\r\n    while (i > 0) {\r\n        const msb_ = (0,_double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_2__.msbExponent)(a[i - 1]);\r\n        if (maxMsb - msb_ > l) {\r\n            break;\r\n        }\r\n        msb = msb_;\r\n        i--;\r\n    }\r\n    const keepBits = Math.min(l - (maxMsb - msb), 53);\r\n    let b = a[i];\r\n    b = (0,_basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_3__.reduceSignificand)(b, keepBits);\r\n    const result = a.slice(i);\r\n    result[0] = b;\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-to-bitlength.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eToDd: () => (/* binding */ eToDd)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress;\r\n/**\r\n * Returns the result of converting a floating point expansion to a\r\n * double-double precision floating point number.\r\n */\r\nfunction eToDd(e) {\r\n    e = compress(e);\r\n    const len = e.length;\r\n    if (len === 2) {\r\n        return e; // already a double-double\r\n    }\r\n    else if (len === 1) {\r\n        return [0, e[0]]; // double-doubles have a fixed length of 2\r\n    }\r\n    return [e[len - 2], e[len - 1]]; // return only most significant parts\r\n}\r\n\r\n//# sourceMappingURL=e-to-double-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/expansion-product.js":
/*!******************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/expansion-product.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expansionProduct: () => (/* binding */ expansionProduct)\n/* harmony export */ });\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scale-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst multByDouble = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_2__.eCompress;\r\n/**\r\n * Returns the product of two double floating point expansions.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * As per Shewchuk in the above paper: \"To find the product of two expansions\r\n * e and f, use SCALE-EXPANSION (with zero elimination) to form the expansions\r\n * ef_1, ef_2, ..., then sum these using a distillation tree.\"\r\n *\r\n * A distillation tree used with fastExpansionSum will give O(k*log k) vs O(k^2)\r\n * operations.\r\n *\r\n * Implemented naively and not as described by Shewchuk (i.e. the algorithm\r\n * takes O(k^2) operations).\r\n * @param e a double floating point expansion\r\n * @param f another double floating point expansion\r\n */\r\nfunction expansionProduct(e, f) {\r\n    let sum = [0];\r\n    for (let i = 0; i < e.length; i++) {\r\n        sum = add(sum, multByDouble(f, e[i]));\r\n    }\r\n    //return compress(sum);\r\n    return sum;\r\n}\r\n\r\n//# sourceMappingURL=expansion-product.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/expansion-product.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastExpansionSum: () => (/* binding */ fastExpansionSum)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress;\r\n/**\r\n * Returns the result of adding two expansions.\r\n *\r\n * Theorem 13: Let e = sum_(i=1)^m(e_i) and f = sum_(i=1)^n(f_i) be strongly\r\n * nonoverlapping expansions of m and n p-bit components, respectively, where\r\n * p >= 4. Suppose that the components of both e and f are sorted in order of\r\n * increasing magnitude, except that any of the e_i or f_i may be zero. On a\r\n * machine whose arithmetic uses the round-to-even rule, the following algorithm\r\n * will produce a strongly nonoverlapping expansion h such that\r\n * sum_(i=1)^(m+n)(e_i + f_i) = e + f, where the components of h are also in\r\n * order of increasing magnitude, except that any of the h_i may be zero.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastExpansionSum(e, f) {\r\n    //const g = merge(e,f);\r\n    // inlined (above line)\r\n    const lenE = e.length;\r\n    const lenF = f.length;\r\n    let i = 0;\r\n    let j = 0;\r\n    const g = [];\r\n    while (i < lenE && j < lenF) {\r\n        if (e[i] === 0) {\r\n            i++;\r\n            continue;\r\n        }\r\n        if (f[j] === 0) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (Math.abs(e[i]) <= Math.abs(f[j])) {\r\n            g.push(e[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            g.push(f[j]);\r\n            j++;\r\n        }\r\n    }\r\n    while (i < lenE) {\r\n        g.push(e[i]);\r\n        i++;\r\n    }\r\n    while (j < lenF) {\r\n        g.push(f[j]);\r\n        j++;\r\n    }\r\n    if (g.length === 0) {\r\n        return [0];\r\n    }\r\n    // end inlined\r\n    const len = g.length;\r\n    if (len === 1) {\r\n        return g;\r\n    }\r\n    //const h: number[] = new Array(len);\r\n    const h = [];\r\n    //const q: number;\r\n    //[h[0], q] = fastTwoSum(g[1], g[0]);\r\n    // inlined (above line)\r\n    const a = g[1];\r\n    const b = g[0];\r\n    let q = a + b;\r\n    //h[0] = b - (q - a);\r\n    const hh = b - (q - a);\r\n    if (hh !== 0) {\r\n        h.push(hh);\r\n    }\r\n    //let j = 0;\r\n    j = 0;\r\n    for (let i = 2; i < len; i++) {\r\n        //[h[i-1], q] = twoSum(q, g[i]);\r\n        // inlined (above line)\r\n        const b = g[i];\r\n        const R = q + b;\r\n        const _ = R - q;\r\n        //h[i-1] = (q - (R - _)) + (b - _);\r\n        const hh = (q - (R - _)) + (b - _);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q = R;\r\n    }\r\n    //h[len-1] = q;\r\n    //h.push(q);\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return compress(h);\r\n    return h;\r\n}\r\n/**\r\n * Returns the result of merging an expansion e and f into a single expansion,\r\n * in order of nondecreasing magnitude (possibly with interspersed zeros).\r\n * (This function is zero-eliminating)\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n * @param f another floating point expansion\r\n */\r\nfunction merge(e, f) {\r\n    const lenE = e.length;\r\n    const lenF = f.length;\r\n    let i = 0;\r\n    let j = 0;\r\n    const merged = [];\r\n    while (i < lenE && j < lenF) {\r\n        if (e[i] === 0) {\r\n            i++;\r\n            continue;\r\n        }\r\n        if (f[j] === 0) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (Math.abs(e[i]) <= Math.abs(f[j])) {\r\n            merged.push(e[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            merged.push(f[j]);\r\n            j++;\r\n        }\r\n    }\r\n    while (i < lenE) {\r\n        merged.push(e[i]);\r\n        i++;\r\n    }\r\n    while (j < lenF) {\r\n        merged.push(f[j]);\r\n        j++;\r\n    }\r\n    if (merged.length === 0) {\r\n        return [0];\r\n    }\r\n    return merged;\r\n}\r\n\r\n//# sourceMappingURL=fast-expansion-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/grow-expansion.js":
/*!***************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/grow-expansion.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   growExpansion: () => (/* binding */ growExpansion)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress;\r\n/**\r\n * Returns the result of adding a double to an expansion.\r\n *\r\n * Let e be a nonoverlapping expansion of m p-bit components, and let b be a\r\n * p-bit value where p >= 3. Suppose that the components e_1, ..., e_m are\r\n * sorted in order of *increasing* magnitude, except that any of the ei may be\r\n * zero.\r\n * Then the following algorithm will produce a nonoverlapping expansion such\r\n * that h = sum_i(h_i) = e + b, where the components h_1, ..., h_(m+1) are also\r\n * in order of increasing magnitude, except that any of the h_i may be zero.\r\n * Furthermore, if e is nonadjacent and round-to-even tiebreaking is used, then\r\n * h is nonadjacent.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param b Another floating point expansion\r\n */\r\nfunction growExpansion(e, b) {\r\n    const m = e.length;\r\n    let q = b;\r\n    //const h: number[] = new Array(m+1);\r\n    const h = [];\r\n    //let j = 0;\r\n    for (let i = 0; i < m; i++) {\r\n        // Note the use of twoSum and not fastTwoSum.\r\n        //[h[i], q] = ts(q, e[i]);\r\n        const ee = e[i];\r\n        const x = q + ee;\r\n        const bv = x - q;\r\n        const hh = (q - (x - bv)) + (ee - bv);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q = x;\r\n    }\r\n    //h[j] = q;\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return compress(h);\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=grow-expansion.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/grow-expansion.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/is-adjacent.js":
/*!************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/is-adjacent.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAdjacent: () => (/* binding */ isAdjacent)\n/* harmony export */ });\n/* harmony import */ var _is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-overlapping.js */ \"./node_modules/big-float-ts/node/double-expansion/is-overlapping.js\");\n\r\n/**\r\n * Returns true if x and y are adjacent, false otherwise.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * for details\r\n *\r\n * @param x a double floating point number\r\n * @param y another double floating point number\r\n */\r\nfunction isAdjacent(x, y) {\r\n    return (0,_is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__.isOverlapping)(x, y) ||\r\n        (0,_is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__.isOverlapping)(x, 2 * y) ||\r\n        (0,_is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__.isOverlapping)(2 * x, y);\r\n}\r\n\r\n//# sourceMappingURL=is-adjacent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/is-adjacent.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/is-overlapping.js":
/*!***************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/is-overlapping.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNonOverlapping: () => (/* binding */ isNonOverlapping),\n/* harmony export */   isNonOverlappingAll: () => (/* binding */ isNonOverlappingAll),\n/* harmony export */   isOverlapping: () => (/* binding */ isOverlapping)\n/* harmony export */ });\n/* harmony import */ var _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../double-representation/get-max-set-bit.js */ \"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double-representation/exponent.js */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns true if a and b overlaps, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Implemented for testing purposes.\r\n * @param a a double\r\n * @param b another double\r\n */\r\nfunction isOverlapping(a, b) {\r\n    return !isNonOverlapping(a, b);\r\n}\r\n/**\r\n * Returns true if a and b does not overlap, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Implemented for testing purposes.\r\n *\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction isNonOverlapping(a, b) {\r\n    if (a === 0 || b === 0) {\r\n        return true;\r\n    }\r\n    if (Math.abs(b) > Math.abs(a)) {\r\n        [a, b] = [b, a];\r\n    }\r\n    // At this point abs(a) > abs(b)\r\n    const l = (0,_double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a);\r\n    const h = (0,_double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(b);\r\n    const shift = (0,_double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a) - (0,_double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(b);\r\n    return (l + shift) > h;\r\n}\r\n/**\r\n * Returns true if all components of the given floating point expansion is\r\n * non-overlapping, false otherwise.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a double floating point expansion\r\n */\r\nfunction isNonOverlappingAll(e) {\r\n    for (let i = 1; i < e.length; i++) {\r\n        if (isOverlapping(e[i - 1], e[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-overlapping.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/is-overlapping.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-expansion/scale-expansion.js":
/*!****************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-expansion/scale-expansion.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scaleExpansion: () => (/* binding */ scaleExpansion),\n/* harmony export */   scaleExpansion2: () => (/* binding */ scaleExpansion2)\n/* harmony export */ });\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/two-product.js */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-sum.js */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../basic/fast-two-sum.js */ \"./node_modules/big-float-ts/node/basic/fast-two-sum.js\");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n\r\n\r\n\r\nconst f = 134217729; // 2**27 + 1;\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst ts = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_1__.twoSum;\r\nconst fts = _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_2__.fastTwoSum;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_3__.eCompress;\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and const b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * @param e a double floating point expansion\r\n * @param b a double\r\n */\r\nfunction scaleExpansion(e, b) {\r\n    const m = e.length;\r\n    //const h: number[] = new Array(2*m);\r\n    let q_;\r\n    //[h[0], q] = tp(e[0], b);\r\n    // inlined (above line)\r\n    const a = e[0];\r\n    let q = a * b;\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const h = [];\r\n    //h[0] = (al*bl) - ((q - (ah*bh)) - (al*bh) - (ah*bl));\r\n    const hh = (al * bl) - ((q - (ah * bh)) - (al * bh) - (ah * bl));\r\n    if (hh !== 0) {\r\n        h.push(hh);\r\n    }\r\n    for (let i = 1; i < m; i++) {\r\n        //const [t, T] = tp(e[i], b);\r\n        // inlined (above line)\r\n        const a = e[i];\r\n        const T = a * b;\r\n        const c = f * a;\r\n        const ah = c - (c - a);\r\n        const al = a - ah;\r\n        const d = f * b;\r\n        const bh = d - (d - b);\r\n        const bl = b - bh;\r\n        const t = (al * bl) - ((T - (ah * bh)) - (al * bh) - (ah * bl));\r\n        //[h[2*i-1], q_] = ts(q, t);\r\n        // inlined (above line)\r\n        const x = q + t;\r\n        const bv = x - q;\r\n        //h[2*i-1] = (q - (x - bv)) + (t - bv);\r\n        //h.push((q - (x - bv)) + (t - bv));\r\n        const hh = (q - (x - bv)) + (t - bv);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q_ = x;\r\n        //[h[2*i], q] = fts(T, q_);\r\n        // inlined (above line)\r\n        const xx = T + q_;\r\n        //h[2*i] = q_ - (xx - T);\r\n        //h.push(q_ - (xx - T));\r\n        const hhh = q_ - (xx - T);\r\n        if (hhh !== 0) {\r\n            h.push(hhh);\r\n        }\r\n        q = xx;\r\n    }\r\n    //h[2*m - 1] = q;\r\n    //h.push(q);\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return eCompress(h);\r\n    return h;\r\n}\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and const b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * @param e a double floating point expansion\r\n * @param b a double\r\n */\r\nfunction scaleExpansion2(b, e) {\r\n    const m = e.length;\r\n    //const h: number[] = new Array(2*m);\r\n    let q_;\r\n    //[h[0], q] = tp(e[0], b);\r\n    // inlined (above line)\r\n    const a = e[0];\r\n    let q = a * b;\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const h = [];\r\n    //h[0] = (al*bl) - ((q - (ah*bh)) - (al*bh) - (ah*bl));\r\n    const hh = (al * bl) - ((q - (ah * bh)) - (al * bh) - (ah * bl));\r\n    if (hh !== 0) {\r\n        h.push(hh);\r\n    }\r\n    for (let i = 1; i < m; i++) {\r\n        //const [t, T] = tp(e[i], b);\r\n        // inlined (above line)\r\n        const a = e[i];\r\n        const T = a * b;\r\n        const c = f * a;\r\n        const ah = c - (c - a);\r\n        const al = a - ah;\r\n        const d = f * b;\r\n        const bh = d - (d - b);\r\n        const bl = b - bh;\r\n        const t = (al * bl) - ((T - (ah * bh)) - (al * bh) - (ah * bl));\r\n        //[h[2*i-1], q_] = ts(q, t);\r\n        // inlined (above line)\r\n        const x = q + t;\r\n        const bv = x - q;\r\n        //h[2*i-1] = (q - (x - bv)) + (t - bv);\r\n        //h.push((q - (x - bv)) + (t - bv));\r\n        const hh = (q - (x - bv)) + (t - bv);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q_ = x;\r\n        //[h[2*i], q] = fts(T, q_);\r\n        // inlined (above line)\r\n        const xx = T + q_;\r\n        //h[2*i] = q_ - (xx - T);\r\n        //h.push(q_ - (xx - T));\r\n        const hhh = q_ - (xx - T);\r\n        if (hhh !== 0) {\r\n            h.push(hhh);\r\n        }\r\n        q = xx;\r\n    }\r\n    //h[2*m - 1] = q;\r\n    //h.push(q);\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return eCompress(h);\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=scale-expansion.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-expansion/scale-expansion.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/bit-length.js":
/*!****************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/bit-length.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitLength: () => (/* binding */ bitLength),\n/* harmony export */   expBitLength: () => (/* binding */ expBitLength)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double-expansion/e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n/* harmony import */ var _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../double-expansion/e-sign.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Returns the bit-length of the significand of the given number in such a way\r\n * that trailing zeros are not counted.\r\n * @param a A double precision floating point number\r\n */\r\nfunction bitLength(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) + 1;\r\n}\r\n/**\r\n * Returns the bit-length of the significand of the given floating point\r\n * expansion in such a way that trailing zeros are not counted.\r\n * * precondition: subnormals not currently supported\r\n * @param a A double precision floating point expansion\r\n */\r\nfunction expBitLength(a) {\r\n    const a_ = (0,_double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_1__.eCompress)(a);\r\n    if ((0,_double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_2__.eSign)(a_) === 0) {\r\n        return 0;\r\n    }\r\n    const msbyte = a_[a_.length - 1];\r\n    const lsbyte = a_[0];\r\n    return (0,_exponent_js__WEBPACK_IMPORTED_MODULE_3__.exponent)(msbyte) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_3__.exponent)(lsbyte) + (53 - (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(lsbyte));\r\n}\r\n\r\n//# sourceMappingURL=bit-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/bit-length.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doubleToBinaryString: () => (/* binding */ doubleToBinaryString)\n/* harmony export */ });\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-octets.js */ \"./node_modules/big-float-ts/node/double-representation/double-to-octets.js\");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\nfunction doubleToBinaryString(number) {\r\n    return octetsToBinaryString((0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__.doubleToOctets)(number));\r\n}\r\n/**\r\n * @param octets The 8 bytes composing a double (msb first)\r\n */\r\nfunction octetsToBinaryString(octets) {\r\n    return octets\r\n        .map(int8ToBinaryString)\r\n        .join('');\r\n}\r\n/**\r\n * intToBinaryString(8) -> \"00001000\"\r\n */\r\nfunction int8ToBinaryString(i) {\r\n    let iStr = i.toString(2);\r\n    for (; iStr.length < 8; iStr = \"0\" + iStr)\r\n        ;\r\n    return iStr;\r\n}\r\n\r\n//# sourceMappingURL=double-to-binary-string.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/double-to-octets.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/double-to-octets.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doubleToOctets: () => (/* binding */ doubleToOctets)\n/* harmony export */ });\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n/**\r\n * Returns the ieee-574 8 bytes composing the given double, starting from the\r\n * sign bit and ending in the lsb of the significand.\r\n * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]\r\n */\r\nfunction doubleToOctets(number) {\r\n    const buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setFloat64(0, number, false);\r\n    return Array.from(new Uint8Array(buffer));\r\n}\r\n\r\n//# sourceMappingURL=double-to-octets.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/double-to-octets.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/exponent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/exponent.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exponent: () => (/* binding */ exponent)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ \"./node_modules/big-float-ts/node/double-representation/parse-double.js\");\n\r\n/**\r\n * Returns the normalized exponent of the given number.\r\n * @param a A double\r\n */\r\nfunction exponent(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).exponent;\r\n}\r\n\r\n//# sourceMappingURL=exponent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/exponent.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHighestSetBit: () => (/* binding */ getHighestSetBit),\n/* harmony export */   getLowestSetBit: () => (/* binding */ getLowestSetBit)\n/* harmony export */ });\n/* harmony import */ var _significand_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./significand.js */ \"./node_modules/big-float-ts/node/double-representation/significand.js\");\n\r\n/**\r\n * Returns the lowest set bit of the given value in [1, (2**31)-1],\r\n * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns\r\n * NaN, otherwise if the number is out of range returns a non-finite\r\n * number.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit_(a) {\r\n    return Math.log2(a & -a);\r\n}\r\n/**\r\n * Returns the lowest set bit of the given number's significand (where the lsb\r\n * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or\r\n * NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // Note: the significand includes the hidden bit!\r\n    const s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    const len = s.length;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === 0) {\r\n            continue;\r\n        }\r\n        const l = getLowestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up\r\n * to 255. If the input number === 0 returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit_(a) {\r\n    return a >= 128 ? 7\r\n        : a >= 64 ? 6\r\n            : a >= 32 ? 5\r\n                : a >= 16 ? 4\r\n                    : a >= 8 ? 3\r\n                        : a >= 4 ? 2\r\n                            : a >= 2 ? 1\r\n                                : a >= 1 ? 0\r\n                                    : NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given double. If no bit is set (input\r\n * === 0 or +/-inf or NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // At this point there must be a highest set bit (always === 52 if the \r\n    // number is not a subnormal.\r\n    const s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    const len = s.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const l = getHighestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n\r\n//# sourceMappingURL=get-max-set-bit.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js":
/*!********************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isBitAligned: () => (/* binding */ isBitAligned)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns true if the given number is bit-aligned in the sense that its a\r\n * multiple of a given power of 2, say e, and such that the number, say a,\r\n * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.\r\n * This essentially means the numbers act somewhat like fixed-point numbers\r\n * which can drastically speed up some geometric algorithms and also reduce\r\n * their complexity.\r\n *\r\n * Visually:\r\n * These numbers (a,b and c) are bit aligned with e === 3 and max\r\n * bitlength === 6:\r\n *    a -> 00|101100|000\r\n *    b -> 00|000100|000\r\n *    c -> 00|110111|000\r\n * These are not\r\n *    a -> 01|101100|000\r\n *    b -> 00|000100|000\r\n * These are not\r\n *    a -> 00|101100|000\r\n *    b -> 00|000100|100\r\n * These are not\r\n *    a -> 00|101100|100\r\n *    b -> 00|000100|100\r\n * @param as An array of numbers to check\r\n * @param maxBitLength The max allowed bitlength\r\n * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent\r\n */\r\nfunction isBitAligned(a, maxBitLength, gridSpacingExponent) {\r\n    if (a === 0) {\r\n        return true;\r\n    }\r\n    const e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.exponent)(a);\r\n    const maxSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getHighestSetBit)(a) - 52 + e;\r\n    const minSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getLowestSetBit)(a) - 52 + e;\r\n    const minBitBigEnough = minSetBit >= gridSpacingExponent;\r\n    const maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;\r\n    return minBitBigEnough && maxBitSmallEnough;\r\n}\r\n\r\n//# sourceMappingURL=is-bit-aligned.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/lsb-exponent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/lsb-exponent.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lsbExponent: () => (/* binding */ lsbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns the true exponent of the lsb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction lsbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    const e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.exponent)(a);\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getLowestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=lsb-exponent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/lsb-exponent.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/msb-exponent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/msb-exponent.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   msbExponent: () => (/* binding */ msbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns the true exponent of the msb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction msbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    const e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.exponent)(a);\r\n    // Will return e for all but subnormal numbers\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getHighestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=msb-exponent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/msb-exponent.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/parse-double.js":
/*!******************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/parse-double.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseDouble: () => (/* binding */ parseDouble),\n/* harmony export */   parseDoubleDetailed: () => (/* binding */ parseDoubleDetailed)\n/* harmony export */ });\n/* harmony import */ var _double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-to-binary-string.js */ \"./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js\");\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-octets.js */ \"./node_modules/big-float-ts/node/double-representation/double-to-octets.js\");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\n\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double. The returned\r\n * exponent has been normalized (i.e. 1023 ha been subtracted) and the\r\n * significand has the hidden bit added if appropriate.\r\n * See https://github.com/bartaz/ieee754-visualization\r\n */\r\nfunction parseDouble(x) {\r\n    const parts = (0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__.doubleToOctets)(x);\r\n    const p0 = parts[0];\r\n    const p1 = parts[1];\r\n    const sign = p0 >> 7;\r\n    const exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);\r\n    //---- Check for negative / positive zero / denormalized numbers.\r\n    const hiddenMsb = exponent_ === 0 ? 0 : 16;\r\n    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).\r\n    const exponent = exponent_ === 0\r\n        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)\r\n        : exponent_ - 1023;\r\n    //---- Break up the significand into bytes\r\n    const significand = parts.slice(1);\r\n    significand[0] = (p1 & 15) + hiddenMsb;\r\n    return {\r\n        sign,\r\n        exponent,\r\n        significand\r\n    };\r\n}\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double.\r\n * See https://github.com/bartaz/ieee754-visualization.\r\n * This is a slower version of parseDouble that gives binary string\r\n * representations of the components.\r\n */\r\nfunction parseDoubleDetailed(x) {\r\n    const str = (0,_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_1__.doubleToBinaryString)(x);\r\n    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)\r\n    const [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);\r\n    const exponent_ = parseInt(exponent, 2);\r\n    const hidden = exponent_ === 0 ? \"0\" : \"1\";\r\n    return {\r\n        full: sign + exponent + hidden + significand,\r\n        sign,\r\n        exponent,\r\n        hidden,\r\n        significand\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=parse-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/parse-double.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/double-representation/significand.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/double-representation/significand.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   significand: () => (/* binding */ significand)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ \"./node_modules/big-float-ts/node/double-representation/parse-double.js\");\n\r\n/**\r\n * Return the significand of the given double with the hidden bit added (in case\r\n * a is not subnormal or 0, etc.)\r\n * @param a A double\r\n */\r\nfunction significand(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).significand;\r\n}\r\n\r\n//# sourceMappingURL=significand.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/double-representation/significand.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/geometric-primitives/orient2d.js":
/*!*************************************************************************!*\
  !*** ./node_modules/big-float-ts/node/geometric-primitives/orient2d.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orient2d: () => (/* binding */ orient2d)\n/* harmony export */ });\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-product.js */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../double-expansion/e-diff.js */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../double-expansion/e-estimate.js */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../basic/two-diff.js */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../double-expansion/fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../double-expansion/e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst ccwerrboundA = 3.330669073875472e-16;\r\nconst ccwerrboundB = 2.220446049250315e-16;\r\nconst ccwerrboundC = 1.109335647967049e-31;\r\nconst resulterrbound = 3.330669073875471e-16;\r\n/**\r\n * * Ported from [Shewchuk](http://docs.ros.org/kinetic/api/asr_approx_mvbb/html/Predicates_8cpp_source.html)\r\n * * see also https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * * Adaptive exact 2d orientation test.\r\n *\r\n * * Robust.\r\n *\r\n * Return a positive value if the points pa, pb, and pc occur in\r\n * counterclockwise order; a negative value if they occur in clockwise order;\r\n * and zero if they are collinear.  The result is also a rough approximation of\r\n * twice the signed area of the triangle defined by the three points.\r\n *\r\n * The result returned is the determinant of a matrix. This determinant is\r\n * computed adaptively, in the sense that exact arithmetic is used only to the\r\n * degree it is needed to ensure that the returned value has the correct sign.\r\n * Hence, orient2d() is usually quite fast, but will run more slowly when the\r\n * input points are collinear or nearly so.\r\n */\r\nfunction orient2d(A, B, C) {\r\n    const detleft = (A[0] - C[0]) * (B[1] - C[1]);\r\n    const detright = (A[1] - C[1]) * (B[0] - C[0]);\r\n    const det = detleft - detright;\r\n    let detsum;\r\n    if (detleft > 0) {\r\n        if (detright <= 0) {\r\n            // Anti-clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = detleft + detright;\r\n        }\r\n    }\r\n    else if (detleft < 0) {\r\n        if (detright >= 0) {\r\n            // Clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = -detleft - detright;\r\n        }\r\n    }\r\n    else {\r\n        // Anti-clockwise, clockwise or straight\r\n        return det;\r\n    }\r\n    if (Math.abs(det) >= ccwerrboundA * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    return orient2dAdapt(A, B, C, detsum);\r\n}\r\nfunction orient2dAdapt(A, B, C, detsum) {\r\n    const acx = A[0] - C[0];\r\n    const bcx = B[0] - C[0];\r\n    const acy = A[1] - C[1];\r\n    const bcy = B[1] - C[1];\r\n    const b = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acx, bcy), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acy, bcx));\r\n    let det = (0,_double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_2__.eEstimate)(b);\r\n    if (Math.abs(det) >= ccwerrboundB * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    const acxtail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(A[0], C[0])[0];\r\n    const bcxtail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(B[0], C[0])[0];\r\n    const acytail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(A[1], C[1])[0];\r\n    const bcytail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(B[1], C[1])[0];\r\n    if (acxtail === 0 && acytail === 0 &&\r\n        bcxtail === 0 && bcytail === 0) {\r\n        // Straight\r\n        return det;\r\n    }\r\n    const errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\r\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\r\n    if (Math.abs(det) >= errbound) {\r\n        return det;\r\n    }\r\n    const a = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acxtail, bcy), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acytail, bcx));\r\n    const c = (0,_double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum)(b, a);\r\n    const d = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acx, bcytail), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acy, bcxtail));\r\n    const e = (0,_double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum)(c, d);\r\n    const f = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acxtail, bcytail), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct)(acytail, bcxtail));\r\n    let D = (0,_double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum)(e, f);\r\n    D = (0,_double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__.eCompress)(D);\r\n    return D[D.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=orient2d.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/geometric-primitives/orient2d.js?");

/***/ }),

/***/ "./node_modules/big-float-ts/node/index.js":
/*!*************************************************!*\
  !*** ./node_modules/big-float-ts/node/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitLength: () => (/* reexport safe */ _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__.bitLength),\n/* harmony export */   doubleToBinaryString: () => (/* reexport safe */ _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_36__.doubleToBinaryString),\n/* harmony export */   doubleToOctets: () => (/* reexport safe */ _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_37__.doubleToOctets),\n/* harmony export */   eAbs: () => (/* reexport safe */ _double_expansion_e_abs_js__WEBPACK_IMPORTED_MODULE_24__.eAbs),\n/* harmony export */   eAdd: () => (/* binding */ eAdd),\n/* harmony export */   eAddDouble: () => (/* binding */ eAddDouble),\n/* harmony export */   eCalculate: () => (/* reexport safe */ _double_expansion_e_calculate_js__WEBPACK_IMPORTED_MODULE_27__.eCalculate),\n/* harmony export */   eCompare: () => (/* reexport safe */ _double_expansion_e_compare_js__WEBPACK_IMPORTED_MODULE_23__.eCompare),\n/* harmony export */   eCompress: () => (/* reexport safe */ _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_15__.eCompress),\n/* harmony export */   eDiff: () => (/* reexport safe */ _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_17__.eDiff),\n/* harmony export */   eDiv: () => (/* reexport safe */ _double_expansion_e_div_js__WEBPACK_IMPORTED_MODULE_11__.eDiv),\n/* harmony export */   eDivBy2: () => (/* reexport safe */ _double_expansion_e_div_by_2_js__WEBPACK_IMPORTED_MODULE_21__.eDivBy2),\n/* harmony export */   eEstimate: () => (/* reexport safe */ _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_16__.eEstimate),\n/* harmony export */   eIntDiv: () => (/* reexport safe */ _double_expansion_e_int_div_js__WEBPACK_IMPORTED_MODULE_13__.eIntDiv),\n/* harmony export */   eIntPow: () => (/* reexport safe */ _double_expansion_e_int_pow_js__WEBPACK_IMPORTED_MODULE_26__.eIntPow),\n/* harmony export */   eIsInteger: () => (/* reexport safe */ _double_expansion_e_is_integer_js__WEBPACK_IMPORTED_MODULE_44__.eIsInteger),\n/* harmony export */   eLongDivide: () => (/* reexport safe */ _double_expansion_e_long_divide_js__WEBPACK_IMPORTED_MODULE_12__.eLongDivide),\n/* harmony export */   eMult: () => (/* binding */ eMult),\n/* harmony export */   eMultBy2: () => (/* reexport safe */ _double_expansion_e_mult_by_2_js__WEBPACK_IMPORTED_MODULE_19__.eMultBy2),\n/* harmony export */   eMultByNeg2: () => (/* reexport safe */ _double_expansion_e_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_20__.eMultByNeg2),\n/* harmony export */   eMultDouble1: () => (/* binding */ eMultDouble1),\n/* harmony export */   eMultDouble2: () => (/* binding */ eMultDouble2),\n/* harmony export */   eNegativeOf: () => (/* reexport safe */ _double_expansion_e_negative_of_js__WEBPACK_IMPORTED_MODULE_18__.eNegativeOf),\n/* harmony export */   eProduct: () => (/* reexport safe */ _double_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_29__.eProduct),\n/* harmony export */   eRem: () => (/* reexport safe */ _double_expansion_e_rem_js__WEBPACK_IMPORTED_MODULE_14__.eRem),\n/* harmony export */   eSign: () => (/* reexport safe */ _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_22__.eSign),\n/* harmony export */   eSum: () => (/* reexport safe */ _double_expansion_e_sum_js__WEBPACK_IMPORTED_MODULE_28__.eSum),\n/* harmony export */   eToBitlength: () => (/* reexport safe */ _double_expansion_e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_25__.eToBitlength),\n/* harmony export */   eToDd: () => (/* reexport safe */ _double_expansion_e_to_double_double_js__WEBPACK_IMPORTED_MODULE_30__.eToDd),\n/* harmony export */   expBitLength: () => (/* reexport safe */ _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__.expBitLength),\n/* harmony export */   expansionProduct: () => (/* reexport safe */ _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_2__.expansionProduct),\n/* harmony export */   exponent: () => (/* reexport safe */ _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_39__.exponent),\n/* harmony export */   fastExpansionSum: () => (/* reexport safe */ _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum),\n/* harmony export */   fastTwoDiff: () => (/* reexport safe */ _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_4__.fastTwoDiff),\n/* harmony export */   fastTwoSum: () => (/* reexport safe */ _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_5__.fastTwoSum),\n/* harmony export */   getHighestSetBit: () => (/* reexport safe */ _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getHighestSetBit),\n/* harmony export */   getLowestSetBit: () => (/* reexport safe */ _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getLowestSetBit),\n/* harmony export */   growExpansion: () => (/* reexport safe */ _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__.growExpansion),\n/* harmony export */   isAdjacent: () => (/* reexport safe */ _double_expansion_is_adjacent_js__WEBPACK_IMPORTED_MODULE_42__.isAdjacent),\n/* harmony export */   isBitAligned: () => (/* reexport safe */ _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_32__.isBitAligned),\n/* harmony export */   isNonOverlappingAll: () => (/* reexport safe */ _double_expansion_is_overlapping_js__WEBPACK_IMPORTED_MODULE_43__.isNonOverlappingAll),\n/* harmony export */   lsbExponent: () => (/* reexport safe */ _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_34__.lsbExponent),\n/* harmony export */   msbExponent: () => (/* reexport safe */ _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_33__.msbExponent),\n/* harmony export */   operators: () => (/* binding */ operators),\n/* harmony export */   orient2d: () => (/* reexport safe */ _geometric_primitives_orient2d_js__WEBPACK_IMPORTED_MODULE_41__.orient2d),\n/* harmony export */   parseDouble: () => (/* reexport safe */ _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__.parseDouble),\n/* harmony export */   parseDoubleDetailed: () => (/* reexport safe */ _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__.parseDoubleDetailed),\n/* harmony export */   reduceSignificand: () => (/* reexport safe */ _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_10__.reduceSignificand),\n/* harmony export */   scaleExpansion: () => (/* reexport safe */ _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion),\n/* harmony export */   scaleExpansion2: () => (/* reexport safe */ _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion2),\n/* harmony export */   significand: () => (/* reexport safe */ _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_40__.significand),\n/* harmony export */   split: () => (/* reexport safe */ _basic_split_js__WEBPACK_IMPORTED_MODULE_6__.split),\n/* harmony export */   twoDiff: () => (/* reexport safe */ _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_7__.twoDiff),\n/* harmony export */   twoProduct: () => (/* reexport safe */ _basic_two_product_js__WEBPACK_IMPORTED_MODULE_8__.twoProduct),\n/* harmony export */   twoSum: () => (/* reexport safe */ _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_9__.twoSum)\n/* harmony export */ });\n/* harmony import */ var _double_expansion_e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./double-expansion/e-to-bitlength.js */ \"./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js\");\n/* harmony import */ var _double_expansion_e_div_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./double-expansion/e-div.js */ \"./node_modules/big-float-ts/node/double-expansion/e-div.js\");\n/* harmony import */ var _double_expansion_e_long_divide_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./double-expansion/e-long-divide.js */ \"./node_modules/big-float-ts/node/double-expansion/e-long-divide.js\");\n/* harmony import */ var _double_expansion_e_int_div_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./double-expansion/e-int-div.js */ \"./node_modules/big-float-ts/node/double-expansion/e-int-div.js\");\n/* harmony import */ var _double_expansion_e_rem_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./double-expansion/e-rem.js */ \"./node_modules/big-float-ts/node/double-expansion/e-rem.js\");\n/* harmony import */ var _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./double-expansion/e-compress.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var _double_expansion_e_compare_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./double-expansion/e-compare.js */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n/* harmony import */ var _double_expansion_e_abs_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./double-expansion/e-abs.js */ \"./node_modules/big-float-ts/node/double-expansion/e-abs.js\");\n/* harmony import */ var _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./double-expansion/e-estimate.js */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./double-expansion/e-diff.js */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-expansion/fast-expansion-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./basic/fast-two-diff.js */ \"./node_modules/big-float-ts/node/basic/fast-two-diff.js\");\n/* harmony import */ var _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./basic/fast-two-sum.js */ \"./node_modules/big-float-ts/node/basic/fast-two-sum.js\");\n/* harmony import */ var _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-expansion/grow-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var _double_expansion_e_negative_of_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./double-expansion/e-negative-of.js */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-expansion/scale-expansion.js */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _double_expansion_e_mult_by_2_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./double-expansion/e-mult-by-2.js */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var _double_expansion_e_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./double-expansion/e-mult-by-neg-2.js */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var _double_expansion_e_div_by_2_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./double-expansion/e-div-by-2.js */ \"./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js\");\n/* harmony import */ var _basic_split_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./basic/split.js */ \"./node_modules/big-float-ts/node/basic/split.js\");\n/* harmony import */ var _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./basic/two-diff.js */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./basic/two-product.js */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./basic/two-sum.js */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./basic/reduce-significand.js */ \"./node_modules/big-float-ts/node/basic/reduce-significand.js\");\n/* harmony import */ var _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-expansion/expansion-product.js */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./double-representation/parse-double.js */ \"./node_modules/big-float-ts/node/double-representation/parse-double.js\");\n/* harmony import */ var _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./double-representation/is-bit-aligned.js */ \"./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js\");\n/* harmony import */ var _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./double-representation/msb-exponent.js */ \"./node_modules/big-float-ts/node/double-representation/msb-exponent.js\");\n/* harmony import */ var _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./double-representation/lsb-exponent.js */ \"./node_modules/big-float-ts/node/double-representation/lsb-exponent.js\");\n/* harmony import */ var _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./double-expansion/e-sign.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./double-representation/bit-length.js */ \"./node_modules/big-float-ts/node/double-representation/bit-length.js\");\n/* harmony import */ var _double_expansion_e_calculate_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./double-expansion/e-calculate.js */ \"./node_modules/big-float-ts/node/double-expansion/e-calculate.js\");\n/* harmony import */ var _double_expansion_e_sum_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./double-expansion/e-sum.js */ \"./node_modules/big-float-ts/node/double-expansion/e-sum.js\");\n/* harmony import */ var _double_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./double-expansion/e-product.js */ \"./node_modules/big-float-ts/node/double-expansion/e-product.js\");\n/* harmony import */ var _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./double-representation/exponent.js */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n/* harmony import */ var _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./double-representation/significand.js */ \"./node_modules/big-float-ts/node/double-representation/significand.js\");\n/* harmony import */ var _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./double-representation/double-to-binary-string.js */ \"./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js\");\n/* harmony import */ var _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./double-representation/double-to-octets.js */ \"./node_modules/big-float-ts/node/double-representation/double-to-octets.js\");\n/* harmony import */ var _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./double-representation/get-max-set-bit.js */ \"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _double_expansion_e_int_pow_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./double-expansion/e-int-pow.js */ \"./node_modules/big-float-ts/node/double-expansion/e-int-pow.js\");\n/* harmony import */ var _double_expansion_e_to_double_double_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./double-expansion/e-to-double-double.js */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n/* harmony import */ var _geometric_primitives_orient2d_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./geometric-primitives/orient2d.js */ \"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js\");\n/* harmony import */ var _double_expansion_is_adjacent_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./double-expansion/is-adjacent.js */ \"./node_modules/big-float-ts/node/double-expansion/is-adjacent.js\");\n/* harmony import */ var _double_expansion_is_overlapping_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./double-expansion/is-overlapping.js */ \"./node_modules/big-float-ts/node/double-expansion/is-overlapping.js\");\n/* harmony import */ var _double_expansion_e_is_integer_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./double-expansion/e-is-integer.js */ \"./node_modules/big-float-ts/node/double-expansion/e-is-integer.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Aliases for some functions which names were not changed due to them being\r\n// used extensively in the literature with a particular recognizable name\r\nconst eAdd = _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst eAddDouble = _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__.growExpansion;\r\nconst eMult = _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst eMultDouble1 = _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion;\r\nconst eMultDouble2 = _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion2;\r\nconst operators = {\r\n    //---- basic ----//\r\n    fastTwoDiff: _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_4__.fastTwoDiff,\r\n    fastTwoSum: _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_5__.fastTwoSum,\r\n    split: _basic_split_js__WEBPACK_IMPORTED_MODULE_6__.split,\r\n    twoDiff: _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_7__.twoDiff,\r\n    twoProduct: _basic_two_product_js__WEBPACK_IMPORTED_MODULE_8__.twoProduct,\r\n    twoSum: _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_9__.twoSum,\r\n    reduceSignificand: _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_10__.reduceSignificand,\r\n    //---- double floating point expansions ----//\r\n    fastExpansionSum: _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum, eAdd,\r\n    growExpansion: _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__.growExpansion, eAddDouble,\r\n    expansionProduct: _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_2__.expansionProduct, eMult,\r\n    scaleExpansion: _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion, eMultDouble1,\r\n    scaleExpansion2: _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion2, eMultDouble2,\r\n    eDiv: _double_expansion_e_div_js__WEBPACK_IMPORTED_MODULE_11__.eDiv,\r\n    eLongDivide: _double_expansion_e_long_divide_js__WEBPACK_IMPORTED_MODULE_12__.eLongDivide,\r\n    eIntDiv: _double_expansion_e_int_div_js__WEBPACK_IMPORTED_MODULE_13__.eIntDiv,\r\n    eRem: _double_expansion_e_rem_js__WEBPACK_IMPORTED_MODULE_14__.eRem,\r\n    eCompress: _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_15__.eCompress,\r\n    eEstimate: _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_16__.eEstimate,\r\n    eDiff: _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_17__.eDiff,\r\n    eNegativeOf: _double_expansion_e_negative_of_js__WEBPACK_IMPORTED_MODULE_18__.eNegativeOf,\r\n    eMultBy2: _double_expansion_e_mult_by_2_js__WEBPACK_IMPORTED_MODULE_19__.eMultBy2,\r\n    eMultByNeg2: _double_expansion_e_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_20__.eMultByNeg2,\r\n    eDivBy2: _double_expansion_e_div_by_2_js__WEBPACK_IMPORTED_MODULE_21__.eDivBy2,\r\n    eSign: _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_22__.eSign,\r\n    eCompare: _double_expansion_e_compare_js__WEBPACK_IMPORTED_MODULE_23__.eCompare,\r\n    eAbs: _double_expansion_e_abs_js__WEBPACK_IMPORTED_MODULE_24__.eAbs,\r\n    eToBitlength: _double_expansion_e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_25__.eToBitlength,\r\n    eIntPow: _double_expansion_e_int_pow_js__WEBPACK_IMPORTED_MODULE_26__.eIntPow,\r\n    eCalculate: _double_expansion_e_calculate_js__WEBPACK_IMPORTED_MODULE_27__.eCalculate,\r\n    eSum: _double_expansion_e_sum_js__WEBPACK_IMPORTED_MODULE_28__.eSum,\r\n    eProduct: _double_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_29__.eProduct,\r\n    eToDd: _double_expansion_e_to_double_double_js__WEBPACK_IMPORTED_MODULE_30__.eToDd,\r\n    //---- double floating point representation ----//\r\n    parseDouble: _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__.parseDouble,\r\n    parseDoubleDetailed: _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__.parseDoubleDetailed,\r\n    isBitAligned: _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_32__.isBitAligned,\r\n    msbExponent: _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_33__.msbExponent,\r\n    lsbExponent: _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_34__.lsbExponent,\r\n    bitLength: _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__.bitLength,\r\n    expBitLength: _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__.expBitLength,\r\n    doubleToBinaryString: _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_36__.doubleToBinaryString,\r\n    doubleToOctets: _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_37__.doubleToOctets,\r\n    getHighestSetBit: _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getHighestSetBit,\r\n    getLowestSetBit: _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getLowestSetBit,\r\n    exponent: _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_39__.exponent,\r\n    significand: _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_40__.significand,\r\n    //---- geometric primitives\r\n    orient2d: _geometric_primitives_orient2d_js__WEBPACK_IMPORTED_MODULE_41__.orient2d,\r\n    //---- others\r\n    isAdjacent: _double_expansion_is_adjacent_js__WEBPACK_IMPORTED_MODULE_42__.isAdjacent,\r\n    isNonOverlappingAll: _double_expansion_is_overlapping_js__WEBPACK_IMPORTED_MODULE_43__.isNonOverlappingAll,\r\n    eIsInteger: _double_expansion_e_is_integer_js__WEBPACK_IMPORTED_MODULE_44__.eIsInteger\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/big-float-ts/node/index.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/fast-two-diff.js":
/*!****************************************************************!*\
  !*** ./node_modules/double-double/node/basic/fast-two-diff.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastTwoDiff: () => (/* binding */ fastTwoDiff)\n/* harmony export */ });\n/**\r\n * Returns the difference and exact error of subtracting two floating point\r\n * numbers.\r\n * Uses an EFT (error-free transformation), i.e. `a-b === x+y` exactly.\r\n * The returned result is a non-overlapping expansion (smallest value first!).\r\n *\r\n * * **precondition:** `abs(a) >= abs(b)` - A fast test that can be used is\r\n * `(a > b) === (a > -b)`\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoDiff(a, b) {\r\n    const x = a - b;\r\n    const y = (a - x) - b;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=fast-two-diff.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/fast-two-diff.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/fast-two-sum.js":
/*!***************************************************************!*\
  !*** ./node_modules/double-double/node/basic/fast-two-sum.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastTwoSum: () => (/* binding */ fastTwoSum)\n/* harmony export */ });\n/**\r\n * Returns the sum and exact error of adding two floating point numbers.\r\n * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.\r\n * The returned sum is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoSum(a, b) {\r\n    const x = a + b;\r\n    return [b - (x - a), x];\r\n}\r\n// inlined\r\n//const R = a + b; const r = b - (R - a); return [r, R];\r\n\r\n//# sourceMappingURL=fast-two-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/fast-two-sum.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/reduce-significand.js":
/*!*********************************************************************!*\
  !*** ./node_modules/double-double/node/basic/reduce-significand.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reduceSignificand: () => (/* binding */ reduceSignificand)\n/* harmony export */ });\n/**\r\n * Truncates a floating point value's significand and returns the result.\r\n * Similar to split, but with the ability to specify the number of bits to keep.\r\n *\r\n * **Theorem 17 (Veltkamp-Dekker)**: Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param a a double\r\n * @param bits the number of significand bits to leave intact\r\n */\r\nfunction reduceSignificand(a, bits) {\r\n    const s = 53 - bits;\r\n    const f = 2 ** s + 1;\r\n    const c = f * a;\r\n    const r = c - (c - a);\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=reduce-significand.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/reduce-significand.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/split.js":
/*!********************************************************!*\
  !*** ./node_modules/double-double/node/basic/split.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   split: () => (/* binding */ split)\n/* harmony export */ });\n/**\r\n * === 2^Math.ceil(p/2) + 1 where p is the # of significand bits in a double === 53.\r\n * @internal\r\n */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of splitting a double into 2 26-bit doubles.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * see e.g. [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * @param a A double floating point number\r\n */\r\nfunction split(a) {\r\n    const c = f * a;\r\n    const a_h = c - (c - a);\r\n    const a_l = a - a_h;\r\n    return [a_h, a_l];\r\n}\r\n// inlined - input a, output a_h, a_l\r\n// const c = f * a; const a_h = c - (c - a); const a_l = a - a_h; return [a_h, a_l];\r\n\r\n//# sourceMappingURL=split.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/split.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/two-diff.js":
/*!***********************************************************!*\
  !*** ./node_modules/double-double/node/basic/two-diff.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoDiff: () => (/* binding */ twoDiff)\n/* harmony export */ });\n/**\r\n * Returns the exact result of subtracting b from a.\r\n *\r\n * @param a minuend - a double-double precision floating point number\r\n * @param b subtrahend - a double-double precision floating point number\r\n */\r\nfunction twoDiff(a, b) {\r\n    const x = a - b;\r\n    const bvirt = a - x;\r\n    const y = (a - (x + bvirt)) + (bvirt - b);\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-diff.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/two-diff.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/two-product.js":
/*!**************************************************************!*\
  !*** ./node_modules/double-double/node/basic/two-product.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoProduct: () => (/* binding */ twoProduct)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the exact result of multiplying two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction twoProduct(a, b) {\r\n    const x = a * b;\r\n    //const [ah, al] = split(a);\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    //const [bh, bl] = split(b);\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //const err1 = x - (ah * bh);\r\n    //const err2 = err1 - (al * bh);\r\n    //const err3 = err2 - (ah * bl);\r\n    //const y = (al * bl) - err3;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-product.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/two-product.js?");

/***/ }),

/***/ "./node_modules/double-double/node/basic/two-sum.js":
/*!**********************************************************!*\
  !*** ./node_modules/double-double/node/basic/two-sum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoSum: () => (/* binding */ twoSum)\n/* harmony export */ });\n/**\r\n * Returns the exact result of adding two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the\r\n * following algorithm will produce a nonoverlapping expansion x + y such that\r\n * a + b = x + y, where x is an approximation to a + b and y is the roundoff\r\n * error in the calculation of x.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction twoSum(a, b) {\r\n    const x = a + b;\r\n    const bv = x - a;\r\n    return [(a - (x - bv)) + (b - bv), x];\r\n}\r\n// inlined\r\n//const R = a + b; const _ = R - a; const r = (a - (R - _)) + (b - _); return [r,R]\r\n\r\n//# sourceMappingURL=two-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/basic/two-sum.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDivDdWithError: () => (/* binding */ ddDivDdWithError)\n/* harmony export */ });\n/* harmony import */ var _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../double-double/binary/dd-div-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-div-dd.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\n/** @internal */\r\nconst div = _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddDivDd;\r\n/** @internal */\r\nconst eps = Number.EPSILON;\r\n/** @internal */\r\nconst u = eps / 2;\r\n/** @internal */\r\nconst uu = u * u;\r\n/**\r\n * Returns the result of dividing two double-double-precision floating point\r\n * numbers together with an absolute error bound where nE and dE are absolute\r\n * error bounds on the *input* values.\r\n *\r\n * @param numer numerator - a double-double-precision float\r\n * @param denom denominator - a double-double-precision float\r\n * @param nE absolute value error bound in numerator\r\n * @param dE absolute value error bound in denominator\r\n */\r\nfunction ddDivDdWithError(numer, denom, nE, dE) {\r\n    const n = numer[0];\r\n    const N = numer[1];\r\n    const d = denom[0];\r\n    const D = denom[1];\r\n    // estimate the result of the division\r\n    const est = div(numer, denom);\r\n    const _n = Math.abs(n + N); // absolute value of estimate of n accurate to within 1/2 ulp\r\n    const _d = Math.abs(d + D); // absolute value of estimate of d accurate to within 1/2 ulp\r\n    const δd = u * _d; // the max error in the rounding to _d\r\n    // if the error in the denominator is too high the error can be \r\n    // arbitrarily high\r\n    const minD = _d - δd - dE;\r\n    // maxErr is only valid if minD > 0\r\n    if (minD <= 0) {\r\n        // the error can be arbitrarily high; est is mostly irrelevant\r\n        return { est, err: Number.POSITIVE_INFINITY };\r\n    }\r\n    const err = ((_d * nE + _n * dE) / minD ** 2) + 9 * uu * Math.abs(_n / _d);\r\n    return { est, err };\r\n}\r\n\r\n//# sourceMappingURL=dd-div-dd-with-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-add-dd.js":
/*!***************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-add-dd.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddAddDd: () => (/* binding */ ddAddDd)\n/* harmony export */ });\n/**\r\n * Returns the result of adding two double-double-precision floating point\r\n * numbers.\r\n *\r\n * * relative error bound: 3u^2 + 13u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n * * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 2.25u^2\r\n *\r\n * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddAddDd(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    //const [sl,sh] = twoSum(xh,yh);\r\n    const sh = xh + yh;\r\n    const _1 = sh - xh;\r\n    const sl = (xh - (sh - _1)) + (yh - _1);\r\n    //const [tl,th] = twoSum(xl,yl);\r\n    const th = xl + yl;\r\n    const _2 = th - xl;\r\n    const tl = (xl - (th - _2)) + (yl - _2);\r\n    const c = sl + th;\r\n    //const [vl,vh] = fastTwoSum(sh,c)\r\n    const vh = sh + c;\r\n    const vl = c - (vh - sh);\r\n    const w = tl + vl;\r\n    //const [zl,zh] = fastTwoSum(vh,w)\r\n    const zh = vh + w;\r\n    const zl = w - (zh - vh);\r\n    return [zl, zh];\r\n}\r\n\r\n//# sourceMappingURL=dd-add-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-add-dd.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-compare.js":
/*!****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-compare.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddCompare: () => (/* binding */ ddCompare)\n/* harmony export */ });\n/**\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n *\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddCompare(x, y) {\r\n    //return ddDiffDd(x,y)[1];\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    //const [sl,sh] = twoSum(xh,yh);\r\n    const sh = xh - yh;\r\n    const _1 = sh - xh;\r\n    const sl = (xh - (sh - _1)) + (-yh - _1);\r\n    //const [tl,th] = twoSum(xl,yl);\r\n    const th = xl - yl;\r\n    const _2 = th - xl;\r\n    const tl = (xl - (th - _2)) + (-yl - _2);\r\n    const c = sl + th;\r\n    //const [vl,vh] = fastTwoSum(sh,c)\r\n    const vh = sh + c;\r\n    const vl = c - (vh - sh);\r\n    const w = tl + vl;\r\n    //const [zl,zh] = fastTwoSum(vh,w)\r\n    const zh = vh + w;\r\n    return zh;\r\n}\r\n\r\n//# sourceMappingURL=dd-compare.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-compare.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-diff-dd.js":
/*!****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-diff-dd.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDiffDd: () => (/* binding */ ddDiffDd)\n/* harmony export */ });\n/**\r\n * Returns the result of subtracting the second given double-double-precision\r\n * floating point number from the first.\r\n *\r\n * * relative error bound: 3u^2 + 13u^3, i.e. fl(a-b) = (a-b)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n * * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 2.25u^2\r\n *\r\n * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddDiffDd(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    //const [sl,sh] = twoSum(xh,yh);\r\n    const sh = xh - yh;\r\n    const _1 = sh - xh;\r\n    const sl = (xh - (sh - _1)) + (-yh - _1);\r\n    //const [tl,th] = twoSum(xl,yl);\r\n    const th = xl - yl;\r\n    const _2 = th - xl;\r\n    const tl = (xl - (th - _2)) + (-yl - _2);\r\n    const c = sl + th;\r\n    //const [vl,vh] = fastTwoSum(sh,c)\r\n    const vh = sh + c;\r\n    const vl = c - (vh - sh);\r\n    const w = tl + vl;\r\n    //const [zl,zh] = fastTwoSum(vh,w)\r\n    const zh = vh + w;\r\n    const zl = w - (zh - vh);\r\n    return [zl, zh];\r\n}\r\n\r\n//# sourceMappingURL=dd-diff-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-diff-dd.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-div-dd.js":
/*!***************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-div-dd.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDivDd: () => (/* binding */ ddDivDd)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of dividing two double-double-precision floating point\r\n * numbers, i.e. returns x/y.\r\n *\r\n * * relative error bound: 15u^2 + 56u^3, i.e. fl(a/b) = (a/b)(1+ϵ),\r\n * where ϵ <= 15u^2 + 56u^3, u = 0.5 * Number.EPSILON\r\n * * the largest error found was 8.465u^2\r\n *\r\n * * ALGORITHM 17 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddDivDd(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    const th = xh / yh;\r\n    // approximation to th*(yh + yl) using Algorithm 7\r\n    //const [rl,rh] = ddMultDouble1(th,[yl,yh]);  \r\n    const ch = yh * th;\r\n    const c = f * yh;\r\n    const ah = c - (c - yh);\r\n    const al = yh - ah;\r\n    const d = f * th;\r\n    const bh = d - (d - th);\r\n    const bl = th - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const cl2 = yl * th;\r\n    const th_ = ch + cl2;\r\n    const tl1 = cl2 - (th_ - ch);\r\n    const tl2 = tl1 + cl1;\r\n    const rh = th_ + tl2;\r\n    const rl = tl2 - (rh - th_);\r\n    const πh = xh - rh; // exact operation\r\n    const δl = xl - rl;\r\n    const δ = πh + δl;\r\n    const tl = δ / yh;\r\n    //return fastTwoSum(th,tl);\r\n    const xx = th + tl;\r\n    return [tl - (xx - th), xx];\r\n}\r\n\r\n//# sourceMappingURL=dd-div-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-div-dd.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-max.js":
/*!************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-max.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMax: () => (/* binding */ ddMax)\n/* harmony export */ });\n/* harmony import */ var _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-diff-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-diff-dd.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\n/** @internal */\r\nconst diff = _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the maximum of a and b.\r\n * @param a a double-double precision floating point number\r\n * @param b another double-double precision floating point number\r\n */\r\nfunction ddMax(a, b) {\r\n    const res = diff(a, b)[1];\r\n    return res > 0 ? a : b;\r\n}\r\n\r\n//# sourceMappingURL=dd-max.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-max.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-min.js":
/*!************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-min.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMin: () => (/* binding */ ddMin)\n/* harmony export */ });\n/* harmony import */ var _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-diff-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-diff-dd.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\n/** @internal */\r\nconst diff = _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the minimum of a and b.\r\n * @param a a double-double precision floating point number\r\n * @param b another double-double precision floating point number\r\n */\r\nfunction ddMin(a, b) {\r\n    const res = diff(a, b)[1];\r\n    return res > 0 ? b : a;\r\n}\r\n\r\n//# sourceMappingURL=dd-min.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-min.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/binary/dd-mult-dd.js":
/*!****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/binary/dd-mult-dd.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMultDd: () => (/* binding */ ddMultDd)\n/* harmony export */ });\n/** @internal */\r\nconst f = 2 ** 27 + 1;\r\n/**\r\n * Returns the product of two double-double-precision floating point numbers.\r\n *\r\n * * relative error bound: 7u^2, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON\r\n * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 5u^2\r\n *\r\n * * ALGORITHM 10 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddMultDd(x, y) {\r\n    //const xl = x[0];\r\n    const xh = x[1];\r\n    //const yl = y[0];\r\n    const yh = y[1];\r\n    //const [cl1,ch] = twoProduct(xh,yh);\r\n    const ch = xh * yh;\r\n    const c = f * xh;\r\n    const ah = c - (c - xh);\r\n    const al = xh - ah;\r\n    const d = f * yh;\r\n    const bh = d - (d - yh);\r\n    const bl = yh - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //return fastTwoSum(ch,cl1 + (xh*yl + xl*yh));\r\n    const b = cl1 + (xh * y[0] + x[0] * yh);\r\n    const xx = ch + b;\r\n    return [b - (xx - ch), xx];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/binary/dd-mult-dd.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/multi/dd-product.js":
/*!***************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/multi/dd-product.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddProduct: () => (/* binding */ ddProduct)\n/* harmony export */ });\n/* harmony import */ var _binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary/dd-mult-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-mult-dd.js\");\n\r\n/**\r\n * Returns the result of multiplying together an array of double-double-precision\r\n * floating point numbers naively (i.e. not using pairwise addition to reduce\r\n * error a bit).\r\n *\r\n * * an error bound is given by: (n-1)(1+ϵ),\r\n * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON\r\n */\r\nfunction ddProduct(qs) {\r\n    let q = qs[0];\r\n    for (let i = 1; i < qs.length; i++) {\r\n        q = (0,_binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(q, qs[i]);\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=dd-product.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/multi/dd-product.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/multi/dd-sum.js":
/*!***********************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/multi/dd-sum.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddSum: () => (/* binding */ ddSum)\n/* harmony export */ });\n/* harmony import */ var _binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary/dd-add-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-add-dd.js\");\n\r\n/**\r\n * Returns the result of summing an array of double-double-precision floating\r\n * point numbers naively (i.e. not using pairwise addition to reduce error a bit).\r\n *\r\n * * an error bound is given by: (n-1)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n */\r\nfunction ddSum(qs) {\r\n    let q = qs[0];\r\n    for (let i = 1; i < qs.length; i++) {\r\n        q = (0,_binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(q, qs[i]);\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=dd-sum.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/multi/dd-sum.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-abs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-abs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddAbs: () => (/* binding */ ddAbs)\n/* harmony export */ });\n/**\r\n * Returns the absolute value of the given double-double precision floating\r\n * point number.\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddAbs(f) {\r\n    const Q = f[1];\r\n    return (Q < 0) ? [-f[0], -Q] : f;\r\n}\r\n\r\n//# sourceMappingURL=dd-abs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-abs.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-div-by-2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-div-by-2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDivBy2: () => (/* binding */ ddDivBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of dividing the given double-double by 2.\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddDivBy2(f) {\r\n    return [f[0] / 2, f[1] / 2];\r\n}\r\n\r\n//# sourceMappingURL=dd-div-by-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-div-by-2.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMultBy2: () => (/* binding */ ddMultBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by 2.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultBy2(f) {\r\n    return [2 * f[0], 2 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMultBy4: () => (/* binding */ ddMultBy4)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by 4.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultBy4(f) {\r\n    return [4 * f[0], 4 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-4.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMultByNeg2: () => (/* binding */ ddMultByNeg2)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by -2.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultByNeg2(f) {\r\n    return [-2 * f[0], -2 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-neg-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMultByNeg4: () => (/* binding */ ddMultByNeg4)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by -4.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultByNeg4(f) {\r\n    return [-4 * f[0], -4 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-neg-4.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-negative-of.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-negative-of.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddNegativeOf: () => (/* binding */ ddNegativeOf)\n/* harmony export */ });\n/**\r\n * Returns the negative of the given double-double precision floating point\r\n * number.\r\n * * the result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddNegativeOf(f) {\r\n    return [-f[0], -f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-negative-of.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-negative-of.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-sign.js":
/*!************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-sign.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddSign: () => (/* binding */ ddSign)\n/* harmony export */ });\n/**\r\n * Returns the sign of the given double-double-precision floating point number.\r\n * * a positive or negative double or zero is returned - not necessarily +1, 0\r\n * or -1\r\n * * prefer inlining this - it is really only here for reference\r\n */\r\nfunction ddSign(f) {\r\n    return f[1];\r\n}\r\n\r\n//# sourceMappingURL=dd-sign.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-sign.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-double/unary/dd-sqrt.js":
/*!************************************************************************!*\
  !*** ./node_modules/double-double/node/double-double/unary/dd-sqrt.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddSqrt: () => (/* binding */ ddSqrt)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts\r\n// Unfortunately no error bound given\r\n/**\r\n * Returns the square root of a double-double as a double-double.\r\n * * no error bound is returned\r\n *\r\n * @param x a double-double precision floating point number\r\n */\r\n// TODO - calculate an error bound and add to function description\r\nfunction ddSqrt(x) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    if (xh === 0) {\r\n        return [0, 0];\r\n    }\r\n    const s = Math.sqrt(xh);\r\n    //const [tl,th] = twoSquare(s);\r\n    const th = s * s;\r\n    const c = f * s;\r\n    const ah = c - (c - s);\r\n    const al = s - ah;\r\n    const tl = (al * al) - ((th - (ah * ah)) - 2 * (ah * al));\r\n    const e = (xh - th - tl + xl) * 0.5 / s;\r\n    return [e - ((s + e) - s), s + e];\r\n}\r\n\r\n//# sourceMappingURL=dd-sqrt.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-double/unary/dd-sqrt.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddAddDouble: () => (/* binding */ ddAddDouble)\n/* harmony export */ });\n/**\r\n * Returns the result of adding a double to a double-double precision floating\r\n * point number.\r\n *\r\n * * relative error bound: 2u^2, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 2u^2, u = 0.5 * Number.EPSILON\r\n * * the error bound is sharp\r\n *\r\n * ALGORITHM 4 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y a double precision floating point number\r\n */\r\nfunction ddAddDouble(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    //const [sl,sh] = twoSum(xh, y);\r\n    const sh = xh + y;\r\n    const c = sh - xh;\r\n    const sl = (xh - (sh - c)) + (y - c);\r\n    const v = xl + sl;\r\n    //const [zl,zh] = fastTwoSum(sh,v);\r\n    const zh = sh + v;\r\n    const zl = v - (zh - sh);\r\n    return [zl, zh];\r\n}\r\n\r\n//# sourceMappingURL=dd-add-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDivDouble: () => (/* binding */ ddDivDouble)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of dividing a double-double-precision floating point\r\n * number by a double.\r\n *\r\n * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,\r\n * u = 0.5 * Number.EPSILON\r\n * * the bound is very sharp\r\n *\r\n * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y the double-precision divisor\r\n */\r\nfunction ddDivDouble(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const th = xh / y;\r\n    //const [πl,πh] = twoProduct(th,y);\r\n    const πh = th * y;\r\n    const c = f * th;\r\n    const ah = c - (c - th);\r\n    const al = th - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const πl = (al * bl) - ((πh - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const δh = xh - πh; // exact operation\r\n    const δt = δh - πl; // exact operation\r\n    const δ = δt + xl;\r\n    const tl = δ / y;\r\n    //return fastTwoSum(th,tl);\r\n    const rl = th + tl;\r\n    return [tl - (rl - th), rl];\r\n}\r\n\r\n//# sourceMappingURL=dd-div-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddMultDouble1: () => (/* binding */ ddMultDouble1),\n/* harmony export */   ddMultDouble2: () => (/* binding */ ddMultDouble2)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the product of a double-double-precision floating point number and a\r\n * double.\r\n *\r\n * * slower than ALGORITHM 8 (one call to fastTwoSum more) but about 2x more\r\n * accurate\r\n * * relative error bound: 1.5u^2 + 4u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 1.5u^2 + 4u^3, u = 0.5 * Number.EPSILON\r\n * * the bound is very sharp\r\n * * probably prefer `ddMultDouble2` due to extra speed\r\n *\r\n * * ALGORITHM 7 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param y a double\r\n * @param x a double-double precision floating point number\r\n */\r\nfunction ddMultDouble1(y, x) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    //const [cl1,ch] = twoProduct(xh,y);\r\n    const ch = xh * y;\r\n    const c = f * xh;\r\n    const ah = c - (c - xh);\r\n    const al = xh - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const cl2 = xl * y;\r\n    //const [tl1,th] = fastTwoSum(ch,cl2);\r\n    const th = ch + cl2;\r\n    const tl1 = cl2 - (th - ch);\r\n    const tl2 = tl1 + cl1;\r\n    //const [zl,zh] = fastTwoSum(th,tl2);\r\n    const zh = th + tl2;\r\n    const zl = tl2 - (zh - th);\r\n    return [zl, zh];\r\n}\r\n/**\r\n * Returns the product of a double-double-precision floating point number and a double.\r\n *\r\n * * faster than ALGORITHM 7 (one call to fastTwoSum less) but about 2x less\r\n * accurate\r\n * * relative error bound: 3u^2, i.e. fl(a*b) = (a*b)(1+ϵ),\r\n * where ϵ <= 3u^2, u = 0.5 * Number.EPSILON\r\n * * the bound is sharp\r\n * * probably prefer this algorithm due to extra speed\r\n *\r\n * * ALGORITHM 8 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param y a double\r\n * @param x a double-double precision floating point number\r\n */\r\nfunction ddMultDouble2(y, x) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    //const [cl1,ch] = twoProduct(xh,y);\r\n    const ch = xh * y;\r\n    const c = f * xh;\r\n    const ah = c - (c - xh);\r\n    const al = xh - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const cl2 = xl * y;\r\n    const cl3 = cl1 + cl2;\r\n    //return fastTwoSum(ch,cl3);\r\n    const xx = ch + cl3;\r\n    return [cl3 - (xx - ch), xx];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-mixed-double-double/double-div-double.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/double-double/node/double-mixed-double-double/double-div-double.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doubleDivDouble: () => (/* binding */ doubleDivDouble)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of dividing a double-precision floating point\r\n * number by a double with the result given as a double-double.\r\n * This is a slight modification of ddDivDd.\r\n *\r\n * * **!! NOT an error-free transformation !!**\r\n * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,\r\n * u = 0.5 * Number.EPSILON\r\n *\r\n * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * (slightly modified)\r\n * @param x dividend\r\n * @param y divisor\r\n */\r\nfunction doubleDivDouble(x, y) {\r\n    const th = x / y;\r\n    //const [πl,πh] = twoProduct(th,y);\r\n    const πh = th * y;\r\n    const c = f * th;\r\n    const ah = c - (c - th);\r\n    const al = th - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const πl = (al * bl) - ((πh - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const δh = x - πh; // exact operation\r\n    const δt = δh - πl; // exact operation\r\n    const tl = δt / y;\r\n    //return fastTwoSum(th,tl);\r\n    const xx = th + tl;\r\n    return [tl - (xx - th), xx];\r\n}\r\n\r\n//# sourceMappingURL=double-div-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-mixed-double-double/double-div-double.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doubleSqrt: () => (/* binding */ doubleSqrt)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts\r\n// Unfortunately no error bound given\r\n/**\r\n * Returns the square root of a double as a double-double.\r\n * * no error bound is returned\r\n */\r\n// TODO - calculate an error bound and add to function description\r\nfunction doubleSqrt(x) {\r\n    if (x === 0) {\r\n        return [0, 0];\r\n    }\r\n    const s = Math.sqrt(x);\r\n    //const [tl,th] = twoSquare(s);\r\n    const th = s * s;\r\n    const c = f * s;\r\n    const ah = c - (c - s);\r\n    const al = s - ah;\r\n    const tl = (al * al) - ((th - (ah * ah)) - 2 * (ah * al));\r\n    const e = (x - th - tl) * 0.5 / s;\r\n    x = s + e;\r\n    const xl = e - (x - s);\r\n    return [xl, x];\r\n}\r\n\r\n//# sourceMappingURL=double-sqrt.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/bit-length.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/bit-length.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitLength: () => (/* binding */ bitLength)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/double-double/node/double-representation/get-max-set-bit.js\");\n\r\n/**\r\n * Returns the bit-length of the significand of the given number in such a way\r\n * that trailing zeros are not counted.\r\n * @param a a double precision floating point number\r\n */\r\nfunction bitLength(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) + 1;\r\n}\r\n\r\n//# sourceMappingURL=bit-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/bit-length.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/double-to-binary-string.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/double-to-binary-string.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doubleToBinaryString: () => (/* binding */ doubleToBinaryString)\n/* harmony export */ });\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-octets.js */ \"./node_modules/double-double/node/double-representation/double-to-octets.js\");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\n/** @internal */\r\nfunction doubleToBinaryString(number) {\r\n    return octetsToBinaryString((0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__.doubleToOctets)(number));\r\n}\r\n/**\r\n * @param octets The 8 bytes composing a double (msb first)\r\n * @internal\r\n */\r\nfunction octetsToBinaryString(octets) {\r\n    return octets\r\n        .map(int8ToBinaryString)\r\n        .join('');\r\n}\r\n/**\r\n * intToBinaryString(8) -> \"00001000\"\r\n * @internal\r\n */\r\nfunction int8ToBinaryString(i) {\r\n    let iStr = i.toString(2);\r\n    for (; iStr.length < 8; iStr = \"0\" + iStr)\r\n        ;\r\n    return iStr;\r\n}\r\n\r\n//# sourceMappingURL=double-to-binary-string.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/double-to-binary-string.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/double-to-octets.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/double-to-octets.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doubleToOctets: () => (/* binding */ doubleToOctets)\n/* harmony export */ });\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n/**\r\n * Returns the ieee-574 8 bytes composing the given double, starting from the\r\n * sign bit and ending in the lsb of the significand.\r\n * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]\r\n * @internal\r\n */\r\nfunction doubleToOctets(number) {\r\n    const buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setFloat64(0, number, false);\r\n    return Array.from(new Uint8Array(buffer));\r\n}\r\n\r\n//# sourceMappingURL=double-to-octets.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/double-to-octets.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/exponent.js":
/*!***************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/exponent.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exponent: () => (/* binding */ exponent)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ \"./node_modules/double-double/node/double-representation/parse-double.js\");\n\r\n/**\r\n * Returns the normalized exponent of the given number.\r\n * @param a A double\r\n */\r\nfunction exponent(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).exponent;\r\n}\r\n\r\n//# sourceMappingURL=exponent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/exponent.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/get-max-set-bit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/get-max-set-bit.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHighestSetBit: () => (/* binding */ getHighestSetBit),\n/* harmony export */   getLowestSetBit: () => (/* binding */ getLowestSetBit)\n/* harmony export */ });\n/* harmony import */ var _significand_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./significand.js */ \"./node_modules/double-double/node/double-representation/significand.js\");\n\r\n/**\r\n * Returns the lowest set bit of the given value in [1, (2**31)-1],\r\n * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns\r\n * NaN, otherwise if the number is out of range returns a non-finite\r\n * number.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n * @internal\r\n */\r\nfunction getLowestSetBit_(a) {\r\n    return Math.log2(a & -a);\r\n}\r\n/**\r\n * Returns the lowest set bit of the given number's significand (where the lsb\r\n * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or\r\n * NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // Note: the significand includes the hidden bit!\r\n    const s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    const len = s.length;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === 0) {\r\n            continue;\r\n        }\r\n        const l = getLowestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up\r\n * to 255. If the input number === 0 returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n * @internal\r\n */\r\nfunction getHighestSetBit_(a) {\r\n    return a >= 128 ? 7\r\n        : a >= 64 ? 6\r\n            : a >= 32 ? 5\r\n                : a >= 16 ? 4\r\n                    : a >= 8 ? 3\r\n                        : a >= 4 ? 2\r\n                            : a >= 2 ? 1\r\n                                : a >= 1 ? 0\r\n                                    : NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given double. If no bit is set (input\r\n * === 0 or +/-inf or NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // At this point there must be a highest set bit (always === 52 if the \r\n    // number is not a subnormal.\r\n    const s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    const len = s.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const l = getHighestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n\r\n//# sourceMappingURL=get-max-set-bit.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/get-max-set-bit.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/is-bit-aligned.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/is-bit-aligned.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isBitAligned: () => (/* binding */ isBitAligned)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/double-double/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/double-double/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns true if the given number is bit-aligned in the sense that its a\r\n * multiple of a given power of 2, say e, and such that the number, say a,\r\n * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.\r\n * This essentially means the numbers act somewhat like fixed-point numbers\r\n * which can drastically speed up some geometric algorithms and also reduce\r\n * their complexity.\r\n *\r\n * Visually:\r\n * These numbers (a,b and c) are grid aligned with e === 3 and max\r\n * bitlength === 6:\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|000\r\n *   c -> 00|110111|000\r\n * These are not\r\n *   a -> 01|101100|000\r\n *   b -> 00|000100|000\r\n * These are not\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|100\r\n * These are not\r\n *   a -> 00|101100|100\r\n *   b -> 00|000100|100\r\n * @param as An array of numbers to check\r\n * @param maxBitLength The max allowed bitlength\r\n * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent\r\n */\r\nfunction isBitAligned(a, maxBitLength, gridSpacingExponent) {\r\n    if (a === 0) {\r\n        return true;\r\n    }\r\n    const e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.exponent)(a);\r\n    const maxSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getHighestSetBit)(a) - 52 + e;\r\n    const minSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getLowestSetBit)(a) - 52 + e;\r\n    const minBitBigEnough = minSetBit >= gridSpacingExponent;\r\n    const maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;\r\n    return minBitBigEnough && maxBitSmallEnough;\r\n}\r\n\r\n//# sourceMappingURL=is-bit-aligned.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/is-bit-aligned.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/lsb-exponent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/lsb-exponent.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lsbExponent: () => (/* binding */ lsbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/double-double/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/double-double/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns the true exponent of the lsb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction lsbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    const e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.exponent)(a);\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getLowestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=lsb-exponent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/lsb-exponent.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/msb-exponent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/msb-exponent.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   msbExponent: () => (/* binding */ msbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-max-set-bit.js */ \"./node_modules/double-double/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ \"./node_modules/double-double/node/double-representation/exponent.js\");\n\r\n\r\n/**\r\n * Returns the true exponent of the msb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction msbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    const e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.exponent)(a);\r\n    // Will return e for all but subnormal numbers\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_1__.getHighestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=msb-exponent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/msb-exponent.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/parse-double.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/parse-double.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseDouble: () => (/* binding */ parseDouble),\n/* harmony export */   parseDoubleDetailed: () => (/* binding */ parseDoubleDetailed)\n/* harmony export */ });\n/* harmony import */ var _double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-to-binary-string.js */ \"./node_modules/double-double/node/double-representation/double-to-binary-string.js\");\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-octets.js */ \"./node_modules/double-double/node/double-representation/double-to-octets.js\");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\n\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double. The returned\r\n * exponent has been normalized (i.e. 1023 ha been subtracted) and the\r\n * significand has the hidden bit added if appropriate.\r\n * See https://github.com/bartaz/ieee754-visualization\r\n */\r\nfunction parseDouble(x) {\r\n    const parts = (0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__.doubleToOctets)(x);\r\n    const p0 = parts[0];\r\n    const p1 = parts[1];\r\n    const sign = p0 >> 7;\r\n    const exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);\r\n    //---- Check for negative / positive zero / denormalized numbers.\r\n    const hiddenMsb = exponent_ === 0 ? 0 : 16;\r\n    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).\r\n    const exponent = exponent_ === 0\r\n        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)\r\n        : exponent_ - 1023;\r\n    //---- Break up the significand into bytes\r\n    const significand = parts.slice(1);\r\n    significand[0] = (p1 & 15) + hiddenMsb;\r\n    return {\r\n        sign,\r\n        exponent,\r\n        significand\r\n    };\r\n}\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double.\r\n * See https://github.com/bartaz/ieee754-visualization.\r\n * This is a slower version of parseDouble that gives binary string\r\n * representations of the components.\r\n */\r\nfunction parseDoubleDetailed(x) {\r\n    const str = (0,_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_1__.doubleToBinaryString)(x);\r\n    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)\r\n    const [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);\r\n    const exponent_ = parseInt(exponent, 2);\r\n    const hidden = exponent_ === 0 ? \"0\" : \"1\";\r\n    return {\r\n        full: sign + exponent + hidden + significand,\r\n        sign,\r\n        exponent,\r\n        hidden,\r\n        significand\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=parse-double.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/parse-double.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-representation/significand.js":
/*!******************************************************************************!*\
  !*** ./node_modules/double-double/node/double-representation/significand.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   significand: () => (/* binding */ significand)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ \"./node_modules/double-double/node/double-representation/parse-double.js\");\n\r\n/**\r\n * Return the significand of the given double with the hidden bit added (in case\r\n * a is not subnormal or 0, etc.)\r\n *\r\n * @param a A double\r\n */\r\nfunction significand(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).significand;\r\n}\r\n\r\n//# sourceMappingURL=significand.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-representation/significand.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-with-err/div-with-err.js":
/*!*************************************************************************!*\
  !*** ./node_modules/double-double/node/double-with-err/div-with-err.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   divWithErr: () => (/* binding */ divWithErr)\n/* harmony export */ });\n/** @internal */\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns the result of dividing two double floating point numbers\r\n * together with an absolute error bound where nE and dE are absolute error\r\n * bounds on the input values.\r\n * @param n numerator\r\n * @param d denominator\r\n * @param nE absolute value error bound in numerator\r\n * @param dE absolute value error bound in denominator\r\n */\r\nfunction divWithErr(n, d, nE, dE) {\r\n    // estimate the result of the division\r\n    const est = n / d;\r\n    const _n = Math.abs(n);\r\n    const _d = Math.abs(d);\r\n    // if the error in the denominator is too high the error can be \r\n    // arbitrarily high\r\n    const minD = _d - dE;\r\n    // maxErr is only valid if minD > 0\r\n    if (minD <= 0) {\r\n        // the error can be arbitrarily high; est is mostly irrelevant\r\n        return { est, err: Number.POSITIVE_INFINITY };\r\n    }\r\n    const err = ((_d * nE + _n * dE) / minD ** 2) + u * Math.abs(_n / _d);\r\n    return { est, err };\r\n}\r\n\r\n//# sourceMappingURL=div-with-err.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-with-err/div-with-err.js?");

/***/ }),

/***/ "./node_modules/double-double/node/double-with-err/sqrt-with-err.js":
/*!**************************************************************************!*\
  !*** ./node_modules/double-double/node/double-with-err/sqrt-with-err.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sqrtWithErr: () => (/* binding */ sqrtWithErr)\n/* harmony export */ });\n/** @internal */\r\nconst eps = Number.EPSILON;\r\n/**\r\n * Returns the result of the square root of a double floating point number\r\n * together with an absolute error bound where x_ is an absolute error\r\n * bound on the input value.\r\n * * see also \"A Reduced Product of Absolute and Relative Error Bounds for Floating-point Analysis\"\r\n * by Maxime Jacquemin, Sylvie Putot, and Franck Vedrine\r\n * @param x numerator\r\n * @param x_ absolute value error bound in numerator\r\n */\r\nfunction sqrtWithErr(x, x_) {\r\n    // Note: it is assumed x + x_ >= 0, else the error in x_ was wrong in the\r\n    // first place (since we can't have a negative input to the square root)\r\n    // estimate the result of the square root\r\n    if (x - x_ <= 0) {\r\n        const est = x > 0 ? Math.sqrt(x) : 0;\r\n        return {\r\n            est,\r\n            err: Math.max(Math.sqrt(x + x_) - est, est)\r\n        };\r\n    }\r\n    const est = Math.sqrt(x);\r\n    const minSqrt = Math.sqrt(x - x_);\r\n    const maxSqrt = Math.sqrt(x + x_);\r\n    const err = Math.max(Math.abs(minSqrt - est), Math.abs(maxSqrt - est));\r\n    //err += eps*abs(est + err);\r\n    //err = eps*abs(est + err);\r\n    // approx relative input error\r\n    //const rel = x_/abs(x);\r\n    // propogated error bound\r\n    //const err = est*(Math.sqrt(1 + rel) - 1) + u*abs(est);\r\n    return { est, err };\r\n}\r\n\r\n//# sourceMappingURL=sqrt-with-err.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/double-with-err/sqrt-with-err.js?");

/***/ }),

/***/ "./node_modules/double-double/node/index.js":
/*!**************************************************!*\
  !*** ./node_modules/double-double/node/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitLength: () => (/* binding */ bitLength),\n/* harmony export */   ddAbs: () => (/* binding */ ddAbs),\n/* harmony export */   ddAddDd: () => (/* binding */ ddAddDd),\n/* harmony export */   ddAddDouble: () => (/* binding */ ddAddDouble),\n/* harmony export */   ddCompare: () => (/* binding */ ddCompare),\n/* harmony export */   ddDiffDd: () => (/* binding */ ddDiffDd),\n/* harmony export */   ddDivBy2: () => (/* binding */ ddDivBy2),\n/* harmony export */   ddDivDd: () => (/* binding */ ddDivDd),\n/* harmony export */   ddDivDdWithError: () => (/* binding */ ddDivDdWithError),\n/* harmony export */   ddDivDouble: () => (/* binding */ ddDivDouble),\n/* harmony export */   ddMax: () => (/* binding */ ddMax),\n/* harmony export */   ddMin: () => (/* binding */ ddMin),\n/* harmony export */   ddMultBy2: () => (/* binding */ ddMultBy2),\n/* harmony export */   ddMultBy4: () => (/* binding */ ddMultBy4),\n/* harmony export */   ddMultByNeg2: () => (/* binding */ ddMultByNeg2),\n/* harmony export */   ddMultByNeg4: () => (/* binding */ ddMultByNeg4),\n/* harmony export */   ddMultDd: () => (/* binding */ ddMultDd),\n/* harmony export */   ddMultDouble1: () => (/* binding */ ddMultDouble1),\n/* harmony export */   ddMultDouble2: () => (/* binding */ ddMultDouble2),\n/* harmony export */   ddNegativeOf: () => (/* binding */ ddNegativeOf),\n/* harmony export */   ddProduct: () => (/* binding */ ddProduct),\n/* harmony export */   ddSign: () => (/* binding */ ddSign),\n/* harmony export */   ddSqrt: () => (/* binding */ ddSqrt),\n/* harmony export */   ddSum: () => (/* binding */ ddSum),\n/* harmony export */   divWithErr: () => (/* binding */ divWithErr),\n/* harmony export */   doubleDivDouble: () => (/* binding */ doubleDivDouble),\n/* harmony export */   doubleSqrt: () => (/* binding */ doubleSqrt),\n/* harmony export */   doubleToBinaryString: () => (/* binding */ doubleToBinaryString),\n/* harmony export */   doubleToOctets: () => (/* binding */ doubleToOctets),\n/* harmony export */   exponent: () => (/* binding */ exponent),\n/* harmony export */   fastTwoDiff: () => (/* binding */ fastTwoDiff),\n/* harmony export */   fastTwoSum: () => (/* binding */ fastTwoSum),\n/* harmony export */   getHighestSetBit: () => (/* binding */ getHighestSetBit),\n/* harmony export */   getLowestSetBit: () => (/* binding */ getLowestSetBit),\n/* harmony export */   isBitAligned: () => (/* binding */ isBitAligned),\n/* harmony export */   lsbExponent: () => (/* binding */ lsbExponent),\n/* harmony export */   msbExponent: () => (/* binding */ msbExponent),\n/* harmony export */   operators: () => (/* binding */ operators),\n/* harmony export */   parseDouble: () => (/* binding */ parseDouble),\n/* harmony export */   parseDoubleDetailed: () => (/* binding */ parseDoubleDetailed),\n/* harmony export */   reduceSignificand: () => (/* binding */ reduceSignificand),\n/* harmony export */   significand: () => (/* binding */ significand),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   sqrtWithErr: () => (/* binding */ sqrtWithErr),\n/* harmony export */   twoDiff: () => (/* binding */ twoDiff),\n/* harmony export */   twoProduct: () => (/* binding */ twoProduct),\n/* harmony export */   twoSum: () => (/* binding */ twoSum)\n/* harmony export */ });\n/* harmony import */ var _double_double_binary_dd_min_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-double/binary/dd-min.js */ \"./node_modules/double-double/node/double-double/binary/dd-min.js\");\n/* harmony import */ var _double_double_binary_dd_max_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./double-double/binary/dd-max.js */ \"./node_modules/double-double/node/double-double/binary/dd-max.js\");\n/* harmony import */ var _double_double_unary_dd_sqrt_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./double-double/unary/dd-sqrt.js */ \"./node_modules/double-double/node/double-double/unary/dd-sqrt.js\");\n/* harmony import */ var _double_mixed_double_double_double_sqrt_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./double-mixed-double-double/double-sqrt.js */ \"./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js\");\n/* harmony import */ var _double_with_err_sqrt_with_err_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./double-with-err/sqrt-with-err.js */ \"./node_modules/double-double/node/double-with-err/sqrt-with-err.js\");\n/* harmony import */ var _double_double_unary_dd_abs_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./double-double/unary/dd-abs.js */ \"./node_modules/double-double/node/double-double/unary/dd-abs.js\");\n/* harmony import */ var _double_mixed_double_double_dd_add_double_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./double-mixed-double-double/dd-add-double.js */ \"./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js\");\n/* harmony import */ var _double_double_binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./double-double/binary/dd-add-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-add-dd.js\");\n/* harmony import */ var _double_double_multi_dd_product_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./double-double/multi/dd-product.js */ \"./node_modules/double-double/node/double-double/multi/dd-product.js\");\n/* harmony import */ var _double_double_multi_dd_sum_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./double-double/multi/dd-sum.js */ \"./node_modules/double-double/node/double-double/multi/dd-sum.js\");\n/* harmony import */ var _double_double_binary_dd_compare_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./double-double/binary/dd-compare.js */ \"./node_modules/double-double/node/double-double/binary/dd-compare.js\");\n/* harmony import */ var _double_double_binary_dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./double-double/binary/dd-diff-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-diff-dd.js\");\n/* harmony import */ var _double_mixed_double_double_dd_mult_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-mixed-double-double/dd-mult-double.js */ \"./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js\");\n/* harmony import */ var _double_double_unary_dd_mult_by_2_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-2.js */ \"./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js\");\n/* harmony import */ var _double_double_unary_dd_mult_by_4_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-4.js */ \"./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js\");\n/* harmony import */ var _double_double_unary_dd_div_by_2_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./double-double/unary/dd-div-by-2.js */ \"./node_modules/double-double/node/double-double/unary/dd-div-by-2.js\");\n/* harmony import */ var _double_double_unary_dd_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-neg-2.js */ \"./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js\");\n/* harmony import */ var _double_double_unary_dd_mult_by_neg_4_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-neg-4.js */ \"./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js\");\n/* harmony import */ var _double_double_binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./double-double/binary/dd-mult-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-mult-dd.js\");\n/* harmony import */ var _double_mixed_double_double_dd_div_double_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./double-mixed-double-double/dd-div-double.js */ \"./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js\");\n/* harmony import */ var _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./double-double/binary/dd-div-dd.js */ \"./node_modules/double-double/node/double-double/binary/dd-div-dd.js\");\n/* harmony import */ var _double_double_unary_dd_negative_of_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./double-double/unary/dd-negative-of.js */ \"./node_modules/double-double/node/double-double/unary/dd-negative-of.js\");\n/* harmony import */ var _double_double_unary_dd_sign_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./double-double/unary/dd-sign.js */ \"./node_modules/double-double/node/double-double/unary/dd-sign.js\");\n/* harmony import */ var _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./basic/fast-two-diff.js */ \"./node_modules/double-double/node/basic/fast-two-diff.js\");\n/* harmony import */ var _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./basic/fast-two-sum.js */ \"./node_modules/double-double/node/basic/fast-two-sum.js\");\n/* harmony import */ var _basic_split_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./basic/split.js */ \"./node_modules/double-double/node/basic/split.js\");\n/* harmony import */ var _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./basic/two-diff.js */ \"./node_modules/double-double/node/basic/two-diff.js\");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./basic/two-product.js */ \"./node_modules/double-double/node/basic/two-product.js\");\n/* harmony import */ var _double_mixed_double_double_double_div_double_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./double-mixed-double-double/double-div-double.js */ \"./node_modules/double-double/node/double-mixed-double-double/double-div-double.js\");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./basic/two-sum.js */ \"./node_modules/double-double/node/basic/two-sum.js\");\n/* harmony import */ var _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./basic/reduce-significand.js */ \"./node_modules/double-double/node/basic/reduce-significand.js\");\n/* harmony import */ var _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-representation/parse-double.js */ \"./node_modules/double-double/node/double-representation/parse-double.js\");\n/* harmony import */ var _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./double-representation/is-bit-aligned.js */ \"./node_modules/double-double/node/double-representation/is-bit-aligned.js\");\n/* harmony import */ var _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./double-representation/msb-exponent.js */ \"./node_modules/double-double/node/double-representation/msb-exponent.js\");\n/* harmony import */ var _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./double-representation/lsb-exponent.js */ \"./node_modules/double-double/node/double-representation/lsb-exponent.js\");\n/* harmony import */ var _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./double-representation/bit-length.js */ \"./node_modules/double-double/node/double-representation/bit-length.js\");\n/* harmony import */ var _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./double-representation/exponent.js */ \"./node_modules/double-double/node/double-representation/exponent.js\");\n/* harmony import */ var _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./double-representation/significand.js */ \"./node_modules/double-double/node/double-representation/significand.js\");\n/* harmony import */ var _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./double-representation/double-to-binary-string.js */ \"./node_modules/double-double/node/double-representation/double-to-binary-string.js\");\n/* harmony import */ var _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./double-representation/double-to-octets.js */ \"./node_modules/double-double/node/double-representation/double-to-octets.js\");\n/* harmony import */ var _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-representation/get-max-set-bit.js */ \"./node_modules/double-double/node/double-representation/get-max-set-bit.js\");\n/* harmony import */ var _double_double_with_error_dd_div_dd_with_error_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./double-double-with-error/dd-div-dd-with-error.js */ \"./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js\");\n/* harmony import */ var _double_with_err_div_with_err_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./double-with-err/div-with-err.js */ \"./node_modules/double-double/node/double-with-err/div-with-err.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst ddMultDouble2 = _double_mixed_double_double_dd_mult_double_js__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst parseDoubleDetailed = _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_1__.parseDoubleDetailed;\r\nconst getLowestSetBit = _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_2__.getLowestSetBit;\r\nconst ddMin = _double_double_binary_dd_min_js__WEBPACK_IMPORTED_MODULE_3__.ddMin;\r\nconst ddMax = _double_double_binary_dd_max_js__WEBPACK_IMPORTED_MODULE_4__.ddMax;\r\nconst ddSqrt = _double_double_unary_dd_sqrt_js__WEBPACK_IMPORTED_MODULE_5__.ddSqrt;\r\nconst doubleSqrt = _double_mixed_double_double_double_sqrt_js__WEBPACK_IMPORTED_MODULE_6__.doubleSqrt;\r\nconst sqrtWithErr = _double_with_err_sqrt_with_err_js__WEBPACK_IMPORTED_MODULE_7__.sqrtWithErr;\r\nconst ddAbs = _double_double_unary_dd_abs_js__WEBPACK_IMPORTED_MODULE_8__.ddAbs;\r\nconst ddAddDouble = _double_mixed_double_double_dd_add_double_js__WEBPACK_IMPORTED_MODULE_9__.ddAddDouble;\r\nconst ddAddDd = _double_double_binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_10__.ddAddDd;\r\nconst ddProduct = _double_double_multi_dd_product_js__WEBPACK_IMPORTED_MODULE_11__.ddProduct;\r\nconst ddSum = _double_double_multi_dd_sum_js__WEBPACK_IMPORTED_MODULE_12__.ddSum;\r\nconst ddCompare = _double_double_binary_dd_compare_js__WEBPACK_IMPORTED_MODULE_13__.ddCompare;\r\nconst ddDiffDd = _double_double_binary_dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_14__.ddDiffDd;\r\nconst ddMultDouble1 = _double_mixed_double_double_dd_mult_double_js__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble1;\r\nconst ddMultBy2 = _double_double_unary_dd_mult_by_2_js__WEBPACK_IMPORTED_MODULE_15__.ddMultBy2;\r\nconst ddMultBy4 = _double_double_unary_dd_mult_by_4_js__WEBPACK_IMPORTED_MODULE_16__.ddMultBy4;\r\nconst ddDivBy2 = _double_double_unary_dd_div_by_2_js__WEBPACK_IMPORTED_MODULE_17__.ddDivBy2;\r\nconst ddMultByNeg2 = _double_double_unary_dd_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_18__.ddMultByNeg2;\r\nconst ddMultByNeg4 = _double_double_unary_dd_mult_by_neg_4_js__WEBPACK_IMPORTED_MODULE_19__.ddMultByNeg4;\r\nconst ddMultDd = _double_double_binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_20__.ddMultDd;\r\nconst ddDivDouble = _double_mixed_double_double_dd_div_double_js__WEBPACK_IMPORTED_MODULE_21__.ddDivDouble;\r\nconst ddDivDd = _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_22__.ddDivDd;\r\nconst ddNegativeOf = _double_double_unary_dd_negative_of_js__WEBPACK_IMPORTED_MODULE_23__.ddNegativeOf;\r\nconst ddSign = _double_double_unary_dd_sign_js__WEBPACK_IMPORTED_MODULE_24__.ddSign;\r\nconst fastTwoDiff = _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_25__.fastTwoDiff;\r\nconst fastTwoSum = _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_26__.fastTwoSum;\r\nconst split = _basic_split_js__WEBPACK_IMPORTED_MODULE_27__.split;\r\nconst twoDiff = _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_28__.twoDiff;\r\nconst twoProduct = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_29__.twoProduct;\r\nconst doubleDivDouble = _double_mixed_double_double_double_div_double_js__WEBPACK_IMPORTED_MODULE_30__.doubleDivDouble;\r\nconst twoSum = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_31__.twoSum;\r\nconst reduceSignificand = _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_32__.reduceSignificand;\r\nconst parseDouble = _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_1__.parseDouble;\r\nconst isBitAligned = _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_33__.isBitAligned;\r\nconst msbExponent = _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_34__.msbExponent;\r\nconst lsbExponent = _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_35__.lsbExponent;\r\nconst bitLength = _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_36__.bitLength;\r\nconst exponent = _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_37__.exponent;\r\nconst significand = _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_38__.significand;\r\nconst doubleToBinaryString = _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_39__.doubleToBinaryString;\r\nconst doubleToOctets = _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_40__.doubleToOctets;\r\nconst getHighestSetBit = _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_2__.getHighestSetBit;\r\nconst ddDivDdWithError = _double_double_with_error_dd_div_dd_with_error_js__WEBPACK_IMPORTED_MODULE_41__.ddDivDdWithError;\r\nconst divWithErr = _double_with_err_div_with_err_js__WEBPACK_IMPORTED_MODULE_42__.divWithErr;\r\nconst operators = {\r\n    //---- basic ----//\r\n    fastTwoDiff,\r\n    fastTwoSum,\r\n    split,\r\n    twoDiff,\r\n    twoProduct,\r\n    doubleDivDouble,\r\n    twoSum,\r\n    reduceSignificand,\r\n    //---- double-double precision ----//\r\n    doubleSqrt,\r\n    ddSqrt,\r\n    ddAbs,\r\n    ddAddDouble,\r\n    ddAddDd,\r\n    ddProduct,\r\n    ddSum,\r\n    ddCompare,\r\n    ddDiffDd,\r\n    ddMultDouble1,\r\n    ddMultDouble2,\r\n    ddMultDd,\r\n    ddDivDouble,\r\n    ddDivDd,\r\n    ddNegativeOf,\r\n    ddSign,\r\n    ddMultBy2,\r\n    ddMultBy4,\r\n    ddDivBy2,\r\n    ddMultByNeg2,\r\n    ddMultByNeg4,\r\n    ddMin,\r\n    ddMax,\r\n    //---- double-double precision error propagation - with error bound on input parameters\r\n    ddDivDdWithError,\r\n    //---- double precision error propagation - with error bound on input parameters\r\n    divWithErr,\r\n    sqrtWithErr,\r\n    //---- double floating point representation ----//\r\n    parseDouble,\r\n    parseDoubleDetailed,\r\n    isBitAligned,\r\n    msbExponent,\r\n    lsbExponent,\r\n    bitLength,\r\n    doubleToBinaryString,\r\n    doubleToOctets,\r\n    getHighestSetBit,\r\n    getLowestSetBit,\r\n    exponent,\r\n    significand\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/double-double/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/add-1-ulp.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/add-1-ulp.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add1Ulp: () => (/* binding */ add1Ulp)\n/* harmony export */ });\nconst { EPSILON: eps } = Number;\nconst u = eps / 2;\nconst es = (eps ** 2) / 2;\nconst ups = u + es;\n/**\n * Add one unit in the last place (ulp) to the given number\n *\n * * subnormal numbers (and 0) are returned unaltered\n * @internal\n */\nfunction add1Ulp(n) {\n    return n > 0 ? n + n * ups : n - n * ups;\n}\n\n//# sourceMappingURL=add-1-ulp.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/add-1-ulp.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-from-angles-and-speeds.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-from-angles-and-speeds.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicFromAnglesAndSpeeds: () => (/* binding */ cubicFromAnglesAndSpeeds)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var _from_power_basis_from_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../from-power-basis/from-power-basis.js */ \"./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js\");\n\n\nconst { cos, sin } = Math;\n/**\n * Returns a cubic bezier curve (given by its control points) with the given\n * angles-and-speeds parameters.\n *\n * @param α initial tangent angle in radians\n * @param β terminal tangent angle in radians\n * @param s0 inital speed\n * @param s1 terminal speed\n * @param L distance between initial and final point (cannot be 0)\n * @param rot rotation of entire curve\n * @param p initial position offset\n */\nfunction cubicFromAnglesAndSpeeds(anglesAndSpeeds) {\n    const { α, β, s0, s1, L, rot, p } = anglesAndSpeeds;\n    const x3 = L * (-2 + s0 * cos(α) + s1 * cos(β));\n    const x2 = L * (3 - 2 * s0 * cos(α) - s1 * cos(β));\n    const x1 = L * (s0 * cos(α));\n    const x0 = L * (0);\n    const y3 = L * (s0 * sin(α) + s1 * sin(β));\n    const y2 = L * (-2 * s0 * sin(α) - s1 * sin(β));\n    const y1 = L * (s0 * sin(α));\n    const y0 = L * (0);\n    return (0,_from_power_basis_from_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.fromPowerBasis)([[x3, x2, x1, x0], [y3, y2, y1, y0]])\n        .map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.rotate)(sin(rot), cos(rot)))\n        .map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.translate)(p));\n}\n\n//# sourceMappingURL=cubic-from-angles-and-speeds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-from-angles-and-speeds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-to-angles-and-speeds.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-to-angles-and-speeds.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicToAnglesAndSpeeds: () => (/* binding */ cubicToAnglesAndSpeeds)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/len.js\");\n\nconst { cos, sin, atan2 } = Math;\n/**\n * For the given bernstein cubic bezier curve basis return the angles-and-speeds\n * basis coefficients, i.e.\n * * α   -> initial tangent angle in degrees\n * * β   -> terminal tangent angle in degrees\n * * s0  -> inital speed\n * * s1  -> terminal speed\n * * L   -> distance between initial and final point (cannot be 0)\n * * rot -> rotation of entire curve\n * * p   -> initial position offset\n *\n * @param ps an order 3 (cubic) bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n */\nfunction cubicToAnglesAndSpeeds(ps) {\n    // [_x1,_y1],[_x2,_y2],[_x3,_y3]\n    const p = ps[0];\n    // move ps to origin\n    ps = ps.map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.reverse)(p)));\n    const [x, y] = [ps[3][0], ps[3][1]];\n    const rot = atan2(y, x);\n    ps = ps.map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.rotate)(sin(-rot), cos(-rot)));\n    const L = ps[3][0];\n    ps = ps.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.scale)(p, 1 / L));\n    // TS -> tangent vector at `t === 0`\n    const TS = ps[1];\n    // TE -> tangent vector at `t === 1`\n    const TE = [1 - ps[2][0], -ps[2][1]];\n    // const h2 = sqrt(x1**2 + y1**2);\n    const α = atan2(TS[1], TS[0]);\n    const β = atan2(TE[1], TE[0]);\n    const s0 = 3 * (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.len)(TS);\n    const s1 = 3 * (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.len)(TE);\n    return { α, β, s0, s1, L, rot, p };\n}\n\n//# sourceMappingURL=cubic-to-angles-and-speeds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-to-angles-and-speeds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/get-cubic-speeds.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/get-cubic-speeds.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCubicSpeeds: () => (/* binding */ getCubicSpeeds)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/len.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n\n/**\n * For the given bernstein basis cubic bezier curve return its initial and\n * terminal speeds in the form `[s0,s1]`.\n *\n * @param ps an order 3 (cubic) bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n */\nfunction getCubicSpeeds(ps) {\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const v = [p3[0] - p0[0], p3[1] - p0[1]]; // vector from 1st to last point\n    const L = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(v);\n    const v01 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(p0, p1);\n    const v32 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(p3, p2);\n    const s0 = 3 * (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(v01) / L;\n    const s1 = 3 * (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(v32) / L;\n    return [s0, s1];\n}\n\n//# sourceMappingURL=get-cubic-speeds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/get-cubic-speeds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/set-cubic-speeds.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/set-cubic-speeds.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setCubicSpeeds: () => (/* binding */ setCubicSpeeds)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/len.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-length.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n\n/**\n * For the given bernstein basis cubic bezier curve return a new cubic bezier\n * curve with its initial and terminal speeds modified.\n *\n * * only the 2nd and 3rd control points are modified\n * * call the original curve `A` and the returned curve `B` then it will be\n * true that `A[0] === B[0]` and `A[3] === B[3]`\n *\n * @param ps an order 3 (cubic) bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n */\nfunction setCubicSpeeds(ps, s0, s1) {\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const v = [p3[0] - p0[0], p3[1] - p0[1]]; // vector from 1st to last point\n    const L = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(v);\n    const v01 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(p0, p1);\n    const v32 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(p3, p2);\n    const v01_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.toLength)(v01, s0 / 3 * L);\n    const p1_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.translate)(p0, v01_);\n    const v32_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.toLength)(v32, s1 / 3 * L);\n    const p2_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.translate)(p3, v32_);\n    return [p0, p1_, p2_, p3]; // keep reference to first and last points\n}\n\n//# sourceMappingURL=set-cubic-speeds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/set-cubic-speeds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoxesIntersecting: () => (/* binding */ areBoxesIntersecting)\n/* harmony export */ });\n/**\n * Returns `true` if the 2 given axis-aligned rectangular boxes intersect.\n *\n * * **exact**: not susceptible to floating point round-off\n *\n * @param closed if `true`, interpret boxes as being closed (i.e. they contain\n * their border), otherwise open.\n * @param a an axis-aligned rectangular box (given by an array of two points,\n * e.g. `[[1,2], [3,4]]`)\n * @param b another axis-aligned rectangular box\n *\n * @doc mdx\n */\nfunction areBoxesIntersecting(closed, a, b) {\n    let [[ax0, ay0], [ax1, ay1]] = a;\n    let [[bx0, by0], [bx1, by1]] = b;\n    // Swap so smaller coordinate comes first\n    if (ay0 > ay1) {\n        [ay0, ay1] = [ay1, ay0];\n    }\n    if (by0 > by1) {\n        [by0, by1] = [by1, by0];\n    }\n    if (ax0 > ax1) {\n        [ax0, ax1] = [ax1, ax0];\n    }\n    if (bx0 > bx1) {\n        [bx0, bx1] = [bx1, bx0];\n    }\n    return closed\n        ? ax0 <= bx1 && ax1 >= bx0 &&\n            by0 <= ay1 && by1 >= ay0\n        : ax0 < bx1 && ax1 > bx0 &&\n            by0 < ay1 && by1 > ay0;\n}\n\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/boxes/intersect-boxes.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/boxes/intersect-boxes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectBoxes: () => (/* binding */ intersectBoxes)\n/* harmony export */ });\nconst min = Math.min;\nconst max = Math.max;\n/**\n * Returns the intersection of 2 given axis-aligned rectangular boxes (or\n * `undefined` if they don't intersect).\n *\n * * **exact**: not susceptible to floating point round-off\n * * **closed**: interpret boxes as being closed (i.e. they contain their border).\n *\n * @param a an axis-aligned rectangular box (given by an array of two points,\n * e.g. `[[1,2], [3,4]]`)\n * @param b another box\n *\n * @doc mdx\n */\nfunction intersectBoxes(a, b) {\n    let [[ax0, ay0], [ax1, ay1]] = a;\n    let [[bx0, by0], [bx1, by1]] = b;\n    // Swap so smaller coordinate comes first\n    if (ax0 > ax1) {\n        [ax0, ax1] = [ax1, ax0];\n    }\n    if (bx0 > bx1) {\n        [bx0, bx1] = [bx1, bx0];\n    }\n    if (ay0 > ay1) {\n        [ay0, ay1] = [ay1, ay0];\n    }\n    if (by0 > by1) {\n        [by0, by1] = [by1, by0];\n    }\n    if (!(ax0 <= bx1 && ax1 >= bx0 &&\n        by0 <= ay1 && by1 >= ay0)) {\n        // they don't intersect\n        return undefined;\n    }\n    return [\n        [max(ax0, bx0), max(ay0, by0)],\n        [min(ax1, bx1), min(ay1, by1)]\n    ];\n}\n\n//# sourceMappingURL=intersect-boxes.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/boxes/intersect-boxes.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicThroughPointGiven013: () => (/* binding */ cubicThroughPointGiven013)\n/* harmony export */ });\n/**\n * Generates and returns a cubic bezier curve going through a specific point\n * given control points 0,1 and 3.\n *\n * * **non-exact:** the returned bezier does not necessarily go through the\n * point *exactly* (due to floating-point round-off).\n *\n * @param ps a cubic bezier curve's 1st, 2nd and 4th control point coordinates,\n * i.e. `[[x0,y0], [x1,y1], [x3,y3]]`, e.g. `[[1,2], [3,4], [5,6]]`\n * @param p a point through which the bezier should go, e.g. `[4.5,6.1]`\n * @param t a `t` parameter value at which the bezier should go through the\n * point - this is necessary due to a degree of freedom still left\n *\n * @doc mdx\n */\nfunction cubicThroughPointGiven013(ps, p, t) {\n    const [[x0, y0], [x1, y1], [x3, y3]] = ps;\n    const [x, y] = p;\n    const x2 = (t ** 3 * (-x0 + 3 * x1 + x3) + 3 * t ** 2 * (x0 - 2 * x1) - 3 * t * (x0 - x1) - x + x0) / (3 * t ** 2 * (t - 1));\n    const y2 = (t ** 3 * (-y0 + 3 * y1 + y3) + 3 * t ** 2 * (y0 - 2 * y1) - 3 * t * (y0 - y1) - y + y0) / (3 * t ** 2 * (t - 1));\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\n\n//# sourceMappingURL=cubic-through-point-given013.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateCuspAtHalf3: () => (/* binding */ generateCuspAtHalf3)\n/* harmony export */ });\n/**\n * Returns the cubic bezier curve control points with a zero tangent vector\n * (i.e. `[0,0]`) at `t = 0.5` (i.e. a 'cusp') at the given point with\n * given starting and ending control points.\n * * **non-exact**: due to floating-point round-off the cusp is not\n * necessarily *exactly* at the given point, nor does the tangent vector\n * necessarily vanish *exactly*.\n *\n * @param p0 the bezier start point\n * @param pz the point at which the vanishing tangent should occur\n * @param pE the bezier end point\n *\n * @doc mdx\n */\nfunction generateCuspAtHalf3(p0, pz, pE) {\n    // x3 - 3x2 + 3x1 - x0, // := a = coefficent of t^3\n    // 3x2 - 6x1 + 3x0,     // := b = coefficent of t^2\n    // 3x1 - 3x0,           // := c = coefficent of t^1\n    // x0,                  // := d = coefficent of t^0\n    // y3 - 3y2 + 3y1 - y0, // := e = coefficent of t^3\n    // 3y2 - 6y1 + 3y0,     // := f = coefficent of t^2\n    // 3y1 - 3y0,           // := g = coefficent of t^1\n    // y0,                  // := h = coefficent of t^0\n    // const x = at^3 + bt^2 + ct + d\n    // const y = et^3 + ft^2 + gt + h\n    // x` = 3at^2 + 2bt + c\n    // y` = 3et^2 + 2ft + g\n    // d = x0 and h = y0\n    const [x0, y0] = p0;\n    const [xz, yz] = pz;\n    const [xE, yE] = pE;\n    // We must have x` = y` = 0 at t = 1/2:\n    // 3a/4 + b + c = 0            =>  3a  + 4b  + 4c  =  0       (1)\n    // 3e/4 + f + g = 0            =>  3e  + 4f  + 4g  =  0       (2)\n    // Also, x(1/2) === pz[0]:\n    // a/8 + b/4 + c/2 + d = pz[0] => a + 2b + 4c + 8d = 8xz      (3)\n    // and y(1/2) === pz[1]:\n    // e/8 + f/4 + g/2 + h = pz[1] => e + 2f + 4g + 8h = 8yz      (4)\n    // and by definitition:\n    // a = x3 - 3x2 + 3x1 - x0     => -3x2 + 3x1 - a   =  x0 - x3 (5)\n    // b = 3x2 - 6x1 + 3x0         =>  3x2 - 6x1 - b   = -3x0     (6)\n    // c = 3x1 - 3x0               =>  3x1       - c   =  3x0     (7)\n    // e = y3 - 3y2 + 3y1 - y0     => -3y2 + 3y1 - e   =  y0 - y3 (8)\n    // f = 3y2 - 6y1 + 3y0         =>  3y2 - 6y1 - f   = -3y0     (9) \n    // g = 3y1 - 3y0               =>  3y1       - g   =  3y0     (10)\n    // Solving the above linear system gives:\n    //const a = 4*xE-4*x0;\n    //const b = 4*x0-4*xz-4*xE+4*x0;\n    //const c = -4*x0+4*xz+xE-x0;\n    //const e = 4*yE-4*y0;\n    //const f = 4*y0-4*yz-4*yE+4*y0;\n    //const g = -4*y0+4*yz+yE-y0;\n    const x1 = -(4 * x0 - 4 * xz - xE - 2 * x0) / 3;\n    const y1 = -(4 * y0 - 4 * yz - yE - 2 * y0) / 3;\n    const x2 = -(4 * x0 - 4 * xz + 2 * xE - 5 * x0) / 3;\n    const y2 = -(4 * y0 - 4 * yz + 2 * yE - 5 * y0) / 3;\n    return [p0, [x1, y1], [x2, y2], pE];\n}\n\n/*\n3*a  + 4*b  + 4*c   = 0\n3*e  + 4*f  + 4*g   = 0\na + 2*b + 4*c + 8*d = 8*xz\ne + 2*f + 4*g + 8*h = 8*yz\n-3*x2 + 3*x1 - a =  x0 - x3\n3*x2 - 6*x1 - b = -3*x0\n3*x1 - c = 3*x0\n-3*y2 + 3*y1 - e = y0 - y3\n3*y2 - 6*y1  - f = -3*y0\n3*y1 - g = 3*y0\n*/\n//# sourceMappingURL=generate-cusp-at-half-t.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/create/generate-quarter-circle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/create/generate-quarter-circle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateQuarterCircle: () => (/* binding */ generateQuarterCircle)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n\n/**\n * Returns a cubic bezier curve that is an approximation of the unit quarter\n * circle in the first quadrant scaled and then translated.\n *\n * * see: [Approximate a circle with cubic Bézier curves](https://spencermortensen.com/articles/bezier-circle/)\n *\n * @doc mdx\n */\nfunction generateQuarterCircle(scale, translation) {\n    // `c` can be made slightly more accurate by calculating a more accurate\n    // value of \n    // const c = 0.551915024494;\n    const c = 0.5519150244935105707435627;\n    const s = scale;\n    return [[0, s], [s * c, s], [s, s * c], [s, 0]].map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(translation));\n}\n\n//# sourceMappingURL=generate-quarter-circle.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/create/generate-quarter-circle.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/create/generate-self-intersecting.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/create/generate-self-intersecting.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSelfIntersecting: () => (/* binding */ generateSelfIntersecting)\n/* harmony export */ });\n/**\n * Returns the cubic bezier curve with given starting, 2nd and 3rd control\n * points such that there is a self-intersection.\n *\n * * **in-exact:** the result may not be exact due to floating point round-off\n *\n * @param ts the two `t` values where the self-intersection should occur\n * @param p0 the bezier's initial control point, e.g. `[1,2]`\n * @param p1 the bezier's 2nd control point\n * @param p2 the bezier's 3rd control point\n *\n * @doc mdx\n */\nfunction generateSelfIntersecting(p0, p1, p2, ts) {\n    const [x0, y0] = p0;\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    const [t1, t2] = ts;\n    // power basis representation:\n    //const a3 = (x3 - x0) + 3*(x1 - x2)\n    const a2 = 3 * ((x2 + x0) - 2 * x1);\n    const a1 = 3 * (x1 - x0);\n    //const b3 = (y3 - y0) + 3*(y1 - y2)\n    const b2 = 3 * ((y2 + y0) - 2 * y1);\n    const b1 = 3 * (y1 - y0);\n    // f4 = a2*b3 - a3*b2;\n    // f5 = a1*b3 - a3*b1;\n    // f6 = a2*b1 - a1*b2;\n    // a = f4*f4;\n    // b = f4*f5;\n    // c = f4*f6 + f5*f5;\n    // The self-intersection is given by the roots of `at^2 + bt + c`\n    const vₓ = b2 * (a1 * b2 - a2 * b1);\n    const vᵧ = -a2 * (a1 * b2 - a2 * b1);\n    // a3**2* (b1**2 + b1*b2*t1 + b2**2*t1**2) +\n    // b3**2* (a1**2 + a1*a2*t1 + a2**2*t1**2) + \n    // a3*b3* (-2*a1*b1 + -a1*b2*t1 + -a2*b1*t1 + -2*a2*b2*t1**2) +\n    // a3* (a1*b2**2 + -a2*b1*b2) +\n    // b3* (a2**2*b1 + -a1*a2*b2) === 0\n    const vₓₓ = b1 ** 2 + b1 * b2 * t1 + b2 ** 2 * t1 ** 2;\n    const vₓᵧ = -2 * a1 * b1 + -a1 * b2 * t1 + -a2 * b1 * t1 + -2 * a2 * b2 * t1 ** 2;\n    const vᵧᵧ = a1 ** 2 + a1 * a2 * t1 + a2 ** 2 * t1 ** 2;\n    // implicit form 1 === {vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v: 0};\n    // a3**2* (b1**2 + b1*b2*t2 + b2**2*t2**2) +\n    // a3*b3* (-2*a1*b1 + -a1*b2*t2 + -a2*b1*t2 + -2*a2*b2*t2**2) +\n    // b3**2* (a1**2 + a1*a2*t2 + a2**2*t2**2) + \n    // a3* (a1*b2**2 + -a2*b1*b2) + \n    // b3* (a2**2*b1 + -a1*a2*b2) === 0\n    const wₓₓ = b1 ** 2 + b1 * b2 * t2 + b2 ** 2 * t2 ** 2;\n    const wₓᵧ = -2 * a1 * b1 + -a1 * b2 * t2 + -a2 * b1 * t2 + -2 * a2 * b2 * t2 ** 2;\n    const wᵧᵧ = a1 ** 2 + a1 * a2 * t2 + a2 ** 2 * t2 ** 2;\n    // implicit form 2 === {wₓₓ, wₓᵧ, wᵧᵧ, vₓ, vᵧ, v: 0};\n    // The below are the coefficients as if we've called \n    // getImplicitCoeffsBez2Bez2, except there are now more constraints (e.g.\n    // `vₓ === wₓ`, etc.) so we reproduce them here.\n    const xx4 = vₓₓ * (wᵧᵧ * (vₓₓ * wᵧᵧ - vₓᵧ * wₓᵧ - 2 * vᵧᵧ * wₓₓ) + vᵧᵧ * wₓᵧ * wₓᵧ) +\n        wₓₓ * (vₓᵧ * (vₓᵧ * wᵧᵧ - vᵧᵧ * wₓᵧ) + vᵧᵧ * vᵧᵧ * wₓₓ);\n    const xx3 = vₓ * (wᵧᵧ * (2 * (vₓₓ * (wᵧᵧ - vᵧᵧ) - vᵧᵧ * wₓₓ) - vₓᵧ * (wₓᵧ - vₓᵧ)) +\n        vᵧᵧ * (2 * vᵧᵧ * wₓₓ - wₓᵧ * (vₓᵧ - wₓᵧ))) +\n        vᵧ * (vₓₓ * (2 * vᵧᵧ * wₓᵧ - wᵧᵧ * (vₓᵧ + wₓᵧ)) +\n            wₓₓ * (2 * vₓᵧ * wᵧᵧ - vᵧᵧ * (vₓᵧ + wₓᵧ)));\n    // Due to constraints, `x2`, `x1` and `x0` all vanish.\n    // Solve for: xx4*x + xx3 = 0\n    const a3 = -xx3 / xx4;\n    const yy3 = vₓ * (vₓₓ * (wₓᵧ * (2 * vᵧᵧ - wᵧᵧ) - vₓᵧ * wᵧᵧ) +\n        wₓₓ * (vₓᵧ * (2 * wᵧᵧ - vᵧᵧ) - vᵧᵧ * wₓᵧ)) +\n        vᵧ * (vₓₓ * (2 * (wᵧᵧ * (vₓₓ - wₓₓ) - vᵧᵧ * wₓₓ) - wₓᵧ * (vₓᵧ - wₓᵧ)) +\n            wₓₓ * (2 * vᵧᵧ * wₓₓ + vₓᵧ * (vₓᵧ - wₓᵧ)));\n    // Due to constraints, `y2`, `y1` and `y0` all vanish.\n    // Solve for: yy4*y + yy3 = 0\n    const b3 = -yy3 / xx4; // note: yy4 === xx4\n    const x3 = a3 + x0 - 3 * (x1 - x2); //note: a3 === (x3 - x0) + 3*(x1 - x2)\n    const y3 = b3 + y0 - 3 * (y1 - y2); //note: b3 === (y3 - y0) + 3*(y1 - y2)\n    // Note: A self-intersection occurs when:\n    // `3*(a1*b3 - a3*b1)**2 + 4*(a2*b1 - a1*b2)*(a2*b3 - a3*b2) <= 0`\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\n\n//# sourceMappingURL=generate-self-intersecting.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/create/generate-self-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/error-analysis/error-analysis.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"γ\": () => (/* binding */ γ),\n/* harmony export */   \"γγ\": () => (/* binding */ γγ)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\nconst uu = u * u;\n/** @internal */\nfunction γ(n) {\n    const nu = n * u;\n    return nu / (1 - nu);\n}\n/** @internal */\nfunction γγ(n) {\n    const nuu = n * uu;\n    return nuu / (1 - nuu);\n}\n\nγ(1); //=> 1.1102230246251568e-16\nγγ(3); //=> 3.697785493223493e-32\n//# sourceMappingURL=error-analysis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/error-analysis/error-analysis.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maxAbsCoordinate: () => (/* binding */ maxAbsCoordinate)\n/* harmony export */ });\n/**\n * Returns the maximum absolute value of the coordinates of the control points\n * of the given bezier curve.\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc\n */\nfunction maxAbsCoordinate(ps) {\n    let m = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < ps.length; i++) {\n        const p = ps[i];\n        const absX = Math.abs(p[0]);\n        const absY = Math.abs(p[1]);\n        if (absX > m) {\n            m = absX;\n        }\n        if (absY > m) {\n            m = absY;\n        }\n    }\n    return m;\n}\n\n//# sourceMappingURL=max-abs-coordinate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fitQuadsToCubic: () => (/* binding */ fitQuadsToCubic)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/classify.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/classify.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transformation/split/from-to/from-to-3-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-abs-area-between.js */ \"./node_modules/flo-bezier3/node/fit/get-abs-area-between.js\");\n/* harmony import */ var _intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../intersection/self-intersection/bezier-self-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js\");\n\n\n\n\n\n/**\n * Approximate the given cubic bezier curve (up to the given tolerance) by\n * fitting an array of ordered (by `t` value) piecewise bezier curves\n * (of quadratic order or less).\n *\n * * the start and end point of each approximating curve lies on the cubic\n * curve and the the tangents of each approximating curve coincide with that of\n * the cubic at each such point\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tolerance tolerance given as the maximum total absolute area difference\n * between the two curves\n *\n * @doc mdx\n */\nfunction fitQuadsToCubic(ps, tolerance) {\n    if (ps.length < 4) {\n        throw new Error('Only cubic bezier curves are supported by this function.');\n    }\n    const { collinear, realOrder, nodeType } = (0,_global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__.classify)(ps);\n    // if all points collinear or a line (or point)\n    if (collinear || realOrder <= 1) {\n        // return a quad that's a line between the first and last points\n        // return [ps[0], [(ps[0][0] + ps[3][0])/2, (ps[0][1] + ps[3][1])/2], ps[3]];\n        return [[ps[0], ps[3]]];\n    }\n    if (realOrder === 2) {\n        // already a quadratic in disguise\n        // It is not possible that `toQuadraticFromCubic(ps)` be undefined here\n        // since the `real order` is exactly 2 and the control points are *not*\n        // collinear.\n        return [(0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__.cubicToQuadratic)(ps)];\n    }\n    const stack = [];\n    // if endpoints coincide\n    if (ps[0][0] === ps[3][0] && ps[0][1] === ps[3][1]) {\n        stack.push([0, 0.5], [0.5, 1]);\n    }\n    else if (nodeType === 'cusp') {\n        const t = (0,_intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_2__.bezierSelfIntersection)(ps)[0];\n        stack.push([0, t], [t, 1]); // split at cusp\n    }\n    else if (nodeType === 'crunode') {\n        const ts = (0,_intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_2__.bezierSelfIntersection)(ps);\n        if (ts.length > 1) {\n            stack.push([0, ts[0]], [ts[0], ts[1]], [ts[1], 1]); // split at intersections\n        }\n        else {\n            // the intersection is outside the range [0,1]\n            stack.push([0, 1]);\n        }\n    }\n    else {\n        stack.push([0, 1]);\n    }\n    const qs = [];\n    while (stack.length !== 0) {\n        const ts = stack.pop();\n        const [tS, tE] = ts;\n        /** the piece of the cubic bezier to approximate */\n        const psCubic = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__.fromTo3InclErrorBound)(ps, tS, tE).ps;\n        const psQuad = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__.cubicToQuadratic)(psCubic);\n        const spanRatio = tE - tS;\n        if (psQuad === undefined ||\n            spanRatio * (0,_get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_4__.getAbsAreaBetween)(psQuad, psCubic) > tolerance) {\n            const tM = (tE + tS) / 2;\n            stack.push([tS, tM], [tM, tE]); // split cubic in 2 equal pieces\n        }\n        else {\n            qs.push(psQuad);\n        }\n    }\n    return qs.reverse();\n}\n\n//# sourceMappingURL=fit-quads-to-cubic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/fit/get-abs-area-between.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/fit/get-abs-area-between.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAbsAreaBetween: () => (/* binding */ getAbsAreaBetween)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../intersection/bezier-bezier-intersection/bezier-bezier-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js\");\n/* harmony import */ var _global_properties_area_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global-properties/area.js */ \"./node_modules/flo-bezier3/node/global-properties/area.js\");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/split/from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n\n\n\n\n/**\n * Returns the *absolute* area between the two given curves.\n *\n * * **precondition**: the first and last control points of each curve must be equal\n * * **precondition**: neither curve should have self-intersections else the results\n * are ambiguous\n * * can be used as an excellent error measure of the similarity between the two curves\n *\n * @doc mdx\n */\nfunction getAbsAreaBetween(ps1, ps2) {\n    const xs = (0,_intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_0__.bezierBezierIntersection)(ps1, ps2);\n    let tS1 = 0;\n    let tS2 = 0;\n    let total = 0;\n    for (let i = 0; i < xs.length + 1; i++) {\n        const x = xs[i];\n        const tE1 = x === undefined ? 1 : (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.mid)(x.ri1);\n        const tE2 = x === undefined ? 1 : (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.mid)(x.ri2);\n        const piece1 = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_2__.fromTo)(ps1, tS1, tE1);\n        const piece2 = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_2__.fromTo)(ps2, tS2, tE2);\n        tS1 = tE1;\n        tS2 = tE2;\n        total += Math.abs((0,_global_properties_area_js__WEBPACK_IMPORTED_MODULE_3__.area)(piece1) - (0,_global_properties_area_js__WEBPACK_IMPORTED_MODULE_3__.area)(piece2));\n    }\n    return total;\n}\n\n//# sourceMappingURL=get-abs-area-between.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/fit/get-abs-area-between.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   quadraticToPolyline: () => (/* binding */ quadraticToPolyline)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_is_quad_flat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-quad-flat.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js\");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transformation/split/from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n\n\nconst { abs, max } = Math;\n/**\n * Transforms the given quadratic bezier curve into a polyline approximation to\n * within a given tolerance and returns the result.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tolerance defaults to `2**-10` of the maximum coordinate of the given\n * bezier curve; a tolerance given as the maximum Hausdorff distance allowed\n * between the polyline and the bezier curve\n *\n * @doc mdx\n */\nfunction quadraticToPolyline(ps, tolerance) {\n    if (tolerance === undefined || tolerance === 0) {\n        const [p0, p1, p2] = ps;\n        const [x0, y0] = p0;\n        const [x1, y1] = p1;\n        const [x2, y2] = p2;\n        const maxCoordinate = max(abs(x0), abs(y0), abs(x1), abs(y1), abs(x2), abs(y2));\n        tolerance = maxCoordinate * 2 ** -10;\n    }\n    // A quad bezier has the following useful properties (Let the control\n    // points be labeled P0, P1 and P2 respectively and let the point at t = 0.5\n    // be labeled M1):\n    // -------------------------------------------------------------------------\n    // * At t = 0.5 P1 has its maximum influence of 0.5 and P0 and P2 each an \n    // influence of 0.25.\n    // * The tangent at t = 0.5 is given by P2 - P0.\n    // * The line implied by the tangent at t = 0.5 cuts the line segments P0-P1\n    // and P2-P1 in half. Lets call these points M0 and M2.\n    // * The polygon P0-M0-M2-P2 bounds the curve.\n    // * The curve can be cut into two quad bezier curves. \n    // * If it is cut at t = 0.5, i.e. at M1 so that we have two quad beziers \n    // defined by the triangles Q1 = P0-M0-M1 and Q2 = M0-M2-P2 then both \n    // the interior angles at P0 and P2 are < 90 degrees (acute). Lets call such\n    // a quad acute, otherwise obtuse.\n    // * If we split an obtuse quad at t = 0.5 then the resulting quads are both\n    // acute.\n    // * Acute quads is such that the point at t = 0.5, i.e. at M1) is the \n    // furthest away from the line P0-P2.\n    // Note: In our algorithm the above property can be used to measure the \n    // flatness of the quad reliably.\n    // The algorithm: q: quad => lines[] such that the Hausdorff distance \n    // between the polyline and the quad < tolerance.\n    // Strategy: Use linked list for polyline - makes splitting easier\n    // -------------------------------------------------------------------------\n    // quad obtuse ? \n    //   no  : Push the quad onto the stack\n    //   yes : Split the quad at t = 0.5 and push both halves onto the stack\n    // Loop while stack not empty\n    //   pop from stack => q\n    //   d <= calculate distance from t = 0.5 to line p0-p2\n    //   tolerance < tol ?\n    //     yes : do nothing\n    //     no  : split quad at t = 0.5 and push both halves onto the stack\n    // Loop end\n    // Stack with nodes still to be checked\n    const stack = [];\n    // Polyline linked list\n    let head = {\n        ps,\n        prev: undefined,\n        next: undefined // keep TypeScript happy - it's ok, we'll set it later\n    };\n    stack.push(head);\n    while (stack.length) {\n        // keep TypeScript happy; of course there'se something in the stack\n        const node = stack.pop();\n        const ps = node.ps;\n        if ((0,_global_properties_classification_is_quad_flat_js__WEBPACK_IMPORTED_MODULE_0__.isQuadFlat)(ps, tolerance)) {\n            continue;\n        }\n        const quads = [\n            (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, 0, 0.5),\n            (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, 0.5, 1)\n        ];\n        const prev = node.prev;\n        const next = node.next;\n        const node1 = {\n            ps: quads[0],\n            prev,\n            next: undefined // keep TypeScript happy - it's ok, we'll set it later\n        };\n        const node2 = {\n            ps: quads[1],\n            prev: undefined,\n            next\n        };\n        node1.next = node2;\n        node2.prev = node1;\n        if (prev) {\n            prev.next = node1;\n        }\n        if (next) {\n            next.prev = node2;\n        }\n        if (head === node) {\n            head = node1;\n        }\n        stack.push(node1);\n        stack.push(node2);\n    }\n    const linePs = [];\n    let node = head;\n    linePs.push(head.ps[0]);\n    while (node) {\n        linePs.push(node.ps[2]);\n        node = node.next;\n    }\n    return linePs;\n}\n\n//# sourceMappingURL=quadratic-to-polyline.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromPowerBasis: () => (/* binding */ fromPowerBasis)\n/* harmony export */ });\n/**\n * Returns the Bernstein basis representation (i.e. control points) of a line,\n * quadratic or cubic bezier given its power bases.\n *\n * * **non-exact**: due to floating-point round-off (see implementation to\n * understand under what conditions the result would be exact)\n *\n * @param cs An order 1,2 or 3 parametric curve in power bases with the\n * x-coordinate coefficients given first (as an array representing the\n * polynomial from highest to lowest power coefficient), e.g. `[[1,2,3,4],\n * [5,6,7,8]]` represents a cubic parametric curve given by\n * `x(t) = t^3 + 2t^2 + 3t^3 + 4t^4, y(t) = 5t^3 + 6t^2 + 7t + 8`.\n *\n * @doc\n */\nfunction fromPowerBasis(cs) {\n    const len = cs[0].length;\n    if (len === 4) {\n        const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = cs;\n        return [\n            [a0,\n                b0],\n            [a0 + a1 / 3,\n                b0 + b1 / 3],\n            [a0 + 2 * a1 / 3 + a2 / 3,\n                b0 + 2 * b1 / 3 + b2 / 3],\n            [a0 + a1 + a2 + a3,\n                b0 + b1 + b2 + b3]\n        ];\n    }\n    if (len === 3) {\n        const [[a2, a1, a0], [b2, b1, b0]] = cs;\n        return [\n            [a0,\n                b0],\n            [a0 + a1 / 2,\n                b0 + b1 / 2],\n            [a0 + a1 + a2,\n                b0 + b1 + b2]\n        ];\n    }\n    if (len === 2) {\n        const [[a1, a0], [b1, b0]] = cs;\n        return [\n            [a0,\n                b0],\n            [a0 + a1,\n                b0 + b1]\n        ];\n    }\n    if (len === 1) {\n        const [[a0], [b0]] = cs;\n        return [\n            [a0,\n                b0]\n        ];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=from-power-basis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-abs-curvature-extrema-polys-dd.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-abs-curvature-extrema-polys-dd.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAbsCurvatureExtremaPolysDd: () => (/* binding */ getAbsCurvatureExtremaPolysDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_double_to_power_basis_3rd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\n/**\n * Returns the polynomials whose zeros are the `t` values of the local\n * minima / maxima of the absolute curvature for the given bezier curve.\n *\n * The polynomials are in the form `p1*p2` where the zeros\n * of `p1` are the inflection points and the zeros of `p2` are the other minima /\n * maxima.\n *\n * * **precondition:** must be a `true` cubic bezier (not degenerate to line or\n * quadratic)\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)\n * * **non-exact:** due to floating point roundof during calculation\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @internal\n */\nfunction getAbsCurvatureExtremaPolysDd(ps) {\n    // It is a real cubic - use the excellent answer from the description:\n    // dd(kappa^2)/dt === (x′′y′ − x′y′′)*((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\n    // Inflection points at: (x′′y′ − x′y′′) === 0\n    // Max abs curvature at: ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′)) === 0\n    const [[dx2, dx1, dx0], [dy2, dy1, dy0]] = (0,_to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivativeDd)(ps); // max bitlength increase === 5\n    const [[ddx1, ddx0], [ddy1, ddy0]] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_2ndDerivativeDd)(ps); // max bitlength increase === 6\n    const [[dddx], [dddy]] = (0,_to_power_basis_to_power_basis_3rd_derivative_double_double_to_power_basis_3rd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis_3rdDerivativeDd)(ps); // max bitlength increase === 6\n    // ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\n    // or \n    // x′′′x′x′y′ + x′′′y′y′y′ - y′′′x′x′x′ - y′′′x′y′y′ + \n    // 3(x′′y′′x′x′ - x′′x′′x′y′ - x′′y′′y′y′ + y′′y′′x′y′)\n    // The above line becomes\n    // ((dddx*dy(t) − dx(t)*dddy)(dx(t)dx(t) + dy(t)dy(t)) − 3(dx(t)ddx(t) + dy(t)ddy(t))(ddx(t)dy(t) − dx(t)ddy(t)))\n    // or \n    // dddx*dxt**2*dyt + dddx*dyt**3 - dddy*dxt**3 - dddy*dxt*dyt**2 - \n    // 3*ddxt**2*dxt*dyt + 3*ddxt*ddyt*dxt**2 - 3*ddxt*ddyt*dyt**2 + 3*ddyt**2*dxt*dyt\n    // which becomes: (after substituting e.g. dy(t) = dy2*t^2 + dy1*t + dy0, etc. using Python and\n    // then expanding and collecting terms)\n    const dddx_dy1 = qmq(dddx, dy1);\n    const dddy_dx1 = qmq(dddy, dx1);\n    const ddx0_dy0 = qmq(ddx0, dy0);\n    const ddx0_dy1 = qmq(ddx0, dy1);\n    const ddy1_ddy1 = qmq(ddy1, ddy1);\n    const ddx1_dy0 = qmq(ddx1, dy0);\n    const ddy0_dx0 = qmq(ddy0, dx0);\n    const ddy0_dx1 = qmq(ddy0, dx1);\n    const ddy1_dx0 = qmq(ddy1, dx0);\n    const dx0_dx1 = qmq(dx0, dx1);\n    const dx0_dx2 = qmq(dx0, dx2);\n    const dx0_dy2 = qmq(dx0, dy2);\n    const dx1_dx1 = qmq(dx1, dx1);\n    const dx1_dx2 = qmq(dx1, dx2);\n    const dx1_dy1 = qmq(dx1, dy1);\n    const dx2_dy0 = qmq(dx2, dy0);\n    const dx2_dy2 = qmq(dx2, dy2);\n    const dx2_dx2 = qmq(dx2, dx2);\n    const dy0_dy1 = qmq(dy0, dy1);\n    const dy0_dy2 = qmq(dy0, dy2);\n    const dy1_dy1 = qmq(dy1, dy1);\n    const dy1_dy2 = qmq(dy1, dy2);\n    const dy2_dy2 = qmq(dy2, dy2);\n    const ss = qdq(qmq(dddx, dy0), qmq(dddy, dx0));\n    const uu = qdq(dddx_dy1, dddy_dx1);\n    const vv = qaq(qmq(ddx0, dx0), qmq(ddy0, dy0));\n    const ww = qaq(qaq(qmq(ddx0, dx1), qmq(ddx1, dx0)), qaq(qmq(ddy0, dy1), qmq(ddy1, dy0)));\n    const xx = qdq(ddx0_dy0, ddy0_dx0);\n    const yy = qdq(qaq(ddx0_dy1, ddx1_dy0), qaq(ddy0_dx1, ddy1_dx0));\n    const qq = qaq(qmq(dx0, dx0), qmq(dy0, dy0));\n    const rr = qaq(dx0_dx1, dy0_dy1);\n    // t6 cancels! see https://math.stackexchange.com/a/1956264/130809\n    const z1 = qaq(dx1_dy1, dx2_dy0);\n    const z2 = qaq(dy0_dy2, dy1_dy1);\n    const z3 = qaq(dx0_dx2, dx1_dx1);\n    const z4 = qaq(qmq(dx1, dy2), qmq(dx2, dy1));\n    const z5 = qdq(dx2_dx2, dy2_dy2);\n    const z6 = qdq(dx1_dx2, dy1_dy2);\n    const z7 = qaq(dx0_dy2, dx1_dy1);\n    const z8 = qdq(dx0_dx1, dy0_dy1);\n    const z9 = qaq(qmq(dx0, dy1), qmq(dx1, dy0));\n    const x1 = qaq(dy0_dy2, z2);\n    const x2 = qaq(dx0_dx2, z3);\n    const x3 = qaq(dx0_dy2, z1);\n    const x4 = qaq(dx1_dy1, z1);\n    const x5 = qdq(x2, x1);\n    const x6 = qaq(z1, dx2_dy0);\n    const x7 = qaq(z7, dx2_dy0);\n    const x8 = qaq((0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2)(ddy0_dx1), ddy1_dx0);\n    // const t5 = \n    //     dx2_dx2*(dddx_dy1 - 3*dddy_dx1) + \n    //     dy2_dy2*(3*dddx_dy1 - dddy_dx1) + \n    //     2*((dx2_dy2)*((dddx*dx1 - dddy*dy1) + 3*(ddy0*ddy1 - ddx0*ddx1)) + 3*ddx1*ddy1*z6) + \n    //     3*(z4*(ddy1_ddy1 - ddx1*ddx1) + z5*(ddx0*ddy1 + ddy0*ddx1));\n    const a1 = qmq(dx2_dx2, (qdq(dddx_dy1, qmd(3, dddy_dx1))));\n    const a2 = qmq(dy2_dy2, (qdq(qmd(3, dddx_dy1), dddy_dx1)));\n    const a3 = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2)(qaq(qmq(dx2_dy2, (qaq(qdq(qmq(dddx, dx1), qmq(dddy, dy1)), qmd(3, qdq(qmq(ddy0, ddy1), qmq(ddx0, ddx1)))))), qmd(3, qmq(qmq(ddx1, ddy1), z6))));\n    const a4 = qmd(3, (qaq(qmq(z4, (qdq(ddy1_ddy1, qmq(ddx1, ddx1)))), qmq(z5, (qaq(qmq(ddx0, ddy1), qmq(ddy0, ddx1)))))));\n    const t5 = qaq(qaq(a1, a2), qaq(a3, a4));\n    // const t4 = \n    //     dddx*(dy2*(x2 + 3*z2) + dx2*x4) -\n    //     dddy*(dx0*(3*dx2_dx2 + dy2_dy2) + dx1*(3*dx1_dx2 + 2*dy1_dy2) + dx2*x1) + \n    //     3*(\n    //         ddx0*((ddy0*z5 - ddx0*dx2_dy2) + 2*(ddy1*z6 - ddx1*z4)) + \n    //         ddx1*(2*ddy0*z6 + ddy1*(2*(dx0_dx2 - dy0_dy2) + (dx1_dx1 - dy1_dy1)) - ddx1*x7) + \n    //         ddy0*(ddy0*dx2_dy2 + 2*ddy1*z4) + \n    //         ddy1_ddy1*x3\n    //     );\n    const b1 = qmq(dddx, (qaq(qmq(dy2, (qaq(x2, qmd(3, z2)))), qmq(dx2, x4))));\n    const b2 = qmq(dddy, qaq(qaq(qmq(dx0, (qaq(qmd(3, dx2_dx2), dy2_dy2))), qmq(dx1, (qaq(qmd(3, dx1_dx2), qm2(dy1_dy2))))), qmq(dx2, x1)));\n    const b3 = qmd(3, qaq(qaq(qmq(ddx0, (qaq((qdq(qmq(ddy0, z5), qmq(ddx0, dx2_dy2))), qm2((qdq(qmq(ddy1, z6), qmq(ddx1, z4))))))), qmq(ddx1, (qdq(qaq(qm2(qmq(ddy0, z6)), qmq(ddy1, (qaq(qm2(qdq(dx0_dx2, dy0_dy2)), (qdq(dx1_dx1, dy1_dy1)))))), qmq(ddx1, x7))))), qaq(qmq(ddy0, (qaq(qmq(ddy0, dx2_dy2), qm2(qmq(ddy1, z4))))), qmq(ddy1_ddy1, x3))));\n    const t4 = qaq(qdq(b1, b2), b3);\n    // const t3 =\n    //     dddx*(2*dx0*z4 + dx1*x6 + dy1*(4*dy0_dy2 + x1)) - \n    //     dddy*(2*dx0*(3*dx1_dx2 + dy1_dy2) + dx1*(dx1_dx1 + 2*dy0_dy2) + dy1*x6) + \n    //     3*(\n    //         ddx0*(2*(ddy0*z6 - ddx1*x7) + ddy1*x5 - ddx0*z4) + \n    //         ddx1*(2*ddy1*z8 - ddx1*z9) +\n    //         ddy0*(ddy0*z4 + 2*ddy1*x3 + ddx1*x5) + \n    //         ddy1_ddy1*z9\n    //     );\n    const c1 = qmq(dddx, (qaq(qaq(qm2(qmq(dx0, z4)), qmq(dx1, x6)), qmq(dy1, (qaq(qm4(dy0_dy2), x1))))));\n    const c2 = qmq(dddy, (qaq(qaq(qm2(qmq(dx0, (qaq(qmd(3, dx1_dx2), dy1_dy2)))), qmq(dx1, (qaq(dx1_dx1, qm2(dy0_dy2))))), qmq(dy1, x6))));\n    const c3 = qmd(3, (qaq(qaq(qmq(ddx0, (qdq(qaq(qm2(qdq(qmq(ddy0, z6), qmq(ddx1, x7))), qmq(ddy1, x5)), qmq(ddx0, z4)))), qmq(ddx1, (qdq(qm2(qmq(ddy1, z8)), qmq(ddx1, z9))))), qaq(qmq(ddy0, (qaq(qaq(qmq(ddy0, z4), qm2(qmq(ddy1, x3))), qmq(ddx1, x5)))), qmq(ddy1_ddy1, z9)))));\n    const t3 = qaq(qdq(c1, c2), c3);\n    // const t2 = \n    //     dddx*(dx0*(dx0_dy2 + 2*z1) + dy0*(dx1_dx1 + 3*z2)) -\n    //     dddy*(dx0*(3*z3 + x1) + dy0*x4) + \n    //     3*(\n    //         ddx0*(ddy0*x5 - ddx0*x3 + 2*(ddy1*z8 - ddx1*z9)) + \n    //         ddx1*(dx0*(x8 - ddx1*dy0) - dy0*(2*ddy0*dy1 + ddy1*dy0)) + \n    //         ddy0*(ddy0*z1 + dx0*(2*ddy1*dy1 + ddy0*dy2)) + \n    //         ddy1*dy0*x8\n    //     );\n    const d1 = qmq(dddx, (qaq(qmq(dx0, (qaq(dx0_dy2, qm2(z1)))), qmq(dy0, (qaq(dx1_dx1, qmd(3, z2)))))));\n    const d2 = qmq(dddy, (qaq(qmq(dx0, (qaq(qmd(3, z3), x1))), qmq(dy0, x4))));\n    const d3 = qmd(3, (qaq(qaq(qmq(ddx0, (qaq(qdq(qmq(ddy0, x5), qmq(ddx0, x3)), qm2(qdq(qmq(ddy1, z8), qmq(ddx1, z9)))))), qmq(ddx1, (qdq(qmq(dx0, (qdq(x8, qmq(ddx1, dy0)))), qmq(dy0, (qaq(qm2(qmq(ddy0, dy1)), qmq(ddy1, dy0)))))))), qaq(qmq(ddy0, (qaq(qmq(ddy0, z1), qmq(dx0, (qaq(qm2(qmq(ddy1, dy1)), qmq(ddy0, dy2))))))), qmq(ddy1, qmq(dy0, x8))))));\n    const t2 = qaq(qdq(d1, d2), d3);\n    // const t1 = (qq*uu + 2*rr*ss) - 3*(vv*yy + ww*xx)\n    const t1 = qdq((qaq(qmq(qq, uu), qm2(qmq(rr, ss)))), qmd(3, qaq(qmq(vv, yy), qmq(ww, xx))));\n    // const t0 = ss*qq - 3*vv*xx;\n    const t0 = qdq(qmq(ss, qq), qmd(3, qmq(vv, xx)));\n    const r3 = qdq(qmq(ddx1, dy2), qmq(ddy1, dx2));\n    const r2 = qdq(qaq(qmq(ddx0, dy2), qmq(ddx1, dy1)), qaq(qmq(ddy0, dx2), qmq(ddy1, dx1)));\n    const r1 = qdq(qaq(ddx0_dy1, ddx1_dy0), qaq(ddy0_dx1, ddy1_dx0));\n    const r0 = qdq(ddx0_dy0, ddy0_dx0);\n    return {\n        inflectionPoly: [r3, r2, r1, r0],\n        otherExtremaPoly: [t5, t4, t3, t2, t1, t0]\n    };\n}\n\n//# sourceMappingURL=get-abs-curvature-extrema-polys-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-abs-curvature-extrema-polys-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-dd.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-dd.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvatureExtremaDd: () => (/* binding */ getCurvatureExtremaDd)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_abs_curvature_extrema_polys_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-abs-curvature-extrema-polys-dd.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-abs-curvature-extrema-polys-dd.js\");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_curvature_extrema_quadratic_poly_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-curvature-extrema-quadratic-poly-dd.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-quadratic-poly-dd.js\");\n\n\n\n\n\n\n\n/**\n * Returns the parameter `t` values (in `[0,1]`) of local minimum / maximum\n * absolute curvature for the given bezier curve.\n *\n * If there are an infinite number of such `t` values (such as is the case for a\n * line), an empty array is returned.\n *\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)'s excellent\n * answer on math.stackexchange\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getCurvatureExtremaDd(ps) {\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\n        return { minima: [], maxima: [], inflections: [] };\n    }\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__.isCubicReallyQuad)(ps)) {\n        ps = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(ps);\n    }\n    if (ps.length === 3) {\n        const poly = (0,_get_curvature_extrema_quadratic_poly_dd_js__WEBPACK_IMPORTED_MODULE_3__.getCurvatureExtremaQuadraticPolyDd)(ps);\n        const maxima = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(poly, 0, 1);\n        return {\n            minima: [],\n            maxima: maxima.map(r => (r.tS + r.tE) / 2),\n            inflections: []\n        };\n    }\n    const polys = (0,_get_abs_curvature_extrema_polys_dd_js__WEBPACK_IMPORTED_MODULE_5__.getAbsCurvatureExtremaPolysDd)(ps);\n    const p1 = polys.inflectionPoly;\n    const p2 = polys.otherExtremaPoly;\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(p2, 0, 1);\n    // get second derivative (using product rule) to see if it is a local \n    // minimum or maximum, i.e. diff(p1*p2) = p1'*p2 + p1*p2' = dp1*p2 + p1*dp2\n    // = p1*dp2 (since dp1*p2 === 0)\n    const dp2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.ddDifferentiate)(p2);\n    const minima = [];\n    const maxima = [];\n    for (let i = 0; i < ts.length; i++) {\n        const t = (ts[i].tS + ts[i].tE) / 2;\n        const dp2_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.eHorner)(dp2, t);\n        const p1_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.eHorner)(p1, t);\n        const secondDerivative = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.eMult)(p1_, dp2_);\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_9__.eSign)(secondDerivative) >= 0) {\n            minima.push(t);\n        }\n        else {\n            maxima.push(t);\n        }\n    }\n    const inflections = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(p1, 0, 1)\n        .map(r => (r.tS + r.tE) / 2);\n    return { minima, maxima, inflections };\n}\n\n//# sourceMappingURL=get-curvature-extrema-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-quadratic-poly-dd.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-quadratic-poly-dd.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvatureExtremaQuadraticPolyDd: () => (/* binding */ getCurvatureExtremaQuadraticPolyDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\n/**\n * Returns the polynomial whose zero is the t value of maximum absolute\n * curvature for the given *quadratic* bezier curve.\n *\n * * **precondition:** the given parabola is not degenerate to a line\n * * **non-exact:** there is floating point roundof during calculation\n * * see e.g. [math.stackexchange](https://math.stackexchange.com/a/2971112)'s\n * answer by [KeithWM](https://math.stackexchange.com/a/2971112/130809)\n *\n * @param ps an order 2 bezier curve given as an array of control points,\n * e.g. `[[0,0],[1,1],[2,1]]`\n *\n * @internal\n */\nfunction getCurvatureExtremaQuadraticPolyDd(ps) {\n    // Find the point of max curvature (of the parabola)\n    // calculate t*\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const x10 = td(x1, x0);\n    const x21 = td(x2, x1);\n    const wx = qdq(x21, x10);\n    const y10 = td(y1, y0);\n    const y21 = td(y2, y1);\n    const wy = qdq(y21, y10);\n    const n = qaq(qdq(qmd(x0, (qdq(wx, [0, -x1]))), qmd(x1, (qdq(x21, [0, -x1])))), qdq(qmd(y0, (qdq(wy, [0, -y1]))), qmd(y1, (qdq(y21, [0, -y1])))));\n    const d = qaq(qmq(wx, wx), qmq(wy, wy));\n    return [d, (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf)(n)];\n}\n\n//# sourceMappingURL=get-curvature-extrema-quadratic-poly-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-quadratic-poly-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-abs-curvature-extrema-polys-e.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-abs-curvature-extrema-polys-e.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAbsCurvatureExtremaPolysE: () => (/* binding */ getAbsCurvatureExtremaPolysE)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_exact_to_power_basis_3rd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2;\nconst em4 = (v) => (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2)(v));\nconst emd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMultDouble1;\nconst eme = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\nconst eae = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\nconst ede = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\n/**\n * Returns the polynomials whose zeros are the `t` values of the local\n * minima / maxima of the absolute curvature for the given bezier curve.\n *\n * The polynomials are in the form `p1*p2` where the zeros\n * of `p1` are the inflection points and the zeros of `p2` are the other minima /\n * maxima.\n *\n * * **precondition:** must be a `true` cubic bezier (not degenerate to line or\n * quadratic)\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)\n * * **non-exact:** due to floating point roundof during calculation\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @internal\n */\nfunction getAbsCurvatureExtremaPolysE(ps) {\n    // It is a real cubic - use the excellent answer from the description:\n    // dd(kappa^2)/dt === (x′′y′ − x′y′′)*((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\n    // Inflection points at: (x′′y′ − x′y′′) === 0\n    // Max abs curvature at: ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′)) === 0\n    const [[dx2, dx1, dx0], [dy2, dy1, dy0]] = (0,_to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis_1stDerivativeExact)(ps); // max bitlength increase === 5\n    const [[ddx1, ddx0], [ddy1, ddy0]] = (0,_to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis_2ndDerivativeExact)(ps); // max bitlength increase === 6\n    const [[dddx], [dddy]] = (0,_to_power_basis_to_power_basis_3rd_derivative_exact_to_power_basis_3rd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_5__.toPowerBasis_3rdDerivativeExact)(ps); // max bitlength increase === 6\n    // ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\n    // or \n    // x′′′x′x′y′ + x′′′y′y′y′ - y′′′x′x′x′ - y′′′x′y′y′ + \n    // 3(x′′y′′x′x′ - x′′x′′x′y′ - x′′y′′y′y′ + y′′y′′x′y′)\n    // The above line becomes\n    // ((dddx*dy(t) − dx(t)*dddy)(dx(t)dx(t) + dy(t)dy(t)) − 3(dx(t)ddx(t) + dy(t)ddy(t))(ddx(t)dy(t) − dx(t)ddy(t)))\n    // or \n    // dddx*dxt**2*dyt + dddx*dyt**3 - dddy*dxt**3 - dddy*dxt*dyt**2 - \n    // 3*ddxt**2*dxt*dyt + 3*ddxt*ddyt*dxt**2 - 3*ddxt*ddyt*dyt**2 + 3*ddyt**2*dxt*dyt\n    // which becomes: (after substituting e.g. dy(t) = dy2*t^2 + dy1*t + dy0, etc. using Python and\n    // then expanding and collecting terms)\n    const dddx_dy1 = eme(dddx, dy1);\n    const dddy_dx1 = eme(dddy, dx1);\n    const ddx0_dy0 = eme(ddx0, dy0);\n    const ddx0_dy1 = eme(ddx0, dy1);\n    const ddy1_ddy1 = eme(ddy1, ddy1);\n    const ddx1_dy0 = eme(ddx1, dy0);\n    const ddy0_dx0 = eme(ddy0, dx0);\n    const ddy0_dx1 = eme(ddy0, dx1);\n    const ddy1_dx0 = eme(ddy1, dx0);\n    const dx0_dx1 = eme(dx0, dx1);\n    const dx0_dx2 = eme(dx0, dx2);\n    const dx0_dy2 = eme(dx0, dy2);\n    const dx1_dx1 = eme(dx1, dx1);\n    const dx1_dx2 = eme(dx1, dx2);\n    const dx1_dy1 = eme(dx1, dy1);\n    const dx2_dy0 = eme(dx2, dy0);\n    const dx2_dy2 = eme(dx2, dy2);\n    const dx2_dx2 = eme(dx2, dx2);\n    const dy0_dy1 = eme(dy0, dy1);\n    const dy0_dy2 = eme(dy0, dy2);\n    const dy1_dy1 = eme(dy1, dy1);\n    const dy1_dy2 = eme(dy1, dy2);\n    const dy2_dy2 = eme(dy2, dy2);\n    const ss = ede(eme(dddx, dy0), eme(dddy, dx0));\n    const uu = ede(dddx_dy1, dddy_dx1);\n    const vv = eae(eme(ddx0, dx0), eme(ddy0, dy0));\n    const ww = eae(eae(eme(ddx0, dx1), eme(ddx1, dx0)), eae(eme(ddy0, dy1), eme(ddy1, dy0)));\n    const xx = ede(ddx0_dy0, ddy0_dx0);\n    const yy = ede(eae(ddx0_dy1, ddx1_dy0), eae(ddy0_dx1, ddy1_dx0));\n    const qq = eae(eme(dx0, dx0), eme(dy0, dy0));\n    const rr = eae(dx0_dx1, dy0_dy1);\n    // t6 cancels! see https://math.stackexchange.com/a/1956264/130809\n    const z1 = eae(dx1_dy1, dx2_dy0);\n    const z2 = eae(dy0_dy2, dy1_dy1);\n    const z3 = eae(dx0_dx2, dx1_dx1);\n    const z4 = eae(eme(dx1, dy2), eme(dx2, dy1));\n    const z5 = ede(dx2_dx2, dy2_dy2);\n    const z6 = ede(dx1_dx2, dy1_dy2);\n    const z7 = eae(dx0_dy2, dx1_dy1);\n    const z8 = ede(dx0_dx1, dy0_dy1);\n    const z9 = eae(eme(dx0, dy1), eme(dx1, dy0));\n    const x1 = eae(dy0_dy2, z2);\n    const x2 = eae(dx0_dx2, z3);\n    const x3 = eae(dx0_dy2, z1);\n    const x4 = eae(dx1_dy1, z1);\n    const x5 = ede(x2, x1);\n    const x6 = eae(z1, dx2_dy0);\n    const x7 = eae(z7, dx2_dy0);\n    const x8 = eae(em2(ddy0_dx1), ddy1_dx0);\n    // const t5 = \n    //     dx2_dx2*(dddx_dy1 - 3*dddy_dx1) + \n    //     dy2_dy2*(3*dddx_dy1 - dddy_dx1) + \n    //     2*((dx2_dy2)*((dddx*dx1 - dddy*dy1) + 3*(ddy0*ddy1 - ddx0*ddx1)) + 3*ddx1*ddy1*z6) + \n    //     3*(z4*(ddy1_ddy1 - ddx1*ddx1) + z5*(ddx0*ddy1 + ddy0*ddx1));\n    const a1 = eme(dx2_dx2, (ede(dddx_dy1, emd(dddy_dx1, 3))));\n    const a2 = eme(dy2_dy2, (ede(emd(dddx_dy1, 3), dddy_dx1)));\n    const a3 = em2(eae(eme(dx2_dy2, (eae(ede(eme(dddx, dx1), eme(dddy, dy1)), emd(ede(eme(ddy0, ddy1), eme(ddx0, ddx1)), 3)))), emd(eme(eme(ddx1, ddy1), z6), 3)));\n    const a4 = emd((eae(eme(z4, (ede(ddy1_ddy1, eme(ddx1, ddx1)))), eme(z5, (eae(eme(ddx0, ddy1), eme(ddy0, ddx1)))))), 3);\n    const t5 = eae(eae(a1, a2), eae(a3, a4));\n    // const t4 = \n    //     dddx*(dy2*(x2 + 3*z2) + dx2*x4) -\n    //     dddy*(dx0*(3*dx2_dx2 + dy2_dy2) + dx1*(3*dx1_dx2 + 2*dy1_dy2) + dx2*x1) + \n    //     3*(\n    //         ddx0*((ddy0*z5 - ddx0*dx2_dy2) + 2*(ddy1*z6 - ddx1*z4)) + \n    //         ddx1*(2*ddy0*z6 + ddy1*(2*(dx0_dx2 - dy0_dy2) + (dx1_dx1 - dy1_dy1)) - ddx1*x7) + \n    //         ddy0*(ddy0*dx2_dy2 + 2*ddy1*z4) + \n    //         ddy1_ddy1*x3\n    //     );\n    const b1 = eme(dddx, (eae(eme(dy2, (eae(x2, emd(z2, 3)))), eme(dx2, x4))));\n    const b2 = eme(dddy, eae(eae(eme(dx0, (eae(emd(dx2_dx2, 3), dy2_dy2))), eme(dx1, (eae(emd(dx1_dx2, 3), em2(dy1_dy2))))), eme(dx2, x1)));\n    const b3 = emd(eae(eae(eme(ddx0, (eae((ede(eme(ddy0, z5), eme(ddx0, dx2_dy2))), em2((ede(eme(ddy1, z6), eme(ddx1, z4))))))), eme(ddx1, (ede(eae(em2(eme(ddy0, z6)), eme(ddy1, (eae(em2(ede(dx0_dx2, dy0_dy2)), (ede(dx1_dx1, dy1_dy1)))))), eme(ddx1, x7))))), eae(eme(ddy0, (eae(eme(ddy0, dx2_dy2), em2(eme(ddy1, z4))))), eme(ddy1_ddy1, x3))), 3);\n    const t4 = eae(ede(b1, b2), b3);\n    // const t3 =\n    //     dddx*(2*dx0*z4 + dx1*x6 + dy1*(4*dy0_dy2 + x1)) - \n    //     dddy*(2*dx0*(3*dx1_dx2 + dy1_dy2) + dx1*(dx1_dx1 + 2*dy0_dy2) + dy1*x6) + \n    //     3*(\n    //         ddx0*(2*(ddy0*z6 - ddx1*x7) + ddy1*x5 - ddx0*z4) + \n    //         ddx1*(2*ddy1*z8 - ddx1*z9) +\n    //         ddy0*(ddy0*z4 + 2*ddy1*x3 + ddx1*x5) + \n    //         ddy1_ddy1*z9\n    //     );\n    const c1 = eme(dddx, (eae(eae(em2(eme(dx0, z4)), eme(dx1, x6)), eme(dy1, (eae(em4(dy0_dy2), x1))))));\n    const c2 = eme(dddy, (eae(eae(em2(eme(dx0, (eae(emd(dx1_dx2, 3), dy1_dy2)))), eme(dx1, (eae(dx1_dx1, em2(dy0_dy2))))), eme(dy1, x6))));\n    const c3 = emd((eae(eae(eme(ddx0, (ede(eae(em2(ede(eme(ddy0, z6), eme(ddx1, x7))), eme(ddy1, x5)), eme(ddx0, z4)))), eme(ddx1, (ede(em2(eme(ddy1, z8)), eme(ddx1, z9))))), eae(eme(ddy0, (eae(eae(eme(ddy0, z4), em2(eme(ddy1, x3))), eme(ddx1, x5)))), eme(ddy1_ddy1, z9)))), 3);\n    const t3 = eae(ede(c1, c2), c3);\n    // const t2 = \n    //     dddx*(dx0*(dx0_dy2 + 2*z1) + dy0*(dx1_dx1 + 3*z2)) -\n    //     dddy*(dx0*(3*z3 + x1) + dy0*x4) + \n    //     3*(\n    //         ddx0*(ddy0*x5 - ddx0*x3 + 2*(ddy1*z8 - ddx1*z9)) + \n    //         ddx1*(dx0*(x8 - ddx1*dy0) - dy0*(2*ddy0*dy1 + ddy1*dy0)) + \n    //         ddy0*(ddy0*z1 + dx0*(2*ddy1*dy1 + ddy0*dy2)) + \n    //         ddy1*dy0*x8\n    //     );\n    const d1 = eme(dddx, (eae(eme(dx0, (eae(dx0_dy2, em2(z1)))), eme(dy0, (eae(dx1_dx1, emd(z2, 3)))))));\n    const d2 = eme(dddy, (eae(eme(dx0, (eae(emd(z3, 3), x1))), eme(dy0, x4))));\n    const d3 = emd((eae(eae(eme(ddx0, (eae(ede(eme(ddy0, x5), eme(ddx0, x3)), em2(ede(eme(ddy1, z8), eme(ddx1, z9)))))), eme(ddx1, (ede(eme(dx0, (ede(x8, eme(ddx1, dy0)))), eme(dy0, (eae(em2(eme(ddy0, dy1)), eme(ddy1, dy0)))))))), eae(eme(ddy0, (eae(eme(ddy0, z1), eme(dx0, (eae(em2(eme(ddy1, dy1)), eme(ddy0, dy2))))))), eme(ddy1, eme(dy0, x8))))), 3);\n    const t2 = eae(ede(d1, d2), d3);\n    // const t1 = (qq*uu + 2*rr*ss) - 3*(vv*yy + ww*xx)\n    const t1 = ede((eae(eme(qq, uu), em2(eme(rr, ss)))), emd(eae(eme(vv, yy), eme(ww, xx)), 3));\n    // const t0 = ss*qq - 3*vv*xx;\n    const t0 = ede(eme(ss, qq), emd(eme(vv, xx), 3));\n    const r3 = ede(eme(ddx1, dy2), eme(ddy1, dx2));\n    const r2 = ede(eae(eme(ddx0, dy2), eme(ddx1, dy1)), eae(eme(ddy0, dx2), eme(ddy1, dx1)));\n    const r1 = ede(eae(ddx0_dy1, ddx1_dy0), eae(ddy0_dx1, ddy1_dx0));\n    const r0 = ede(ddx0_dy0, ddy0_dx0);\n    return {\n        inflectionPoly: [r3, r2, r1, r0],\n        otherExtremaPoly: [t5, t4, t3, t2, t1, t0]\n    };\n}\n\n//# sourceMappingURL=get-abs-curvature-extrema-polys-e.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-abs-curvature-extrema-polys-e.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-e.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-e.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvatureExtremaE: () => (/* binding */ getCurvatureExtremaE)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_abs_curvature_extrema_polys_e_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-abs-curvature-extrema-polys-e.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-abs-curvature-extrema-polys-e.js\");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_curvature_extrema_quadratic_poly_e_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-curvature-extrema-quadratic-poly-e.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-quadratic-poly-e.js\");\n/* harmony import */ var _get_curvature_extrema_dd_get_curvature_extrema_quadratic_poly_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-curvature-extrema-dd/get-curvature-extrema-quadratic-poly-dd.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-quadratic-poly-dd.js\");\n/* harmony import */ var _get_curvature_extrema_dd_get_abs_curvature_extrema_polys_dd_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../get-curvature-extrema-dd/get-abs-curvature-extrema-polys-dd.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-abs-curvature-extrema-polys-dd.js\");\n\n\n\n\n\n\n\n\n\nconst { abs } = Math;\n/**\n * Returns the parameter `t` values (in `[0,1]`) of local minimum / maximum\n * absolute curvature for the given bezier curve.\n *\n * If there are an infinite number of such `t` values (such as is the case for a\n * line), an empty array is returned.\n *\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)'s excellent\n * answer on math.stackexchange\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\n// TODO - slow - currently just for testing!\nfunction getCurvatureExtremaE(ps) {\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\n        return { minima: [], maxima: [], inflections: [] };\n    }\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__.isCubicReallyQuad)(ps)) {\n        ps = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(ps);\n    }\n    if (ps.length === 3) {\n        const polyDd = (0,_get_curvature_extrema_dd_get_curvature_extrema_quadratic_poly_dd_js__WEBPACK_IMPORTED_MODULE_3__.getCurvatureExtremaQuadraticPolyDd)(ps);\n        const polyE = (0,_get_curvature_extrema_quadratic_poly_e_js__WEBPACK_IMPORTED_MODULE_4__.getCurvatureExtremaQuadraticPolyE)(ps);\n        const polyErr = polyE.map((c, i) => {\n            const cDd = polyDd[i];\n            const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eDiff)(c, cDd);\n            return abs(d[d.length - 1]);\n        });\n        // const maxima = allRoots(poly, 0, 1);\n        const maxima = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.allRootsCertified)(polyDd, 0, 1, polyErr, () => polyE);\n        return {\n            minima: [],\n            maxima: maxima.map(r => (r.tS + r.tE) / 2),\n            inflections: []\n        };\n    }\n    const polys = (0,_get_abs_curvature_extrema_polys_e_js__WEBPACK_IMPORTED_MODULE_7__.getAbsCurvatureExtremaPolysE)(ps);\n    const p1 = polys.inflectionPoly;\n    const p2 = polys.otherExtremaPoly;\n    const polysDd = (0,_get_curvature_extrema_dd_get_abs_curvature_extrema_polys_dd_js__WEBPACK_IMPORTED_MODULE_8__.getAbsCurvatureExtremaPolysDd)(ps);\n    const p1Dd = polysDd.inflectionPoly;\n    const p2Dd = polysDd.otherExtremaPoly;\n    const polyErr1 = p1.map((c, i) => {\n        const cDd = p1Dd[i];\n        const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eDiff)(c, cDd);\n        return abs(d[d.length - 1]);\n    });\n    const polyErr2 = p2.map((c, i) => {\n        const cDd = p2Dd[i];\n        const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eDiff)(c, cDd);\n        return abs(d[d.length - 1]);\n    });\n    // if (p2Dd.length || polyErr1)\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.allRootsCertified)(p2Dd, 0, 1, polyErr2, () => p2);\n    // get second derivative (using product rule) to see if it is a local \n    // minimum or maximum, i.e. diff(p1*p2) = p1'*p2 + p1*p2' = dp1*p2 + p1*dp2\n    // = p1*dp2 (since dp1*p2 === 0)\n    const dp2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.eDifferentiate)(p2);\n    const minima = [];\n    const maxima = [];\n    for (let i = 0; i < ts.length; i++) {\n        const t = (ts[i].tS + ts[i].tE) / 2;\n        const dp2_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_10__.eHorner)(dp2, t);\n        const p1_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_10__.eHorner)(p1, t);\n        const secondDerivative = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eMult)(p1_, dp2_);\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_12__.eSign)(secondDerivative) >= 0) {\n            minima.push(t);\n        }\n        else {\n            maxima.push(t);\n        }\n    }\n    const inflections = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.allRootsCertified)(p1Dd, 0, 1, polyErr1, () => p1)\n        .map(r => (r.tS + r.tE) / 2);\n    return { minima, maxima, inflections };\n}\n\n//# sourceMappingURL=get-curvature-extrema-e.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-e.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-quadratic-poly-e.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-quadratic-poly-e.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvatureExtremaQuadraticPolyE: () => (/* binding */ getCurvatureExtremaQuadraticPolyE)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst emd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultDouble2;\nconst eme = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult;\nconst eae = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\nconst ede = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoDiff;\n/**\n * Returns the polynomial whose zero is the t value of maximum absolute\n * curvature for the given *quadratic* bezier curve.\n *\n * * **precondition:** the given parabola is not degenerate to a line\n * * **non-exact:** there is floating point roundof during calculation\n * * see e.g. [math.stackexchange](https://math.stackexchange.com/a/2971112)'s\n * answer by [KeithWM](https://math.stackexchange.com/a/2971112/130809)\n *\n * @param ps an order 2 bezier curve given as an array of control points,\n * e.g. `[[0,0],[1,1],[2,1]]`\n *\n * @internal\n */\nfunction getCurvatureExtremaQuadraticPolyE(ps) {\n    // Find the point of max curvature (of the parabola)\n    // calculate t*\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const x10 = td(x1, x0);\n    const x21 = td(x2, x1);\n    const wx = ede(x21, x10);\n    const y10 = td(y1, y0);\n    const y21 = td(y2, y1);\n    const wy = ede(y21, y10);\n    const n = eae(ede(emd(x0, (ede(wx, [0, -x1]))), emd(x1, (ede(x21, [0, -x1])))), ede(emd(y0, (ede(wy, [0, -y1]))), emd(y1, (ede(y21, [0, -y1])))));\n    const d = eae(eme(wx, wx), eme(wy, wy));\n    return [d, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eNegativeOf)(n)];\n}\n\n//# sourceMappingURL=get-curvature-extrema-quadratic-poly-e.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-quadratic-poly-e.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAbsCurvatureExtremaPolys: () => (/* binding */ getAbsCurvatureExtremaPolys)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js\");\n\n\n\n/**\n * Returns the polynomials whose zeros are the `t` values of the local\n * minima / maxima of the absolute curvature for the given bezier curve.\n *\n * The polynomials are in the form `p1*p2` where the zeros\n * of `p1` are the inflection points and the zeros of `p2` are the other minima /\n * maxima.\n *\n * * **precondition:** must be a `true` cubic bezier (not degenerate to line or\n * quadratic)\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)\n * * **non-exact:** due to floating point roundof during calculation\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @internal\n */\nfunction getAbsCurvatureExtremaPolys(ps) {\n    // It is a real cubic - use the excellent answer from the description:\n    // dd(kappa^2)/dt === (x′′y′ − x′y′′)*((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\n    // Inflection points at: (x′′y′ − x′y′′) === 0\n    // Max abs curvature at: ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′)) === 0\n    const [[dx2, dx1, dx0], [dy2, dy1, dy0]] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps); // max bitlength increase === 5\n    const [[ddx1, ddx0], [ddy1, ddy0]] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_2ndDerivative)(ps); // max bitlength increase === 6\n    const [[dddx], [dddy]] = (0,_to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_3rdDerivative)(ps); // max bitlength increase === 6\n    // ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\n    // or \n    // x′′′x′x′y′ + x′′′y′y′y′ - y′′′x′x′x′ - y′′′x′y′y′ + \n    // 3(x′′y′′x′x′ - x′′x′′x′y′ - x′′y′′y′y′ + y′′y′′x′y′)\n    // The above line becomes\n    // ((dddx*dy(t) − dx(t)*dddy)(dx(t)dx(t) + dy(t)dy(t)) − 3(dx(t)ddx(t) + dy(t)ddy(t))(ddx(t)dy(t) − dx(t)ddy(t)))\n    // or \n    // dddx*dxt**2*dyt + dddx*dyt**3 - dddy*dxt**3 - dddy*dxt*dyt**2 - \n    // 3*ddxt**2*dxt*dyt + 3*ddxt*ddyt*dxt**2 - 3*ddxt*ddyt*dyt**2 + 3*ddyt**2*dxt*dyt\n    // which becomes: (after substituting e.g. dy(t) = dy2*t^2 + dy1*t + dy0, etc. using Python and\n    // then expanding and collecting terms)\n    const dddx_dy1 = dddx * dy1;\n    const dddy_dx1 = dddy * dx1;\n    const ddx0_dy0 = ddx0 * dy0;\n    const ddx0_dy1 = ddx0 * dy1;\n    const ddy1_ddy1 = ddy1 * ddy1;\n    const ddx1_dy0 = ddx1 * dy0;\n    const ddy0_dx0 = ddy0 * dx0;\n    const ddy0_dx1 = ddy0 * dx1;\n    const ddy1_dx0 = ddy1 * dx0;\n    const dx0_dx1 = dx0 * dx1;\n    const dx0_dx2 = dx0 * dx2;\n    const dx0_dy2 = dx0 * dy2;\n    const dx1_dx1 = dx1 * dx1;\n    const dx1_dx2 = dx1 * dx2;\n    const dx1_dy1 = dx1 * dy1;\n    const dx2_dy0 = dx2 * dy0;\n    const dx2_dy2 = dx2 * dy2;\n    const dx2_dx2 = dx2 * dx2;\n    const dy0_dy1 = dy0 * dy1;\n    const dy0_dy2 = dy0 * dy2;\n    const dy1_dy1 = dy1 * dy1;\n    const dy1_dy2 = dy1 * dy2;\n    const dy2_dy2 = dy2 * dy2;\n    const ss = dddx * dy0 - dddy * dx0;\n    const uu = dddx_dy1 - dddy_dx1;\n    const vv = ddx0 * dx0 + ddy0 * dy0;\n    const ww = ddx0 * dx1 + ddx1 * dx0 + ddy0 * dy1 + ddy1 * dy0;\n    const xx = ddx0_dy0 - ddy0_dx0;\n    const yy = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;\n    const qq = dx0 * dx0 + dy0 * dy0;\n    const rr = dx0_dx1 + dy0_dy1;\n    // t6 cancels! see https://math.stackexchange.com/a/1956264/130809\n    const z1 = dx1_dy1 + dx2_dy0;\n    const z2 = dy0_dy2 + dy1_dy1;\n    const z3 = dx0_dx2 + dx1_dx1;\n    const z4 = dx1 * dy2 + dx2 * dy1;\n    const z5 = dx2_dx2 - dy2_dy2;\n    const z6 = dx1_dx2 - dy1_dy2;\n    const z7 = dx0_dy2 + dx1_dy1;\n    const z8 = dx0_dx1 - dy0_dy1;\n    const z9 = dx0 * dy1 + dx1 * dy0;\n    const x1 = dy0_dy2 + z2;\n    const x2 = dx0_dx2 + z3;\n    const x3 = dx0_dy2 + z1;\n    const x4 = dx1_dy1 + z1;\n    const x5 = x2 - x1;\n    const x6 = z1 + dx2_dy0;\n    const x7 = z7 + dx2_dy0;\n    const x8 = 2 * ddy0_dx1 + ddy1_dx0;\n    const t5 = dx2_dx2 * (dddx_dy1 - 3 * dddy_dx1) +\n        dy2_dy2 * (3 * dddx_dy1 - dddy_dx1) +\n        2 * ((dx2_dy2) * ((dddx * dx1 - dddy * dy1) + 3 * (ddy0 * ddy1 - ddx0 * ddx1)) + 3 * ddx1 * ddy1 * z6) +\n        3 * (z4 * (ddy1_ddy1 - ddx1 * ddx1) + z5 * (ddx0 * ddy1 + ddy0 * ddx1));\n    const t4 = dddx * (dy2 * (x2 + 3 * z2) + dx2 * x4) -\n        dddy * (dx0 * (3 * dx2_dx2 + dy2_dy2) + dx1 * (3 * dx1_dx2 + 2 * dy1_dy2) + dx2 * x1) +\n        3 * (ddx0 * ((ddy0 * z5 - ddx0 * dx2_dy2) + 2 * (ddy1 * z6 - ddx1 * z4)) +\n            ddx1 * (2 * ddy0 * z6 + ddy1 * (2 * (dx0_dx2 - dy0_dy2) + (dx1_dx1 - dy1_dy1)) - ddx1 * x7) +\n            ddy0 * (ddy0 * dx2_dy2 + 2 * ddy1 * z4) +\n            ddy1_ddy1 * x3);\n    const t3 = dddx * (2 * dx0 * z4 + dx1 * x6 + dy1 * (4 * dy0_dy2 + x1)) -\n        dddy * (2 * dx0 * (3 * dx1_dx2 + dy1_dy2) + dx1 * (dx1_dx1 + 2 * dy0_dy2) + dy1 * x6) +\n        3 * (ddx0 * (2 * (ddy0 * z6 - ddx1 * x7) + ddy1 * x5 - ddx0 * z4) +\n            ddx1 * (2 * ddy1 * z8 - ddx1 * z9) +\n            ddy0 * (ddy0 * z4 + 2 * ddy1 * x3 + ddx1 * x5) +\n            ddy1_ddy1 * z9);\n    const t2 = dddx * (dx0 * (dx0_dy2 + 2 * z1) + dy0 * (dx1_dx1 + 3 * z2)) -\n        dddy * (dx0 * (3 * z3 + x1) + dy0 * x4) +\n        3 * (ddx0 * (ddy0 * x5 - ddx0 * x3 + 2 * (ddy1 * z8 - ddx1 * z9)) +\n            ddx1 * (dx0 * (x8 - ddx1 * dy0) - dy0 * (2 * ddy0 * dy1 + ddy1 * dy0)) +\n            ddy0 * (ddy0 * z1 + dx0 * (2 * ddy1 * dy1 + ddy0 * dy2)) +\n            ddy1 * dy0 * x8);\n    const t1 = (qq * uu + 2 * rr * ss) - 3 * (vv * yy + ww * xx);\n    const t0 = ss * qq - 3 * vv * xx;\n    const r3 = ddx1 * dy2 - ddy1 * dx2;\n    const r2 = ddx0 * dy2 + ddx1 * dy1 - ddy0 * dx2 - ddy1 * dx1;\n    const r1 = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;\n    const r0 = ddx0_dy0 - ddy0_dx0;\n    return {\n        inflectionPoly: [r3, r2, r1, r0],\n        otherExtremaPoly: [t5, t4, t3, t2, t1, t0]\n    };\n}\n\n//# sourceMappingURL=get-abs-curvature-extrema-polys.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvatureExtrema: () => (/* binding */ getCurvatureExtrema)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/calculus/double/differentiate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _get_abs_curvature_extrema_polys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-abs-curvature-extrema-polys.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js\");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n\n\n\n\n\n/**\n * Returns the parameter `t` values (in `[0,1]`) of local minimum / maximum\n * absolute curvature for the given bezier curve.\n *\n * If there are an infinite number of such `t` values (such as is the case for a\n * line), an empty array is returned.\n *\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)'s excellent\n * answer on math.stackexchange\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getCurvatureExtrema(ps) {\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\n        return { minima: [], maxima: [], inflections: [] };\n    }\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__.isCubicReallyQuad)(ps)) {\n        ps = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(ps);\n    }\n    if (ps.length === 3) {\n        const poly = getCurvatureExtremaQuadraticPoly(ps);\n        const maxima = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.allRoots)(poly, 0, 1);\n        return {\n            minima: [],\n            maxima,\n            inflections: []\n        };\n    }\n    const polys = (0,_get_abs_curvature_extrema_polys_js__WEBPACK_IMPORTED_MODULE_4__.getAbsCurvatureExtremaPolys)(ps);\n    const p1 = polys.inflectionPoly;\n    const p2 = polys.otherExtremaPoly;\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.allRoots)(p2, 0, 1);\n    // get second derivative (using product rule) to see if it is a local \n    // minimum or maximum, i.e. diff(p1*p2) = p1'*p2 + p1*p2' = dp1*p2 + p1*dp2\n    // = p1*dp2 (since dp1*p2 === 0)\n    const dp2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.differentiate)(p2);\n    const minima = [];\n    const maxima = [];\n    for (let i = 0; i < ts.length; i++) {\n        const t = ts[i];\n        const dp2_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.Horner)(dp2, t);\n        const p1_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.Horner)(p1, t);\n        const secondDerivative = p1_ * dp2_;\n        if (secondDerivative >= 0) {\n            minima.push(t);\n        }\n        else {\n            maxima.push(t);\n        }\n    }\n    const inflections = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.allRoots)(p1, 0, 1);\n    return { minima, maxima, inflections };\n}\n/**\n * Returns the polynomial whose zero is the t value of maximum absolute\n * curvature for the given *quadratic* bezier curve.\n *\n * * **precondition:** the given parabola is not degenerate to a line\n * * **non-exact:** there is floating point roundof during calculation\n * * see e.g. [math.stackexchange](https://math.stackexchange.com/a/2971112)'s\n * answer by [KeithWM](https://math.stackexchange.com/a/2971112/130809)\n *\n * @param ps an order 2 bezier curve given as an array of control points,\n * e.g. `[[0,0],[1,1],[2,1]]`\n *\n * @internal\n */\nfunction getCurvatureExtremaQuadraticPoly(ps) {\n    // Find the point of max curvature (of the parabola)\n    // calculate t*\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const x10 = x1 - x0;\n    const x21 = x2 - x1;\n    const wx = x21 - x10;\n    const y10 = y1 - y0;\n    const y21 = y2 - y1;\n    const wy = y21 - y10;\n    const n = x0 * (wx - x1) - x1 * (x21 - x1) +\n        y0 * (wy - y1) - y1 * (y21 - y1);\n    const d = wx * wx + wy * wy;\n    return [d, -n];\n}\n\n//# sourceMappingURL=get-curvature-extrema.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/area.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/area.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   area: () => (/* binding */ area)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/calculus/double/integrate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/basic/double/subtract.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/basic/double/multiply.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n\n\n\n/**\n * Returns the signed area between the given bezier curve and the line between\n * its 1st and last control points.\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n */\nfunction area(ps) {\n    const [x, y] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis)(ps);\n    const [dx, dy] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\n    const poly = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.integrate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.subtract)((0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.multiply)(x, dy), (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.multiply)(y, dx)), 0);\n    // the below is exactly te same as: Horner(poly,1) - Horner(poly,0)\n    let total = 0;\n    for (let i = 0; i < poly.length; i++) {\n        total += poly[i];\n    }\n    return total / 2;\n}\n\n//# sourceMappingURL=area.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/area.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingBoxTight: () => (/* binding */ getBoundingBoxTight)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-bounding-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\n/* harmony import */ var _length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../length/control-point-lines-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\n\n\n\n/**\n * Returns a **non-certified**, **rotated**, **tight** bounding box of the given\n * bezier curve as four ordered points of a rotated rectangle (with each given\n * as `[x,y]`)\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getBoundingBoxTight(ps) {\n    const [xS, yS] = ps[0];\n    const [xE, yE] = ps[ps.length - 1];\n    let sinθ;\n    let cosθ;\n    // take care of the case the endpoints are close together\n    const len = (0,_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(ps);\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(ps[0], ps[ps.length - 1]) * 2 ** 8 < len * len) {\n        const [xE_, yE_] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, 0.5);\n        const hypotenuse = Math.sqrt((xE_ - xS) * (xE_ - xS) + (yE_ - yS) * (yE_ - yS));\n        sinθ = (yE_ - yS) / hypotenuse;\n        cosθ = (xE_ - xS) / hypotenuse;\n    }\n    else {\n        const hypotenuse = Math.sqrt((xE - xS) * (xE - xS) + (yE - yS) * (yE - yS));\n        sinθ = (yE - yS) / hypotenuse;\n        cosθ = (xE - xS) / hypotenuse;\n    }\n    const box = getNormalizedBoundingBox(ps, sinθ, cosθ);\n    const [[p0x, p0y], [p1x, p1y]] = box;\n    const axisAlignedBox = [\n        box[0], [p1x, p0y],\n        box[1], [p0x, p1y]\n    ];\n    const rotate_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.rotate)(sinθ, cosθ);\n    return axisAlignedBox.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.translate)(ps[0], rotate_(p)));\n}\n/**\n * Helper function. Returns the bounding box of the normalized (i.e. first point\n * moved to origin and rotated so that last point lies on x-axis) given cubic\n * bezier.\n *\n * * returns the bounding box in the form [[minX, minY], [maxX,maxY]\n *\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param sinθ - Sine of angle made by line from first bezier point to\n * last with x-axis.\n * @param cosθ - Cosine of angle made by line from first bezier point\n * to last with x-axis.\n *\n * @internal\n */\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\n    const vectorToOrigin = ps[0].map(x => -x);\n    const f = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.translate)(vectorToOrigin);\n    const boundingPs = ps.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.rotate)(-sinθ, cosθ, f(p)));\n    return (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__.getBoundingBox)(boundingPs);\n}\n\n//# sourceMappingURL=get-bounding-box-tight.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingBox: () => (/* binding */ getBoundingBox)\n/* harmony export */ });\n/* harmony import */ var _get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-x-bounds-tight.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js\");\n/* harmony import */ var _get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-y-bounds-tight.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js\");\n\n\n/**\n * Returns a tight axis-aligned bounding box of the given bezier curve.\n *\n * * **certified**: the box is guaranteed to engulf the given bezier curve.\n *\n * * returns the box in the form `[[minX, minY], [maxX, maxY]`\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getBoundingBox(ps) {\n    const xBounds = (0,_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_0__.getXBoundsTight)(ps);\n    const yBounds = (0,_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_1__.getYBoundsTight)(ps);\n    return [\n        [xBounds.minX.box[0][0], yBounds.minY.box[0][1]],\n        [xBounds.maxX.box[1][0], yBounds.maxY.box[1][1]]\n    ];\n}\n\n//# sourceMappingURL=get-bounding-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingHull: () => (/* binding */ getBoundingHull)\n/* harmony export */ });\n/* harmony import */ var flo_graham_scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-graham-scan */ \"./node_modules/flo-graham-scan/node/index.js\");\n\n/**\n * Finds the convex hull of the given set of 2d points using the\n * Graham Scan algorithm and returns the hull as an array of points.\n *\n * * see https://en.wikipedia.org/wiki/Graham_scan\n *\n * **exact**: this algorithm is robust via adaptive infinite precision floating\n * point arithmetic.\n *\n * @param ps a set of points, e.g. a bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param includeAllBoundaryPoints set this to `true` to if all boundary points\n * should be returned, even redundant ones; defaults to `false`\n *\n * @dox mdx\n */\nconst getBoundingHull = flo_graham_scan__WEBPACK_IMPORTED_MODULE_0__.grahamScan;\n\n//# sourceMappingURL=get-bounding-hull.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBounds: () => (/* binding */ getBounds)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\n\n\n/**\n * Returns an axis-aligned bounding box together with the `t` values where the\n * bounds on the bezier are reached.\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getBounds(ps) {\n    // Roots of derivative\n    const dxy = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    const rootsX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRoots)(dxy[0], 0, 1);\n    const rootsY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRoots)(dxy[1], 0, 1);\n    // Endpoints\n    rootsX.push(0, 1);\n    rootsY.push(0, 1);\n    let minX = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    let tMinX;\n    let tMaxX;\n    let tMinY;\n    let tMaxY;\n    // Test points\n    for (let i = 0; i < rootsX.length; i++) {\n        const t = rootsX[i];\n        const [x,] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\n        if (x < minX) {\n            minX = x;\n            tMinX = t;\n        }\n        if (x > maxX) {\n            maxX = x;\n            tMaxX = t;\n        }\n    }\n    for (let i = 0; i < rootsY.length; i++) {\n        const t = rootsY[i];\n        const [, y] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\n        if (y < minY) {\n            minY = y;\n            tMinY = t;\n        }\n        if (y > maxY) {\n            maxY = y;\n            tMaxY = t;\n        }\n    }\n    // `tMinX`, ... is guaranteed defined below - TS was (understandably) \n    // unable to follow the logic.\n    const ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n    const box = [[minX, minY], [maxX, maxY]];\n    return { ts, box };\n}\n\n//# sourceMappingURL=get-bounds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getControlPointBox: () => (/* binding */ getControlPointBox)\n/* harmony export */ });\n/**\n * Returns a tight axis-aligned bounding box of the given bezier curve's control\n * points. (Note that the box is not a tight bound of the bezier curve itself.)\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getControlPointBox(ps) {\n    let minX = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (const p of ps) {\n        const x = p[0];\n        const y = p[1];\n        if (x < minX) {\n            minX = x;\n        }\n        if (x > maxX) {\n            maxX = x;\n        }\n        if (y < minY) {\n            minY = y;\n        }\n        if (y > maxY) {\n            maxY = y;\n        }\n    }\n    return [[minX, minY], [maxX, maxY]];\n}\n\n//# sourceMappingURL=get-control-point-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIntervalBoxDd: () => (/* binding */ getIntervalBoxDd)\n/* harmony export */ });\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/eval-de-casteljau-error.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\n\nconst ddDiffDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\nconst ddDivDdWithError = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivDdWithError;\nconst ddAddDouble = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\nconst ddMultDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst ddAddDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst ddMultBy2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst ddMin = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMin;\nconst ddMax = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMax;\nconst u = Number.EPSILON / 2;\nconst uu = u * u;\nconst abs = Math.abs;\nconst qdq = ddDiffDd;\nconst qOne = [0, 1];\nconst qad = ddAddDouble;\nconst qaq = ddAddDd;\nconst qmq = ddMultDd;\nconst qmd = ddMultDouble2;\nconst qm2 = ddMultBy2;\nconst qDivQuadWithError = ddDivDdWithError;\nconst qMin = ddMin;\nconst qMax = ddMax;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns an axis-aligned-box that is guaranteed to engulf the entire\n * given bezier curve from `t1` to `t2`. The returned box is given as an array\n * of points in double-double precision, e.g. `[[[0,1],[0,1]], [[0,2],[0,2]]]`.\n *\n * * **precondition**: (to satisfy guarantee) t1 < t2\n * * **precondition**: (to satisfy guarantee) t1,t2 >= 0 && t1,t2 <= 1\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ts [first, second] parameter values, given in double-double\n * precision, e.g. [[0,0.11], [0,0.12]]. (Use [[getIntervalBox]] instead for\n * double precision)\n *\n * @doc mdx\n */\nfunction getIntervalBoxDd(ps, ts) {\n    if (ts[0][0] !== ts[1][0] || ts[0][1] !== ts[1][1]) {\n        if (ps.length === 4) {\n            return getIntervalBox3Dd(ps, ts);\n        }\n        if (ps.length === 3) {\n            return getIntervalBox2Dd(ps, ts);\n        }\n        return getIntervalBox1Dd(ps, ts);\n    }\n    else { // ts[0] === ts[1]\n        return getIntervalBoxAtTDd(ps, ts[0]);\n    }\n}\n/**\n * quad precision t1, t2\n *\n * @param param0\n * @param param1\n *\n * @internal\n */\nfunction getIntervalBox3Dd([[x0, y0], [x1, y1], [x2, y2], [x3, y3]], [t1, t2]) {\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\n    const tDel = qdq(t2, t1);\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\n    const oMt1 = qdq(qOne, t1);\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\n    const s1 = qdq(qOne, t1); // <1>s1\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\n    const tt1 = qmq(t1, t1); // <2>tt1  \n    const ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\n    const ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\n    const ttt1 = qmq(tt1, t1); // <4>(<2>tt1<0>t1)\n    const tts1 = qmq(tt1, s1); // <5>(<2>tt1<1>s1)\n    const tss1 = qmq(ss1, t1); // <6>(<4>ss1<0>t1)\n    const sss1 = qmq(ss1, s1); // <7>(<4>ss1<1>s1)\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\n    const tt2 = qmq(t2, t2); // <2>tt2\n    const ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\n    const ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\n    const ttt2 = qmq(tt2, t2); // <4>(<1>tt2<0>t2)\n    const tts2 = qmq(tt2, s2); // <5>(<1>tt2<1>s2)\n    const tss2 = qmq(ss2, t2); // <6>(<3>ss2<0>t2)\n    const sss2 = qmq(ss2, s2); // <7>(<3>ss2<1>s2)\n    const _t1 = abs(t1[1]);\n    const _s1 = abs(s1[1]);\n    const _tt1 = abs(tt1[1]);\n    const _ts1 = abs(ts1[1]);\n    const _ss1 = abs(ss1[1]);\n    const _ttt1 = abs(ttt1[1]);\n    const _tts1 = abs(tts1[1]);\n    const _tss1 = abs(tss1[1]);\n    const _sss1 = abs(sss1[1]);\n    const _t2 = abs(t2[1]);\n    const _s2 = abs(s2[1]);\n    const _tt2 = abs(tt2[1]);\n    const _ts2 = abs(ts2[1]);\n    const _ss2 = abs(ss2[1]);\n    const _ttt2 = abs(ttt2[1]);\n    const _tts2 = abs(tts2[1]);\n    const _tss2 = abs(tss2[1]);\n    const _sss2 = abs(sss2[1]);\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\n    // bound (using e.g. counters <k>):\n    // counter rules:\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   <k>a<l>b = <k + l + 1>ab\n    //   fl(a) === <1>a\n    let _x0 = abs(x0);\n    let _y0 = abs(y0);\n    let _x1 = abs(x1);\n    let _y1 = abs(y1);\n    let _x2 = abs(x2);\n    let _y2 = abs(y2);\n    let _x3 = abs(x3);\n    let _y3 = abs(y3);\n    //---- x - calculation\n    const q8 = qaq(qmd(x3, t1), qmd(x2, s1));\n    const q7 = qaq(qaq(qmd(x3, tt1), qmd(2 * x2, ts1)), qmd(x1, ss1));\n    const qx0 = qaq(qaq(qmd(x3, ttt1), qmd(x0, sss1)), qmd(3, (qaq(qmd(x2, tts1), qmd(x1, tss1)))));\n    const qx1 = qaq(qmq(q7, t2), qmq(qx0, s2));\n    const qx2 = qaq(qaq(qmq(q8, tt2), qmq(qx0, ss2)), qmq(qm2(q7), ts2));\n    const qx3 = qaq(qaq(qmd(x3, ttt2), qmq(qx0, sss2)), qmd(3, qaq(qmq(q8, tts2), qmq(q7, tss2))));\n    const _qx0 = abs(qx0[1]);\n    //---- error / abs value calculation\n    const _q8 = _x3 * _t1 + _x2 * _s1; // <= <3>\n    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))\n    const _q7 = _x3 * _tt1 + 2 * _x2 * _ts1 + _x1 * _ss1; // <= <6> \n    // q7: <6>(<5>(<3>(x3*<2>tt1) + <4>(2*x2*<3>ts1)) + <5>(x1*<4>ss1));\n    _x0 = (_x3 * _ttt1 + _x0 * _sss1) + 3 * (_x2 * _tts1 + _x1 * _tss1); // <= <11>\n    // x0: <11>(<9>(x3*<4>ttt1 + x0*<7>sss1) + <10>(3*<9>(<8>(<6>(x2*<5>tts1) + <7>(x1*<6>tss1)))));\n    _x1 = _q7 * _t2 + _qx0 * _s2; // <= <15>\n    // x1: <15>(<7>(<6>q7*t2) + <14>(<11>x0*<1>s2));\n    _x2 = _q8 * _tt2 + _qx0 * _ss2 + 2 * _q7 * _ts2; // <= <20>\n    // x2: <20>(<19>(<18>(<3>q8*<2>tt2) + <17>(<11>x0*<4>ss2)) + <11>(2*<6>q7*<3>ts2));\n    _x3 = _x3 * _ttt2 + _qx0 * _sss2 + 3 * (_q8 * _tts2 + _q7 * _tss2); // <= <22>\n    // x3: <22>(<21>(<5>(x3*<4>ttt2) + <20>(<11>x0*<7>sss2)) + <16>(3*<15>(<10>(<3>q8*<5>tts2) + <14>(<6>q7*<6>tss2)))));\n    // max errors: \n    _x0 = 11 * uu * _x0;\n    _x1 = 15 * uu * _x1;\n    _x2 = 20 * uu * _x2;\n    _x3 = 22 * uu * _x3;\n    //---- y - calculation\n    const r8 = qaq(qmd(y3, t1), qmd(y2, s1));\n    const r7 = qaq(qaq(qmd(y3, tt1), qmd(2 * y2, ts1)), qmd(y1, ss1));\n    const qy0 = qaq(qaq(qmd(y3, ttt1), qmd(y0, sss1)), qmd(3, (qaq(qmd(y2, tts1), qmd(y1, tss1)))));\n    const qy1 = qaq(qmq(r7, t2), qmq(qy0, s2));\n    const qy2 = qaq(qaq(qmq(r8, tt2), qmq(qy0, ss2)), qmq(qm2(r7), ts2));\n    const qy3 = qaq(qaq(qmd(y3, ttt2), qmq(qy0, sss2)), qmd(3, qaq(qmq(r8, tts2), qmq(r7, tss2))));\n    const _qy0 = abs(qy0[1]);\n    //---- error / abs value calculation\n    const _r8 = _y3 * _t1 + _y2 * _s1; // <= <3>\n    const _r7 = _y3 * _tt1 + 2 * _y2 * _ts1 + _y1 * _ss1; // <= <6> \n    _y0 = (_y3 * _ttt1 + _y0 * _sss1) + 3 * (_y2 * _tts1 + _y1 * _tss1); // <= <11>\n    _y1 = _r7 * _t2 + _qy0 * _s2; // <= <15>\n    _y2 = _r8 * _tt2 + _qy0 * _ss2 + 2 * _r7 * _ts2; // <= <20>\n    _y3 = _y3 * _ttt2 + _qy0 * _sss2 + 3 * (_r8 * _tts2 + _r7 * _tss2); // <= <22>\n    // max errors: \n    _y0 = 11 * uu * _y0;\n    _y1 = 15 * uu * _y1;\n    _y2 = 20 * uu * _y2;\n    _y3 = 22 * uu * _y3;\n    const minX = qMin(qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qMin(qad(qx2, -_x2), qad(qx3, -_x3)));\n    const maxX = qMax(qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qMax(qad(qx2, +_x2), qad(qx3, +_x3)));\n    const minY = qMin(qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qMin(qad(qy2, -_y2), qad(qy3, -_y3)));\n    const maxY = qMax(qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qMax(qad(qy2, +_y2), qad(qy3, +_y3)));\n    return [[minX, minY], [maxX, maxY]];\n}\n/**\n * quad precision t1, t2\n *\n * @param param0\n * @param param1\n *\n * @internal\n */\nfunction getIntervalBox2Dd([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\n    const tDel = qdq(t2, t1);\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\n    const oMt1 = qdq(qOne, t1);\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\n    //const s1 = (1 - t1);  // <= exact by precondition - not anymore\n    const s1 = qdq(qOne, t1); // <1>s1\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\n    const tt1 = qmq(t1, t1); // <2>tt1  \n    const ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\n    const ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\n    const tt2 = qmq(t2, t2); // <2>tt2\n    const ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\n    const ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\n    const _t1 = abs(t1[1]);\n    const _s1 = abs(s1[1]);\n    const _tt1 = abs(tt1[1]);\n    const _ts1 = abs(ts1[1]);\n    const _ss1 = abs(ss1[1]);\n    const _t2 = abs(t2[1]);\n    const _s2 = abs(s2[1]);\n    const _tt2 = abs(tt2[1]);\n    const _ts2 = abs(ts2[1]);\n    const _ss2 = abs(ss2[1]);\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\n    // bound (using e.g. counters <k>):\n    // counter rules:\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   <k>a<l>b = <k + l + 1>ab\n    //   fl(a) === <1>a\n    let _x0 = abs(x0);\n    let _y0 = abs(y0);\n    let _x1 = abs(x1);\n    let _y1 = abs(y1);\n    let _x2 = abs(x2);\n    let _y2 = abs(y2);\n    //---- x - calculation\n    const q1 = qaq(qaq(qmd(x2, tt1), qmd(2 * x1, ts1)), qmd(x0, ss1));\n    const q2 = qaq(qmd(x2, t1), qmd(x1, s1));\n    const qx0 = q1;\n    const qx1 = qaq(qmq(t2, q2), qmq(s2, q1));\n    const qx2 = qaq(qaq(qmd(x2, tt2), qmq(qm2(ts2), q2)), qmq(ss2, q1));\n    const _q1 = _x2 * _tt1 + 2 * _x1 * _ts1 + _x0 * _ss1; // <= <7>\n    // q1: <7>(<6>(<5>(x2*<2>tt1) + <4>(2*x1*<3>ts1)) + <5>(x0*<4>ss1));\n    const _q2 = _x2 * _t1 + _x1 * _s1; // <= <3>\n    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));\n    _x0 = _q1; // <= <7>\n    // x0: <7>q1;\n    _x1 = _t2 * _q2 + _s2 * _q1; // <= <11>\n    // x1: <11>(<5>(t2*<3>q2) + <10>(<1>s2*<7>q1));\n    _x2 = (_tt2 * x2 + 2 * _ts2 * _q2) + _ss2 * _q1; // <= <14>\n    // x2: <14>(<9>(<3>(<2>tt2*x2) + <8>(2*<3>ts2*<3>q2)) + <13>(<4>ss2*<7>q1));\n    // max errors: \n    _x0 = 7 * uu * _x0;\n    _x1 = 11 * uu * _x1;\n    _x2 = 14 * uu * _x2;\n    //---- y - calculation\n    const r1 = qaq(qaq(qmd(y2, tt1), qmd(2 * y1, ts1)), qmd(y0, ss1));\n    const r2 = qaq(qmd(y2, t1), qmd(y1, s1));\n    const qy0 = r1;\n    const qy1 = qaq(qmq(t2, r2), qmq(s2, r1));\n    const qy2 = qaq(qaq(qmd(y2, tt2), qmq(qm2(ts2), r2)), qmq(ss2, r1));\n    const _r1 = _y2 * _tt1 + 2 * _y1 * _ts1 + _y0 * _ss1; // <= <7>\n    // r1: <7>(<6>(<5>(y2*<2>tt1) + <4>(2*y1*<3>ts1)) + <5>(y0*<4>ss1));\n    const _r2 = _y2 * _t1 + _y1 * _s1; // <= <3>\n    // r2: <3>(<1>(y2*t1) + <2>(y1*<1>s1));\n    _y0 = _r1; // <= <7>\n    // y0: <7>r1;\n    _y1 = _t2 * _r2 + _s2 * _r1; // <= <11>\n    // y1: <11>(<5>(t2*<3>r2) + <10>(<1>s2*<7>r1));\n    _y2 = (_tt2 * y2 + 2 * _ts2 * _r2) + _ss2 * _r1; // <= <14>\n    // y2: <14>(<9>(<3>(<2>tt2*y2) + <8>(2*<3>ts2*<3>r2)) + <13>(<4>ss2*<7>r1));\n    // max errors: \n    _y0 = 7 * uu * _y0;\n    _y1 = 11 * uu * _y1;\n    _y2 = 14 * uu * _y2;\n    const minX = qMin(qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qad(qx2, -_x2));\n    const maxX = qMax(qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qad(qx2, +_x2));\n    const minY = qMin(qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qad(qy2, -_y2));\n    const maxY = qMax(qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qad(qy2, +_y2));\n    return [[minX, minY], [maxX, maxY]];\n}\n/**\n * quad precision t1, t2\n *\n * @param param0\n * @param param1\n *\n * @internal\n */\nfunction getIntervalBox1Dd([[x0, y0], [x1, y1]], [t1, t2]) {\n    // Implementation for lines kept for symmetry - there are obviously much\n    // simpler ways to calculate the required box in the case of a line.\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\n    const tDel = qdq(t2, t1);\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\n    const oMt1 = qdq(qOne, t1);\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\n    const s1 = qdq(qOne, t1); // <1>s1\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\n    const _t1 = abs(t1[1]);\n    const _s1 = abs(s1[1]);\n    const _t2 = abs(t2[1]);\n    const _s2 = abs(s2[1]);\n    // counter rules:\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   <k>a<l>b = <k + l + 1>ab\n    //   fl(a) === <1>a\n    let _x0 = abs(x0);\n    let _y0 = abs(y0);\n    let _x1 = abs(x1);\n    let _y1 = abs(y1);\n    //---- x - calculation\n    const qx0 = qaq(qmd(x1, t1), qmd(x0, s1));\n    const qx1 = qaq(qmd(x1, t2), qmq(qx0, s2));\n    _x0 = _x1 * _t1 + _x0 * _s1; // <= <3>\n    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));\n    _x1 = _x1 * _t2 + _x0 * _s2; // <= <7>\n    // x1: <7>(<1>(x1*t2) + <6>(<3>x0*<1>s2));\n    // max errors: \n    _x0 = 3 * u * _x0;\n    _x1 = 7 * u * _x1;\n    //---- y - calculation\n    const qy0 = qaq(qmd(y1, t1), qmd(y0, s1));\n    const qy1 = qaq(qmd(y1, t2), qmq(qy0, s2));\n    _y0 = _y1 * _t1 + _y0 * _s1; // <= <3>\n    _y1 = _y1 * _t2 + _y0 * _s2; // <= <7>\n    // max errors: \n    _y0 = 3 * u * _y0;\n    _y1 = 7 * u * _y1;\n    const minX = qMin(qad(qx0, -_x0), qad(qx1, -_x1));\n    const maxX = qMax(qad(qx0, +_x0), qad(qx1, +_x1));\n    const minY = qMin(qad(qy0, -_y0), qad(qy1, -_y1));\n    const maxY = qMax(qad(qy0, +_y0), qad(qy1, +_y1));\n    //return [[x0,y0],[x1,y1]];\n    return [[minX, minY], [maxX, maxY]];\n}\n/**\n * quad precision t1, t2\n *\n * @param ps\n * @param t\n *\n * @internal\n */\nfunction getIntervalBoxAtTDd(ps, t) {\n    const _pS = ps[0];\n    const _pE = ps[ps.length - 1];\n    if (t[0] === 0 && t[1] === 0) {\n        const pSx = [0, _pS[0]];\n        const pSy = [0, _pS[1]];\n        return [\n            [pSx, pSy],\n            [pSx, pSy]\n        ];\n    }\n    else if (t[0] === 0 && t[1] === 1) {\n        const pEx = [0, _pE[0]];\n        const pEy = [0, _pE[1]];\n        return [\n            [pEx, pEy],\n            [pEx, pEy]\n        ];\n    }\n    const p = (0,_local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljauDd)(ps, t);\n    let pE;\n    if (ps.length === 4) {\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljauError)(ps, t).map(c_ => 8 * 2 * γγ3 * c_);\n    }\n    else if (ps.length === 3) {\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljauError)(ps, t).map(c_ => 5 * 2 * γγ3 * c_);\n    }\n    else if (ps.length === 2) {\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljauError)(ps, t).map(c_ => 2 * 2 * γγ3 * c_);\n    }\n    else if (ps.length === 1) {\n        return [p, p];\n    }\n    return [\n        [qad(p[0], -pE[0]), qad(p[1], -pE[1])],\n        [qad(p[0], +pE[0]), qad(p[1], +pE[1])]\n    ];\n}\n\n//# sourceMappingURL=get-interval-box-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIntervalBox: () => (/* binding */ getIntervalBox)\n/* harmony export */ });\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/eval-de-casteljau-error.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-3-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-2-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-1-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js\");\n\n\n\n\n\n\nconst eps = Number.EPSILON;\nconst u = eps / 2;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γ\"])(1);\n/**\n * Returns an axis-aligned-box that is guaranteed to engulf the entire\n * given bezier curve from t1 to t2. The returned box is given as a pair\n * of points (the box corners) in double precision, e.g. `[[1,1], [2,2]]`.\n *\n * * **precondition:** (to satisfy guarantee) t1 < t2\n * * **precondition:** (to satisfy guarantee) t1,t2 >= 0 && t1,t2 <= 1\n *\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ts [first, second] parameter values, e.g. [0.11, 0.12]\n *\n * @doc mdx\n */\nfunction getIntervalBox(ps, ts) {\n    if (ts[0] !== ts[1]) {\n        if (ps.length === 4) {\n            return getIntervalBox3(ps, ts);\n        }\n        if (ps.length === 3) {\n            return getIntervalBox2(ps, ts);\n        }\n        return getIntervalBox1(ps, ts);\n    }\n    // ts[0] === ts[1]\n    return getIntervalBoxAtT(ps, ts[0]);\n}\n/**\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\n * bezier curve from t1 to t2.\n *\n * This is achieved by calculating the error bounds of a new curve calculated\n * form t1 to t2 using a splitting algorithm and then taking its extreme\n * control points and finally finding a box that engulfs the control points.\n * @internal\n *\n * @param ps\n * @param ts\n */\nfunction getIntervalBox3(ps, ts) {\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__.fromTo3InclErrorBound)(ps, ts[0], ts[1]);\n    const x0 = psI[0][0];\n    const x1 = psI[1][0];\n    const x2 = psI[2][0];\n    const x3 = psI[3][0];\n    const _x0 = 9 * u * _psI[0][0];\n    const _x1 = 9 * u * _psI[1][0];\n    const _x2 = 9 * u * _psI[2][0];\n    const _x3 = 9 * u * _psI[3][0];\n    const y0 = psI[0][1];\n    const y1 = psI[1][1];\n    const y2 = psI[2][1];\n    const y3 = psI[3][1];\n    const _y0 = 9 * u * _psI[0][1];\n    const _y1 = 9 * u * _psI[1][1];\n    const _y2 = 9 * u * _psI[2][1];\n    const _y3 = 9 * u * _psI[3][1];\n    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2, x3 - _x3);\n    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2, x3 + _x3);\n    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2, y3 - _y3);\n    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2, y3 + _y3);\n    return [[minX, minY], [maxX, maxY]];\n}\n/**\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\n * bezier curve from t1 to t2.\n *\n * This is achievied by calculating the error bounds of a new curve calculated\n * form t1 to t2 using a splitting algorithm and then taking its extreme\n * control points and finally finding a box that engulfs the control points\n *\n * @param param0\n * @param param1\n *\n * @internal\n */\nfunction getIntervalBox2(ps, ts) {\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo2InclErrorBound)(ps, ts[0], ts[1]);\n    const x0 = psI[0][0];\n    const x1 = psI[1][0];\n    const x2 = psI[2][0];\n    const _x0 = 5 * u * _psI[0][0];\n    const _x1 = 5 * u * _psI[1][0];\n    const _x2 = 5 * u * _psI[2][0];\n    const y0 = psI[0][1];\n    const y1 = psI[1][1];\n    const y2 = psI[2][1];\n    const _y0 = 5 * u * _psI[0][1];\n    const _y1 = 5 * u * _psI[1][1];\n    const _y2 = 5 * u * _psI[2][1];\n    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2);\n    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2);\n    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2);\n    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2);\n    return [[minX, minY], [maxX, maxY]];\n}\n/**\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\n * bezier curve from t1 to t2.\n *\n * This is achievied by calculating the error bounds of a new curve calculated\n * form t1 to t2 using a splitting algorithm and then taking its extreme\n * control points and finally finding a box that engulfs the control points\n *\n * @param param0\n * @param param1\n *\n * @internal\n */\nfunction getIntervalBox1(ps, ts) {\n    // Implementation for lines kept for symmetry - there are obviously much\n    // simpler ways to calculate the required box in the case of a line.\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__.fromTo1InclErrorBound)(ps, ts[0], ts[1]);\n    const x0 = psI[0][0];\n    const x1 = psI[1][0];\n    const _x0 = 3 * u * _psI[0][0];\n    const _x1 = 3 * u * _psI[1][0];\n    const y0 = psI[0][1];\n    const y1 = psI[1][1];\n    const _y0 = 3 * u * _psI[0][1];\n    const _y1 = 3 * u * _psI[1][1];\n    const minX = Math.min(x0 - _x0, x1 - _x1);\n    const maxX = Math.max(x0 + _x0, x1 + _x1);\n    const minY = Math.min(y0 - _y0, y1 - _y1);\n    const maxY = Math.max(y0 + _y0, y1 + _y1);\n    return [[minX, minY], [maxX, maxY]];\n}\n/**\n * @param ps\n * @param t\n *\n * @internal\n */\nfunction getIntervalBoxAtT(ps, t) {\n    const _pS = ps[0];\n    const _pE = ps[ps.length - 1];\n    if (t === 0) {\n        return [_pS, _pS];\n    }\n    else if (t === 1) {\n        return [_pE, _pE];\n    }\n    const p = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_4__.evalDeCasteljau)(ps, t);\n    let pE;\n    if (ps.length === 4) {\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 8 * γ1 * c_);\n    }\n    else if (ps.length === 3) {\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 5 * γ1 * c_);\n    }\n    else if (ps.length === 2) {\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 2 * γ1 * c_);\n    }\n    else if (ps.length === 1) {\n        return [p, p];\n    }\n    return [\n        [p[0] - pE[0], p[1] - pE[1]],\n        [p[0] + pE[0], p[1] + pE[1]]\n    ];\n}\n\n// 416\n//# sourceMappingURL=get-interval-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getXBoundsTight: () => (/* binding */ getXBoundsTight)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n\n\n\n/**\n * Returns tight x-coordinate bounds of the given bezier curve.\n *\n * @param ps an order 1, 2 or 3 bezier curve given as an array of control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getXBoundsTight(ps) {\n    const pS = ps[0];\n    const pE = ps[ps.length - 1];\n    let minX;\n    let maxX;\n    if (pS[0] < pE[0]) {\n        minX = { ts: [0, 0], box: [pS, pS] };\n        maxX = { ts: [1, 1], box: [pE, pE] };\n    }\n    else {\n        minX = { ts: [1, 1], box: [pE, pE] };\n        maxX = { ts: [0, 0], box: [pS, pS] };\n    }\n    if (ps.length === 2) {\n        return { minX, maxX };\n    }\n    const [dx,] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    const rootsX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertifiedSimplified)(dx, 0, 1);\n    // Test points\n    for (let i = 0; i < rootsX.length; i++) {\n        const r = rootsX[i];\n        const ts = [r.tS, r.tE];\n        const box = (0,_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, ts);\n        if (box[0][0] < minX.box[0][0]) {\n            minX = { ts, box };\n        }\n        if (box[1][0] > maxX.box[0][0]) {\n            maxX = { ts, box };\n        }\n    }\n    return { minX, maxX };\n}\n\n//# sourceMappingURL=get-x-bounds-tight.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getYBoundsTight: () => (/* binding */ getYBoundsTight)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n\n\n\n/**\n * Returns tight y-coordinate bounds of the given bezier curve.\n *\n * @param ps an order 1, 2 or 3 bezier curve given as an array of control\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getYBoundsTight(ps) {\n    const pS = ps[0];\n    const pE = ps[ps.length - 1];\n    let minY;\n    let maxY;\n    if (pS[1] < pE[1]) {\n        minY = { ts: [0, 0], box: [pS, pS] };\n        maxY = { ts: [1, 1], box: [pE, pE] };\n    }\n    else {\n        minY = { ts: [1, 1], box: [pE, pE] };\n        maxY = { ts: [0, 0], box: [pS, pS] };\n    }\n    if (ps.length === 2) {\n        return { minY, maxY };\n    }\n    const [, dy] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    const rootsY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertifiedSimplified)(dy, 0, 1);\n    // Test points\n    for (let i = 0; i < rootsY.length; i++) {\n        const r = rootsY[i];\n        const ts = [r.tS, r.tE];\n        const box = (0,_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, ts);\n        if (box[0][1] < minY.box[0][1]) {\n            minY = { ts, box };\n        }\n        if (box[1][1] > maxY.box[0][1]) {\n            maxY = { ts, box };\n        }\n    }\n    return { minY, maxY };\n}\n\n//# sourceMappingURL=get-y-bounds-tight.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/classify.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/classify.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classification: () => (/* binding */ classification),\n/* harmony export */   classifications: () => (/* binding */ classifications),\n/* harmony export */   classify: () => (/* binding */ classify)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _is_really_point_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./is-really-point.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js\");\n/* harmony import */ var _is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./is-quad-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js\");\n/* harmony import */ var _is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./is-cubic-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js\");\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _intersection_self_intersection_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../intersection//self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js\");\n/* harmony import */ var _intersection_self_intersection_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js\");\n\n\n\n\n\n\n\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst { eSign, eCompare } = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.operators;\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion2;\nconst td = double_double__WEBPACK_IMPORTED_MODULE_4__.twoDiff;\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_4__.twoSum;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.growExpansion;\nconst abs = Math.abs;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_7__[\"γ\"])(1);\n// The classifications form an equivalence class, in other words *all* \n// possible planar polynomial bezier curves (of order <= 3) are represented and \n// all options are mutually exclusive.\nconst point = { order: 0, realOrder: 0, collinear: true, nodeType: 'n/a' };\nconst lineGeneral = { order: 1, realOrder: 1, collinear: true, nodeType: 'n/a' };\nconst lineDegenPoint = { order: 1, realOrder: 0, collinear: true, nodeType: 'n/a' };\nconst quadGeneral = { order: 2, realOrder: 2, collinear: false, nodeType: 'n/a' };\n/** The curve is collinear but not a line (i.e. evaluating at `t` values won't correspond to same points) */\nconst quadDegenCollinear = { order: 2, realOrder: 2, collinear: true, nodeType: 'n/a' };\nconst quadDegenLine = { order: 2, realOrder: 1, collinear: true, nodeType: 'n/a' };\nconst quadDegenPoint = { order: 2, realOrder: 0, collinear: true, nodeType: 'n/a' };\nconst cubicGeneralCrunode = { order: 3, realOrder: 3, collinear: false, nodeType: 'crunode' };\nconst cubicGeneralAcnode = { order: 3, realOrder: 3, collinear: false, nodeType: 'acnode' };\nconst cubicGeneralCusp = { order: 3, realOrder: 3, collinear: false, nodeType: 'cusp' };\nconst cubicGeneralExplicit = { order: 3, realOrder: 3, collinear: false, nodeType: 'explicit' };\nconst cubicDegenCollinearCubic = { order: 3, realOrder: 3, collinear: true, nodeType: 'n/a' };\nconst cubicDegenQuad = { order: 3, realOrder: 2, collinear: false, nodeType: 'n/a' };\nconst cubicDegenCollinearQuad = { order: 3, realOrder: 2, collinear: true, nodeType: 'n/a' };\nconst cubicDegenLine = { order: 3, realOrder: 1, collinear: true, nodeType: 'n/a' };\nconst cubicDegenPoint = { order: 3, realOrder: 0, collinear: true, nodeType: 'n/a' };\n/**\n * The classifications form an equivalence class, in other words *all*\n * possible planar polynomial bezier curves (of order <= 3) are represented and\n * all options are mutually exclusive.\n */\nconst classifications = {\n    point,\n    lineGeneral,\n    lineDegenPoint,\n    quadGeneral,\n    quadDegenCollinear,\n    quadDegenLine,\n    quadDegenPoint,\n    cubicGeneralCrunode,\n    cubicGeneralAcnode,\n    cubicGeneralCusp,\n    cubicGeneralExplicit,\n    cubicDegenCollinearCubic,\n    cubicDegenQuad,\n    cubicDegenCollinearQuad,\n    cubicDegenLine,\n    cubicDegenPoint\n};\nfunction isPoint(ps) {\n    return classify(ps) === point;\n}\nfunction isLineGeneral(ps) {\n    return classify(ps) === lineGeneral;\n}\nfunction isLineDegenPoint(ps) {\n    return classify(ps) === lineDegenPoint;\n}\nfunction isQuadGeneral(ps) {\n    return classify(ps) === quadGeneral;\n}\nfunction isQuadDegenCollinear(ps) {\n    return classify(ps) === quadDegenCollinear;\n}\nfunction isQuadDegenLine(ps) {\n    return classify(ps) === quadDegenLine;\n}\nfunction isQuadDegenPoint(ps) {\n    return classify(ps) === quadDegenPoint;\n}\nfunction isCubicGeneralCrunode(ps) {\n    return classify(ps) === cubicGeneralCrunode;\n}\nfunction isCubicGeneralAcnode(ps) {\n    return classify(ps) === cubicGeneralAcnode;\n}\nfunction isCubicGeneralCusp(ps) {\n    return classify(ps) === cubicGeneralCusp;\n}\nfunction isCubicGeneralExplicit(ps) {\n    return classify(ps) === cubicGeneralExplicit;\n}\nfunction isCubicDegenCollinearCubic(ps) {\n    return classify(ps) === cubicDegenCollinearCubic;\n}\nfunction isCubicDegenQuad(ps) {\n    return classify(ps) === cubicDegenQuad;\n}\nfunction isCubicDegenCollinearQuad(ps) {\n    return classify(ps) === cubicDegenCollinearQuad;\n}\nfunction isCubicDegenLine(ps) {\n    return classify(ps) === cubicDegenLine;\n}\nfunction isCubicDegenPoint(ps) {\n    return classify(ps) === cubicDegenPoint;\n}\nconst classification = {\n    isPoint,\n    isLineGeneral,\n    isLineDegenPoint,\n    isQuadGeneral,\n    isQuadDegenCollinear,\n    isQuadDegenLine,\n    isQuadDegenPoint,\n    isCubicGeneralCrunode,\n    isCubicGeneralAcnode,\n    isCubicGeneralCusp,\n    isCubicGeneralExplicit,\n    isCubicDegenCollinearCubic,\n    isCubicDegenQuad,\n    isCubicDegenCollinearQuad,\n    isCubicDegenLine,\n    isCubicDegenPoint,\n};\n/**\n * Returns a classification of the given bezier curve.\n *\n * * **exact**: not susceptible to floating point round-off\n *\n * @param ps a bezier curve of order 0,1,2 or 3 given as an array of its\n * control points.\n *\n * @doc mdx\n */\nfunction classify(ps) {\n    if (ps.length === 4) {\n        if ((0,_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_8__.isCubicReallyQuad)(ps)) {\n            return (0,_is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_9__.isCubicReallyLine)(ps)\n                ? (0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_10__.isReallyPoint)(ps) ? cubicDegenPoint : cubicDegenLine\n                : (0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_11__.isCollinear)(ps) ? cubicDegenCollinearQuad : cubicDegenQuad;\n        }\n        return (0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_11__.isCollinear)(ps)\n            ? cubicDegenCollinearCubic\n            : classifyGeneralCubic(ps);\n    }\n    if (ps.length === 3) {\n        return (0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_11__.isCollinear)(ps)\n            ? (0,_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_12__.isQuadReallyLine)(ps)\n                ? (0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_10__.isReallyPoint)(ps) ? quadDegenPoint : quadDegenLine\n                : quadDegenCollinear\n            : quadGeneral;\n    }\n    if (ps.length === 2) {\n        return (0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_10__.isReallyPoint)(ps) ? lineDegenPoint : lineGeneral;\n    }\n    if (ps.length === 1) {\n        return point;\n    }\n    throw new Error('The given bezier curve must be of order <= 3');\n}\n/**\n * Return a complete classification of the given *general* cubic bezier curve as\n * either having an `acnode`, `crunode`, `cusp` or being an `explicit` curve.\n *\n * * **precondition**: the given bezier curve is a 'general' cubic, i.e. not all\n * points collinear and not degenerate to a quadratic curve, line or point.\n *\n * @param ps\n */\nfunction classifyGeneralCubic(ps) {\n    // First get fast naively calculated coefficients for self-intersection\n    const { coeffs: [a, b, c], errBound: [a_, b_, c_] } = (0,_intersection_self_intersection_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_13__.getCoeffsBez3WithRunningError)(ps);\n    // if error in `a` cannot discern it from zero\n    if (abs(a) <= a_) {\n        // it is rare to get here \n        // check for sure if a === 0 exactly\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        //const a3 = (x3 - x0) + 3*(x1 - x2);\n        //const a2 = (x2 + x0) - 2*x1;\n        //const b3 = (y3 - y0) + 3*(y1 - y2);\n        //const b2 = (y2 + y0) - 2*y1;\n        const a3 = fes(td(x3, x0), sce(3, (td(x1, x2))));\n        const a2 = ge(ts(x2, x0), -2 * x1);\n        const b3 = fes(td(y3, y0), sce(3, (td(y1, y2))));\n        const b2 = ge(ts(y2, y0), -2 * y1);\n        const a2b3 = epr(a2, b3);\n        const a3b2 = epr(a3, b2);\n        if (eCompare(a2b3, a3b2) === 0) {\n            // a === 0 => no roots possible! (also b === 0)\n            return cubicGeneralExplicit;\n        }\n    }\n    // `Discr` = discriminant = b^2 - 4ac\n    // calculate `Discr` and its absolute error Discr_\n    const bb = b * b;\n    const bb_ = 2 * b_ * abs(b) + γ1 * bb; // the error in b**2\n    const ac4 = 4 * a * c;\n    const ac4_ = 4 * (a_ * abs(c) + abs(a) * c_) + γ1 * abs(ac4);\n    const Discr = bb - ac4;\n    const Discr_ = bb_ + ac4_ + γ1 * abs(Discr);\n    // if the discriminant is smaller than negative the error bound then\n    // certainly there are no roots, i.e. no cusp and no self-intersections\n    if (Discr < -Discr_) {\n        // discriminant is definitely negative\n        return cubicGeneralAcnode;\n    }\n    // if the discriminant is definitely positive\n    if (Discr > Discr_) {\n        // calculate roots naively as a fast pre-filter\n        return cubicGeneralCrunode;\n    }\n    // we need to check exactly - (a !== 0) at this point - tested for earlier\n    const [A, B, C] = (0,_intersection_self_intersection_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_14__.getCoeffsBez3Exact)(ps);\n    // exact - Discr = b^2 - 4ac\n    const eDiscr = edif(epr(B, B), sce(4, epr(A, C)));\n    const sgnDiscr = eSign(eDiscr);\n    return sgnDiscr < 0\n        ? cubicGeneralAcnode\n        : sgnDiscr > 0\n            ? cubicGeneralCrunode\n            : cubicGeneralCusp;\n}\n\n//# sourceMappingURL=classify.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/classify.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCollinear: () => (/* binding */ isCollinear),\n/* harmony export */   isHorizontal: () => (/* binding */ isHorizontal),\n/* harmony export */   isVertical: () => (/* binding */ isVertical)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\nconst { orient2d } = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.operators;\n/**\n * Returns `true` if the given bezier curve has all control points collinear,\n * `false` otherwise.\n *\n * * if you need to know whether a given bezier curve can be converted to an\n * order 1 bezier curve (a line) such that the same `(x,y)` point is returned\n * for the same `t` value then use e.g. [[isQuadReallyLine]] instead.\n *\n * * **exact** not susceptible to floating point round-off\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction isCollinear(ps) {\n    if (ps.length === 4) {\n        // Cubic bezier\n        return (orient2d(ps[0], ps[1], ps[2]) === 0 &&\n            orient2d(ps[1], ps[2], ps[3]) === 0 &&\n            // The below check is necessary for if ps[1] === ps[2]\n            orient2d(ps[0], ps[2], ps[3]) === 0);\n    }\n    if (ps.length === 3) {\n        // Quadratic bezier\n        return orient2d(ps[0], ps[1], ps[2]) === 0;\n    }\n    if (ps.length <= 2) {\n        // Line (or point)\n        return true;\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/**\n * Returns `true` if the given bezier curve has all control points the\n * same `y` value (possibly self-overlapping), `false` otherwise.\n *\n * @param ps An order 0, 1, 2 or 3 bezier curve.\n *\n * @doc\n */\nfunction isHorizontal(ps) {\n    const y = ps[0][1];\n    for (let i = 1; i < ps.length; i++) {\n        if (ps[i][1] !== y) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns `true` if the given bezier curve has all control points the\n * same `x` value (possibly self-overlapping), `false` otherwise.\n *\n * @param ps An order 0, 1, 2 or 3 bezier curve.\n *\n * @doc\n */\nfunction isVertical(ps) {\n    const x = ps[0][0];\n    for (let i = 1; i < ps.length; i++) {\n        if (ps[i][0] !== x) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=is-collinear.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCubicReallyLine: () => (/* binding */ isCubicReallyLine)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoSum;\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\n/**\n * Returns `true` if the given bezier curve has all control points collinear\n * *and* it can be converted to an order 1 bezier curve (a line) such that the\n * same `(x,y)` point is returned for the same `t` value, `false` otherwise.\n *\n * * **exact**: not susceptible to floating point round-off\n *\n * @param ps a cubic bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction isCubicReallyLine(ps) {\n    // note: if cubic is really a quad then\n    // x3 + 3*(x1 - x2) === x0 && \n    // y3 + 3*(y1 - y2) === y0\n    if (!(0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_4__.isCollinear)(ps)) {\n        return false;\n    }\n    const [p0, p1, p2, p3] = ps;\n    const [x0, y0] = p0;\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    const [x3, y3] = p3;\n    // convert middle two control points to single quad point\n    // [\n    //   (3*(x1 + x2) - (x0 + x3)) / 4, \n    //   (3*(y1 + y2) - (y0 + y3)) / 4\n    // ]\n    const qx1 = ediff(sce(ts(x1 / 4, x2 / 4), 3), ts(x0 / 4, x3 / 4));\n    const qy1 = ediff(sce(ts(y1 / 4, y2 / 4), 3), ts(y0 / 4, y3 / 4));\n    // is quad really line:\n    //   if (x0 + x2 === 2*x1) && (y0 + y2 === 2*y1) OR\n    //   if ((x0 + x2)/2 === x1) && ((y0 + y2)/2 === y1)\n    return (esign(ediff(ts(x0 / 2, x3 / 2), qx1)) === 0 &&\n        esign(ediff(ts(y0 / 2, y3 / 2), qy1)) === 0);\n}\n\n//# sourceMappingURL=is-cubic-really-line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCubicReallyQuad: () => (/* binding */ isCubicReallyQuad)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eDiff;\nconst u = Number.EPSILON / 2;\nconst abs = Math.abs;\n/**\n * Returns `true` if the given cubic bezier curve is really a quadratic (or\n * lower order) curve in disguise, i.e. it can be represent by a quadratic\n * bezier curve, `false` otherwise.\n *\n * * **exact**: not susceptible to floating point round-off\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction isCubicReallyQuad(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // The line below is unrolled (uses a toHybridQuadratic condition (points same?))\n    //if ((x3 + 3*x1) - (x0 + 3*x2) === 0 && \n    //    (y3 + 3*y1) - (y0 + 3*y2) === 0) {\n    // Calculate an approximation of the above with error bounds and use it as\n    // a fast filter.\n    const u1 = 3 * x1;\n    const u1_ = abs(3 * x1); // the absolute error in u1\n    const u2 = x3 + u1;\n    const u2_ = u1_ + abs(u2); // the absolute error in u2\n    const v1 = 3 * x2;\n    const v1_ = abs(3 * x2); // the absolute error in v1\n    const v2 = x0 + v1;\n    const v2_ = v1_ + abs(v2); // the absolute error in v2\n    const w = u2 - v2;\n    const w_ = u2_ + v2_ + abs(w); // the absolute error in w\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\n    if (abs(w) - u * w_ > 0) {\n        // fast filter 1 passed\n        return false;\n    }\n    const q1 = 3 * y1;\n    const q1_ = abs(3 * y1); // the absolute error in q1\n    const q2 = y3 + q1;\n    const q2_ = q1_ + abs(q2); // the absolute error in q2\n    const r1 = 3 * y2;\n    const r1_ = abs(3 * y2); // the absolute error in r1\n    const r2 = y0 + r1;\n    const r2_ = r1_ + abs(r2); // the absolute error in r2\n    const s = q2 - r2;\n    const s_ = q2_ + r2_ + abs(s); // the absolute error in s\n    if (abs(s) - u * s_ > 0) {\n        // fast filter 2 passed\n        return false;\n    }\n    // unable to filter - go slow and exact\n    return (esign(ediff(fes([x3], tp(3, x1)), fes([x0], tp(3, x2)))) === 0 &&\n        esign(ediff(fes([y3], tp(3, y1)), fes([y0], tp(3, y2)))) === 0);\n}\n\n//# sourceMappingURL=is-cubic-really-quad.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isQuadFlat: () => (/* binding */ isQuadFlat)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var _is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-quad-obtuse.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\n\n\nconst { max, abs } = Math;\n/**\n * Returns `true` if the given quadratic bezier curve is acute (see `isQuadObtuse`)\n * and can be approximated with a line segment with maximum Hausdorff distance\n * <= the given tolerance, `false` otherwise.\n *\n * @param ps a quadratic bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6]]`\n * @param tolerance a maximum Hausdorff distance tolerance; defaults to `2**-10`\n * of the maximum coordinate of the given bezier curve\n *\n * @internal\n */\nfunction isQuadFlat(ps, tolerance) {\n    if ((0,_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_0__.isQuadObtuse)(ps)) {\n        return false;\n    }\n    const [p0, p1, p2] = ps;\n    const [x0, y0] = p0;\n    const [x2, y2] = p2;\n    if (tolerance === undefined) {\n        const [x1, y1] = p1;\n        const maxCoordinate = max(abs(x0), abs(y0), abs(x1), abs(y1), abs(x2), abs(y2));\n        tolerance = maxCoordinate * 2 ** -10;\n    }\n    if (x0 === x2 && y0 === y2) {\n        const d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p0, p1) / 4;\n        return d <= tolerance ** 2;\n    }\n    const [x, y] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, 0.5);\n    const numerator = ((y2 - y0) * x - (x2 - x0) * y + x2 * y0 - y2 * x0) ** 2;\n    const denominator = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p0, p2);\n    const dSquared = numerator / denominator;\n    return dSquared <= tolerance ** 2;\n}\n\n//# sourceMappingURL=is-quad-flat.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isQuadObtuse: () => (/* binding */ isQuadObtuse)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n\n/**\n * Returns `true` if the given quadratic bezier is obtuse, `false` otherwise (i.e.\n * `false` if acute).\n *\n * Obtuse here is defined as follows: let the quad form a triangle through its\n * control points P0, P1, P2 where P0 and P2 are the endpoints. If both interior\n * angles ∠P0 and ∠P2 are <= 90 degrees then the quad is considered acute,\n * otherwise it is considered obtuse.\n *\n * @doc mdx\n */\nfunction isQuadObtuse(ps) {\n    const v0 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[0], ps[1]);\n    const v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[1], ps[2]);\n    const v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[2], ps[0]);\n    const angleP0Obtuse = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.dot)(v2, v0) > 0;\n    const angleP2Obtuse = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.dot)(v1, v2) > 0;\n    return angleP0Obtuse || angleP2Obtuse;\n}\n\n//# sourceMappingURL=is-quad-obtuse.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isQuadReallyLine: () => (/* binding */ isQuadReallyLine)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign;\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoSum;\nconst { abs } = Math;\n/**\n * Returns `true` if the given quadratic bezier curve is really a linear curve\n * (or a point), i.e. if all control points collinear *and* it can be converted\n * to an order 1 bezier curve (a line) such that the\n * same `(x,y)` point is returned for the same `t` value, `false` otherwise.\n *\n * * the required condition is met if: `x0 + x2 = 2*x1` and `y0 + y2 = 2*y1`\n * * **exact**: not susceptible to floating point round-off\n *\n * @param ps a quadratic bezier curve given as an array of its control\n * points, e.g. `[[1,2],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction isQuadReallyLine(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    //if (x0 + x2 === 2*x1) && (y0 + y2 === 2*y1)\n    // Calculate an approximation of the above with error bounds and use it as\n    // a fast filter.\n    const q = x0 + x2;\n    const _q_ = abs(q); // the absolute error bound in q (after multipliciation by `u`)\n    const w = q - 2 * x1;\n    const w_ = _q_ + abs(w); // the absolute error bound in w\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\n    if (abs(w) - w_ > 0) {\n        // fast filter passed\n        return false;\n    }\n    const r = y0 + y2;\n    const _r_ = abs(r); // the absolute error bound in r (after multipliciation by `u`)\n    const z = r - 2 * y1;\n    const z_ = _r_ + abs(z); // the absolute error bound in w\n    // if the error is smaller than the value\n    if (abs(z) - z_ > 0) {\n        // fast filter passed\n        return false;\n    }\n    // unable to filter - go slow and exact\n    return (esign(ediff(ts(x0, x2), [2 * x1])) === 0 &&\n        esign(ediff(ts(y0, y2), [2 * y1])) === 0);\n}\n\n//# sourceMappingURL=is-quad-really-line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isReallyPoint: () => (/* binding */ isReallyPoint)\n/* harmony export */ });\n/**\n * Returns `true` if the given bezier curve has all control points coincident,\n * `false` otherwise.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction isReallyPoint(ps) {\n    const x = ps[0][0];\n    const y = ps[0][1];\n    for (let i = 1; i < ps.length; i++) {\n        if (x !== ps[i][0] || y !== ps[i][1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=is-really-point.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSelfOverlapping: () => (/* binding */ isSelfOverlapping)\n/* harmony export */ });\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n\n/**\n * Returns `true` if the given bezier has all control points collinear and\n * it is self-overlapping, i.e. if it intersects itself at an infinite number\n * of points.\n *\n * * a bezier curve can only intersect itself at an infinite number of\n * points if its locus is a 'self-overlapping line'.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction isSelfOverlapping(ps) {\n    if (!(0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\n        return false;\n    }\n    // Check if control points are non-strict monotone\n    const xs = ps.map(p => p[0]);\n    const ys = ps.map(p => p[1]);\n    return !(isMonotone(xs) && isMonotone(ys));\n}\n/**\n * Returns true if the given array of numbers are non-strict monotone increasing.\n * @param xs an array of numbers\n *\n * @internal\n */\nfunction isMonotoneIncreasing(xs) {\n    for (let i = 1; i < xs.length; i++) {\n        if (xs[i - 1] > xs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns true if the given array of numbers are non-strict monotone decreasing.\n * @param xs an array of numbers\n *\n * @internal\n */\nfunction isMonotoneDecreasing(xs) {\n    for (let i = 1; i < xs.length; i++) {\n        if (xs[i - 1] < xs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @param xs\n *\n * @internal\n */\nfunction isMonotone(xs) {\n    return isMonotoneIncreasing(xs) || isMonotoneDecreasing(xs);\n}\n\n//# sourceMappingURL=is-self-overlapping.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/curviness.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/curviness.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curviness: () => (/* binding */ curviness)\n/* harmony export */ });\n/* harmony import */ var _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../simultaneous-properties/get-interface-rotation.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js\");\n\nconst { abs } = Math;\n/**\n * Returns a 'curviness' measure of the given bezier curve. `0` is considered\n * the `flattest` (as is the case of e.g. a line).\n *\n * The returned flatness, say `f` is such that `0 <= f <= (order-1)*𝜋`, where\n * `order` is the order of the bezier curve (e.g. cubics are of order 3); thus,\n * for example, cubics can have a maximum value of `2𝜋` for curviness (the most\n * curvy) and a minimum value of `0` (the flattest)\n *\n * This function is useful as a heuristic to test the `flatness` of curves to\n * see if they should be subdivided (in which case they would become flatter)\n *\n * * curviness is calculated simply as the sum of the absolute rotation (in\n * radians) of consecutive vectors formed by the ordered control points of the\n * curve\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction curviness(ps) {\n    // The below was the old heuristic which did not work well e.g. if an end \n    // control point was far away from the other 3\n    //return controlPointLinesLength(ps) / distanceBetween(ps[0], ps[ps.length-1]);\n    const vs = [];\n    for (let i = 0; i < ps.length - 1; i++) {\n        const v = [ps[i + 1][0] - ps[i][0], ps[i + 1][1] - ps[i][1]];\n        if ((v[0] !== 0 || v[1]) !== 0) {\n            vs.push(v);\n        }\n    }\n    const len = vs.length;\n    let total = 0;\n    for (let i = 0; i < len - 1; i++) {\n        total += abs((0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceRotation)(vs[i], vs[i + 1]));\n    }\n    return total;\n}\n\n//# sourceMappingURL=curviness.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/curviness.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/get-bending-energy.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/get-bending-energy.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBendingEnergy: () => (/* binding */ getBendingEnergy)\n/* harmony export */ });\n/* harmony import */ var flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\n/* harmony import */ var _classification_classify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classification/classify.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/classify.js\");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/split/split-by-curvature.js */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js\");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transformation/split/from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n/* harmony import */ var _classification_is_self_overlapping_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classification/is-self-overlapping.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js\");\n\n\n\n\n\nconst { sqrt } = Math;\n/**\n * Returns an accurate approximation of the bending energy of the given bezier\n * curve.\n *\n * @param maxCurviness defaults to 1.125\n * @param gaussOrder defaults to 4\n * @param ps a cubic bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc mdx\n */\nfunction getBendingEnergy(ps, maxCurviness = 1.125, gaussOrder = 4) {\n    // return getBendingEnergyByGauss(ps, maxCurviness, gaussOrder);\n    const c = (0,_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__.classify)(ps);\n    if (c.collinear) {\n        if ((0,_classification_is_self_overlapping_js__WEBPACK_IMPORTED_MODULE_1__.isSelfOverlapping)(ps)) {\n            return Number.POSITIVE_INFINITY;\n        }\n        return 0;\n    }\n    if (c.realOrder === 3) {\n        if (c.nodeType === 'cusp') {\n            return Number.POSITIVE_INFINITY;\n        }\n        // it is a well behaved 'acnode', 'crunode' or 'explicit'\n        return getBendingEnergyByGauss(κi3, ps, maxCurviness, gaussOrder);\n    }\n    if (c.realOrder === 2) {\n        // it is a well behaved 'quadratic'\n        return getBendingEnergyByGauss(κi2, ps, maxCurviness, gaussOrder);\n    }\n    return 0;\n}\n/**\n * Returns an estimate of the bending energy of the given bezier curve.\n *\n * @param ps\n * @param maxCurviness maximum curviness (must be > 0) as calculated using the\n * curviness function (which measures the total angle in radians formed by the\n * vectors formed by the ordered control points)\n * @param gaussOrder\n */\nfunction getBendingEnergyByGauss(κi, ps, maxCurviness, gaussOrder) {\n    const ts = (0,_transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_2__.splitByCurvature)(ps, maxCurviness);\n    let total = 0;\n    for (let i = 0; i < ts.length - 1; i++) {\n        const tS = ts[i];\n        const tE = ts[i + 1];\n        const ps_ = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_3__.fromTo)(ps, tS, tE);\n        total += (0,flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_4__.gaussQuadrature)(κi(ps_), [0, 1], gaussOrder);\n    }\n    return total;\n}\n/**\n * * For insight: https://faculty.sites.iastate.edu/jia/files/inline-files/curvature.pdf\n * * cubic version\n *\n * @param ps\n */\nfunction κi3(ps) {\n    /*\n    return (t: number): number => {\n        const [dx, dy] = tangent(ps, t);\n        const [ddx, ddy] = evaluate2ndDerivative(ps, t);\n\n        const a = (dx*ddy - dy*ddx)**2;\n        const b = sqrt((dx*dx + dy*dy)**5);\n\n        return a/b;\n    }\n    */\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const x3 = p3[0];\n    const y3 = p3[1];\n    const A = ((x3 - x0) + 3 * (x1 - x2));\n    const B = ((y3 - y0) + 3 * (y1 - y2));\n    const C = ((x2 + x0) - 2 * x1);\n    const D = ((y2 + y0) - 2 * y1);\n    return (t) => {\n        const tt = t * t;\n        const dx_3 = tt * A + 2 * t * C + (x1 - x0);\n        const dy_3 = tt * B + 2 * t * D + (y1 - y0);\n        const ddx_6 = t * A + C;\n        const ddy_6 = t * B + D;\n        const a = dx_3 * ddy_6 - dy_3 * ddx_6;\n        const c = dx_3 * dx_3 + dy_3 * dy_3;\n        const b = c * c * sqrt(c);\n        return (4 / 3) * a * a / b;\n    };\n}\n/**\n * * For insight: https://faculty.sites.iastate.edu/jia/files/inline-files/curvature.pdf\n * * quadratic version\n *\n * @param ps\n */\nfunction κi2(ps) {\n    /*\n    return (t: number): number => {\n        const [dx, dy] = tangent(ps, t);\n        const [ddx, ddy] = evaluate2ndDerivative(ps, t);\n\n        const a = (dx*ddy - dy*ddx)**2;\n        const b = sqrt((dx*dx + dy*dy)**5);\n\n        return a/b;\n    }\n    */\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const A = x2 - 2 * x1 + x0;\n    const B = y2 - 2 * y1 + y0;\n    return (t) => {\n        const dx = A * t + (x1 - x0);\n        const dy = B * t + (y1 - y0);\n        const ddx = A;\n        const ddy = B;\n        const a = dx * ddy - dy * ddx;\n        const c = dx * dx + dy * dy;\n        const b = c * c * sqrt(c);\n        return 0.5 * a * a / b;\n    };\n}\n\n//# sourceMappingURL=get-bending-energy.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/get-bending-energy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/get-inflections.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/get-inflections.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInflections: () => (/* binding */ getInflections)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n\n/**\n * Returns the given order 1,2 or 3 bezier curve's inflection point `t`\n * parameter values in ascending order.\n *\n * * see [Caffeine Owl](http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html)\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction getInflections(ps) {\n    if (ps.length < 4) {\n        // Neither lines, nor parabolas have inflection points\n        return [];\n    }\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\n    const ax = x1 - x0;\n    const ay = y1 - y0;\n    const bx = x2 - x1 - ax;\n    const by = y2 - y1 - ay;\n    const cx = x3 - x2 - ax - (2 * bx);\n    const cy = y3 - y2 - ay - (2 * by);\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\n    const a = bx * cy - by * cx;\n    const b = ax * cy - ay * cx;\n    const c = ax * by - ay * bx;\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)([a, b, c], 0, 1);\n}\n\n//# sourceMappingURL=get-inflections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/get-inflections.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   controlPointLinesLength: () => (/* binding */ controlPointLinesLength)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n\n/**\n * Returns an upper bound for the length of the given bezier curve - this bound\n * is not very strict as it uses the sum of the straight-line distances between\n * control points as a measure.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n *\n * @doc mdx\n */\nfunction controlPointLinesLength(ps) {\n    let totalLength = 0;\n    for (let i = 0; i < ps.length - 1; i++) {\n        totalLength += (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(ps[i], ps[i + 1]);\n    }\n    return totalLength;\n}\n\n//# sourceMappingURL=control-point-lines-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lengthBez1: () => (/* binding */ lengthBez1)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n\n/**\n * Returns the curve length of the given line within the specified parameter\n * interval.\n *\n * @param interval the paramter interval over which the length is\n * to be calculated (often `[0,1]`)\n * @param ps a linear bezier curve given by an ordered array of its control\n * points, e.g. `[[0,0],[1,1]]`\n *\n * @internal\n */\nfunction lengthBez1(interval, ps) {\n    const [t1, t2] = interval;\n    const [[x0, y0], [x1, y1]] = ps;\n    const p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];\n    const p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];\n    return (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(p1, p2);\n}\n\n//# sourceMappingURL=length-bez1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lengthBez2: () => (/* binding */ lengthBez2)\n/* harmony export */ });\n/* harmony import */ var flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\n/* harmony import */ var _local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../local-properties-at-t/ds.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/ds.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transformation/split/from-to/from-to-2-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../transformation/split/split-by-curvature.js */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js\");\n\n\n\n\n/**\n * Returns the curve length of the given quadratic bezier curve within the\n * specified parameter interval.\n *\n * @param interval the paramter interval over which the length is\n * to be calculated (often `[0,1]`)\n * @param ps a quadratic bezier curve given by an ordered array of its control\n * points, e.g. `[[0,0],[1,1],[2,1]]`\n * @param maxCurviness optional maximum 'curviness' (defined as the total angle\n * change between consecutive line segments between the curve control points)\n * before subdivision occurs; defaults to 0.4 radians\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\n * between curve segments; defaults to 16; can be 4,16 or 64\n *\n * @internal\n */\nfunction lengthBez2(interval, ps, maxCurviness = 0.4, gaussOrder = 16) {\n    const tS = interval[0];\n    const tE = interval[1];\n    if (tS === tE) {\n        return 0;\n    }\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    // Ensure zero length curve returns zero!\n    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {\n        return 0;\n    }\n    const ps_ = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__.fromTo2InclErrorBound)(ps, tS, tE).ps;\n    const ts = (0,_transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_1__.splitByCurvature)(ps_, maxCurviness);\n    let total = 0;\n    for (let i = 0; i < ts.length - 1; i++) {\n        const tS = ts[i];\n        const tE = ts[i + 1];\n        total += (0,flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_2__.gaussQuadrature)((0,_local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_3__.ds)(ps_), [tS, tE], gaussOrder);\n    }\n    return total;\n}\n/**\n * Returns the curve length in the specified interval.\n *\n * * unused because it is not numerically stable in its current form.\n *\n * See https://gist.github.com/tunght13488/6744e77c242cc7a94859\n *\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\n * @param interval - The paramter interval over which the length is\n * to be calculated (often === [0,1]).\n */\n/*\nfunction lengthBez2(interval: number[], ps: number[][]) {\n    if (interval[0] === interval[1]) { return 0; }\n\n    const [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;\n    // Keep line below to ensure zero length curve returns zero!\n    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {\n        return 0;\n    }\n\n    const [[x0, y0], [x1, y1], [x2, y2]] =\n            fromTo(ps)(interval[0], interval[1]);\n\n    const ax = x0 - 2*x1 + x2;\n    const ay = y0 - 2*y1 + y2;\n    const bx = 2*x1 - 2*x0;\n    const by = 2*y1 - 2*y0;\n\n    const A = 4 * (ax*ax + ay*ay);\n    const B = 4 * (ax*bx + ay*by);\n    const C = bx*bx + by*by;\n\n    const Sabc = 2*Math.sqrt(A+B+C);\n    const A_2 = Math.sqrt(A);\n    const A_32 = 2*A*A_2;\n    const C_2 = 2*Math.sqrt(C);\n    const BA = B/A_2;\n\n    return (\n        A_32*Sabc + A_2*B*(Sabc - C_2) +\n        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))\n    ) / (4*A_32);\n}\n*/\n\n//# sourceMappingURL=length-bez2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lengthBez3: () => (/* binding */ lengthBez3)\n/* harmony export */ });\n/* harmony import */ var flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\n/* harmony import */ var _local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../local-properties-at-t/ds.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/ds.js\");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../transformation/split/split-by-curvature.js */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transformation/split/from-to/from-to-3-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js\");\n\n\n\n\n/**\n * Returns the curve length of the given cubic bezier curve within the\n * specified parameter interval.\n *\n * @param interval the paramter interval over which the length is\n * to be calculated (often `[0,1]`)\n * @param ps a cubic bezier curve given by an ordered array of its control\n * points, e.g. `[[0,0],[1,1],[2,1],[3,3]]`\n * @param maxCurviness optional maximum 'curviness' (defined as the total angle\n * change between consecutive line segments between the curve control points)\n * before subdivision occurs; defaults to 0.4 radians\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\n * between curve segments; defaults to 16; can be 4,16 or 64\n *\n * @internal\n */\nfunction lengthBez3(interval, ps, maxCurviness = 0.4, gaussOrder = 16) {\n    const tS = interval[0];\n    const tE = interval[1];\n    if (tS === tE) {\n        return 0;\n    }\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // Keep line below to ensure zero length curve returns zero!\n    if (x0 === x1 && x1 === x2 && x2 === x3 &&\n        y0 === y1 && y1 === y2 && y2 === y3) {\n        return 0;\n    }\n    const ps_ = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3InclErrorBound)(ps, tS, tE).ps;\n    const ts = (0,_transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_1__.splitByCurvature)(ps_, maxCurviness);\n    let total = 0;\n    for (let i = 0; i < ts.length - 1; i++) {\n        const tS = ts[i];\n        const tE = ts[i + 1];\n        total += (0,flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_2__.gaussQuadrature)((0,_local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_3__.ds)(ps_), [tS, tE], gaussOrder);\n    }\n    return total;\n}\n\n//# sourceMappingURL=length-bez3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   length: () => (/* binding */ length)\n/* harmony export */ });\n/* harmony import */ var _length_bez1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length-bez1.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js\");\n/* harmony import */ var _length_bez2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length-bez2.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js\");\n/* harmony import */ var _length_bez3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length-bez3.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js\");\n\n\n\n/**\n * Returns the curve length (for a linear, quadratic or cubic bezier curve) in\n * the specified interval calculated using Gaussian Quadrature *with* adaptive\n * subdivision for improved accuracy.\n *\n * @param interval the paramter interval over which the length is\n * to be calculated (typically `[0,1]`)\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n * @param maxCurviness optional maximum 'curviness' (defined as the total angle\n * change between consecutive line segments between the curve control points)\n * before subdivision occurs; defaults to 0.4 radians\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\n * between curve segments; defaults to 16; can be 4,16 or 64\n *\n * @doc mdx\n */\nfunction length(interval, ps, maxCurviness = 0.4, gaussOrder = 16) {\n    if (ps.length === 4) {\n        return (0,_length_bez3_js__WEBPACK_IMPORTED_MODULE_0__.lengthBez3)(interval, ps, maxCurviness, gaussOrder);\n    }\n    if (ps.length === 3) {\n        return (0,_length_bez2_js__WEBPACK_IMPORTED_MODULE_1__.lengthBez2)(interval, ps, maxCurviness, gaussOrder);\n    }\n    if (ps.length === 2) {\n        return (0,_length_bez1_js__WEBPACK_IMPORTED_MODULE_2__.lengthBez1)(interval, ps);\n    }\n    if (ps.length === 1) {\n        return 0;\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/length/length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/total-length.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/total-length.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   totalLength: () => (/* binding */ totalLength)\n/* harmony export */ });\n/* harmony import */ var _length_bez1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length-bez1.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js\");\n/* harmony import */ var _length_bez2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length-bez2.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js\");\n/* harmony import */ var _length_bez3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length-bez3.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js\");\n\n\n\n/**\n * Returns the curve (a linear, quadratic or cubic bezier curve) length in the\n * specified interval calculated using Gaussian Quadrature *with* adaptive\n * subdivision for improved accuracy.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n * @param maxCurviness optional maximum 'curviness' (defined as the total angle\n * change between consecutive line segments between the curve control points)\n * before subdivision occurs; defaults to 0.4 radians\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\n * between curve segments; defaults to 16; can be 4,16 or 64\n *\n * @doc mdx\n */\nfunction totalLength(ps, maxCurviness = 0.4, gaussOrder = 16) {\n    if (ps.length === 4) {\n        return (0,_length_bez3_js__WEBPACK_IMPORTED_MODULE_0__.lengthBez3)([0, 1], ps, maxCurviness, gaussOrder);\n    }\n    if (ps.length === 3) {\n        return (0,_length_bez2_js__WEBPACK_IMPORTED_MODULE_1__.lengthBez2)([0, 1], ps, maxCurviness, gaussOrder);\n    }\n    if (ps.length === 2) {\n        return (0,_length_bez1_js__WEBPACK_IMPORTED_MODULE_2__.lengthBez1)([0, 1], ps);\n    }\n    if (ps.length === 1) {\n        return 0;\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=total-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/length/total-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   totalAbsoluteCurvature: () => (/* binding */ totalAbsoluteCurvature),\n/* harmony export */   totalCurvature: () => (/* binding */ totalCurvature)\n/* harmony export */ });\n/* harmony import */ var _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../simultaneous-properties/get-interface-rotation.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/split/from-to/from-to-2-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transformation/split/from-to/from-to-3-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js\");\n/* harmony import */ var _classification_classify_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classification/classify.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/classify.js\");\n/* harmony import */ var _get_inflections_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-inflections.js */ \"./node_modules/flo-bezier3/node/global-properties/get-inflections.js\");\n\n\n\n\n\nconst { abs, PI: 𝜋 } = Math;\n/**\n * Returns the total absolute curvature of the given bezier curve over the\n * given interval\n *\n * * the result is given in radians.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\n * @param interval\n *\n * @doc mdx\n */\nfunction totalAbsoluteCurvature(ps, interval = [0, 1]) {\n    if (ps.length <= 3) {\n        return abs(totalCurvature(ps, interval));\n    }\n    if (ps.length === 4) {\n        const [tS, tE] = interval;\n        if (tS === tE) {\n            return 0;\n        }\n        const ps_ = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3InclErrorBound)(ps, tS, tE).ps;\n        const ts = [0, ...(0,_get_inflections_js__WEBPACK_IMPORTED_MODULE_1__.getInflections)(ps_), 1];\n        let total = 0;\n        for (let i = 0; i < ts.length - 1; i++) {\n            total += abs(totalCurvature(ps_, [ts[i], ts[i + 1]]));\n        }\n        return total;\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/**\n * Returns the total curvature of the bezier over the given interval.\n *\n * * the result is given in radians.\n *\n * @param ps a cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param interval the interval of integration (often === [0,1])\n *\n * @doc mdx\n */\nfunction totalCurvature(ps, interval = [0, 1]) {\n    if (ps.length <= 2) {\n        return 0;\n    }\n    const [tS, tE] = interval;\n    if (tS === tE) {\n        return 0;\n    }\n    if (ps.length === 3) {\n        const ps_ = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo2InclErrorBound)(ps, tS, tE).ps;\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps_;\n        const tanS = [x1 - x0, y1 - y0];\n        const tanE = [x2 - x1, y2 - y1];\n        // guaranteed: |θ| <= 𝜋, curvature = θ\n        return (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_3__.getInterfaceRotation)(tanS, tanE);\n    }\n    if (ps.length === 4) {\n        // guaranteed: curvature <= 2𝜋\n        const ps_ = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3InclErrorBound)(ps, tS, tE).ps;\n        const bezClass = (0,_classification_classify_js__WEBPACK_IMPORTED_MODULE_4__.classify)(ps_);\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps_;\n        const tanS = [x1 - x0, y1 - y0];\n        const tanM = [x2 - x1, y2 - y1];\n        const tanE = [x3 - x2, y3 - y2];\n        if ((tanM[0] === 0 && tanM[1] === 0) ||\n            bezClass.realOrder <= 2) {\n            return (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_3__.getInterfaceRotation)(tanS, tanE);\n        }\n        const cpθ = (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_3__.getInterfaceRotation)(tanS, tanM) +\n            (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_3__.getInterfaceRotation)(tanM, tanE);\n        if (bezClass.nodeType === 'acnode' ||\n            bezClass.nodeType === 'cusp') {\n            return cpθ <= -𝜋\n                ? cpθ + 2 * 𝜋\n                : cpθ >= +𝜋\n                    ? cpθ - 2 * 𝜋\n                    : cpθ;\n        }\n        return cpθ;\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=total-absolute-curvature.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1DdWithRunningError: () => (/* binding */ getImplicitForm1DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\nconst abs = Math.abs;\n/**\n * Returns a double-double precision implicit form of the given line segment\n * and a coefficientwise error bound.\n *\n * Returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n *\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in double-double precision and this is\n * reflected in the error bound\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\n * where `u === Number.EPSILON / 2` before use\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a line segment given as an array of its control points,\n * e.g. `[[1,2],[3,4]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm1DdWithRunningError(ps) {\n    // The implicit form is given by:\n    // vₓx + vᵧy + v = 0\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis1DdWithRunningError)(ps);\n    const vₓ = eno(b1); // exact\n    const vᵧ = a1; // exact\n    //const v = a1*b0 - a0*b1;\n    const a1b0 = qmd(b0, a1);\n    const _a1b0_ = abs(a1b0[1]);\n    const a0b1 = qmd(a0, b1);\n    const _a0b1_ = abs(a0b1[1]);\n    const v = qdq(a0b1, a1b0);\n    const v_ = _a1b0_ + _a0b1_ + abs(v[1]);\n    return {\n        coeffs: { vₓ, vᵧ, v },\n        errorBound: { v_ } // vₓ_, vᵧ_ === 0\n    };\n}\n\n//# sourceMappingURL=get-implicit-form1-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1Dd: () => (/* binding */ getImplicitForm1Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf;\n/**\n * Returns a double-double precision implicit form of the given\n * linear bezier curve.\n *\n * Returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n *\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\n * * intermediate calculations are performed in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a line segment given as an array of its control points,\n * e.g. `[[1,2],[3,4]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm1Dd(ps) {\n    // The implicit form is given by:\n    // vₓx + vᵧy + v = 0\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Dd)(ps);\n    const vₓ = qno(b1); // exact\n    const vᵧ = a1; // exact\n    //const v = a0*b1 - a1*b0;\n    const v = qdq(qmd(a0, b1), qmd(b0, a1));\n    return { vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2DdWithRunningError: () => (/* binding */ getImplicitForm2DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\nconst abs = Math.abs;\n/**\n * Returns a double-double precision implicit form of the given quadratic\n * bezier curve and a coefficientwise error bound.\n *\n * Returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n *\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in double-double precision and this is\n * reflected in the error bound\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\n * where `u === Number.EPSILON / 2` before use\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a quadratic bezier curve given as an array of its control points,\n * e.g. `[[1,2],[3,4],[5,7]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm2DdWithRunningError(ps) {\n    // The implicit form is given by:\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    const { coeffs: [[a2, a1, [, a0]], [b2, b1, [, b0]]], errorBound: [[a2_], [b2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2DdWithRunningError)(ps);\n    const $a2 = a2[1];\n    const $a1 = a1[1];\n    const $b2 = b2[1];\n    const $b1 = b1[1];\n    const _a0 = abs(a0);\n    const _a1 = abs($a1);\n    const _a2 = abs($a2);\n    const _b0 = abs(b0);\n    const _b1 = abs($b1);\n    const _b2 = abs($b2);\n    const a2b1 = qmq(a2, b1);\n    const a2b1_ = a2_ * _b1 + 2 * abs($a2 * $b1);\n    const a1b2 = qmq(a1, b2);\n    const a1b2_ = _a1 * b2_ + 2 * abs($a1 * $b2);\n    const a2b0 = qmd(b0, a2);\n    const a2b0_ = _b0 * a2_ + abs(b0 * $a2);\n    const a0b2 = qmd(a0, b2);\n    const a0b2_ = _a0 * b2_ + abs(a0 * $b2);\n    const a1b0 = qmd(b0, a1);\n    const a1b0_ = abs(b0 * $a1);\n    const a0b1 = qmd(a0, b1);\n    const a0b1_ = abs(a0 * $b1);\n    const a2a2 = qmq(a2, a2);\n    const a2a2_ = 2 * (a2_ * _a2 + abs($a2 * $a2));\n    const a2b2 = qmq(a2, b2);\n    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * abs($a2 * $b2);\n    const b2b2 = qmq(b2, b2);\n    const b2b2_ = 2 * (b2_ * _b2 + abs($b2 * $b2));\n    const $a2b1 = $a2 * $b1;\n    const $a1b2 = $a1 * $b2;\n    const $a2b0 = $a2 * b0;\n    const $a0b2 = a0 * $b2;\n    const $a1b0 = $a1 * b0;\n    const $a0b1 = a0 * $b1;\n    const $q1 = $a2b1 - $a1b2;\n    const $q2 = $a2b0 - $a0b2;\n    const $q3 = $a1b0 - $a0b1;\n    const q1 = qdq(a2b1, a1b2);\n    const _q1 = abs($q1);\n    const q1_ = a2b1_ + a1b2_ + abs($q1);\n    const q2 = qdq(a2b0, a0b2);\n    const _q2 = abs($q2);\n    const q2_ = a2b0_ + a0b2_ + abs($q2);\n    const q3 = qdq(a1b0, a0b1);\n    const _q3 = abs($q3);\n    const q3_ = a1b0_ + a0b1_ + abs($q3);\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\n    // -------------\n    // b2**2 *x**2\n    // -b2**2 *x**2\n    // -------------\n    const vₓₓ = qno(b2b2);\n    const vₓₓ_ = b2b2_;\n    // -------------\n    // -2*a2*b2 *x*y\n    // 2*a2*b2 *x*y\n    // -------------\n    const vₓᵧ = qm2(a2b2);\n    const vₓᵧ_ = a2b2_;\n    // -------------\n    // a2**2 *y**2 \n    // -a2**2 *y**2 \n    // -------------\n    const vᵧᵧ = qno(a2a2);\n    const vᵧᵧ_ = a2a2_;\n    // -----------------------------------------------\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\n    // (b1*q1 + -2*b2*q2) *x\n    //const vₓ = b1*q1 - 2*b2*q2;\n    // -----------------------------------------------\n    const $w1 = $b1 * $q1;\n    const w1 = qmq(b1, q1);\n    const w1_ = _b1 * q1_ + 2 * abs($w1);\n    const $w2 = 2 * $q2 * $b2;\n    const w2 = qm2(qmq(b2, q2));\n    const w2_ = 2 * (b2_ * _q2 + _b2 * q2_ + 2 * abs($w2));\n    const $vₓ = $w1 - $w2;\n    const vₓ = qdq(w1, w2);\n    const vₓ_ = w1_ + w2_ + abs($vₓ);\n    // -----------------------------------------------\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\n    // (-a1*q1 + 2*a2*q2) *y\n    // -----------------------------------------------\n    const $w3 = 2 * $a2 * $q2;\n    const w3 = qm2(qmq(a2, q2));\n    const w3_ = 2 * (a2_ * _q2 + _a2 * q2_ + 2 * abs($w3));\n    const $w4 = $a1 * $q1;\n    const w4 = qmq(a1, q1);\n    const w4_ = _a1 * q1_ + 2 * abs($w4);\n    const $vᵧ = $w3 - $w4;\n    const vᵧ = qdq(w3, w4);\n    const vᵧ_ = w3_ + w4_ + abs($vᵧ);\n    // --------------------------------------------------------------------------------------------------\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\n    // q1*q3 + -q2**2\n    // --------------------------------------------------------------------------------------------------\n    const $w5 = $q1 * $q3;\n    const w5 = qmq(q1, q3);\n    const w5_ = q1_ * _q3 + _q1 * q3_ + 2 * abs($w5);\n    const $w6 = $q2 * $q2;\n    const w6 = qmq(q2, q2);\n    const w6_ = 2 * (q2_ * _q2 + abs($w6));\n    const $v = $w5 - $w6;\n    const v = qdq(w5, w6);\n    const v_ = w5_ + w6_ + abs($v);\n    return {\n        coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\n        errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\n    };\n}\n\n//# sourceMappingURL=get-implicit-form2-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2Dd: () => (/* binding */ getImplicitForm2Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js\");\n\n\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\n/**\n * Returns a double-double precision implicit form of the given quadratic\n * bezier curve and a coefficientwise error bound.\n *\n * Returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n *\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a quadratic bezier curve given as an array of its control points,\n * e.g. `[[1,2],[3,4],[5,7]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm2Dd(ps) {\n    // The implicit form is given by:\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    const [[a2, a1, [, a0]], [b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Dd)(ps);\n    const q1 = qdq(qmq(a2, b1), qmq(a1, b2));\n    const q2 = qdq(qmd(b0, a2), qmd(a0, b2));\n    const q3 = qdq(qmd(b0, a1), qmd(a0, b1));\n    //----------------------------------------------------------------------------------------------------\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\n    //----------------------------------------------------------------------------------------------------\n    // -------------\n    // -b2**2\n    // -------------\n    const vₓₓ = qno(qmq(b2, b2));\n    // -------------\n    // 2*a2*b2\n    // -------------\n    const vₓᵧ = qm2(qmq(a2, b2));\n    // -------------\n    // -a2**2\n    // -------------\n    const vᵧᵧ = qno(qmq(a2, a2));\n    // -----------------------------------------------\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\n    // b1*q1 - 2*b2*q2\n    // -----------------------------------------------\n    const vₓ = qdq(qmq(b1, q1), qm2(qmq(b2, q2)));\n    // -----------------------------------------------\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\n    // 2*a2*q2 - a1*q1\n    // -----------------------------------------------\n    const vᵧ = qdq(qm2(qmq(a2, q2)), qmq(a1, q1));\n    // --------------------------------------------------------------------------------------------------\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\n    // q1*q3 - q2**2\n    // --------------------------------------------------------------------------------------------------\n    const v = qdq(qmq(q1, q3), qmq(q2, q2));\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3DdWithRunningError: () => (/* binding */ getImplicitForm3DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\nconst abs = Math.abs;\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \nconst qd2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivBy2; // error -> 0 \n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 5*γ² (worst found), 7*γ² (theoretical), we use 6*γ²\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd; // error -> 3*γ²\n/**\n * Returns a double-double precision implicit form of the given cubic\n * bezier curve curve and a coefficientwise error bound.\n *\n * Returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n *\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in double-double precision and this is\n * reflected in the error bound\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\n * where `u === Number.EPSILON / 2` before use\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a cubic bezier curve given as an array of its control points,\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm3DdWithRunningError(ps) {\n    // Takes about 15 micro-seconds on a 3rd gen i7 and Chrome 79.\n    //--------------------------------------------------------------------------\n    // `var` -> a variable\n    // `$var` -> the double precision approximation to `var`\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\n    // `_var_` -> means both absolute value and absolute error bound\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\n    // * the returned errors need to be multiplied by 3γ² to get the true error\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\n    //   due to multiplication by 3*γ² and not 3*u²\n    //--------------------------------------------------------------------------\n    // examples:\n    // ----------------\n    // let qmd === ddMultDouble2, etc.\n    //\n    // ---------------\n    // 1. double-double X by double\n    // ---------------\n    // qmd(a,b);  // both `a` and `b` is error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\n    //                           === 0|b| + |a|0 + |a*b|\n    //                           === |a*b|\n    //\n    // ---------------\n    // 2a. double-double +/- double-double\n    // ---------------\n    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\n    //                           === _a_ + _b_ + |a+b|\n    //\n    // ---------------\n    // 2b. double-double +/- double-double\n    // ---------------\n    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\n    //                           === 2*_a + 2*_b + |a+b|\n    //                           === 2*(_a + _b) + |a+b| OR\n    //                           === a_ + b_ + |a+b|\n    //\n    // ---------------\n    // 3a. double-double X double-double\n    // ---------------\n    // qmq(a,b);  // both `a` and `b` error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\n    //                           === 0|b| + |a|0 + 2|a*b|\n    //                           === 2|a*b| \n    //\n    // ---------------\n    // 3b. double-double X double-double\n    // ---------------\n    // qmq(a,b);  // both `a` and `b` not error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\n    //\n    // ---------------\n    // 3b. double-double X double-double\n    // ---------------\n    // qmq(a,b);  // both `a` not error-free and `b` error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\n    //                           === a_|b| + 2|a*b| \n    //\n    // ---------------\n    // 4a. double-double +/- double\n    // ---------------\n    // qad(a,b);  // both `a` and `b` error-free\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\n    //                           === 0 + 0 + |a+b|\n    //                           === |a+b| \n    //--------------------------------------------------------------------------\n    const { coeffs: [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]], errorBound: [[a3_, a2_, a1_], [b3_, b2_, b1_]] // a0, b0 - error free\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3DdWithRunningError)(ps);\n    // The implicit form is given by:\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    const $a1 = a1[1];\n    const $a2 = a2[1];\n    const $a3 = a3[1];\n    const $b1 = b1[1];\n    const $b2 = b2[1];\n    const $b3 = b3[1];\n    const _a0 = abs(a0);\n    const _a1 = abs($a1);\n    const _a2 = abs($a2);\n    const _a3 = abs($a3);\n    const _b0 = abs(b0);\n    const _b1 = abs($b1);\n    const _b2 = abs($b2);\n    const _b3 = abs($b3);\n    const a3b1 = qmq(a3, b1);\n    const $a3b1 = $a3 * $b1;\n    const a3b1_ = a3_ * _b1 + _a3 * b1_ + 2 * abs($a3b1);\n    const a1b3 = qmq(a1, b3);\n    const $a1b3 = $a1 * $b3;\n    const a1b3_ = a1_ * _b3 + _a1 * b3_ + 2 * abs($a1b3);\n    const a3b2 = qmq(a3, b2);\n    const $a3b2 = $a3 * $b2;\n    const a3b2_ = a3_ * _b2 + _a3 * b2_ + 2 * abs($a3b2);\n    const a2b2 = qmq(a2, b2);\n    const $a2b2 = $a2 * $b2;\n    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * abs($a2b2);\n    const a2b3 = qmq(a2, b3);\n    const $a2b3 = $a2 * $b3;\n    const a2b3_ = a2_ * _b3 + _a2 * b3_ + 2 * abs($a2b3);\n    const a3a3 = qmq(a3, a3);\n    const $a3a3 = $a3 * $a3;\n    const _a3a3 = abs($a3a3);\n    const a3a3_ = a3_ * _a3 + _a3 * a3_ + 2 * abs($a3a3);\n    const b2b2 = qmq(b2, b2);\n    const $b2b2 = $b2 * $b2;\n    const b2b2_ = b2_ * _b2 + _b2 * b2_ + 2 * abs($b2b2);\n    const b3b3 = qmq(b3, b3);\n    const $b3b3 = $b3 * $b3;\n    const _b3b3 = abs($b3b3);\n    const b3b3_ = b3_ * _b3 + _b3 * b3_ + 2 * abs($b3b3);\n    const a1a3 = qmq(a1, a3);\n    const $a1a3 = $a1 * $a3;\n    const a1a3_ = a1_ * _a3 + _a1 * a3_ + 2 * abs($a1a3);\n    const a2a2 = qmq(a2, a2);\n    const $a2a2 = $a2 * $a2;\n    const a2a2_ = a2_ * _a2 + _a2 * a2_ + 2 * abs($a2a2);\n    const b1b3 = qmq(b1, b3);\n    const $b1b3 = $b1 * $b3;\n    const b1b3_ = b1_ * _b3 + _b1 * b3_ + 2 * abs($b1b3);\n    const b2b3 = qmq(b2, b3);\n    const _b2b3 = abs($b2 * $b3); // or equivalently `_b2b3 = _b2*_b3`;\n    const b2b3_ = b2_ * _b3 + _b2 * b3_ + 2 * _b2b3;\n    const a2a3 = qmq(a2, a3);\n    const _a2a3 = abs($a2 * $a3);\n    const a2a3_ = a2_ * _a3 + _a2 * a3_ + 2 * _a2a3;\n    const a3b3 = qmq(a3, b3);\n    const _a3b3 = abs($a3 * $b3);\n    const a3b3_ = a3_ * _b3 + _a3 * b3_ + 2 * _a3b3;\n    const a3b0 = qmd(b0, a3);\n    const $a3b0 = $a3 * b0;\n    const a3b0_ = a3_ * _b0 + abs($a3b0);\n    const a0b3 = qmd(a0, b3);\n    const $a0b3 = a0 * $b3;\n    const a0b3_ = _a0 * b3_ + abs($a0b3);\n    const a2b0 = qmd(b0, a2);\n    const $a2b0 = $a2 * b0;\n    const a2b0_ = a2_ * _b0 + abs($a2b0);\n    const a0b2 = qmd(a0, b2);\n    const $a0b2 = a0 * $b2;\n    const a0b2_ = _a0 * b2_ + abs($a0b2);\n    const a2b1 = qmq(a2, b1);\n    const $a2b1 = $a2 * $b1;\n    const a2b1_ = a2_ * _b1 + _a2 * b1_ + 2 * abs($a2b1);\n    const a1b2 = qmq(a1, b2);\n    const $a1b2 = $a1 * $b2;\n    const a1b2_ = a1_ * _b2 + _a1 * b2_ + 2 * abs($a1b2);\n    const a1b0 = qmd(b0, a1);\n    const $a1b0 = $a1 * b0;\n    const a1b0_ = a1_ * _b0 + abs($a1b0);\n    const a0b1 = qmd(a0, b1);\n    const $a0b1 = a0 * $b1;\n    const a0b1_ = _a0 * b1_ + abs($a0b1);\n    const q1 = qdq(a3b0, a0b3);\n    const q1_ = a3b0_ + a0b3_ + abs($a3b0 - $a0b3);\n    const q2 = qdq(a3b1, a1b3);\n    const q2_ = a3b1_ + a1b3_ + abs($a3b1 - $a1b3);\n    const q3 = qdq(a3b2, a2b3);\n    const q3_ = a3b2_ + a2b3_ + abs($a3b2 - $a2b3);\n    const q4 = qdq(a2b0, a0b2);\n    const q4_ = a2b0_ + a0b2_ + abs($a2b0 - $a0b2);\n    const q5 = qdq(a2b1, a1b2);\n    const q5_ = a2b1_ + a1b2_ + abs($a2b1 - $a1b2);\n    const q6 = qdq(a1b0, a0b1);\n    const q6_ = a1b0_ + a0b1_ + abs($a1b0 - $a0b1);\n    const _t1 = abs($b1b3 - $b2b2);\n    const t1 = qdq(b1b3, b2b2);\n    const t1_ = b1b3_ + b2b2_ + _t1;\n    const _t2 = abs($a1a3 - $a2a2);\n    const t2 = qdq(a1a3, a2a2);\n    const t2_ = a1a3_ + a2a2_ + abs($a1a3 - $a2a2);\n    const _p1 = abs($a2b3 + $a3b2);\n    const p1 = qaq(a2b3, a3b2);\n    const p1_ = a2b3_ + a3b2_ + abs($a2b3 + $a3b2);\n    const $p2 = $a1b3 + $a3b1;\n    const _p2 = abs($p2);\n    const p2 = qaq(a1b3, a3b1);\n    const p2_ = a1b3_ + a3b1_ + _p2;\n    const tq2 = qm2(q2);\n    const tq2_ = 2 * q2_;\n    const $q1 = $a3b0 - $a0b3;\n    const $q2 = $a3b1 - $a1b3;\n    const $q3 = $a3b2 - $a2b3;\n    const $q4 = $a2b0 - $a0b2;\n    const $q5 = $a2b1 - $a1b2;\n    const $q6 = $a1b0 - $a0b1;\n    const _q1 = abs($q1);\n    const _q2 = abs($q2);\n    const _q3 = abs($q3);\n    const _q4 = abs($q4);\n    const _q5 = abs($q5);\n    const _q6 = abs($q6);\n    const _tq2 = 2 * _q2;\n    const q1q1 = qmq(q1, q1);\n    const q1q2 = qmq(q1, q2);\n    const q1q3 = qmq(q1, q3);\n    const q1q5 = qmq(q1, q5);\n    const q2q2 = qmq(q2, q2);\n    const tq2q4 = qmq(tq2, q4);\n    const q3q4 = qmq(q3, q4);\n    const q3q5 = qmq(q3, q5);\n    const q3q6 = qmq(q3, q6);\n    const q1q1_ = q1_ * _q1 + _q1 * q1_ + 2 * abs(q1q1[1]);\n    const q1q2_ = q1_ * _q2 + _q1 * q2_ + 2 * abs(q1q2[1]);\n    const q1q3_ = q1_ * _q3 + _q1 * q3_ + 2 * abs(q1q3[1]);\n    const q1q5_ = q1_ * _q5 + _q1 * q5_ + 2 * abs(q1q5[1]);\n    const q2q2_ = q2_ * _q2 + _q2 * q2_ + 2 * abs(q2q2[1]);\n    const tq2q4_ = tq2_ * _q4 + _tq2 * q4_ + 2 * abs(tq2q4[1]);\n    const q3q4_ = q3_ * _q4 + _q3 * q4_ + 2 * abs(q3q4[1]);\n    const q3q5_ = q3_ * _q5 + _q3 * q5_ + 2 * abs(q3q5[1]);\n    const q3q6_ = q3_ * _q6 + _q3 * q6_ + 2 * abs(q3q4[1]);\n    const vₓₓₓ = qmq(qno(b3), b3b3);\n    const vₓₓₓ_ = b3_ * _b3b3 + _b3 * b3b3_ + 2 * abs(vₓₓₓ[1]);\n    const _z1 = 3 * _a3;\n    const z1 = qmd(3, a3);\n    const z1_ = 3 * a3_ + _z1;\n    const vₓₓᵧ = qmq(z1, b3b3);\n    const vₓₓᵧ_ = z1_ * _b3b3 + _z1 * b3b3_ + 2 * abs(vₓₓᵧ[1]);\n    const _z2 = 3 * _b3;\n    const z2 = qmd(-3, b3);\n    const z2_ = 3 * b3_ + _z2;\n    const vₓᵧᵧ = qmq(z2, a3a3);\n    const vₓᵧᵧ_ = z2_ * _a3a3 + _z2 * a3a3_ + 2 * abs(vₓᵧᵧ[1]);\n    const vᵧᵧᵧ = qmq(a3, a3a3);\n    const vᵧᵧᵧ_ = a3_ * _a3a3 + _a3 * a3a3_ + 2 * abs(vᵧᵧᵧ[1]);\n    const $z3 = -3 * $q1;\n    const _z3 = 3 * _q1;\n    const z3 = qmd(-3, q1);\n    const z3_ = 3 * q1_ + _z3;\n    const u1 = qdq(z3, q5);\n    const _u1 = abs($z3 - $q5);\n    const u1_ = z3_ + q5_ + _u1;\n    //const t1_ = _b1b3 + _b2b2 + _t1;\n    //const _t2 = abs(t2);\n    //const t2_ = _a1a3 + _a2a2 + abs(t2);\n    const w1 = qmq(u1, b3b3);\n    const w1_ = u1_ * _b3b3 + _u1 * b3b3_ + 2 * abs(w1[1]);\n    const w2 = qmq(q3, t1);\n    const w2_ = q3_ * _t1 + _q3 * t1_ + 2 * abs(w2[1]);\n    const w3 = qaq(w1, w2);\n    const w3_ = w1_ + w2_ + abs(w3[1]);\n    const w4 = qmq(tq2, b2b3);\n    const w4_ = tq2_ * _b2b3 + _tq2 * b2b3_ + 2 * abs(w4[1]);\n    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\n    const vₓₓ = qaq(w3, w4);\n    const vₓₓ_ = w3_ + w4_ + abs(vₓₓ[1]);\n    const w5 = qmq(u1, a3a3);\n    const w5_ = u1_ * _a3a3 + _u1 * a3a3_ + 2 * abs(w5[1]);\n    const w6 = qmq(q3, t2);\n    const w6_ = q3_ * _t2 + _q3 * t2_ + 2 * abs(w6[1]);\n    const w7 = qaq(w5, w6);\n    const w7_ = w5_ + w6_ + abs(w7[1]);\n    const w8 = qmq(tq2, a2a3);\n    const w8_ = tq2_ * _a2a3 + _tq2 * a2a3_ + 2 * abs(w8[1]);\n    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\n    const vᵧᵧ = qaq(w7, w8);\n    const vᵧᵧ_ = w7_ + w8_ + abs(vᵧᵧ[1]);\n    const _wa = abs($a2b2 - $p2 / 2);\n    const wa = qdq(a2b2, qd2(p2));\n    const wa_ = a2b2_ + p2_ / 2 + abs(wa[1]);\n    const wb = qmq(u1, a3b3);\n    const wb_ = u1_ * _a3b3 + _u1 * a3b3_ + 2 * abs(wb[1]);\n    const wc = qmq(q2, p1);\n    const wc_ = q2_ * _p1 + _q2 * p1_ + 2 * abs(wc[1]);\n    const wd = qaq(wb, wc);\n    const wd_ = wb_ + wc_ + abs(wd[1]);\n    const wq = qmq(q3, wa);\n    const wq_ = q3_ * _wa + _q3 * wa_ + 2 * abs(wq[1]);\n    //-------------------------------------------------------\n    // const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\n    //-------------------------------------------------------\n    const vₓᵧ = qm2(qdq(wq, wd));\n    const vₓᵧ_ = 2 * (wq_ + wd_) + abs(vₓᵧ[1]);\n    const wr = qmd(-3, q1q1);\n    const wr_ = 3 * q1q1_ + abs(wr[1]);\n    const we = qdq(wr, qm2(q1q5));\n    const we_ = wr_ + 2 * q1q5_ + abs(we[1]);\n    const wf = qaq(tq2q4, q3q6);\n    const wf_ = tq2q4_ + q3q6_ + abs(wf[1]);\n    //------------------------------------------------\n    // const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\n    //------------------------------------------------\n    const s1 = qaq(we, wf);\n    const _s1 = abs(s1[1]);\n    const s1_ = we_ + wf_ + _s1;\n    //-----------------------------\n    // const s2 = 2*(q1q2 - q3q4);\n    //-----------------------------\n    const s2 = qm2(qdq(q1q2, q3q4));\n    const _s2 = abs(s2[1]);\n    const s2_ = 2 * (q1q2_ + q3q4_) + _s2;\n    const wl = qdq(q1q3, q2q2);\n    const wl_ = q1q3_ + q2q2_ + abs(wl[1]);\n    //-------------------------------\n    // const s3 = q1q3 - q2q2 + q3q5;\n    //-------------------------------\n    const s3 = qaq(wl, q3q5);\n    const _s3 = abs(s3[1]);\n    const s3_ = wl_ + q3q5_ + _s3;\n    const wm = qmq(b3, s1);\n    const wm_ = b3_ * _s1 + _b3 * s1_ + 2 * abs(wm[1]);\n    const ws = qmq(b2, s2);\n    const ws_ = b2_ * _s2 + _b2 * s2_ + 2 * abs(ws[1]);\n    const wt = qmq(b1, s3);\n    const wt_ = b1_ * _s3 + _b1 * s3_ + 2 * abs(wt[1]);\n    const wn = qaq(ws, wt);\n    const wn_ = ws_ + wt_ + abs(wn[1]);\n    //-------------------------------\n    // const vₓ = b3*s1 + (b2*s2 + b1*s3);\n    //-------------------------------\n    const vₓ = qaq(wm, wn);\n    const vₓ_ = wm_ + wn_ + abs(vₓ[1]);\n    const wo = qmq(a3, s1);\n    const wo_ = a3_ * _s1 + _a3 * s1_ + 2 * abs(wo[1]);\n    const wu = qmq(a2, s2);\n    const wu_ = a2_ * _s2 + _a2 * s2_ + 2 * abs(wu[1]);\n    const wv = qmq(a1, s3);\n    const wv_ = a1_ * _s3 + _a1 * s3_ + 2 * abs(wv[1]);\n    const wp = qaq(wu, wv);\n    const wp_ = wu_ + wv_ + abs(wp[1]);\n    //-------------------------------------\n    // const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\n    //-------------------------------------\n    const vᵧ = qno(qaq(wo, wp));\n    const vᵧ_ = wo_ + wp_ + abs(vᵧ[1]);\n    // the commented part above is re\n    const v3 = qdq(tq2q4, q1q1);\n    const v1 = qdq(v3, q1q5);\n    const _v1 = abs(v1[1]);\n    const v4 = qmq(s3, q6);\n    const v5 = qmq(q3q4, q4);\n    const v2 = qdq(v4, v5);\n    const v2_ = s3_ * abs(q6[1]) + 2 * abs(v4[1]) + q3q4_ * abs(q4[1]) + 2 * abs(v5[1]) + abs(v2[1]);\n    const v6 = qmq(q1, v1);\n    const v6_ = q1_ * _v1 + _q1 * tq2q4_ + q1q1_ + abs(v3[1]) + q1q5_ + _v1 + 2 * abs(v6[1]);\n    // -------------------------------------------------------------------------\n    //-------------------------------------------------------\n    // const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\n    //-------------------------------------------------------\n    const v = qaq(v6, v2);\n    const v_ = v6_ + v2_ + abs(v[1]);\n    return {\n        coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\n        errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\n    };\n}\n\n//# sourceMappingURL=get-implicit-form3-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3Dd: () => (/* binding */ getImplicitForm3Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js\");\n\n\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \nconst qd2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivBy2; // error -> 0 \n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 5*γ² (worst found), 7*γ² (theoretical), we use 6*γ²\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd; // error -> 3*γ²\n/**\n * Returns a double-double precision implicit form of the given cubic bezier\n * curve.\n *\n * Returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n *\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a cubic bezier curve given as an array of its control points,\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm3Dd(ps) {\n    // Takes about 15 micro-seconds on a 3rd gen i7 and Chrome 79.\n    // The implicit form is given by:\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    const [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Dd)(ps);\n    const a3b1 = qmq(a3, b1);\n    const a1b3 = qmq(a1, b3);\n    const a3b2 = qmq(a3, b2);\n    const a2b3 = qmq(a2, b3);\n    const a3a3 = qmq(a3, a3);\n    const b3b3 = qmq(b3, b3);\n    const q1 = qdq(qmd(b0, a3), qmd(a0, b3));\n    const q2 = qdq(a3b1, a1b3);\n    const q3 = qdq(a3b2, a2b3);\n    const q4 = qdq(qmd(b0, a2), qmd(a0, b2));\n    const q5 = qdq(qmq(a2, b1), qmq(a1, b2));\n    const q6 = qdq(qmd(b0, a1), qmd(a0, b1));\n    const tq2 = qm2(q2);\n    const q1q1 = qmq(q1, q1);\n    const q1q5 = qmq(q1, q5);\n    const tq2q4 = qmq(tq2, q4);\n    const q3q4 = qmq(q3, q4);\n    const u1 = qdq(qmd(-3, q1), q5);\n    const vₓₓₓ = qmq(qno(b3), b3b3);\n    const vₓₓᵧ = qmq(qmd(3, a3), b3b3);\n    const vₓᵧᵧ = qmq(qmd(-3, b3), a3a3);\n    const vᵧᵧᵧ = qmq(a3, a3a3);\n    const vₓₓ = qaq(qaq(qmq(u1, b3b3), qmq(q3, qdq(qmq(b1, b3), qmq(b2, b2)))), qmq(tq2, qmq(b2, b3)));\n    const vᵧᵧ = qaq(qaq(qmq(u1, a3a3), qmq(q3, qdq(qmq(a1, a3), qmq(a2, a2)))), qmq(tq2, qmq(a2, a3)));\n    //-------------------------------------------------------\n    // const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\n    //-------------------------------------------------------\n    const vₓᵧ = qm2(qdq(qmq(q3, qdq(qmq(a2, b2), qd2(qaq(a1b3, a3b1)))), qaq(qmq(u1, qmq(a3, b3)), qmq(q2, qaq(a2b3, a3b2)))));\n    //------------------------------------------------\n    // const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\n    //------------------------------------------------\n    const s1 = qaq(qdq(qmd(-3, q1q1), qm2(q1q5)), qaq(tq2q4, qmq(q3, q6)));\n    //-----------------------------\n    // const s2 = 2*(q1q2 - q3q4);\n    //-----------------------------\n    const s2 = qm2(qdq(qmq(q1, q2), q3q4));\n    //-------------------------------\n    // const s3 = q1q3 - q2q2 + q3q5;\n    //-------------------------------\n    const s3 = qaq(qdq(qmq(q1, q3), qmq(q2, q2)), qmq(q3, q5));\n    //-------------------------------\n    // const vₓ = b3*s1 + (b2*s2 + b1*s3);\n    //-------------------------------\n    const vₓ = qaq(qmq(b3, s1), qaq(qmq(b2, s2), qmq(b1, s3)));\n    //-------------------------------------\n    // const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\n    //-------------------------------------\n    const vᵧ = qno(qaq(qmq(a3, s1), qaq(qmq(a2, s2), qmq(a1, s3))));\n    //-------------------------------------------------------\n    // const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\n    //-------------------------------------------------------\n    const v = qaq(qmq(q1, qdq(qdq(tq2q4, q1q1), q1q5)), qdq(qmq(s3, q6), qmq(q3q4, q4)));\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1: () => (/* binding */ getImplicitForm1)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n\n/**\n * Returns the implicit form of the given linear bezier curve, i.e. line\n * segment.\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in **double** precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a line segment given as an array of its control points,\n * e.g. `[[1,2],[3,4]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm1(ps) {\n    // The implicit form is given by:\n    // vₓx + vᵧy + v = 0\n    const [[a1, a0], [b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1)(ps);\n    const vₓ = -b1;\n    const vᵧ = a1;\n    const v = a0 * b1 - a1 * b0;\n    return { vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2: () => (/* binding */ getImplicitForm2)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n\n/**\n * Returns the implicit form of the given quadratic bezier curve.\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * intermediate calculations are done in **double** precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a quadratic bezier curve given as an array of its control points,\n * e.g. `[[1,2],[3,4],[5,7]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm2(ps) {\n    // The implicit form is given by:\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    const [[a2, a1, a0], [b2, b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2)(ps);\n    const q1 = a2 * b1 - a1 * b2;\n    const q2 = a2 * b0 - a0 * b2;\n    const vₓₓ = -b2 * b2;\n    const vₓᵧ = 2 * a2 * b2;\n    const vᵧᵧ = -a2 * a2;\n    const vₓ = b1 * q1 - 2 * b2 * q2;\n    const vᵧ = 2 * a2 * q2 - a1 * q1;\n    const v = q1 * (a1 * b0 - a0 * b1) - q2 * q2;\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3: () => (/* binding */ getImplicitForm3)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n\n/**\n * Returns the implicit form of the given cubic bezier curve.\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n * * takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79\n *\n * @param ps a cubic bezier curve given as an array of its control points,\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\n *\n * @doc mdx\n */\nfunction getImplicitForm3(ps) {\n    // The implicit form is given by:\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3)(ps);\n    const a3b1 = a3 * b1;\n    const a1b3 = a1 * b3;\n    const a3b2 = a3 * b2;\n    const a2b3 = a2 * b3;\n    const a3a3 = a3 * a3;\n    const b3b3 = b3 * b3;\n    const q1 = a3 * b0 - a0 * b3;\n    const q2 = a3b1 - a1b3;\n    const q3 = a3b2 - a2b3;\n    const q4 = a2 * b0 - a0 * b2;\n    const q5 = a2 * b1 - a1 * b2;\n    const q6 = a1 * b0 - a0 * b1;\n    const tq2 = 2 * q2;\n    const q1q1 = q1 * q1;\n    const q1q5 = q1 * q5;\n    const tq2q4 = tq2 * q4;\n    const q3q4 = q3 * q4;\n    const u1 = -3 * q1 - q5;\n    const vₓₓₓ = -b3 * b3b3;\n    const vₓₓᵧ = 3 * a3 * b3b3;\n    const vₓᵧᵧ = -3 * b3 * a3a3;\n    const vᵧᵧᵧ = a3 * a3a3;\n    const vₓₓ = (u1 * b3b3 + q3 * (b1 * b3 - b2 * b2)) + tq2 * b2 * b3;\n    const vᵧᵧ = (u1 * a3a3 + q3 * (a1 * a3 - a2 * a2)) + tq2 * a2 * a3;\n    const vₓᵧ = 2 * (q3 * (a2 * b2 - (a1b3 + a3b1) / 2) - (u1 * a3 * b3 + q2 * (a2b3 + a3b2)));\n    const s1 = (-3 * q1q1 - 2 * q1q5) + (tq2q4 + q3 * q6);\n    const s2 = 2 * (q1 * q2 - q3q4);\n    const s3 = q1 * q3 - q2 * q2 + q3 * q5;\n    const vₓ = b3 * s1 + (b2 * s2 + b1 * s3);\n    const vᵧ = -a3 * s1 - (a2 * s2 + a1 * s3);\n    const v = (q1 * ((tq2q4 - q1q1) - q1q5)) + (s3 * q6 - q3q4 * q4);\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateImplicit1: () => (/* binding */ evaluateImplicit1)\n/* harmony export */ });\n/**\n * Evaluates and returns the result of evaluating the given implicit function\n * (a degree 1 bivariate polynomial in `x` and `y`) at the point `[x,y]`.\n *\n * * the implicit form is given by: `vₓ*x + vᵧ*y + v`, where the `vₓ`, `vₓ`, `v`,\n * etc are constants\n *\n * @example\n * ```typescript\n * evaluateImplicit1({ vₓ: 1, vᵧ: 2, v: 3 }, 1, 1);  //=> 6\n * ```\n *\n * @param cs the polynomial to evaluate\n * @param x the `x` variable at which to evaluate\n * @param y the `y` variable at which to evaluate\n *\n * @doc\n */\nfunction evaluateImplicit1(cs, x, y) {\n    const { vₓ, vᵧ, v } = cs;\n    return vₓ * x + vᵧ * y + v;\n}\n\n//# sourceMappingURL=evaluate-implicit1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateImplicit2: () => (/* binding */ evaluateImplicit2)\n/* harmony export */ });\n/**\n * Evaluates and returns the result of evaluating the given implicit function\n * (a degree 2 bivariate polynomial in `x` and `y`) at the point `[x,y]`.\n *\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`, where the `vₓ`, `vₓ`, `v`,\n * etc are constants\n *\n * @example\n * ```typescript\n * evaluateImplicit2({ vₓₓ: 4, vₓᵧ: 5, vᵧᵧ: 6, vₓ: 1, vᵧ: 2, v: 3 }, 1, 1);  //=> 21\n * ```\n *\n * @param cs the polynomial to evaluate\n * @param x the `x` variable at which to evaluate\n * @param y the `y` variable at which to evaluate\n *\n * @doc\n */\nfunction evaluateImplicit2(cs, x, y) {\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = cs;\n    return vₓₓ * x * x + vₓᵧ * x * y + vᵧᵧ * y * y + vₓ * x + vᵧ * y + v;\n}\n\n//# sourceMappingURL=evaluate-implicit2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateImplicit3: () => (/* binding */ evaluateImplicit3)\n/* harmony export */ });\n/**\n * Evaluates and returns the result of evaluating the given implicit function\n * (a degree 3 bivariate polynomial in `x` and `y`) at the point `[x,y]`.\n *\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`,\n * where the `vₓ`, `vₓ`, `v`, etc are constants\n *\n * @example\n * ```typescript\n * evaluateImplicit3({ vₓₓₓ: -1, vₓₓᵧ: -2, vₓᵧᵧ: -3, vᵧᵧᵧ: -4, vₓₓ: 4, vₓᵧ: 5, vᵧᵧ: 6, vₓ: 1, vᵧ: 2, v: 3 }, 7, -4);  //=> 123\n * ```\n *\n * @param cs the polynomial to evaluate\n * @param x the `x` variable at which to evaluate\n * @param y the `y` variable at which to evaluate\n *\n * @doc\n */\nfunction evaluateImplicit3(cs, x, y) {\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = cs;\n    return (vₓₓₓ * x * x * x +\n        vₓₓᵧ * x * x * y +\n        vₓᵧᵧ * x * y * y +\n        vᵧᵧᵧ * y * y * y +\n        vₓₓ * x * x +\n        vₓᵧ * x * y +\n        vᵧᵧ * y * y +\n        vₓ * x +\n        vᵧ * y +\n        v);\n}\n\n//# sourceMappingURL=evaluate-implicit3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1Exact: () => (/* binding */ getImplicitForm1Exact),\n/* harmony export */   getImplicitForm1ExactPb: () => (/* binding */ getImplicitForm1ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eNegativeOf;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\n/**\n * Returns the *exact* implicit form of the given linear bezier curve (a line\n * segment) or `undefined` if the line degenerates to a point.\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps\n *\n * @doc mdx\n */\nfunction getImplicitForm1Exact(ps) {\n    return getImplicitForm1ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps));\n}\n/**\n * The power basis version of [[getImplicitForm1Exact]].\n *\n * @param pspb the power basis representation of a linear bezier curve that\n * can be found via [[toPowerBasis1Exact]]\n *\n * @internal\n */\nfunction getImplicitForm1ExactPb(pspb) {\n    const [[a1, [a0]], [b1, [b0]]] = pspb;\n    if (eSign(a1) === 0 && eSign(b1) === 0) {\n        // the input bezier curve is in fact not linear but has order < 1\n        // it is a point and no implicit form is possible\n        return undefined;\n    }\n    const vₓ = eno(b1);\n    const vᵧ = a1;\n    //const v = a1*b0 - a0*b1;\n    const v = edif(sce(a0, b1), sce(b0, a1));\n    return { vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2Exact: () => (/* binding */ getImplicitForm2Exact),\n/* harmony export */   getImplicitForm2ExactPb: () => (/* binding */ getImplicitForm2ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-implicit-form1-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMultBy2;\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.expansionProduct;\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eNegativeOf;\n/**\n * Returns the exact implicit form of the given quadratic bezier curve\n * or `undefined` if the curve degenerates to a point.\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps\n *\n * @doc mdx\n */\nfunction getImplicitForm2Exact(ps) {\n    return getImplicitForm2ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_5__.toPowerBasis2Exact)(ps));\n}\n/**\n * The power basis version of [[getImplicitForm2Exact]].\n *\n * @param pspb the power basis representation of a quadratic bezier curve that\n * can be found via [[toPowerBasis2Exact]]\n *\n * @internal\n */\nfunction getImplicitForm2ExactPb(pspb) {\n    const [[a2, a1, [a0]], [b2, b1, [b0]]] = pspb;\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eSign)(a2) === 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eSign)(b2) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm1ExactPb)([[a1, [a0]], [b1, [b0]]]);\n    }\n    const a2b1 = epr(a2, b1);\n    const a1b2 = epr(a1, b2);\n    const a2b0 = sce(b0, a2);\n    const a0b2 = sce(a0, b2);\n    const a1b0 = sce(b0, a1);\n    const a0b1 = sce(a0, b1);\n    const a2a2 = epr(a2, a2);\n    const a2b2 = epr(a2, b2);\n    const b2b2 = epr(b2, b2);\n    const q1 = edif(a2b1, a1b2);\n    const q2 = edif(a2b0, a0b2);\n    const q3 = edif(a1b0, a0b1);\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\n    // b2**2*x**2\n    // -b2**2 *x**2\n    const vₓₓ = eno(b2b2);\n    // -2*a2*b2*x*y\n    // 2*a2*b2 *x*y\n    const vₓᵧ = em2(a2b2);\n    // a2**2*y**2\n    // -a2**2 *y**2 \n    const vᵧᵧ = eno(a2a2);\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\n    // (b1*q1 + -2*b2*q2) *x\n    //const vₓ = b1*q1 - 2*b2*q2;\n    const w1 = epr(b1, q1);\n    const w2 = em2(epr(b2, q2));\n    const vₓ = edif(w1, w2);\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\n    // (-a1*q1 + 2*a2*q2) *y\n    const w3 = em2(epr(a2, q2));\n    const w4 = epr(a1, q1);\n    const vᵧ = edif(w3, w4);\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\n    // q1*q3 + -q2**2\n    const w5 = epr(q1, q3);\n    const w6 = epr(q2, q2);\n    const v = edif(w5, w6);\n    //console.log({ vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v })\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3Exact: () => (/* binding */ getImplicitForm3Exact),\n/* harmony export */   getImplicitForm3ExactPb: () => (/* binding */ getImplicitForm3ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-implicit-form2-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\n\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eDiff;\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eNegativeOf;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMultBy2;\nconst ed2 = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eDivBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_7__.eSign;\n/**\n * Returns the exact implicit form of the given cubic bezier curve\n * or `undefined` if the curve degenerates to a point.\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps\n *\n * @doc mdx\n */\nfunction getImplicitForm3Exact(ps) {\n    // Takes about 155 micro-seconds on a 3rd gen i7 and Chrome 79.\n    return getImplicitForm3ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_8__.toPowerBasis3Exact)(ps));\n}\n/**\n * The power basis version of [[getImplicitForm3Exact]].\n *\n * @param pspb the power basis representation of a cubic bezier curve that can\n * be found via [[toPowerBasis3Exact]]\n *\n * @internal\n */\nfunction getImplicitForm3ExactPb(pspb) {\n    const [[a3, a2, a1, [a0]], [b3, b2, b1, [b0]]] = pspb;\n    if (eSign(a3) === 0 && eSign(b3) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm2ExactPb)([[a2, a1, [a0]], [b2, b1, [b0]]]);\n    }\n    const a3b1 = epr(a3, b1);\n    const a1b3 = epr(a1, b3);\n    const a3b2 = epr(a3, b2);\n    const a2b2 = epr(a2, b2);\n    const a2b3 = epr(a2, b3);\n    const a3a3 = epr(a3, a3);\n    const b2b2 = epr(b2, b2);\n    const b3b3 = epr(b3, b3);\n    const a1a3 = epr(a1, a3);\n    const a2a2 = epr(a2, a2);\n    const b1b3 = epr(b1, b3);\n    const b2b3 = epr(b2, b3);\n    const a2a3 = epr(a2, a3);\n    const a3b3 = epr(a3, b3);\n    const a3b0 = sce(b0, a3);\n    const a0b3 = sce(a0, b3);\n    const a2b0 = sce(b0, a2);\n    const a0b2 = sce(a0, b2);\n    const a2b1 = epr(a2, b1);\n    const a1b2 = epr(a1, b2);\n    const a1b0 = sce(b0, a1);\n    const a0b1 = sce(a0, b1);\n    const q1 = edif(a3b0, a0b3);\n    const q2 = edif(a3b1, a1b3);\n    const q3 = edif(a3b2, a2b3);\n    const q4 = edif(a2b0, a0b2);\n    const q5 = edif(a2b1, a1b2);\n    const q6 = edif(a1b0, a0b1);\n    const t1 = edif(b1b3, b2b2);\n    const t2 = edif(a1a3, a2a2);\n    const p1 = fes(a2b3, a3b2);\n    const p2 = fes(a1b3, a3b1);\n    const tq2 = em2(q2); // error free\n    const q1q1 = epr(q1, q1);\n    const q1q2 = epr(q1, q2);\n    const q1q3 = epr(q1, q3);\n    const q1q5 = epr(q1, q5);\n    const q2q2 = epr(q2, q2);\n    const tq2q4 = epr(tq2, q4);\n    const q3q4 = epr(q3, q4);\n    const q3q5 = epr(q3, q5);\n    const q3q6 = epr(q3, q6);\n    const vₓₓₓ = epr(eno(b3), b3b3);\n    const vₓₓᵧ = epr(sce(3, a3), b3b3);\n    const vₓᵧᵧ = epr(sce(-3, b3), a3a3);\n    const vᵧᵧᵧ = epr(a3, a3a3);\n    const u1 = edif(sce(-3, q1), q5);\n    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\n    const w1 = epr(u1, b3b3);\n    const w2 = epr(q3, t1);\n    const w3 = fes(w1, w2);\n    const w4 = epr(tq2, b2b3);\n    const vₓₓ = fes(w3, w4);\n    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\n    const w5 = epr(u1, a3a3);\n    const w6 = epr(q3, t2);\n    const w7 = fes(w5, w6);\n    const w8 = epr(tq2, a2a3);\n    const vᵧᵧ = fes(w7, w8);\n    //const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\n    const wa = edif(a2b2, ed2(p2));\n    const wb = epr(u1, a3b3);\n    const wc = epr(q2, p1);\n    const wd = fes(wb, wc);\n    const wq = epr(q3, wa);\n    const vₓᵧ = em2(edif(wq, wd));\n    //const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\n    const wr = sce(-3, q1q1);\n    const we = edif(wr, em2(q1q5));\n    const wf = fes(tq2q4, q3q6);\n    const s1 = fes(we, wf);\n    //const s2 = 2*(q1q2 - q3q4);\n    const s2 = em2(edif(q1q2, q3q4));\n    //const s3 = q1q3 - q2q2 + q3q5;\n    const wl = edif(q1q3, q2q2);\n    const s3 = fes(wl, q3q5);\n    //const vₓ = b3*s1 + (b2*s2 + b1*s3);\n    const wm = epr(b3, s1);\n    const ws = epr(b2, s2);\n    const wt = epr(b1, s3);\n    const wn = fes(ws, wt);\n    const vₓ = fes(wm, wn);\n    //const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\n    const wo = epr(a3, s1);\n    const wu = epr(a2, s2);\n    const wv = epr(a1, s3);\n    const wp = fes(wu, wv);\n    const vᵧ = eno(fes(wo, wp));\n    const v3 = edif(tq2q4, q1q1);\n    const v1 = edif(v3, q1q5);\n    const v4 = epr(s3, q6);\n    const v5 = epr(q3q4, q4);\n    const v2 = edif(v4, v5);\n    const v6 = epr(q1, v1);\n    //const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\n    const v = fes(v6, v2);\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\n}\n\n//# sourceMappingURL=get-implicit-form3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1ErrorCounters: () => (/* binding */ getImplicitForm1ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n\nconst abs = Math.abs;\n/**\n * Returns a representation of the error (from which an absolute error bound\n * can be calculated) when calculating the implicit form of the given bezier\n * curve (using [[getImplicitForm1]] or [[getImplicitForm1Dd]]).\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * the implicit form is given by: `vₓx + vᵧy + v`\n * * The returned error representation needs to be multiplied with\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\n * or double-double). This is explained in more detail below. See\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n * p. 68 near the bottom.\n *\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\n *\n * The absolute erros below can be calculated as follows (where `<E>` are the\n * error counters as indicated in the comments of the return value below):\n *  * double precision: `<E> * (γ(1)) * result_`\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\n *\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\n * and `γγ(3) === 3.697785493223493e-32`.\n *\n * ```\n * return {\n *      vₓ_,  // <1>\n *      vᵧ_,  // <1>\n *      v_    // <3>\n * }\n * ```\n *\n * @param ps\n *\n * @doc\n */\nfunction getImplicitForm1ErrorCounters(ps) {\n    // The implicit form is given by:\n    // vₓx + vᵧy + v = 0\n    //const [[a1, a0], [b1, b0]] = toPowerBasis1ErrorCounters(ps);\n    const [a0, b0] = ps[0];\n    const [[a1_], // <1>a1\n    [b1_] // <1>b1\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1ErrorCounters)(ps);\n    // <3>v <-- <3>(<2>(<0>a0*<1>b1) - <2>(<1>a1*<0>b0))\n    const v_ = abs(a0) * b1_ + abs(b0) * a1_; // <3>\n    return {\n        vₓ_: b1_,\n        vᵧ_: a1_,\n        v_ // <3>\n    };\n}\n\n//# sourceMappingURL=get-implicit-form1-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2ErrorCounters: () => (/* binding */ getImplicitForm2ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n\nconst abs = Math.abs;\n/**\n * Returns a representation of the error (from which an absolute error bound\n * can be calculated) when calculating the implicit form of the given bezier\n * curve (using [[getImplicitForm2]] or [[getImplicitForm2Dd]]).\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`\n * * The returned error representation needs to be multiplied with\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\n * or double-double). This is explained in more detail below. See\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n * p. 68 near the bottom.\n *\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\n *\n * The absolute erros below can be calculated as follows (where `<E>` are the\n * error counters as indicated in the comments of the return value below):\n *  * double precision: `<E> * (γ(1)) * result_`\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\n *\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\n * and `γγ(3) === 3.697785493223493e-32`.\n *\n * ```\n * return {\n *      vₓₓ_,  // <5>\n *      vₓᵧ_,  // <5>\n *      vᵧᵧ_,  // <5>\n *      vₓ_,   // <8>\n *      vᵧ_,   // <8>\n *      v_     // <10>\n * }\n * ```\n *\n * @param ps\n *\n * @doc\n */\nfunction getImplicitForm2ErrorCounters(ps) {\n    // The implicit form is given by:\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    //const [[,,a0],[,,b0]] = toPowerBasis2ErrorCounters(ps);\n    const [a0, b0] = ps[0];\n    const [[a2_, a1_], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))\n    [b2_, b1_] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2ErrorCounters)(ps);\n    //-------------------\n    // Error calculation\n    //-------------------\n    const a0_ = abs(a0);\n    const b0_ = abs(b0);\n    // <5>q1 <-- <5>(<4>(<2>a2*<1>b1) - <4>(a1*b2))\n    const q1_ = a2_ * b1_ + a1_ * b2_;\n    // <4>q2 <-- <4>(<3>(a2*b0) - <3>(a0*b2))\n    const q2_ = a2_ * b0_ + a0_ * b2_;\n    // <5>vₓₓ <-- <5>(-<2>b2*<2>b2)\n    const vₓₓ_ = b2_ * b2_;\n    // <5>vₓᵧ <-- 2*a2*b2\n    const vₓᵧ_ = 2 * a2_ * b2_;\n    // <5>vᵧᵧ <-- -a2*a2\n    const vᵧᵧ_ = a2_ * a2_;\n    // <8>vₓ <-- <8>(<7>(<1>b1*<5>q1) - <7>(2*<2>b2*<4>q2))\n    const vₓ_ = b1_ * q1_ + 2 * b2_ * q2_;\n    // <8>vᵧ <-- <8>(<7>(2*<2>a2<4>q2) - <7>(<1>a1<5>q1))\n    const vᵧ_ = 2 * a2_ * q2_ + a1_ * q1_;\n    // <10>v <-- <10>(<9>(<5>q1*<3>(<2>(a1*b0) - <2>(a0*b1))) - <9>(<4>q2*<4>q2))\n    const v_ = q1_ * (a1_ * b0_ + a0_ * b1_) + q2_ * q2_;\n    return {\n        vₓₓ_,\n        vₓᵧ_,\n        vᵧᵧ_,\n        vₓ_,\n        vᵧ_,\n        v_ // <10>\n    };\n}\n\n//# sourceMappingURL=get-implicit-form2-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3ErrorCounters: () => (/* binding */ getImplicitForm3ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n\nconst abs = Math.abs;\n/**\n * Returns a representation of the error (from which an absolute error bound\n * can be calculated) when calculating the implicit form of the given bezier\n * curve (using [[getImplicitForm1]] or [[getImplicitForm1Dd]]).\n *\n * * returned coefficients are subscripted to match their monomial's variables,\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`\n * * The returned error representation needs to be multiplied with\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\n * or double-double). This is explained in more detail below. See\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n * p. 68 near the bottom.\n *\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\n *\n * The absolute erros below can be calculated as follows (where `<E>` are the\n * error counters as indicated in the comments of the return value below):\n *  * double precision: `<E> * (γ(1)) * result_`\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\n *\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\n * and `γγ(3) === 3.697785493223493e-32`.\n *\n * ```\n * errorBound: {\n *      vₓₓₓ_,  // <11>\n *      vₓₓᵧ_,  // <12>\n *      vₓᵧᵧ_,  // <12>\n *      vᵧᵧᵧ_,  // <11>\n *      vₓₓ_,   // <19>\n *      vₓᵧ_,   // <18>\n *      vᵧᵧ_,   // <19>\n *      vₓ_,    // <22>\n *      vᵧ_,    // <22>\n *      v_      // <24>\n * }\n * ```\n * @param ps\n *\n * @doc\n */\nfunction getImplicitForm3ErrorCounters(ps) {\n    // Takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79.\n    // The implicit form is given by:\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\n    //const [[,,,a0],[,,,b0]] = toPowerBasis3ErrorCounters(ps);\n    const [a0, b0] = ps[0];\n    const [[a3_, a2_, a1_], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))\n    [b3_, b2_, b1_] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3ErrorCounters)(ps);\n    //-------------------\n    // Error calculation\n    //-------------------\n    const a0_ = abs(a0);\n    const b0_ = abs(b0);\n    // <6>a3b1 <-- <6>(<3>a3*<2>b1);\n    const a3b1_ = a3_ * b1_;\n    // <6>a1b3 <-- a1*b3;\n    const a1b3_ = a1_ * b3_;\n    // <7>a3b2 <-- <7>(<3>a3*<3>b2);\n    const a3b2_ = a3_ * b2_;\n    // <7>a2b3 <-- a2*b3;\n    const a2b3_ = a2_ * b3_;\n    // <7>a3a3 <-- a3*a3;\n    const a3a3_ = a3_ * a3_;\n    // <7>b3b3 <-- b3*b3;\n    const b3b3_ = b3_ * b3_;\n    // <5>q1 <-- <5>(<4>(a3*b0) - <4>(a0*b3));\n    const q1_ = a3_ * b0_ + a0_ * b3_;\n    // <7>q2 <-- <7>(<6>a3b1 - <6>a1b3);\n    const q2_ = a3b1_ + a1b3_;\n    // <8>q3 <-- <8>(<7>a3b2 - <7>a2b3);\n    const q3_ = a3b2_ + a2b3_;\n    // <5>q4 <-- a2*b0 - a0*b2;\n    const q4_ = a2_ * b0_ + a0_ * b2_;\n    // <7>q5 <-- a2*b1 - a1*b2;\n    const q5_ = a2_ * b1_ + a1_ * b2_;\n    // <4>q6 <-- <4>(<3>(<2>a1*<0>b0) - <3>(<0>a0*<2>b1));\n    const q6_ = a1_ * b0_ + a0_ * b1_;\n    // <7>tq2 <-- 2*q2;\n    const tq2_ = 2 * q2_;\n    // <11>q1q1 <-- <11>(<5>q1*<5>q1)\n    const q1q1_ = q1_ * q1_;\n    // <13>q1q5 <-- <13>(<5>q1*<7>q5)\n    const q1q5_ = q1_ * q5_;\n    // <13>tq2q4 <-- <13>(<7>tq2*<5>q4)\n    const tq2q4_ = tq2_ * q4_;\n    // <14>q3q4 <-- <14>(<8>q3*<5>q4)\n    const q3q4_ = q3_ * q4_;\n    // <8>u1 <-- <8>(<6>(-3*<5>q1) - <7>q5)\n    const u1_ = 3 * q1_ + q5_;\n    // <11>vₓₓₓ <-- <11>(-<3>b3*<7>b3b3)\n    const vₓₓₓ_ = b3_ * b3b3_;\n    // <12>vₓₓᵧ <--  <12>(3*<11>(<3>a3*<7>b3b3))\n    const vₓₓᵧ_ = 3 * a3_ * b3b3_;\n    // <12>vₓᵧᵧ <-- -3*b3*a3a3\n    const vₓᵧᵧ_ = 3 * b3_ * a3a3_;\n    // <11>vᵧᵧᵧ <--  a3*a3a3\n    const vᵧᵧᵧ_ = a3_ * a3a3_;\n    // <19>vₓₓ <-- <19>(<18>(<16>(<8>u1*<7>b3b3) + <17>(<8>q3*(<8>(<6>(b1*b3) - <7>(b2*b2))))) + <15>(<7>tq2*<7>(b2*b3)))\n    const vₓₓ_ = (u1_ * b3b3_ + q3_ * (b1_ * b3_ + b2_ * b2_)) + tq2_ * b2_ * b3_;\n    // <19>vᵧᵧ <-- <19>((<18>(<16>(<8>u1*<7>a3a3) + <17>(<8>q3*<8>(<6>(a1*a3) - <7>(a2*a2))))) + <15>(<7>tq2*<7>(a2*a3)))\n    const vᵧᵧ_ = (u1_ * a3a3_ + q3_ * (a1_ * a3_ + a2_ * a2_)) + tq2_ * a2_ * a3_;\n    // <18>vₓᵧ <-- <18>(2*(<17>(<8>q3*<8>(<7>(a2*b2) - <7>(<6>a1b3 + <6>a3b1)/2)) - <17>(<16>(<8>u1*<7>(a3*b3)) + <16>(<7>q2*(<8>(a2b3 + a3b2))))))\n    const vₓᵧ_ = 2 * (q3_ * (a2_ * b2_ + (a1b3_ + a3b1_) / 2) + (u1_ * a3_ * b3_ + q2_ * (a2b3_ + a3b2_)));\n    // <15>s1 <-- <15>(<14>(<12>(-3*q1q1) - <13>2*q1q5) + <14>(<13>tq2q4 + <13>(<8>q3*<4>q6)))\n    const s1_ = (3 * q1q1_ + 2 * q1q5_) + (tq2q4_ + q3_ * q6_);\n    // <15>s2 <-- <15>(2*(<13>(<5>q1*<7>q2) - <14>q3q4))\n    const s2_ = 2 * (q1_ * q2_ + q3q4_);\n    // <17>s3 <-- <17>(<16>(<14>(<5>q1*<8>q3) - <15>(<7>q2*<7>q2)) + <16>(<8>q3*<7>q5))\n    const s3_ = q1_ * q3_ + q2_ * q2_ + q3_ * q5_;\n    // <22>vₓ <-- <22>(<19>(<3>b3*<15>s1) + <21>(<19>(<3>b2*<15>s2) + <20>(<2>b1*<17>s3)))\n    const vₓ_ = b3_ * s1_ + (b2_ * s2_ + b1_ * s3_);\n    // <22>vᵧ <-- <22>(<19>(<3>-a3*<15>s1) - <21>(<19>(<3>a2*<15>s2) + <20>(<2>a1*<17>s3)))\n    const vᵧ_ = a3_ * s1_ + (a2_ * s2_ + a1_ * s3_);\n    // <24>v <-- <24>(<21>(<5>q1*<15>(<14>(<13>tq2q4 - <11>q1q1) - <13>q1q5)) + <23>(<22>(<17>s3*<4>q6) - <20>(<14>q3q4*<5>q4)))\n    const v_ = (q1_ * ((tq2q4_ + q1q1_) + q1q5_)) + (s3_ * q6_ + q3q4_ * q4_);\n    return {\n        vₓₓₓ_,\n        vₓₓᵧ_,\n        vₓᵧᵧ_,\n        vᵧᵧᵧ_,\n        vₓₓ_,\n        vₓᵧ_,\n        vᵧᵧ_,\n        vₓ_,\n        vᵧ_,\n        v_ // <24>\n    };\n}\n\n//# sourceMappingURL=get-implicit-form3-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoxesIntersecting: () => (/* reexport safe */ _boxes_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_100__.areBoxesIntersecting),\n/* harmony export */   area: () => (/* reexport safe */ _global_properties_area_js__WEBPACK_IMPORTED_MODULE_71__.area),\n/* harmony export */   bezierBezierIntersection: () => (/* reexport safe */ _intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_97__.bezierBezierIntersection),\n/* harmony export */   bezierBezierIntersectionBoundless: () => (/* reexport safe */ _intersection_bezier_bezier_intersection_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_122__.bezierBezierIntersectionBoundless),\n/* harmony export */   bezierBezierIntersectionFast: () => (/* reexport safe */ _intersection_bezier_bezier_intersection_fast_bezier_bezier_intersection_fast_js__WEBPACK_IMPORTED_MODULE_124__.bezierBezierIntersectionFast),\n/* harmony export */   bezierSelfIntersection: () => (/* reexport safe */ _intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_102__.bezierSelfIntersection),\n/* harmony export */   circleBezierIntersection: () => (/* reexport safe */ _intersection_circle_bezier_intersection_circle_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_101__.circleBezierIntersection),\n/* harmony export */   classification: () => (/* reexport safe */ _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__.classification),\n/* harmony export */   classifications: () => (/* reexport safe */ _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__.classifications),\n/* harmony export */   classify: () => (/* reexport safe */ _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__.classify),\n/* harmony export */   clone: () => (/* reexport safe */ _transformation_clone_js__WEBPACK_IMPORTED_MODULE_36__.clone),\n/* harmony export */   closestPointOnBezier: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_91__.closestPointOnBezier),\n/* harmony export */   closestPointOnBezierCertified: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_87__.closestPointOnBezierCertified),\n/* harmony export */   closestPointsBetweenBeziers: () => (/* reexport safe */ _simultaneous_properties_closest_distance_between_beziers_closest_distance_between_beziers_js__WEBPACK_IMPORTED_MODULE_138__.closestPointsBetweenBeziers),\n/* harmony export */   controlPointLinesLength: () => (/* reexport safe */ _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_63__.controlPointLinesLength),\n/* harmony export */   cubicFromAnglesAndSpeeds: () => (/* reexport safe */ _angles_and_speeds_bezier_by_angles_and_speeds_cubic_from_angles_and_speeds_js__WEBPACK_IMPORTED_MODULE_134__.cubicFromAnglesAndSpeeds),\n/* harmony export */   cubicThroughPointGiven013: () => (/* reexport safe */ _create_cubic_through_point_given013_js__WEBPACK_IMPORTED_MODULE_105__.cubicThroughPointGiven013),\n/* harmony export */   cubicToAnglesAndSpeeds: () => (/* reexport safe */ _angles_and_speeds_bezier_by_angles_and_speeds_cubic_to_angles_and_speeds_js__WEBPACK_IMPORTED_MODULE_135__.cubicToAnglesAndSpeeds),\n/* harmony export */   cubicToHybridQuadratic: () => (/* reexport safe */ _transformation_degree_or_type_cubic_to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_29__.cubicToHybridQuadratic),\n/* harmony export */   cubicToQuadratic: () => (/* reexport safe */ _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_82__.cubicToQuadratic),\n/* harmony export */   curvature: () => (/* reexport safe */ _local_properties_at_t_curvature_js__WEBPACK_IMPORTED_MODULE_21__.curvature),\n/* harmony export */   curviness: () => (/* reexport safe */ _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_74__.curviness),\n/* harmony export */   ddCurvature: () => (/* reexport safe */ _local_properties_at_t_dd_curvature_js__WEBPACK_IMPORTED_MODULE_23__.ddCurvature),\n/* harmony export */   eCurvature: () => (/* reexport safe */ _local_properties_at_t_e_curvature_js__WEBPACK_IMPORTED_MODULE_22__.eCurvature),\n/* harmony export */   equal: () => (/* reexport safe */ _simultaneous_properties_equal_js__WEBPACK_IMPORTED_MODULE_85__.equal),\n/* harmony export */   evalDeCasteljau: () => (/* reexport safe */ _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_107__.evalDeCasteljau),\n/* harmony export */   evalDeCasteljauDd: () => (/* reexport safe */ _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_121__.evalDeCasteljauDd),\n/* harmony export */   evalDeCasteljauError: () => (/* reexport safe */ _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_108__.evalDeCasteljauError),\n/* harmony export */   evalDeCasteljauWithErr: () => (/* reexport safe */ _local_properties_at_t_evaluate_double_eval_de_casteljau_with_err_js__WEBPACK_IMPORTED_MODULE_109__.evalDeCasteljauWithErr),\n/* harmony export */   evalDeCasteljauWithErrDd: () => (/* reexport safe */ _local_properties_at_t_evaluate_double_double_eval_de_casteljau_with_err_dd_js__WEBPACK_IMPORTED_MODULE_110__.evalDeCasteljauWithErrDd),\n/* harmony export */   evaluate: () => (/* reexport safe */ _local_properties_at_t_evaluate_double_evaluate_js__WEBPACK_IMPORTED_MODULE_113__.evaluate),\n/* harmony export */   evaluate2ndDerivative: () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_114__.evaluate2ndDerivative),\n/* harmony export */   evaluate2ndDerivativeAt0: () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_0_js__WEBPACK_IMPORTED_MODULE_8__.evaluate2ndDerivativeAt0),\n/* harmony export */   evaluate2ndDerivativeAt0Exact: () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_0_exact_js__WEBPACK_IMPORTED_MODULE_117__.evaluate2ndDerivativeAt0Exact),\n/* harmony export */   evaluate2ndDerivativeAt1: () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_1_js__WEBPACK_IMPORTED_MODULE_6__.evaluate2ndDerivativeAt1),\n/* harmony export */   evaluate2ndDerivativeAt1Exact: () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_1_exact_js__WEBPACK_IMPORTED_MODULE_118__.evaluate2ndDerivativeAt1Exact),\n/* harmony export */   evaluate2ndDerivativeExact: () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_116__.evaluate2ndDerivativeExact),\n/* harmony export */   evaluateExact: () => (/* reexport safe */ _local_properties_at_t_evaluate_exact_evaluate_exact_js__WEBPACK_IMPORTED_MODULE_111__.evaluateExact),\n/* harmony export */   evaluateImplicit1: () => (/* reexport safe */ _implicit_form_evaluate_double_evaluate_implicit1_js__WEBPACK_IMPORTED_MODULE_51__.evaluateImplicit1),\n/* harmony export */   evaluateImplicit2: () => (/* reexport safe */ _implicit_form_evaluate_double_evaluate_implicit2_js__WEBPACK_IMPORTED_MODULE_45__.evaluateImplicit2),\n/* harmony export */   evaluateImplicit3: () => (/* reexport safe */ _implicit_form_evaluate_double_evaluate_implicit3_js__WEBPACK_IMPORTED_MODULE_39__.evaluateImplicit3),\n/* harmony export */   fitQuadsToCubic: () => (/* reexport safe */ _fit_fit_quads_to_cubic_js__WEBPACK_IMPORTED_MODULE_126__.fitQuadsToCubic),\n/* harmony export */   fromPowerBasis: () => (/* reexport safe */ _from_power_basis_from_power_basis_js__WEBPACK_IMPORTED_MODULE_28__.fromPowerBasis),\n/* harmony export */   fromTo: () => (/* reexport safe */ _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_32__.fromTo),\n/* harmony export */   fromToInclErrorBound: () => (/* reexport safe */ _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_31__.fromToInclErrorBound),\n/* harmony export */   furthestPointOnBezier: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_92__.furthestPointOnBezier),\n/* harmony export */   generateCuspAtHalf3: () => (/* reexport safe */ _create_generate_cusp_at_half_t_js__WEBPACK_IMPORTED_MODULE_103__.generateCuspAtHalf3),\n/* harmony export */   generateQuarterCircle: () => (/* reexport safe */ _create_generate_quarter_circle_js__WEBPACK_IMPORTED_MODULE_93__.generateQuarterCircle),\n/* harmony export */   generateSelfIntersecting: () => (/* reexport safe */ _create_generate_self_intersecting_js__WEBPACK_IMPORTED_MODULE_104__.generateSelfIntersecting),\n/* harmony export */   getAbsAreaBetween: () => (/* reexport safe */ _fit_get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_133__.getAbsAreaBetween),\n/* harmony export */   getBendingEnergy: () => (/* reexport safe */ _global_properties_get_bending_energy_js__WEBPACK_IMPORTED_MODULE_70__.getBendingEnergy),\n/* harmony export */   getBoundingBox: () => (/* reexport safe */ _global_properties_bounds_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_62__.getBoundingBox),\n/* harmony export */   getBoundingBoxTight: () => (/* reexport safe */ _global_properties_bounds_get_bounding_box_tight_js__WEBPACK_IMPORTED_MODULE_61__.getBoundingBoxTight),\n/* harmony export */   getBoundingHull: () => (/* reexport safe */ _global_properties_bounds_get_bounding_hull_js__WEBPACK_IMPORTED_MODULE_60__.getBoundingHull),\n/* harmony export */   getBounds: () => (/* reexport safe */ _global_properties_bounds_get_bounds_js__WEBPACK_IMPORTED_MODULE_57__.getBounds),\n/* harmony export */   getCoeffsBezBez: () => (/* reexport safe */ _intersection_bezier_bezier_intersection_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_98__.getCoeffsBezBez),\n/* harmony export */   getControlPointBox: () => (/* reexport safe */ _global_properties_bounds_get_control_point_box_js__WEBPACK_IMPORTED_MODULE_125__.getControlPointBox),\n/* harmony export */   getCubicSpeeds: () => (/* reexport safe */ _angles_and_speeds_bezier_by_angles_and_speeds_get_cubic_speeds_js__WEBPACK_IMPORTED_MODULE_136__.getCubicSpeeds),\n/* harmony export */   getCurvatureExtrema: () => (/* reexport safe */ _get_curvature_extrema_get_curvature_extrema_js__WEBPACK_IMPORTED_MODULE_65__.getCurvatureExtrema),\n/* harmony export */   getCurvatureExtremaDd: () => (/* reexport safe */ _get_curvature_extrema_dd_get_curvature_extrema_dd_js__WEBPACK_IMPORTED_MODULE_66__.getCurvatureExtremaDd),\n/* harmony export */   getCurvatureExtremaE: () => (/* reexport safe */ _get_curvature_extrema_e_get_curvature_extrema_e_js__WEBPACK_IMPORTED_MODULE_67__.getCurvatureExtremaE),\n/* harmony export */   getEndpointIntersections: () => (/* reexport safe */ _intersection_get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_132__.getEndpointIntersections),\n/* harmony export */   getFootPointsOnBezierCertified: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_foot_points_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_88__.getFootPointsOnBezierCertified),\n/* harmony export */   getFootPointsOnBezierPolysCertified: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_foot_points_polys_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_89__.getFootPointsOnBezierPolysCertified),\n/* harmony export */   getFootpointPoly: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_get_footpoint_poly_js__WEBPACK_IMPORTED_MODULE_129__.getFootpointPoly),\n/* harmony export */   getFootpointPolyDd: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_double_get_footpoint_poly_dd_js__WEBPACK_IMPORTED_MODULE_130__.getFootpointPolyDd),\n/* harmony export */   getFootpointPolyExact: () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_exact_get_footpoint_poly_exact_js__WEBPACK_IMPORTED_MODULE_131__.getFootpointPolyExact),\n/* harmony export */   getHodograph: () => (/* reexport safe */ _transformation_get_hodograph_js__WEBPACK_IMPORTED_MODULE_77__.getHodograph),\n/* harmony export */   getImplicitForm1: () => (/* reexport safe */ _implicit_form_double_get_implicit_form1_js__WEBPACK_IMPORTED_MODULE_52__.getImplicitForm1),\n/* harmony export */   getImplicitForm1Dd: () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form1_dd_js__WEBPACK_IMPORTED_MODULE_53__.getImplicitForm1Dd),\n/* harmony export */   getImplicitForm1DdWithRunningError: () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_55__.getImplicitForm1DdWithRunningError),\n/* harmony export */   getImplicitForm1ErrorCounters: () => (/* reexport safe */ _implicit_form_get_error_counters_get_implicit_form1_error_counters_js__WEBPACK_IMPORTED_MODULE_54__.getImplicitForm1ErrorCounters),\n/* harmony export */   getImplicitForm1Exact: () => (/* reexport safe */ _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_56__.getImplicitForm1Exact),\n/* harmony export */   getImplicitForm2: () => (/* reexport safe */ _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_46__.getImplicitForm2),\n/* harmony export */   getImplicitForm2Dd: () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form2_dd_js__WEBPACK_IMPORTED_MODULE_47__.getImplicitForm2Dd),\n/* harmony export */   getImplicitForm2DdWithRunningError: () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_49__.getImplicitForm2DdWithRunningError),\n/* harmony export */   getImplicitForm2ErrorCounters: () => (/* reexport safe */ _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_48__.getImplicitForm2ErrorCounters),\n/* harmony export */   getImplicitForm2Exact: () => (/* reexport safe */ _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_50__.getImplicitForm2Exact),\n/* harmony export */   getImplicitForm3: () => (/* reexport safe */ _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_40__.getImplicitForm3),\n/* harmony export */   getImplicitForm3Dd: () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form3_dd_js__WEBPACK_IMPORTED_MODULE_41__.getImplicitForm3Dd),\n/* harmony export */   getImplicitForm3DdWithRunningError: () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_43__.getImplicitForm3DdWithRunningError),\n/* harmony export */   getImplicitForm3ErrorCounters: () => (/* reexport safe */ _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_42__.getImplicitForm3ErrorCounters),\n/* harmony export */   getImplicitForm3Exact: () => (/* reexport safe */ _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_44__.getImplicitForm3Exact),\n/* harmony export */   getInflections: () => (/* reexport safe */ _global_properties_get_inflections_js__WEBPACK_IMPORTED_MODULE_84__.getInflections),\n/* harmony export */   getInterfaceRotation: () => (/* reexport safe */ _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_90__.getInterfaceRotation),\n/* harmony export */   getIntervalBox: () => (/* reexport safe */ _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_64__.getIntervalBox),\n/* harmony export */   getIntervalBoxDd: () => (/* reexport safe */ _global_properties_bounds_get_interval_box_get_interval_box_dd_js__WEBPACK_IMPORTED_MODULE_106__.getIntervalBoxDd),\n/* harmony export */   getTAtLength: () => (/* reexport safe */ _local_properties_to_t_get_t_at_length_js__WEBPACK_IMPORTED_MODULE_26__.getTAtLength),\n/* harmony export */   getXBoundsTight: () => (/* reexport safe */ _global_properties_bounds_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_58__.getXBoundsTight),\n/* harmony export */   getYBoundsTight: () => (/* reexport safe */ _global_properties_bounds_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_59__.getYBoundsTight),\n/* harmony export */   hausdorffDistance: () => (/* reexport safe */ _simultaneous_properties_hausdorff_distance_hausdorff_distance_js__WEBPACK_IMPORTED_MODULE_95__.hausdorffDistance),\n/* harmony export */   hausdorffDistanceOneSided: () => (/* reexport safe */ _simultaneous_properties_hausdorff_distance_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_94__.hausdorffDistanceOneSided),\n/* harmony export */   intersectBoxes: () => (/* reexport safe */ _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_99__.intersectBoxes),\n/* harmony export */   isCollinear: () => (/* reexport safe */ _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_75__.isCollinear),\n/* harmony export */   isCubicReallyLine: () => (/* reexport safe */ _global_properties_classification_is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_81__.isCubicReallyLine),\n/* harmony export */   isCubicReallyQuad: () => (/* reexport safe */ _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_80__.isCubicReallyQuad),\n/* harmony export */   isHorizontal: () => (/* reexport safe */ _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_75__.isHorizontal),\n/* harmony export */   isPointOnBezierExtension: () => (/* reexport safe */ _simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_112__.isPointOnBezierExtension),\n/* harmony export */   isQuadObtuse: () => (/* reexport safe */ _global_properties_classification_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_73__.isQuadObtuse),\n/* harmony export */   isQuadReallyLine: () => (/* reexport safe */ _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_79__.isQuadReallyLine),\n/* harmony export */   isReallyPoint: () => (/* reexport safe */ _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_78__.isReallyPoint),\n/* harmony export */   isSelfOverlapping: () => (/* reexport safe */ _global_properties_classification_is_self_overlapping_js__WEBPACK_IMPORTED_MODULE_76__.isSelfOverlapping),\n/* harmony export */   isVertical: () => (/* reexport safe */ _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_75__.isVertical),\n/* harmony export */   length: () => (/* reexport safe */ _global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_69__.length),\n/* harmony export */   lineToCubic: () => (/* reexport safe */ _transformation_degree_or_type_line_to_cubic_js__WEBPACK_IMPORTED_MODULE_128__.lineToCubic),\n/* harmony export */   lineToQuadratic: () => (/* reexport safe */ _transformation_degree_or_type_line_to_quadratic_js__WEBPACK_IMPORTED_MODULE_127__.lineToQuadratic),\n/* harmony export */   maxAbsCoordinate: () => (/* reexport safe */ _error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_139__.maxAbsCoordinate),\n/* harmony export */   normal: () => (/* reexport safe */ _local_properties_at_t_normal_normal_js__WEBPACK_IMPORTED_MODULE_25__.normal),\n/* harmony export */   quadraticToCubic: () => (/* reexport safe */ _transformation_degree_or_type_quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_83__.quadraticToCubic),\n/* harmony export */   quadraticToPolyline: () => (/* reexport safe */ _fit_quadratic_to_polyline_js__WEBPACK_IMPORTED_MODULE_38__.quadraticToPolyline),\n/* harmony export */   reduceOrderIfPossible: () => (/* reexport safe */ _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_123__.reduceOrderIfPossible),\n/* harmony export */   reverse: () => (/* reexport safe */ _transformation_reverse_js__WEBPACK_IMPORTED_MODULE_30__.reverse),\n/* harmony export */   setCubicSpeeds: () => (/* reexport safe */ _angles_and_speeds_bezier_by_angles_and_speeds_set_cubic_speeds_js__WEBPACK_IMPORTED_MODULE_137__.setCubicSpeeds),\n/* harmony export */   splitByCurvature: () => (/* reexport safe */ _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_34__.splitByCurvature),\n/* harmony export */   splitByCurvatureAndLength: () => (/* reexport safe */ _transformation_split_split_by_curvature_and_length_js__WEBPACK_IMPORTED_MODULE_35__.splitByCurvatureAndLength),\n/* harmony export */   splitByLength: () => (/* reexport safe */ _transformation_split_split_by_length_js__WEBPACK_IMPORTED_MODULE_33__.splitByLength),\n/* harmony export */   tFromXY: () => (/* reexport safe */ _local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_96__.tFromXY),\n/* harmony export */   tangent: () => (/* reexport safe */ _local_properties_at_t_tangent_double_tangent_js__WEBPACK_IMPORTED_MODULE_24__.tangent),\n/* harmony export */   tangentAt0: () => (/* reexport safe */ _local_properties_at_t_tangent_double_tangent_at_0_js__WEBPACK_IMPORTED_MODULE_7__.tangentAt0),\n/* harmony export */   tangentAt0Exact: () => (/* reexport safe */ _local_properties_at_t_tangent_exact_tangent_at_0_exact_js__WEBPACK_IMPORTED_MODULE_119__.tangentAt0Exact),\n/* harmony export */   tangentAt1: () => (/* reexport safe */ _local_properties_at_t_tangent_double_tangent_at_1_js__WEBPACK_IMPORTED_MODULE_5__.tangentAt1),\n/* harmony export */   tangentAt1Exact: () => (/* reexport safe */ _local_properties_at_t_tangent_exact_tangent_at_1_exact_js__WEBPACK_IMPORTED_MODULE_120__.tangentAt1Exact),\n/* harmony export */   tangentExact: () => (/* reexport safe */ _local_properties_at_t_tangent_exact_tangent_exact_js__WEBPACK_IMPORTED_MODULE_115__.tangentExact),\n/* harmony export */   toCubic: () => (/* reexport safe */ _transformation_degree_or_type_to_cubic_js__WEBPACK_IMPORTED_MODULE_27__.toCubic),\n/* harmony export */   toPowerBasis: () => (/* reexport safe */ _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis),\n/* harmony export */   toPowerBasisDd: () => (/* reexport safe */ _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_12__.toPowerBasisDd),\n/* harmony export */   toPowerBasisDdWithRunningError: () => (/* reexport safe */ _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_18__.toPowerBasisDdWithRunningError),\n/* harmony export */   toPowerBasisErrorCounters: () => (/* reexport safe */ _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_19__.toPowerBasisErrorCounters),\n/* harmony export */   toPowerBasisExact: () => (/* reexport safe */ _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_13__.toPowerBasisExact),\n/* harmony export */   toPowerBasisWithRunningError: () => (/* reexport safe */ _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_17__.toPowerBasisWithRunningError),\n/* harmony export */   toPowerBasis_1stDerivative: () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_1stDerivative),\n/* harmony export */   toPowerBasis_1stDerivativeDd: () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_11__.toPowerBasis_1stDerivativeDd),\n/* harmony export */   toPowerBasis_1stDerivativeErrorCounters: () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_to_power_basis_1st_derivative_error_counters_js__WEBPACK_IMPORTED_MODULE_20__.toPowerBasis_1stDerivativeErrorCounters),\n/* harmony export */   toPowerBasis_1stDerivativeExact: () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_14__.toPowerBasis_1stDerivativeExact),\n/* harmony export */   toPowerBasis_2ndDerivative: () => (/* reexport safe */ _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis_2ndDerivative),\n/* harmony export */   toPowerBasis_2ndDerivativeDd: () => (/* reexport safe */ _to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_10__.toPowerBasis_2ndDerivativeDd),\n/* harmony export */   toPowerBasis_2ndDerivativeExact: () => (/* reexport safe */ _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_15__.toPowerBasis_2ndDerivativeExact),\n/* harmony export */   toPowerBasis_3rdDerivative: () => (/* reexport safe */ _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis_3rdDerivative),\n/* harmony export */   toPowerBasis_3rdDerivativeDd: () => (/* reexport safe */ _to_power_basis_to_power_basis_3rd_derivative_double_double_to_power_basis_3rd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_9__.toPowerBasis_3rdDerivativeDd),\n/* harmony export */   toPowerBasis_3rdDerivativeExact: () => (/* reexport safe */ _to_power_basis_to_power_basis_3rd_derivative_exact_to_power_basis_3rd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_16__.toPowerBasis_3rdDerivativeExact),\n/* harmony export */   toString: () => (/* reexport safe */ _transformation_to_string_js__WEBPACK_IMPORTED_MODULE_37__.toString),\n/* harmony export */   totalAbsoluteCurvature: () => (/* reexport safe */ _global_properties_total_absolute_curvature_js__WEBPACK_IMPORTED_MODULE_68__.totalAbsoluteCurvature),\n/* harmony export */   totalCurvature: () => (/* reexport safe */ _global_properties_total_absolute_curvature_js__WEBPACK_IMPORTED_MODULE_68__.totalCurvature),\n/* harmony export */   totalLength: () => (/* reexport safe */ _global_properties_length_total_length_js__WEBPACK_IMPORTED_MODULE_72__.totalLength),\n/* harmony export */   \"γ\": () => (/* reexport safe */ _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_86__[\"γ\"]),\n/* harmony export */   \"γγ\": () => (/* reexport safe */ _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_86__[\"γγ\"]),\n/* harmony export */   \"κ\": () => (/* reexport safe */ _local_properties_at_t_curvature_js__WEBPACK_IMPORTED_MODULE_21__[\"κ\"])\n/* harmony export */ });\n/* harmony import */ var _global_properties_bounds_get_bounding_hull_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./global-properties/bounds/get-bounding-hull.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js\");\n/* harmony import */ var _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global-properties/classification/classify.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/classify.js\");\n/* harmony import */ var _global_properties_area_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./global-properties/area.js */ \"./node_modules/flo-bezier3/node/global-properties/area.js\");\n/* harmony import */ var _global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./global-properties/length/length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length.js\");\n/* harmony import */ var _global_properties_length_total_length_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./global-properties/length/total-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/total-length.js\");\n/* harmony import */ var _transformation_clone_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./transformation/clone.js */ \"./node_modules/flo-bezier3/node/transformation/clone.js\");\n/* harmony import */ var _local_properties_to_t_get_t_at_length_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./local-properties-to-t/get-t-at-length.js */ \"./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js\");\n/* harmony import */ var _simultaneous_properties_equal_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./simultaneous-properties/equal.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/equal.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./transformation/split/from-to-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./transformation/split/from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n/* harmony import */ var _fit_fit_quads_to_cubic_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./fit/fit-quads-to-cubic.js */ \"./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js\");\n/* harmony import */ var _global_properties_bounds_get_control_point_box_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./global-properties/bounds/get-control-point-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js\");\n/* harmony import */ var _create_generate_quarter_circle_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./create/generate-quarter-circle.js */ \"./node_modules/flo-bezier3/node/create/generate-quarter-circle.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_fast_bezier_bezier_intersection_fast_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js\");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./boxes/intersect-boxes.js */ \"./node_modules/flo-bezier3/node/boxes/intersect-boxes.js\");\n/* harmony import */ var _boxes_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./boxes/are-boxes-intersecting.js */ \"./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/eval-de-casteljau-error.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_with_err_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_with_err_dd_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js\");\n/* harmony import */ var _simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js\");\n/* harmony import */ var _global_properties_total_absolute_curvature_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./global-properties/total-absolute-curvature.js */ \"./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js\");\n/* harmony import */ var _transformation_reverse_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./transformation/reverse.js */ \"./node_modules/flo-bezier3/node/transformation/reverse.js\");\n/* harmony import */ var _global_properties_get_inflections_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./global-properties/get-inflections.js */ \"./node_modules/flo-bezier3/node/global-properties/get-inflections.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js\");\n/* harmony import */ var _implicit_form_evaluate_double_evaluate_implicit3_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./implicit-form/evaluate/double/evaluate-implicit3.js */ \"./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js\");\n/* harmony import */ var _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./implicit-form/double/get-implicit-form3.js */ \"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form3-dd.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./implicit-form/get-error-counters/get-implicit-form3-error-counters.js */ \"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _implicit_form_evaluate_double_evaluate_implicit2_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./implicit-form/evaluate/double/evaluate-implicit2.js */ \"./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js\");\n/* harmony import */ var _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./implicit-form/double/get-implicit-form2.js */ \"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form2-dd.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./implicit-form/get-error-counters/get-implicit-form2-error-counters.js */ \"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _implicit_form_evaluate_double_evaluate_implicit1_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./implicit-form/evaluate/double/evaluate-implicit1.js */ \"./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js\");\n/* harmony import */ var _implicit_form_double_get_implicit_form1_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./implicit-form/double/get-implicit-form1.js */ \"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form1-dd.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form1_error_counters_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./implicit-form/get-error-counters/get-implicit-form1-error-counters.js */ \"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _from_power_basis_from_power_basis_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./from-power-basis/from-power-basis.js */ \"./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js\");\n/* harmony import */ var _transformation_get_hodograph_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./transformation/get-hodograph.js */ \"./node_modules/flo-bezier3/node/transformation/get-hodograph.js\");\n/* harmony import */ var _create_generate_cusp_at_half_t_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./create/generate-cusp-at-half-t.js */ \"./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js\");\n/* harmony import */ var _create_generate_self_intersecting_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./create/generate-self-intersecting.js */ \"./node_modules/flo-bezier3/node/create/generate-self-intersecting.js\");\n/* harmony import */ var _create_cubic_through_point_given013_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./create/cubic-through-point-given013.js */ \"./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js\");\n/* harmony import */ var _intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./intersection/self-intersection/bezier-self-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js\");\n/* harmony import */ var _intersection_get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./intersection/get-endpoint-intersections/get-endpoint-intersections.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js\");\n/* harmony import */ var _local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./local-properties-to-t/t-from-xy.js */ \"./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_double_to_power_basis_3rd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_exact_to_power_basis_3rd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_to_power_basis_1st_derivative_error_counters_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js\");\n/* harmony import */ var _local_properties_at_t_normal_normal_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./local-properties-at-t/normal/normal.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection/bezier-bezier-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js\");\n/* harmony import */ var _transformation_degree_or_type_to_cubic_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./transformation/degree-or-type/to-cubic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js\");\n/* harmony import */ var _local_properties_at_t_curvature_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./local-properties-at-t/curvature.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js\");\n/* harmony import */ var _local_properties_at_t_e_curvature_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./local-properties-at-t/e-curvature.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/e-curvature.js\");\n/* harmony import */ var _local_properties_at_t_dd_curvature_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./local-properties-at-t/dd-curvature.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/dd-curvature.js\");\n/* harmony import */ var _fit_quadratic_to_polyline_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./fit/quadratic-to-polyline.js */ \"./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js\");\n/* harmony import */ var _global_properties_classification_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./global-properties/classification/is-quad-obtuse.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_dd_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./global-properties/bounds/get-interval-box/get-interval-box-dd.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js\");\n/* harmony import */ var _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./simultaneous-properties/get-interface-rotation.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_foot_points_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-on-bezier-certified.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-on-bezier-certified.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_foot_points_polys_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js\");\n/* harmony import */ var _simultaneous_properties_hausdorff_distance_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js\");\n/* harmony import */ var _simultaneous_properties_hausdorff_distance_hausdorff_distance_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./simultaneous-properties/hausdorff-distance/hausdorff-distance.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js\");\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./global-properties/length/control-point-lines-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _transformation_split_split_by_length_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./transformation/split/split-by-length.js */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-length.js\");\n/* harmony import */ var _get_curvature_extrema_get_curvature_extrema_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./get-curvature-extrema/get-curvature-extrema.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js\");\n/* harmony import */ var _get_curvature_extrema_dd_get_curvature_extrema_dd_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./get-curvature-extrema-dd/get-curvature-extrema-dd.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-dd.js\");\n/* harmony import */ var _get_curvature_extrema_e_get_curvature_extrema_e_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./get-curvature-extrema-e/get-curvature-extrema-e.js */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-e/get-curvature-extrema-e.js\");\n/* harmony import */ var _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./global-properties/curviness.js */ \"./node_modules/flo-bezier3/node/global-properties/curviness.js\");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./transformation/split/split-by-curvature.js */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js\");\n/* harmony import */ var _transformation_split_split_by_curvature_and_length_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./transformation/split/split-by-curvature-and-length.js */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js\");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./global-properties/classification/is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _global_properties_classification_is_self_overlapping_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./global-properties/classification/is-self-overlapping.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js\");\n/* harmony import */ var _global_properties_bounds_get_bounds_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./global-properties/bounds/get-bounds.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js\");\n/* harmony import */ var _global_properties_bounds_get_bounding_box_tight_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./global-properties/bounds/get-bounding-box-tight.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js\");\n/* harmony import */ var _global_properties_bounds_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./global-properties/bounds/get-bounding-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./transformation/degree-or-type/cubic-to-hybrid-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js\");\n/* harmony import */ var _global_properties_classification_is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./global-properties/classification/is-cubic-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js\");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./global-properties/classification/is-quad-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js\");\n/* harmony import */ var _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./global-properties/classification/is-really-point.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _transformation_degree_or_type_quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./transformation/degree-or-type/quadratic-to-cubic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js\");\n/* harmony import */ var _intersection_circle_bezier_intersection_circle_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./intersection/circle-bezier-intersection/circle-bezier-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_exact_evaluate_exact_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/exact/evaluate-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_evaluate_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double/evaluate.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js\");\n/* harmony import */ var _transformation_degree_or_type_line_to_quadratic_js__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./transformation/degree-or-type/line-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js\");\n/* harmony import */ var _transformation_degree_or_type_line_to_cubic_js__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./transformation/degree-or-type/line-to-cubic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js\");\n/* harmony import */ var _local_properties_at_t_tangent_double_tangent_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./local-properties-at-t/tangent/double/tangent.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js\");\n/* harmony import */ var _local_properties_at_t_tangent_exact_tangent_exact_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./local-properties-at-t/tangent/exact/tangent-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js\");\n/* harmony import */ var _local_properties_at_t_tangent_exact_tangent_at_0_exact_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./local-properties-at-t/tangent/exact/tangent-at-0-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_0_exact_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js\");\n/* harmony import */ var _local_properties_at_t_tangent_exact_tangent_at_1_exact_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./local-properties-at-t/tangent/exact/tangent-at-1-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_1_exact_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js\");\n/* harmony import */ var _local_properties_at_t_tangent_double_tangent_at_0_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./local-properties-at-t/tangent/double/tangent-at-0.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_0_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js\");\n/* harmony import */ var _local_properties_at_t_tangent_double_tangent_at_1_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./local-properties-at-t/tangent/double/tangent-at-1.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_1_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js\");\n/* harmony import */ var _transformation_to_string_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./transformation/to-string.js */ \"./node_modules/flo-bezier3/node/transformation/to-string.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js\");\n/* harmony import */ var _global_properties_bounds_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./global-properties/bounds/get-x-bounds-tight.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js\");\n/* harmony import */ var _global_properties_bounds_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./global-properties/bounds/get-y-bounds-tight.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_exact_get_footpoint_poly_exact_js__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_get_footpoint_poly_js__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js\");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_double_get_footpoint_poly_dd_js__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js\");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./transformation/reduce-order-if-possible.js */ \"./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js\");\n/* harmony import */ var _fit_get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./fit/get-abs-area-between.js */ \"./node_modules/flo-bezier3/node/fit/get-abs-area-between.js\");\n/* harmony import */ var _global_properties_get_bending_energy_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./global-properties/get-bending-energy.js */ \"./node_modules/flo-bezier3/node/global-properties/get-bending-energy.js\");\n/* harmony import */ var _angles_and_speeds_bezier_by_angles_and_speeds_cubic_from_angles_and_speeds_js__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./angles-and-speeds/bezier-by-angles-and-speeds/cubic-from-angles-and-speeds.js */ \"./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-from-angles-and-speeds.js\");\n/* harmony import */ var _angles_and_speeds_bezier_by_angles_and_speeds_cubic_to_angles_and_speeds_js__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./angles-and-speeds/bezier-by-angles-and-speeds/cubic-to-angles-and-speeds.js */ \"./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/cubic-to-angles-and-speeds.js\");\n/* harmony import */ var _angles_and_speeds_bezier_by_angles_and_speeds_get_cubic_speeds_js__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./angles-and-speeds/bezier-by-angles-and-speeds/get-cubic-speeds.js */ \"./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/get-cubic-speeds.js\");\n/* harmony import */ var _angles_and_speeds_bezier_by_angles_and_speeds_set_cubic_speeds_js__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./angles-and-speeds/bezier-by-angles-and-speeds/set-cubic-speeds.js */ \"./node_modules/flo-bezier3/node/angles-and-speeds/bezier-by-angles-and-speeds/set-cubic-speeds.js\");\n/* harmony import */ var _simultaneous_properties_closest_distance_between_beziers_closest_distance_between_beziers_js__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./simultaneous-properties/closest-distance-between-beziers/closest-distance-between-beziers.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/closest-distance-between-beziers.js\");\n/* harmony import */ var _error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./error-analysis/max-abs-coordinate.js */ \"./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierBezierIntersectionFast: () => (/* binding */ bezierBezierIntersectionFast)\n/* harmony export */ });\n/* harmony import */ var _check_intersection_in_ranges_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./check-intersection-in-ranges.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js\");\n/* harmony import */ var _bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bezier-bezier-intersection/bezier-bezier-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js\");\n\n\nconst checkIntersectionInRanges = _check_intersection_in_ranges_js__WEBPACK_IMPORTED_MODULE_0__.checkIntersectionInRanges;\nconst bezierBezierIntersection = _bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersection;\nconst min = Math.min;\nconst max = Math.max;\nconst abs = Math.abs;\n/**\n * The guarantee in accuracy of the `t` parameter value chosen to be reasonable\n * for this type of intersection algorithm.\n */\nconst δ = 2 ** -33; // 2**(-33) === 1.1641532182693481e-10\n/** a heuristic value for the minimum t-span of the final iteration */\nconst Δ = 2 ** (-43); // 2**(-43) === 1.1368683772161603e-13\n/**\n * Accurate, fast (*eventually* cubically convergent) algorithm that returns\n * the intersections between two bezier curves (of order <= 3).\n *\n * * returns an array that contains the `t` paramater pairs at intersection\n * of the first and second bezier curves respectively.\n *\n * * Each returned `t` paramter value is mathematically guaranteed to be\n * accurate to within 2**-33 or about ten billionths of a unit.\n *\n * * the algorithm is based on a paper at http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\n * that finds the intersection of a fat line and a so-called geometric interval\n * making it faster than the standard fat-line intersection algorithm (that\n * is *eventually* only *quadratically* convergent)\n * * *eventually* cubically convergent (usually converging in about 4 to 8\n * iterations for typical intersections) but for hard intersections can become\n * extremely slow due to sub-linear convergence (and similarly for *all* fatline\n * algorithms) in those cases; luckily this algorithm detects those cases and\n * reverts to implicitization with strict error bounds to guarantee accuracy\n * and efficiency (implicitization is roughly 5x slower but is very rare)\n *\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ps2 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction bezierBezierIntersectionFast(ps1, ps2) {\n    if (ps1.length <= 2 || ps2.length <= 2) {\n        // revert to implicit form when it's going to be fast anyway\n        return implicit(ps1, ps2);\n    }\n    /** Intersection `t` values for both beziers */\n    const ts = [];\n    /** an iteration still left to check for intersections */\n    const iteration = {\n        F: ps1,\n        G: ps2,\n        fRange: [0, 1],\n        gRange: [0, 1],\n        last: undefined\n    };\n    const stack = [iteration];\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n        globalThis.__debug__.tree = iteration;\n    }\n    let iters = 0;\n    // A slight improvement to the algorithm may be possible by doing a \n    // breath-first (rather than depth-first) traversal and reverting to \n    // implicitization once the tree reaches a certain width\n    /** max iteration heuristic before reverting to implicitization */\n    const maxIters = 60;\n    while (stack.length !== 0 && iters < maxIters) {\n        iters++;\n        // keep TypeScript happy; `stack` cannot be empty here\n        const iter = stack.pop();\n        if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n            globalThis.__debug__.currentIter = iter;\n            iter.uid = globalThis.__debug__.uid++;\n        }\n        const newIterations = checkIntersectionInRanges(iter);\n        if (newIterations.length === 1) {\n            const newIter = newIterations[0];\n            const fRange = newIter.fRange;\n            const δδ = abs(fRange[1] - fRange[0]);\n            // if the previous iteration was precise enough\n            if (newIter.last) {\n                const lfRange = newIter.last.fRange;\n                if (δδ > δ) {\n                    // This case can occur when the geometric interval clips a\n                    // piece of the other bezier very far away but is by \n                    // coincidence of length < δ.\n                    // It can also occur in some other edge cases such as \n                    // self-overlapping cubic curves, etc.\n                    // revert to implicitization\n                    return implicit(ps1, ps2);\n                }\n                ts.push(iter.F === ps2\n                    ? [fRange, lfRange]\n                    : [lfRange, fRange]);\n                // else if this iteration is precise enough\n            }\n            else {\n                if (δδ < δ) {\n                    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n                        newIter.foundX = true;\n                    }\n                    if (δδ < Δ) {\n                        // destructively change the `fRange` as a heuristic so its not\n                        // too narrow for the final clip; this might only be a \n                        // problem if `fRange === 0` \n                        fRange[0] = max(0, fRange[0] - Δ);\n                        fRange[1] = min(1, fRange[1] + Δ);\n                    }\n                    newIter.last = newIter;\n                }\n                stack.push(newIter); // push the (possibly) final iteration\n            }\n        }\n        else if (newIterations.length === 2) {\n            //stack.push(...newIterations);\n            stack.push(newIterations[0], newIterations[1]);\n        }\n    }\n    if (iters === maxIters) {\n        if (globalThis.__debug__ !== undefined /* && !globalThis.__debug__.already*/) {\n            globalThis.__debug__.maxItersCount++;\n        }\n        return implicit(ps1, ps2);\n    }\n    if (globalThis.__debug__ !== undefined) {\n        // prevent further debugging\n        globalThis.__debug__.already = true;\n    }\n    //---------------------------------------------------------------\n    // check for possible duplicate intersections at split points\n    //---------------------------------------------------------------\n    ts.sort((t1, t2) => t1[0][0] - t2[0][0]);\n    combineXs(ts);\n    return ts.map(tPair => tPair.map(t => (t[0] + t[1]) / 2));\n}\nfunction combineXs(xs) {\n    let testAgain = true;\n    while (testAgain) {\n        testAgain = false;\n        for (let i = 1; i < xs.length; i++) {\n            const x1bez1 = xs[i - 1][0];\n            const x2bez1 = xs[i][0];\n            // if the prior tmax value is higher than the next t value's tmin\n            // then they overlap\n            if (x1bez1[1] >= x2bez1[0]) { // if overlap found\n                // Check if the second bezier's `t` values also overlap, else we\n                // have a loop getting intersected at its self-intersection point.\n                const x1bez2 = xs[i - 1][1];\n                const x2bez2 = xs[i][1];\n                const x1min = x1bez2[0];\n                const x1max = x1bez2[1];\n                const x2min = x2bez2[0];\n                const x2max = x2bez2[1];\n                const overlap = (x1min <= x2max && x1max >= x2min) ||\n                    (x2min <= x1max && x2max >= x1min);\n                if (overlap) {\n                    // combine ranges and test agin\n                    testAgain = true;\n                    const tMinBez2 = min(x1min, x1max, x2min, x2max);\n                    const tMaxBez2 = max(x1min, x1max, x2min, x2max);\n                    const x1min1 = x1bez1[0];\n                    const x1max1 = x1bez1[1];\n                    const x2min1 = x2bez1[0];\n                    const x2max1 = x2bez1[1];\n                    const tMinBez1 = min(x1min1, x1max1, x2min1, x2max1);\n                    const tMaxBez1 = max(x1min1, x1max1, x2min1, x2max1);\n                    const x = [\n                        [tMinBez1, tMaxBez1],\n                        [tMinBez2, tMaxBez2]\n                    ];\n                    // insert new combined intersection\n                    xs.splice(i - 1, 2, x);\n                    break; // break out of inner loop\n                }\n            }\n        }\n    }\n}\nfunction implicit(ps1, ps2) {\n    return bezierBezierIntersection(ps1, ps2).map(x => [x.t1, x.t2]);\n}\n\n//# sourceMappingURL=bezier-bezier-intersection-fast.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkIntersectionInRanges: () => (/* binding */ checkIntersectionInRanges)\n/* harmony export */ });\n/* harmony import */ var _clip_geo_clip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clip/geo-clip.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-length.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var _get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-distance-to-line-function.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js\");\n/* harmony import */ var _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transformation/split/from-to-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js\");\n\n\n\n\n\n\nconst getDistanceToLineFunction = _get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_0__.getDistanceToLineFunction;\nconst geoClip = _clip_geo_clip_js__WEBPACK_IMPORTED_MODULE_1__.geoClip;\nconst fromToInclErrorBound = _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromToInclErrorBound;\nconst fromToVect = flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.fromTo;\nconst translate = flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.translate;\nconst toLength = flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.toLength;\n/**\n * the heuristic value indicating the maximum `t` parameter span allowed after\n * clipping before perpendicular fatline clipping or curve splitting is\n * employed.\n */\nconst maxClipTSpan = 0.7;\n/**\n * Returns 0, 1 or 2 new narrowed ranges of possible intersections based on the\n * given current iteration's ranges.\n *\n * * helper function to the geometric interval bezier-bezier intersection\n * algorithm\n *\n * @param iter\n *\n * @internal\n */\nfunction checkIntersectionInRanges(iter) {\n    //--------------------------------------\n    // let { F, G, fRange, gRange } = iter;\n    const F = iter.F;\n    const G = iter.G;\n    const fRange = iter.fRange;\n    const gRange = iter.gRange;\n    //--------------------------------------\n    //-----------------------------------------------------------------------\n    // an invariant at this stage is that `eps | ftMin, ftMax, gtMin, gtMax`\n    //-----------------------------------------------------------------------\n    /**\n     * the minimum `t` value bound for the bezier that will be fatline bounded;\n     * it will not change during normal geo clipping\n     */\n    const ftMin = fRange[0];\n    /**\n     * the maximum `t` value bound for the bezier that will be fatline bounded;\n     * it will not change during normal geo clipping\n     */\n    const ftMax = fRange[1];\n    /**\n     * the minimum `t` value bound for the bezier that will be geo bounded;\n     * it will be geo clipped for the next iteration\n     */\n    const gtMin = gRange[0];\n    /**\n     * the maximum `t` value bound for the bezier that will be geo bounded;\n     * it will be geo clipped for the next iteration\n     */\n    const gtMax = gRange[1];\n    // Get the bezier curves (and an error bound) within the narrowed ranges\n    // Note: the error bound need be multiplied by `8u`, where \n    // `u === Number.EPSILON/2` (see `fromTo3` for details).\n    const F_ = fromToInclErrorBound(F, ftMin, ftMax);\n    const G_ = fromToInclErrorBound(G, gtMin, gtMax);\n    const Fps = F_.ps;\n    const F_ps = F_._ps;\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n        globalThis.__debug__.currentIter.F_ = F_;\n        globalThis.__debug__.currentIter.G_ = G_;\n    }\n    const lenF = Fps.length;\n    // Q will be fat line bounded. Get start and endpoint of curve\n    const FS = Fps[0];\n    const FE = Fps[lenF - 1];\n    // Note: The case where `FS` and `FE` are the same point will result in\n    // `geoClip` not clipping and returning 'no intersection' so we don't\n    // explicitly test for it here.\n    // Get the implict line equation for the line defined by the first and \n    // last control point of Q. This equation gives the distance between any \n    // point and the line (but scaled for efficiency *and* robustness).\n    const dF = getDistanceToLineFunction(FS, FE);\n    // Signed distances to cubic mid control points *plus* the first and last\n    // control points since there is an error bound involved that need to\n    // be included to ensure robustness\n    const dF0 = dF(Fps[0], F_ps[0]);\n    const dF1 = dF(Fps[1], F_ps[1]);\n    const dF2 = dF(Fps[2], F_ps[2]);\n    const dF3 = lenF === 4 ? dF(Fps[3], F_ps[3]) : { dMin: 0, dMax: 0 };\n    // Calculate the fat line of F.\n    // Calculate the distance from the control points of F to the line.\n    //let C = len === 4 ? (dF1*dF2 > 0) ? 3/4 : 4/9 : 1/2;\n    // The above calculation of C has been replaced by the one below so we can\n    // ensure robustness (`dF1` and `dF2` are not simply numbers but also have\n    // an error bound associated with them)\n    const C = lenF === 4 ? 3 / 4 : 1 / 2;\n    const dMin = C * Math.min(0, dF0.dMin, dF1.dMin, dF2.dMin, dF3.dMin);\n    const dMax = C * Math.max(0, dF0.dMax, dF1.dMax, dF2.dMax, dF3.dMax);\n    // Add fatline debug info\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n        globalThis.__debug__.currentIter.fatline = getFatlineDebugInfo(FS, FE, dMin, dMax);\n    }\n    const tRange = geoClip(G_, dF, dMin, dMax);\n    const last = iter.last;\n    if (tRange === undefined) {\n        return [];\n    }\n    let tMin = tRange[0];\n    let tMax = tRange[1];\n    if (!last && tMax - tMin > maxClipTSpan) {\n        // This optimization is for cases where the bezier curves meet nearly \n        // collinearly at interface points.\n        if (!clipPerp()) {\n            return [];\n        }\n    }\n    if (!last && tMax - tMin > maxClipTSpan) {\n        return split();\n    }\n    const gtSpan = gtMax - gtMin;\n    // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`\n    const tMin_ = gtMin + tMin * gtSpan + 1 - 1;\n    // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMax_`\n    const tMax_ = gtMin + tMax * gtSpan + 1 - 1;\n    // Swap Q and P and iterate.\n    const newIter = {\n        F: G, G: F,\n        fRange: [tMin_, tMax_],\n        gRange: fRange,\n        last\n    };\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n        newIter.parent = globalThis.__debug__.currentIter;\n        globalThis.__debug__.currentIter.children = [newIter];\n    }\n    return [newIter];\n    function clipPerp() {\n        // First try a fatline perpendicular to the prior one. This is \n        // important for efficiency especially in cases where the bezier\n        // curves meet (or almost meet) with nearly the same tangent and\n        // curvature.\n        const FSx = FS[0];\n        const FSy = FS[1];\n        const FEx = FE[0];\n        const FEy = FE[1];\n        // rotate [FS,FE] 90 degrees about FS\n        const V = [FSx + FSy - FEy, FSy + FEx - FSx];\n        const dQ_ = getDistanceToLineFunction(FS, V);\n        // Signed distances to other 3 control points *plus* the first\n        // control point since there is an error bound involved that need to\n        // be included to ensure robustness\n        const dF0_ = dQ_(Fps[0], F_ps[0]);\n        const dF1_ = dQ_(Fps[1], F_ps[1]);\n        const dF2_ = dQ_(Fps[2], F_ps[2]);\n        const dF3_ = lenF === 4 ? dQ_(Fps[3], F_ps[3]) : { dMin: 0, dMax: 0 };\n        const dMin_ = Math.min(0, dF0_.dMin, dF1_.dMin, dF2_.dMin, dF3_.dMin);\n        const dMax_ = Math.max(0, dF0_.dMax, dF1_.dMax, dF2_.dMax, dF3_.dMax);\n        // Add fatline debug info\n        if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n            globalThis.__debug__.currentIter.fatlinePerp = getFatlineDebugInfo(FS, V, dMin_, dMax_);\n        }\n        const tRange = geoClip(G_, dQ_, dMin_, dMax_);\n        if (tRange === undefined) {\n            return false;\n        }\n        const tMin_ = tRange[0];\n        const tMax_ = tRange[1];\n        tMin = Math.max(tMin, tMin_);\n        tMax = Math.min(tMax, tMax_);\n        return true;\n    }\n    /**\n     * Split the bezier curve.\n     */\n    function split() {\n        // The paper calls for a heuristic that if less than 30% will be\n        // clipped, rather split the longest curve and find intersections in the\n        // two halfs seperately.\n        const gtSpan = gtMax - gtMin;\n        const ftSpan = ftMax - ftMin;\n        // Split the curve in half\n        if (gtSpan >= ftSpan) {\n            // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`\n            const tMid = gtMin + gtSpan / 2 + 1 - 1;\n            const iter1 = { F, G, fRange, gRange: [gtMin, tMid], last };\n            const iter2 = { F, G, fRange, gRange: [tMid, gtMax], last };\n            if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n                iter1.parent = globalThis.__debug__.currentIter;\n                iter2.parent = globalThis.__debug__.currentIter;\n                globalThis.__debug__.currentIter.children = [iter2, iter1];\n            }\n            return [iter2, iter1];\n        }\n        // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`\n        const tMid = ftMin + ftSpan / 2 + 1 - 1;\n        const iter1 = { F, G, fRange: [ftMin, tMid], gRange, last };\n        const iter2 = { F, G, fRange: [tMid, ftMax], gRange, last };\n        if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n            iter1.parent = globalThis.__debug__.currentIter;\n            iter2.parent = globalThis.__debug__.currentIter;\n            globalThis.__debug__.currentIter.children = [iter2, iter1];\n        }\n        return [iter2, iter1];\n    }\n}\nfunction getFatlineDebugInfo(FS, FE, dMin, dMax) {\n    const vF = fromToVect(FS, FE); // Move [FS, FE] to the origin\n    const vFr = [-vF[1], vF[0]]; // Rotate vector by -90 degrees\n    // get scale factor `d` to scale back to actual distances \n    // (not perfectly accurate due to rounding)\n    const xS = FS[0];\n    const yS = FS[1];\n    const xE = FE[0];\n    const yE = FE[1];\n    const s = yS - yE;\n    const t = xE - xS;\n    const u = xS * yE - xE * yS;\n    const d = Math.sqrt(s ** 2 + t ** 2);\n    const offsetMin = toLength(vFr, dMin / d);\n    const offsetMax = toLength(vFr, dMax / d);\n    const psMin = [translate(FS, offsetMin), translate(FE, offsetMin)];\n    const psMax = [translate(FS, offsetMax), translate(FE, offsetMax)];\n    return {\n        psBase: [FS, FE],\n        psMin, psMax\n    };\n}\n\n//# sourceMappingURL=check-intersection-in-ranges.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   geoClip: () => (/* binding */ geoClip)\n/* harmony export */ });\n/* harmony import */ var _to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./to-hybrid-quadratic.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js\");\n\nconst toHybridQuadratic = _to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_0__.toHybridQuadratic;\nconst min = Math.min;\nconst max = Math.max;\nconst abs = Math.abs;\nconst eps = Number.EPSILON;\nconst u = eps / 2;\nconst onemin = 1 - eps;\nconst onemax = 1 + eps;\nconst noClip = [0, 1];\n/**\n * Performs geometric clipping of the given bezier curve and returns the new\n * minimum and maximum `t` parameter values.\n *\n * * helper function to the geometric interval bezier-bezier intersection\n * algorithm\n * * the returned min and max `t` values has the following guarantees:\n *   * `Number.EPSILON | t`\n *   * `0 <= t <= 1`\n *\n * @param G the bezier curve to be geo clipped - coordinate error bounds are\n * assumed to have counters of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`\n * @param dF function to calculate a min and max distance to the fat line's 'baseline'\n * @param dMin fat line min signed distance\n * @param dMax fat line max signed distance\n *\n * @internal\n */\nfunction geoClip(G, dF, dMin, dMax) {\n    // estimated bezier control points\n    const Gps = G.ps;\n    const lenG = Gps.length;\n    const _hq_ = lenG === 4\n        ? toHybridQuadratic(G)\n        : { hq: [Gps[1], Gps[1]], _hq: [[0, 0], [0, 0]] }; // degenerate\n    // estimated hybrid coordinates\n    const hq = _hq_.hq;\n    // hybrid coordinate error bounds with error counters of <8> and <12> for\n    // the two points respectively (both x and y coordinates have same error\n    // counters)\n    const _hq = _hq_._hq;\n    // coordinate error bounds are assumed to have counters \n    // of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`\n    const G_ps = G._ps;\n    /** min/max distance (from line) to hybrid quadratic (and cubic) first control point */\n    const dH0 = dF(Gps[0], G_ps[0]);\n    /** min/max distance (from line) to hybrid quadratic (and cubic) last control point */\n    const dH2 = dF(Gps[lenG - 1], G_ps[lenG - 1]);\n    /** min/max distance (from line) to hybrid quadratic's moving control point start */\n    const dH10 = dF(hq[0], _hq[0]);\n    /** min/max distance (from line) to hybrid quadratic's moving control point end */\n    const dH11 = dF(hq[1], _hq[1]);\n    const dH1min = min(dH10.dMin, dH11.dMin);\n    const dH1max = max(dH10.dMax, dH11.dMax);\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\n        const currentIter = globalThis.__debug__.currentIter;\n        // just for drawing purposes (not perfectle accurate)\n        currentIter.hq = [G.ps[0], ...hq, G.ps[lenG - 1]];\n        if (currentIter.geo) {\n            // we already did the first geoclip - assume this to be the perpendicular clip\n            currentIter.geoPerp = { dH0, dH10, dH11, dH2, dMin, dMax };\n        }\n        else {\n            currentIter.geo = { dH0, dH10, dH11, dH2, dMin, dMax };\n        }\n    }\n    const dH0Min = dH0.dMin;\n    const dH0Max = dH0.dMax;\n    const dH2Min = dH2.dMin;\n    const dH2Max = dH2.dMax;\n    //--------------------------------------------------------------------------\n    // see the paper at https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=2206&context=etd)\n    // After writing eq. (3.16) and (3.17) in power basis (by simply multiplying \n    // out and collecting terms) and taking error bounds into account:\n    //--------------------------------------------------------------------------\n    /** the quadratic term coefficient of the *lower* Bernstein basis polynomial */\n    const a = dH0Min - 2 * dH1min + dH2Min; // t^2 \n    /** the linear term coefficient of the *lower* Bernstein basis polynomial */\n    const b = -2 * (dH0Min - dH1min); // t^1\n    /**\n     * the constant term coefficient of the *lower* Bernstein basis polynomial's\n     * intersection with the lower fat line (dMin)\n     */\n    const c1 = dH0Min - dMin; // t^0 - dMin\n    /**\n     * the constant term coefficient of the *lower* Bernstein basis polynomial's\n     * intersection with the upper fat line (dMax)\n     */\n    const c2 = dH0Min - dMax; // t^0 - dMax\n    /** the quadratic term coefficient of the *upper* Bernstein basis polynomial */\n    const d = dH0Max - 2 * dH1max + dH2Max;\n    /** the linear term coefficient of the *upper* Bernstein basis polynomial */\n    const e = -2 * (dH0Max - dH1max);\n    /**\n     * the constant term coefficient of the *upper* Bernstein basis polynomial's\n     * intersection with the *lower* fat line (dMin)\n     */\n    const f1 = dH0Max - dMin;\n    /**\n     * the constant term coefficient of the *upper* Bernstein basis polynomial's\n     * intersection with the *upper* fat line (dMax)\n     */\n    const f2 = dH0Max - dMax;\n    //--------------------------------------------------------------------------\n    let tMin = Number.POSITIVE_INFINITY;\n    let tMax = Number.NEGATIVE_INFINITY;\n    /** *lower* Bernstein *lower* fatline roots */\n    const rootsMinBMinF = quadraticRoots(a, b, c1);\n    /** *lower* Bernstein *upper* fatline roots */\n    const rootsMinBMaxF = quadraticRoots(a, b, c2);\n    /** *upper* Bernstein *lower* fatline roots */\n    const rootsMaxBMinF = quadraticRoots(d, e, f1);\n    /** *upper* Bernstein *upper* fatline roots */\n    const rootsMaxBMaxF = quadraticRoots(d, e, f2);\n    // if there are an infinite number of roots, i.e. if the quadratic is\n    // really the zero polynomial\n    if (rootsMinBMinF === undefined || rootsMinBMaxF === undefined ||\n        rootsMaxBMinF === undefined || rootsMaxBMaxF === undefined) {\n        // no clipping could happen\n        return noClip;\n    }\n    //--------------------------------------------------------------------------\n    // see the paper at https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=2206&context=etd)\n    // According to the paper we can do clipping such that 2 intervals are\n    // sometimes returned. We just return the combined interval in those cases\n    // which might make the algorithm slightly slower but a bit simpler.\n    //--------------------------------------------------------------------------\n    for (let i = 0; i < rootsMinBMinF.length; i++) {\n        const r = rootsMinBMinF[i];\n        if (r < tMin) {\n            tMin = r;\n        }\n        if (r > tMax) {\n            tMax = r;\n        }\n    }\n    for (let i = 0; i < rootsMinBMaxF.length; i++) {\n        const r = rootsMinBMaxF[i];\n        if (r < tMin) {\n            tMin = r;\n        }\n        if (r > tMax) {\n            tMax = r;\n        }\n    }\n    for (let i = 0; i < rootsMaxBMinF.length; i++) {\n        const r = rootsMaxBMinF[i];\n        if (r < tMin) {\n            tMin = r;\n        }\n        if (r > tMax) {\n            tMax = r;\n        }\n    }\n    for (let i = 0; i < rootsMaxBMaxF.length; i++) {\n        const r = rootsMaxBMaxF[i];\n        if (r < tMin) {\n            tMin = r;\n        }\n        if (r > tMax) {\n            tMax = r;\n        }\n    }\n    if (dH0Max >= dMin && dH0Min <= dMax) {\n        tMin = 0;\n    }\n    if (dH2Max >= dMin && dH2Min <= dMax) {\n        tMax = 1;\n    }\n    if (tMin === Number.POSITIVE_INFINITY) {\n        // will have here also: `tMax === Number.NEGATIVE_INFINITY`\n        return undefined;\n    }\n    return [tMin, tMax];\n}\n/**\n * Floating-point-stably calculates and returns the (ordered) quadratic roots of\n * the given quadratic polynomial in [0,1].\n *\n * * **precondition:** the input polynomial must be quadratic (given as an array\n * of exactly 3 values with the first value *unequal* to zero)\n *\n * @param p a quadratic polynomial with coefficients given as an array\n * of double floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the quadratic `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * quadraticRoots([1, -3, 2]); //=> [1,2]\n * ```\n *\n * @internal\n */\nfunction quadraticRoots(a, b, c) {\n    if (a === 0) {\n        if (b === 0) {\n            // degenerate constant (degree 0 polynomial)\n            if (c === 0) {\n                // degenerate zero polynomial (degree -infinity polynomial)\n                // infinite number of roots\n                return undefined;\n            }\n            // no roots\n            return [];\n        }\n        // degenerate linear\n        //return [-c/b];\n        const r = -c / b;\n        const E = abs(r * u);\n        const Emin = r - E;\n        const Emax = r + E;\n        if (Emax < 0 || Emin > 1) {\n            return [];\n        }\n        if (Emin < 0 && Emax > 0) {\n            return [0, Emax];\n        }\n        if (Emin < 1 && Emax > 1) {\n            return [Emin, 1];\n        }\n        // we return the root interval pairs inline to account for error\n        return [Emin, Emax];\n    }\n    if (c === 0) {\n        const r = -b / a;\n        const E = abs(r * u);\n        const Emin = r - E;\n        const Emax = r + E;\n        if (Emax < 0 || Emin > 1) {\n            return [0];\n        }\n        if (Emin < 0 && Emax > 0) {\n            return [0, Emax];\n        }\n        if (Emin < 1 && Emax > 1) {\n            return [0, Emin, 1];\n        }\n        // we return the root interval pairs inline to account for error\n        return [0, Emin, Emax];\n    }\n    const D1 = b * b; // <1>D1 (error counters)\n    const D2 = 4 * a * c; // <1>D2\n    const D = D1 - D2;\n    // <2>D <= D1 - D2;  // <2>(<1>D1 + <1>D2)\n    const _D = D1 + abs(D2);\n    const D_ = 2 * u * _D;\n    if (D + D_ < 0) {\n        // no real roots possible\n        return [];\n    }\n    // at this point `D + D_ >= 0`\n    if (D + D_ === 0) {\n        const r = -b / (2 * a);\n        const E = abs(r * u); // single division error\n        const Emin = r - E;\n        const Emax = r + E;\n        if (Emax < 0 || Emin > 1) {\n            return [];\n        }\n        if (Emin < 0 && Emax > 0) {\n            return [0, Emax];\n        }\n        if (Emin < 1 && Emax > 1) {\n            return [Emin, 1];\n        }\n        // we return the root interval pairs inline to account for error\n        return [Emin, Emax];\n    }\n    // at this point `D + D_ > 0`\n    const Dmin = D - D_ < 0 ? 0 : D - D_;\n    const DDmin = Math.sqrt(Dmin) * (onemin);\n    const DDmax = Math.sqrt(D + D_) * (onemax);\n    // at this point DDMax > 0\n    // at this point `DDmax > 0` and `DDmin >= 0`\n    let numerMaxAbs;\n    let numerMinAbs;\n    if (b >= 0) {\n        numerMaxAbs = -b - DDmax;\n        numerMinAbs = -b - DDmin;\n    }\n    else {\n        numerMinAbs = -b + DDmin;\n        numerMaxAbs = -b + DDmax;\n    }\n    const a2 = 2 * a;\n    const c2 = 2 * c;\n    //const r1 = numerMin / a2;\n    //const r2 = c2 / numerMin;\n    // at this point `numerMin` and `numerMax` have the same sign (or numerMin is zero)\n    let r1min;\n    let r1max;\n    let r2min;\n    let r2max;\n    if (numerMaxAbs * a2 >= 0) {\n        // same signs - `r1min >= 0` and `r1max > 0`\n        r1min = (numerMinAbs / a2) * (onemin);\n        r1max = (numerMaxAbs / a2) * (onemax);\n    }\n    else {\n        // opposite signs - `r1min <= 0` and `r1max < 0`\n        r1min = (numerMaxAbs / a2) * (onemax);\n        r1max = (numerMinAbs / a2) * (onemin);\n    }\n    if (numerMaxAbs * c2 > 0) {\n        // same signs - `r2min > 0` and `r2Max >= 0`\n        r2min = (c2 / numerMaxAbs) * (onemin);\n        // `r2max` cannot be a `NaN` since `c2` is > 0\n        r2max = (c2 / numerMinAbs) * (onemax); // could be +-inf\n    }\n    else if (numerMaxAbs * c2 < 0) {\n        // opposite signs - `r2min < 0` and `r2Max <= 0`\n        // `r2min` cannot be a `NaN` since `c2` is > 0\n        r2min = (c2 / numerMinAbs) * (onemax); // could be +-inf \n        r2max = (c2 / numerMaxAbs) * (onemin);\n    }\n    const rs = [];\n    if (r1max < 0 || r1min > 1) {\n        // root is outside of range\n    }\n    else {\n        // we return the root interval pairs inline\n        // at this stage r1min might be (slightly) < 0 and r1max > 1\n        rs.push(r1min < 0 ? 0 : r1min, r1max > 1 ? 1 : r1max);\n    }\n    // keep TypeScript happy; `r2max` cannot be `undefined` at this point\n    if (r2max < 0 || r2min > 1) {\n        // root is outside of range\n    }\n    else {\n        // we return the root interval pairs inline\n        // at this stage r2min might be (slightly) < 0 and r2max > 1\n        // keep TypeScript happy; `r2max` cannot be `undefined` at this point\n        rs.push(r2min < 0 ? 0 : r2min, r2max > 1 ? 1 : r2max);\n    }\n    return rs; // not ordered\n}\n\n//# sourceMappingURL=geo-clip.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toHybridQuadratic: () => (/* binding */ toHybridQuadratic)\n/* harmony export */ });\n/**\n * Returns a hybrid quadratic bezier curve with error bounds (with the first\n * and last control points omitted).\n *\n * * **the returned error bounds have counters of <8> and <12> respectively for\n * the 1st and 2nd control points (i.e. for the hybrid control points)**\n * * specifically modified for use in the geometric interval bezier-bezier\n * intersection algorithm, e.g. for efficiency the first and last points are\n * not returned\n * * **precondition:** coordinate-wise error bound 'Wilson counters' on the\n * cubic bezier control points of\n * `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]` are assumed (due to other\n * parts of the algorithm)\n *\n * @param G a cubic bezier curve - coordinate error bounds are assumed to have\n * counters of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`\n *\n * @internal\n */\nfunction toHybridQuadratic(G) {\n    // the below is too slow\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const Gps = G.ps; // the cubic bezier curve\n    const G_ps = G._ps; // and its error bound coordinates\n    const p0 = Gps[0];\n    const p1 = Gps[1];\n    const p2 = Gps[2];\n    const p3 = Gps[3];\n    const x0 = p0[0]; // <6>x0\n    const y0 = p0[1]; // <6>y0\n    const x1 = p1[0]; // <6>x1\n    const y1 = p1[1]; // <6>y1\n    const x2 = p2[0]; // <10>x2\n    const y2 = p2[1]; // <10>y2\n    const x3 = p3[0]; // <11>x3\n    const y3 = p3[1]; // <11>y3\n    const _p0 = G_ps[0];\n    const _p1 = G_ps[1];\n    const _p2 = G_ps[2];\n    const _p3 = G_ps[3];\n    const _x0 = _p0[0];\n    const _y0 = _p0[1];\n    const _x1 = _p1[0];\n    const _y1 = _p1[1];\n    const _x2 = _p2[0];\n    const _y2 = _p2[1];\n    const _x3 = _p3[0];\n    const _y3 = _p3[1];\n    // <8> <= <8>(<7>(<0>3*<6>x1) + <6>x0)\n    const _hq1 = [(3 * _x1 + _x0) / 2, (3 * _y1 + _y0) / 2];\n    // <12> <= <12>(<11>(<0>3*<10>x2) + <11>x3)\n    const _hq2 = [(3 * _x2 + _x3) / 2, (3 * _y2 + _y3) / 2];\n    return {\n        hq: [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\n            [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]],\n        // error bounds (still need to be multiplied by 4*u and 6*u)\n        _hq: [_hq1, _hq2]\n    };\n}\n\n//# sourceMappingURL=to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDistanceToLineFunction: () => (/* binding */ getDistanceToLineFunction)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\nconst abs = Math.abs;\nconst eps = Number.EPSILON;\nconst u = eps / 2;\n/*\nfunction getDistanceToLineFunction(\n        pS: number[],\n        pE: number[]): (p: number[]) => number {\n\n    const xS = pS[0];\n    const yS = pS[1];\n    const xE = pE[0];\n    const yE = pE[1];\n\n    const s = yS - yE;\n    const t = xE - xS;\n    const u = qdq(tp(xS,yE), tp(xE,yS))[1];\n\n    return function(p: number[]) {\n        return s*p[0] + t*p[1] + u;\n    }\n}\n*/\n/**\n * @param pS\n * @param pE\n *\n * @internal\n */\nfunction getDistanceToLineFunction(pS, pE) {\n    const xS = pS[0];\n    const yS = pS[1];\n    const xE = pE[0];\n    const yE = pE[1];\n    // note: td(yS, yE) nearly always has low double === 0 -> could potentially be taken advantage of in future\n    const s = yS - yE; // <1>s\n    const t = xE - xS; // <1>t\n    const v = qdq(tp(xS, yE), tp(xE, yS))[1]; // <1>v\n    const _s = abs(s);\n    const _t = abs(t);\n    const _v = abs(v);\n    return function (p, _p) {\n        // error counter assumed <12> \n        // (the max of <3>,<5>,<8> and <12> from other functions (`fromTo3` and `toHybridQuadratic`))\n        const x = p[0]; // <12>x \n        const y = p[1]; // <12>y\n        //return s*x + t*y + u;\n        const _x = _p[0];\n        const _y = _p[1];\n        // error counter of <12> on all coordinates\n        const d = s * x + t * y + v;\n        // <16>r <= <16>(<15>(<14>(<1>s*<12>x) + <14>(<1>t*<12>y)) + <1>v)\n        const _d = _s * _x + _t * _y + _v;\n        const E = 16 * u * _d;\n        return { dMin: d - E, dMax: d + E };\n    };\n}\n\n//# sourceMappingURL=get-distance-to-line-function.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierBezierIntersectionBoundless: () => (/* binding */ bezierBezierIntersectionBoundless)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var _get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coefficients/get-coeffs-bez-bez.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js\");\n\n\n/**\n * Returns the intersection between any of two linear, quadratic or cubic bezier\n * curves without limiting the `t` parameter value of the first given curve\n * in [0,1], i.e. `t ∈ [-∞,+∞]`.\n *\n * * if the two curves have an infinite number of intersections `undefined` is returned\n * * the second bezier curve's parameter `t` values are returned *ordered* by `t` value\n *\n * * **precondition:** the bezier curves must be of lowest possible\n * representable order, i.e. cubics are really cubics, etc. (else\n * use [[reduceOrderIfPossible]] first)\n *\n * @param ps1 an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\n * @param ps2 an order 1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\n *\n * @internal but still exported for backwards compatibility\n */\nfunction bezierBezierIntersectionBoundless(ps1, ps2) {\n    const { coeffs, errBound, getPExact } = (0,_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsBezBez)(ps1, ps2);\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)(coeffs, 0, 1, errBound, getPExact, true);\n}\n\n//# sourceMappingURL=bezier-bezier-intersection-boundless.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierBezierIntersection: () => (/* binding */ bezierBezierIntersection)\n/* harmony export */ });\n/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./x.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js\");\n/* harmony import */ var _bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier-bezier-intersection-boundless.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js\");\n/* harmony import */ var _simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js\");\n/* harmony import */ var _local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../local-properties-to-t/t-from-xy.js */ \"./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../boxes/intersect-boxes.js */ \"./node_modules/flo-bezier3/node/boxes/intersect-boxes.js\");\n/* harmony import */ var _self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../self-intersection/bezier-self-intersection.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js\");\n/* harmony import */ var _get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../get-endpoint-intersections/get-endpoint-intersections.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js\");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../global-properties/classification/is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transformation/reduce-order-if-possible.js */ \"./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst eps = Number.EPSILON;\nconst eps2 = 2 * eps;\n/**\n * Returns an array of intersections between two bezier curves up to cubic order\n * (i.e. points, linear, quadratic or cubic bezier curves (i.e. order 0,1,2 or 3\n * curves).\n *\n * The algorithm employed uses advanced techniques such as floating point error\n * bounding, adaptive multi-precision floating point arithmetic, pre-filtering\n * of easy cases, certified root finding and algebraic implicitization of the\n * curves in order to find *guaranteed* accurate results.\n *\n * * this algorithm is mathematically guaranteed accurate to within\n * `4 * Number.EPSILON` in the returned `t` parameter values of the bezier\n * curves (bar underflow/overflow)\n *\n * * the returned intersections are *ordered* by `t` parameter value of the\n * first bezier curve\n * * if the two curves have an infinite number of intersections then the\n * intersection of the endpoints of each curve with the other is returned\n * instead (and the intersection `kind` property will equal `5`)\n *\n * * each intersection in the returned array of intersections is an object with\n * the following properties (see the type [[X]]`):\n *      * `p`: point of intersection (calculated from the guaranteed root interval)\n *      * `t1`: first bezier curve's parameter `t` value (calculated from the guaranteed root interval)\n *      * `t2`: second bezier curve's parameter `t` value (calculated from the guaranteed root interval)\n *      * `kind`: kind of intersection (see [[X]] for details)\n *      * `ri1`: first bezier curve's root interval guaranteed to contain the\n *               correct `t` value in the form `{ tS, tE, multiplicity }`,\n *               where `tS` and `tE` are the start and end of the interval\n *      * `ri2`: second bezier curve's root interval guaranteed to contain the\n *               correct `t` value in the form `{ tS, tE, multiplicity }`,\n *               where `tS` and `tE` are the start and end of the interval\n *      * `box`: small box that is guaranteed to contain the intersection\n *               (calculated from the guaranteed root interval)\n *\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ps2 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction bezierBezierIntersection(ps1, ps2) {\n    ps1 = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__.reduceOrderIfPossible)(ps1);\n    ps2 = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__.reduceOrderIfPossible)(ps2);\n    if (ps1.length === 1 || ps2.length === 1) {\n        return handlePointDegenerateCases(ps1, ps2);\n    }\n    const ris2 = (0,_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersectionBoundless)(ps1, ps2);\n    if (ris2 === undefined) {\n        return handleInfiniteIntersections(ps1, ps2);\n    }\n    if (ris2.length === 0) {\n        return [];\n    }\n    // `ris1` are ordered by inersection `t` values of `ps1`\n    const ris1 = (0,_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersectionBoundless)(ps2, ps1);\n    if (ris1.length === 0) {\n        return [];\n    }\n    const is1 = ris1.map(ri => (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps1, [ri.tS, ri.tE]));\n    const is2 = ris2.map(ri => (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps2, [ri.tS, ri.tE]));\n    const xs = [];\n    for (let i = 0; i < ris1.length; i++) {\n        const box1 = is1[i];\n        for (let j = 0; j < ris2.length; j++) {\n            const box2 = is2[j];\n            const box = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_3__.intersectBoxes)(box1, box2);\n            if (box !== undefined) {\n                const ri1 = ris1[i];\n                const ri2 = ris2[j];\n                const x = {\n                    p: (0,_x_js__WEBPACK_IMPORTED_MODULE_4__.getPFromBox)(box), kind: 1, box,\n                    t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri1), ri1: ri1,\n                    t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri2), ri2: ri2\n                };\n                xs.push(x);\n            }\n        }\n    }\n    return xs;\n}\n/**\n * * **precondition:** the bezier curves must be of lowest possible\n * representable order\n * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must\n * return `undefined` to represent the fact of an infinite number of\n * intersections exist\n * * **precondition:** neither bezier curve may be of order 1 (a point)\n *\n * @param ps1 an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ps2 an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @internal\n */\nfunction handleInfiniteIntersections(ps1, ps2) {\n    // At this point there are an infinite number of intersections, i.e.:\n    // `bezierBezierIntersectionBoundless(ps1, ps2) === undefined`\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_6__.isCollinear)(ps1) && !(ps1.length === 2 && ps2.length === 2)) {\n        // `ps2` must also be collinear\n        return handleCollinearIntersections(ps1, ps2);\n    }\n    // Now neither `ps1` nor `ps2` is collinear and they are thus algebraically\n    // identical\n    return [\n        ...(0,_get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_7__.getEndpointIntersections)(ps1, ps2, true),\n        ...getCoincidingSelfIntersections(ps1, ps2)\n    ].sort((a, b) => a.t1 - b.t1);\n}\n/**\n * Get the intersection (if it exist) that is the double-point of both given\n * algebraically identical curves if both the double-points are given for `t`\n * values in `[0,1]` for each curve.\n *\n * * **precondition:** the bezier curves must be of lowest possible\n * representable order\n * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must\n * return `undefined` to represent the fact of an infinite number of\n * intersections exist\n * * **precondition:** neither curve is allowed to have all points collinear\n *\n * @param ps1 a bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ps2 a bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @internal\n */\nfunction getCoincidingSelfIntersections(ps1, ps2) {\n    const ts1 = (0,_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_8__.bezierSelfIntersection)(ps1, false);\n    const ts2 = (0,_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_8__.bezierSelfIntersection)(ps2, false);\n    const len1 = ts1.length;\n    const len2 = ts2.length;\n    if (len1 < 1 || len2 < 1) {\n        return [];\n    }\n    const xs = [];\n    // this is a *very* rare case\n    for (const t1 of ts1) {\n        for (const t2 of ts2) {\n            const ri1 = { tS: t1 - eps2, tE: t1 + eps2, multiplicity: 1 };\n            const ri2 = { tS: t2 - eps2, tE: t2 + eps2, multiplicity: 1 };\n            const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps1, [t1 - eps2, t1 + eps2]);\n            // const box2 = getIntervalBox(ps2, [t2-eps2, t2+eps2]);\n            xs.push({\n                // this is actually *also* a self-intersection\n                p: (0,_x_js__WEBPACK_IMPORTED_MODULE_4__.getPFromBox)(box), kind: 1, box,\n                t1: t1, ri1: ri1,\n                t2: t2, ri2: ri2\n            });\n        }\n    }\n    return xs;\n}\n/**\n * * self-overlap is not considered, only endpoints\n *\n * * **precondition:** one curve must be of at least order 1 (line) and the\n * other of at least order 2 (quadratic)\n * * **precondition:** the bezier curves must be of lowest possible\n * representable order\n * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must\n * return `undefined` to represent the fact of an infinite number of\n * intersections exist\n * * **precondition:** all points (from both curves) must be collinear\n *\n * @param psA an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param psB an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @internal\n */\nfunction handleCollinearIntersections(psA, psB) {\n    const A0 = psA[0];\n    const A1 = psA[psA.length - 1];\n    const B0 = psB[0];\n    const B1 = psB[psB.length - 1];\n    // Check for exact endpoint overlap\n    const overlapSS = A0[0] === B0[0] && A0[1] == B0[1];\n    const overlapSE = A0[0] === B1[0] && A0[1] == B1[1];\n    const overlapES = A1[0] === B0[0] && A1[1] == B0[1];\n    const overlapEE = A1[0] === B1[0] && A1[1] == B1[1];\n    const overlapB0 = overlapSS || overlapES;\n    const overlapB1 = overlapSE || overlapEE;\n    const root0 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.createRootExact)(0);\n    const root1 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.createRootExact)(1);\n    const tA_B0 = overlapSS ? [root0] : overlapES ? [root1] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__.tFromXY)(psA, B0);\n    const tA_B1 = overlapSE ? [root0] : overlapEE ? [root1] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__.tFromXY)(psA, B1);\n    const tB_A0 = overlapSS || overlapSE ? [] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__.tFromXY)(psB, A0);\n    const tB_A1 = overlapES || overlapEE ? [] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__.tFromXY)(psB, A1);\n    return [\n        ...tA_B0.map(ri => {\n            const box = [B0, B0];\n            const kind = overlapB0 ? 4 : 5;\n            return {\n                p: B0, kind, box,\n                t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri), ri1: ri,\n                t2: 0, ri2: root0\n            };\n        }),\n        ...tA_B1.map(ri => {\n            const box = [B1, B1];\n            const kind = overlapB1 ? 4 : 5;\n            return {\n                p: B1, kind, box,\n                t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri), ri1: ri,\n                t2: 1, ri2: root1\n            };\n        }),\n        ...tB_A0.map(ri => {\n            const box = [A0, A0];\n            const kind = 5;\n            return {\n                p: A0, kind, box,\n                t1: 0, ri1: root0,\n                t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri), ri2: ri\n            };\n        }),\n        ...tB_A1.map(ri => {\n            const box = [A1, A1];\n            const kind = 5;\n            return {\n                p: A1, kind, box,\n                t1: 1, ri1: root1,\n                t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri), ri2: ri\n            };\n        })\n    ]\n        .sort((a, b) => a.t1 - b.t1);\n}\n/**\n * Handles the degenerate cases where either bezier curve is really a point and\n * returns the relevant intersections if any.\n *\n * * **precondition:** either or both bezier curves must be a point\n * * **precondition:** the bezier curves must be of lowest possible\n * representable order\n *\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param ps2 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @internal\n */\nfunction handlePointDegenerateCases(ps1, ps2) {\n    if (ps1.length === 1) {\n        const p1 = ps1[0];\n        const box = [p1, p1];\n        if (ps2.length === 1) {\n            const p2 = ps2[0];\n            if (p1[0] === p2[0] && p1[1] === p2[1]) {\n                // literally the same points - very degenerate\n                const ri = { tS: 0.5, tE: 0.5, multiplicity: 1 };\n                return [\n                    {\n                        p: p1, kind: 6, box,\n                        t1: 0.5, ri1: ri,\n                        t2: 0.5, ri2: ri,\n                    }\n                ];\n            }\n            return [];\n        }\n        if ((0,_simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_10__.isPointOnBezierExtension)(ps2, [[p1[0]], [p1[1]]])) {\n            // keep TypeScript happy; at this point `tFromXY` cannot return `undefined`\n            return (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__.tFromXY)(ps2, p1).map(ri => ({\n                p: p1, kind: 6, box,\n                t1: 0.5, ri1: { tS: 0.5, tE: 0.5, multiplicity: 1 },\n                t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri), ri2: ri,\n            }));\n        }\n        return [];\n    }\n    const p2 = ps2[0];\n    const box = [p2, p2];\n    if ((0,_simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_10__.isPointOnBezierExtension)(ps1, [[p2[0]], [p2[1]]])) {\n        // keep TypeScript happy; at this point `tFromXY` cannot return `undefined`\n        return (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_9__.tFromXY)(ps1, p2).map(ri => ({\n            p: p2, kind: 6, box,\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri), ri1: ri,\n            t2: 0.5, ri2: { tS: 0.5, tE: 0.5, multiplicity: 1 },\n        }));\n    }\n    return [];\n}\n\n//# sourceMappingURL=bezier-bezier-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez1Dd: () => (/* binding */ getCoeffsBez1Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of two\n * order 1 bezier curves (i.e. 2 lines).\n *\n * The returned polynomial degree will be 1\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez1Bez1Dd(ps1, ps2) {\n    const { coeffs: { vₓ, vᵧ, v }, // all these are double-doubles\n    errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\n    const $c1 = c1[1];\n    const $d1 = d1[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    //----------------------------------\n    // const v1 = c1*vₓ + d1*vᵧ;\n    //----------------------------------\n    const $p1 = $c1 * $vₓ;\n    const _p1 = abs($p1);\n    const p1_ = 2 * _p1;\n    const p1 = qmq(c1, vₓ);\n    const $p2 = $d1 * $vᵧ;\n    const _p2 = abs($p2);\n    const p2_ = 2 * _p2;\n    const p2 = qmq(d1, vᵧ);\n    const $v1 = $p1 + $p2;\n    //const _$v1 = abs($v1);\n    const v1 = qaq(p1, p2);\n    const v1_ = p1_ + p2_ + abs($v1);\n    //----------------------------------\n    // const v0 = c0*vₓ + d0*vᵧ + v_0;\n    //----------------------------------\n    const $p3 = c0 * $vₓ;\n    const p3 = qmd(c0, vₓ);\n    const _p3_ = abs($p3);\n    const $p4 = d0 * $vᵧ;\n    const p4 = qmd(d0, vᵧ);\n    const _p4_ = abs($p4);\n    const $p5 = $p3 + $p4;\n    //const _p5 = abs($p5);\n    const p5 = qaq(p3, p4);\n    const p5_ = _p3_ + _p4_ + abs($p5);\n    const v0 = qaq(p5, v);\n    const v0_ = p5_ + v_ + abs($p5 + $v);\n    return {\n        coeffs: [v1, v0],\n        errBound: [γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez1-bez1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez2Dd: () => (/* binding */ getCoeffsBez1Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of an order\n * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).\n *\n * The returned polynomial degree will be 2\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez1Bez2Dd(ps1, ps2) {\n    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const _vₓ = abs($vₓ);\n    const _vᵧ = abs($vᵧ);\n    const _v = abs($v);\n    const $c1 = c1[1];\n    const $c2 = c2[1];\n    const $d1 = d1[1];\n    const $d2 = d2[1];\n    // --------------------------\n    // a2*v_x + b2*v_y\n    // const v2 = c2*vₓ + d2*vᵧ;\n    // --------------------------\n    const $p1 = $c2 * $vₓ;\n    const p1 = qmq(c2, vₓ);\n    const p1_ = c2_ * _vₓ + 2 * abs($p1);\n    const $p2 = $d2 * $vᵧ;\n    const p2 = qmq(d2, vᵧ);\n    const p2_ = d2_ * _vᵧ + 2 * abs($p2);\n    const $v2 = $p1 + $p2;\n    const v2 = qaq(p1, p2);\n    const v2_ = p1_ + p2_ + abs($v2);\n    // a1*v_x + b1*v_y\n    //const v1 = c1*vₓ + d1*vᵧ;\n    const $p3 = $c1 * $vₓ;\n    const p3 = qmq(c1, vₓ);\n    const p3_ = 2 * abs($p3);\n    const $p4 = $d1 * $vᵧ;\n    const p4 = qmq(d1, vᵧ);\n    const p4_ = 2 * abs($p4);\n    const $v1 = $p3 + $p4;\n    const v1 = qaq(p3, p4);\n    const v1_ = p3_ + p4_ + abs($v1);\n    // a0*v_x + b0*v_y + v_0\n    //const v0 = c0*vₓ + d0*vᵧ + v;\n    const p5 = qmd(c0, vₓ);\n    const $p5 = c0 * $vₓ;\n    const p5_ = abs($p5);\n    const p6 = qmd(d0, vᵧ);\n    const $p6 = d0 * $vᵧ;\n    const p6_ = abs($p6);\n    const $p7 = $p5 + $p6;\n    const p7 = qaq(p5, p6);\n    const p7_ = p5_ + p6_ + abs($p7);\n    const $v0 = $p7 + $v;\n    const v0 = qaq(p7, v);\n    const v0_ = p7_ + v_ + abs($v0);\n    return {\n        coeffs: [v2, v1, v0],\n        errBound: [γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez1-bez2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez3Dd: () => (/* binding */ getCoeffsBez1Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of an order\n * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).\n *\n * The returned polynomial degree will be 3\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez1Bez3Dd(ps1, ps2) {\n    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\n    const _vₓ = abs(vₓ[1]);\n    const _vᵧ = abs(vᵧ[1]);\n    // a3*v_x + b3*v_y\n    //const v3 = c3*vₓ + d3*vᵧ;\n    const p1 = qmq(c3, vₓ); // vₓ is error free\n    const p1_ = c3_ * _vₓ + 2 * abs(p1[1]);\n    const p2 = qmq(d3, vᵧ); // vᵧ is error free\n    const p2_ = d3_ * _vᵧ + 2 * abs(p2[1]);\n    const v3 = qaq(p1, p2);\n    const v3_ = p1_ + p2_ + abs(v3[1]);\n    // a2*v_x + b2*v_y\n    //const v2 = c2*vₓ + d2*vᵧ;\n    const p3 = qmq(c2, vₓ); // vₓ is error free\n    const p3_ = c2_ * _vₓ + 2 * abs(p3[1]);\n    const p4 = qmq(d2, vᵧ); // vᵧ is error free\n    const p4_ = d2_ * _vᵧ + 2 * abs(p4[1]);\n    const v2 = qaq(p3, p4);\n    const v2_ = p3_ + p4_ + abs(v2[1]);\n    // a1*v_x + b1*v_y\n    //const v1 = c1*vₓ + d1*vᵧ;\n    const p5 = qmq(c1, vₓ); // vₓ is error free\n    const p5_ = c1_ * _vₓ + 2 * abs(p5[1]);\n    const p6 = qmq(d1, vᵧ); // vᵧ is error free\n    const p6_ = d1_ * _vᵧ + 2 * abs(p6[1]);\n    const v1 = qaq(p5, p6);\n    const v1_ = p5_ + p6_ + abs(v1[1]);\n    // a0*v_x + b0*v_y + v_0\n    //const v0 = c0*vₓ + d0*vᵧ + v;\n    const p7 = qmd(c0, vₓ); // vₓ is error free\n    const p7_ = abs(p7[1]);\n    const p8 = qmd(d0, vᵧ); // vᵧ is error free\n    const p8_ = abs(p8[1]);\n    const p9 = qaq(p7, p8);\n    const p9_ = p7_ + p8_ + abs(p9[1]);\n    const v0 = qaq(p9, v);\n    const v0_ = p9_ + v_ + abs(v0[1]);\n    return {\n        coeffs: [v3, v2, v1, v0],\n        errBound: [γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez1-bez3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez1Dd: () => (/* binding */ getCoeffsBez2Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of an order\n * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).\n *\n * The returned polynomial degree will be 2\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez2Bez1Dd(ps1, ps2) {\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\n    const $vₓₓ = vₓₓ[1];\n    const $vₓᵧ = vₓᵧ[1];\n    const $vᵧᵧ = vᵧᵧ[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const _vₓₓ = abs($vₓₓ);\n    const _vₓᵧ = abs($vₓᵧ);\n    const _vᵧᵧ = abs($vᵧᵧ);\n    const $c1 = c1[1];\n    const $d1 = d1[1];\n    const _c0 = abs(c0);\n    const _c1 = abs($c1);\n    const _d0 = abs(d0);\n    const _d1 = abs($d1);\n    const $c0c0 = c0 * c0;\n    const $c0c1 = c0 * $c1;\n    const $c0d0 = c0 * d0;\n    const $c0d1 = c0 * $d1;\n    const $c1c1 = $c1 * $c1;\n    const $c1d0 = $c1 * d0;\n    const $c1d1 = $c1 * $d1;\n    const $d0d0 = d0 * d0;\n    const $d0d1 = d0 * $d1;\n    const $d1d1 = $d1 * $d1;\n    const c0c0 = tp(c0, c0);\n    const c0c1 = qmd(c0, c1);\n    const _c0c1_ = abs($c0c1);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = qmd(c0, d1);\n    const c0d1_ = abs($c0d1);\n    const _c1c1 = abs($c1c1);\n    const c1c1 = qmq(c1, c1);\n    const c1c1_ = 2 * _c1c1;\n    const c1d0 = qmd(d0, c1);\n    const c1d0_ = abs($c1d0);\n    const _c1d1 = abs($c1d1);\n    const c1d1 = qmq(c1, d1);\n    const c1d1_ = 2 * _c1d1;\n    const d0d0 = tp(d0, d0);\n    const d0d1 = qmd(d0, d1);\n    const _d0d1_ = abs($d0d1);\n    const _d1d1 = abs($d1d1);\n    const d1d1 = qmq(d1, d1);\n    const d1d1_ = 2 * _d1d1;\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\n    const $p1 = $c1c1 * $vₓₓ;\n    const p1 = qmq(c1c1, vₓₓ);\n    const p1_ = c1c1_ * _vₓₓ * _c1c1 * vₓₓ_ + 2 * abs($p1);\n    const $p2 = $d1d1 * $vᵧᵧ;\n    const p2 = qmq(d1d1, vᵧᵧ);\n    const p2_ = d1d1_ * _vᵧᵧ * _d1d1 * vᵧᵧ_ + 2 * abs($p2);\n    const $p3 = $c1d1 * $vₓᵧ;\n    const p3 = qmq(c1d1, vₓᵧ);\n    const p3_ = c1d1_ * _vₓᵧ * _c1d1 * vₓᵧ_ + 2 * abs($p3);\n    const $p4 = $p1 + $p2;\n    const p4 = qaq(p1, p2);\n    const p4_ = p1_ + p2_ + abs($p4);\n    const $v2 = $p4 + $p3;\n    const v2 = qaq(p4, p3);\n    const v2_ = p4_ + p3_ + abs($v2);\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\n    const $p5 = $c0c1 * $vₓₓ;\n    const p5 = qmq(c0c1, vₓₓ);\n    const p5_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * abs($p5);\n    const $p6 = $d0d1 * $vᵧᵧ;\n    const p6 = qmq(d0d1, vᵧᵧ);\n    const p6_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * abs($p6);\n    const $p7 = $c0d1 + $c1d0;\n    const p7 = qaq(c0d1, c1d0);\n    const p7_ = c0d1_ + c1d0_ + abs($p7);\n    const $pn = $p7 * $vₓᵧ;\n    const pn = qmq(p7, vₓᵧ);\n    const pn_ = p7_ * _vₓᵧ + abs($p7) * vₓᵧ_ + 2 * abs($pn);\n    const $p8 = 2 * ($p5 + $p6);\n    const p8 = qm2(qaq(p5, p6));\n    const p8_ = 2 * (p5_ + p6_) + abs($p8);\n    const $p9 = $p8 + $pn;\n    const p9 = qaq(p8, pn);\n    const p9_ = p8_ + pn_ + abs($p9);\n    const $pa = $c1 * $vₓ;\n    const pa = qmq(c1, vₓ);\n    const pa_ = _c1 * vₓ_ + 2 * abs($pa);\n    const $pb = $d1 * $vᵧ;\n    const pb = qmq(d1, vᵧ);\n    const pb_ = _d1 * vᵧ_ + 2 * abs($pb);\n    const $pc = $pa + $pb;\n    const pc = qaq(pa, pb);\n    const pc_ = pa_ + pb_ + abs($pc);\n    const $v1 = $p9 + $pc;\n    const v1 = qaq(p9, pc);\n    const v1_ = p9_ + pc_ + abs($v1);\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\n    const $pe = $c0c0 * $vₓₓ;\n    const pe = qmq(c0c0, vₓₓ);\n    const pe_ = 2 * abs($pe);\n    const $pf = $c0d0 * $vₓᵧ;\n    const pf = qmq(c0d0, vₓᵧ);\n    const pf_ = 2 * abs($pf);\n    const $pg = $d0d0 * $vᵧᵧ;\n    const pg = qmq(d0d0, vᵧᵧ);\n    const pg_ = 2 * abs($pg);\n    const $ph = $pe + $pf;\n    const ph = qaq(pe, pf);\n    const ph_ = pe_ + pf_ + abs($ph);\n    const $pi = $ph + $pg;\n    const pi = qaq(ph, pg);\n    const pi_ = ph_ + pg_ + abs($pi);\n    const $pj = c0 * $vₓ;\n    const pj = qmd(c0, vₓ);\n    const pj_ = _c0 * vₓ_ + abs($pj);\n    const $pk = d0 * $vᵧ;\n    const pk = qmd(d0, vᵧ);\n    const pk_ = _d0 * vᵧ_ + abs($pk);\n    const $pl = $pj + $pk;\n    const pl = qaq(pj, pk);\n    const pl_ = pj_ + pk_ + abs($pl);\n    const $pm = $pi + $pl;\n    const pm = qaq(pi, pl);\n    const pm_ = pi_ + pl_ + abs($pm);\n    const $v0 = $pm + $v;\n    const v0 = qaq(pm, v);\n    const v0_ = pm_ + v_ + abs($v0);\n    return {\n        coeffs: [v2, v1, v0],\n        errBound: [γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez2-bez1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez2Dd: () => (/* binding */ getCoeffsBez2Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of 2 order\n * 2 bezier curves (i.e. 2 quadratic bezier curves).\n *\n * The returned polynomial degree will be 4\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez2Bez2Dd(ps1, ps2) {\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\n    const $vₓₓ = vₓₓ[1];\n    const $vₓᵧ = vₓᵧ[1];\n    const $vᵧᵧ = vᵧᵧ[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const _vₓₓ = abs($vₓₓ);\n    const _vₓᵧ = abs($vₓᵧ);\n    const _vᵧᵧ = abs($vᵧᵧ);\n    const _vₓ = abs($vₓ);\n    const _vᵧ = abs($vᵧ);\n    const $c1 = c1[1];\n    const $c2 = c2[1];\n    const $d1 = d1[1];\n    const $d2 = d2[1];\n    const _c0 = abs(c0);\n    const _c1 = abs($c1);\n    const _c2 = abs($c2);\n    const _d0 = abs(d0);\n    const _d1 = abs($d1);\n    const _d2 = abs($d2);\n    const $c0c0 = c0 * c0;\n    const $c0c1 = c0 * $c1;\n    const $c0c2 = c0 * $c2;\n    const $c0d0 = c0 * d0;\n    const $c0d1 = c0 * $d1;\n    const $c0d2 = c0 * $d2;\n    const $c1c1 = $c1 * $c1;\n    const $c1c2 = $c1 * $c2;\n    const $c1d0 = $c1 * d0;\n    const $c1d1 = $c1 * $d1;\n    const $c1d2 = $c1 * $d2;\n    const $c2d1 = $c2 * $d1;\n    const $c2c2 = $c2 * $c2;\n    const $c2d0 = $c2 * d0;\n    const $c2d2 = $c2 * $d2;\n    const $d0d0 = d0 * d0;\n    const $d0d1 = d0 * $d1;\n    const $d0d2 = d0 * $d2;\n    const $d1d1 = $d1 * $d1;\n    const $d1d2 = $d1 * $d2;\n    const $d2d2 = $d2 * $d2;\n    const _c0c0 = abs($c0c0);\n    const _c0d0 = abs($c0d0);\n    const _d0d0 = abs($d0d0);\n    const c0c0 = tp(c0, c0); // error free\n    const c0c1 = qmd(c0, c1);\n    const _c0c1_ = abs($c0c1);\n    const c0c2 = qmd(c0, c2);\n    const _c0c2_ = abs($c0c2);\n    const c0d0 = tp(c0, d0); // error free\n    const c0d1 = qmd(c0, d1);\n    const _c0d1_ = abs($c0d1);\n    const c0d2 = qmd(c0, d2);\n    const _c0d2_ = abs($c0d2);\n    const c1c1 = qmq(c1, c1);\n    const c1c1_ = 2 * abs($c1c1);\n    const c1c2 = qmq(c1, c2);\n    const _c1c2 = abs($c1c2);\n    const c1c2_ = _c1 * c2_ + 2 * _c1c2;\n    const c1d0 = qmd(d0, c1);\n    const _c1d0_ = abs($c1d0);\n    const c1d1 = qmq(c1, d1);\n    const c1d1_ = 2 * abs($c1d1);\n    const c1d2 = qmq(c1, d2);\n    const c1d2_ = _c1 * d2_ + 2 * abs($c1d2);\n    const c2d1 = qmq(c2, d1);\n    const c2d1_ = c2_ * _d1 + 2 * abs($c2d1);\n    const c2c2 = qmq(c2, c2);\n    const _c2c2 = abs($c2c2);\n    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);\n    const c2d0 = qmd(d0, c2);\n    const _c2d0_ = abs($c2d0);\n    const c2d2 = qmq(c2, d2);\n    const _c2d2 = abs($c2d2);\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * _c2d2;\n    const d0d0 = tp(d0, d0); // error free\n    const d0d1 = qmd(d0, d1);\n    const _d0d1_ = abs($d0d1);\n    const d0d2 = qmd(d0, d2);\n    const _d0d2_ = abs($d0d2);\n    const d1d1 = qmq(d1, d1);\n    const d1d1_ = 2 * abs($d1d1);\n    const d1d2 = qmq(d1, d2);\n    const _d1d2 = abs($d1d2);\n    const d1d2_ = _d1 * d2_ + 2 * _d1d2;\n    const d2d2 = qmq(d2, d2);\n    const _d2d2 = abs($d2d2);\n    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\n    //const v4 = \n    //    (c2*c2)*vₓₓ +\n    //    (c2*d2)*vₓᵧ +\n    //    (d2*d2)*vᵧᵧ;\n    const $p1 = $c2c2 * $vₓₓ;\n    const p1 = qmq(c2c2, vₓₓ);\n    const p1_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * abs($p1);\n    const $p2 = $c2d2 * $vₓᵧ;\n    const p2 = qmq(c2d2, vₓᵧ);\n    const p2_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * abs($p2);\n    const $p3 = $d2d2 * $vᵧᵧ;\n    const p3 = qmq(d2d2, vᵧᵧ);\n    const p3_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * abs($p3);\n    const $p4 = $p1 + $p2;\n    const p4 = qaq(p1, p2);\n    const p4_ = p1_ + p2_ + abs($p4);\n    const $v4 = $p4 + $p3;\n    const v4 = qaq(p4, p3);\n    const v4_ = p4_ + p3_ + abs($v4);\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\n    //const v3 =\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\n    const $p5 = $c1c2 * $vₓₓ;\n    const p5 = qmq(c1c2, vₓₓ);\n    const p5_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * abs($p5);\n    const $p6 = $d1d2 * $vᵧᵧ;\n    const p6 = qmq(d1d2, vᵧᵧ);\n    const p6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * abs($p6);\n    const $p7 = $c1d2 + $c2d1;\n    const p7 = qaq(c1d2, c2d1);\n    const _p7 = abs($p7);\n    const p7_ = c1d2_ + c2d1_ + _p7;\n    const $p8 = $p7 * $vₓᵧ;\n    const p8 = qmq(p7, vₓᵧ);\n    const p8_ = p7_ * _vₓᵧ + _p7 * vₓᵧ_ + 2 * abs($p8);\n    const $p9 = 2 * ($p5 + $p6);\n    const p9 = qm2(qaq(p5, p6));\n    const p9_ = 2 * (p5_ + p6_) + abs($p9);\n    const $v3 = $p9 + $p8;\n    const v3 = qaq(p9, p8);\n    const v3_ = p9_ + p8_ + abs($v3);\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\n    //const v2 = \n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\n    //    c2*vₓ  +          \n    //    d2*vᵧ;\n    const $pa = 2 * $c0c2 + $c1c1;\n    const _pa = abs($pa);\n    const pa = qaq(qm2(c0c2), c1c1);\n    const pa_ = 2 * _c0c2_ + c1c1_ + abs($pa);\n    const $pb = 2 * $d0d2 + $d1d1;\n    const _pb = abs($pb);\n    const pb = qaq(qm2(d0d2), d1d1);\n    const pb_ = 2 * _d0d2_ + d1d1_ + abs($pb);\n    const $pc = $c0d2 + $c1d1;\n    const _pc = abs($pc);\n    const pc = qaq(c0d2, c1d1);\n    const pc_ = _c0d2_ + c1d1_ + abs($pc);\n    const $pd = $pc + $c2d0;\n    const pd = qaq(pc, c2d0);\n    const _pd = abs($pd);\n    const pd_ = pc_ + _c2d0_ + _pd;\n    const $pe = $pa * $vₓₓ;\n    const pe = qmq(pa, vₓₓ);\n    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * abs($pe);\n    const $pf = $pb * $vᵧᵧ;\n    const pf = qmq(pb, vᵧᵧ);\n    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * abs($pf);\n    const $pg = $pd * $vₓᵧ;\n    const pg = qmq(pd, vₓᵧ);\n    const pg_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * abs($pg);\n    const $ph = $c2 * $vₓ;\n    const ph = qmq(c2, vₓ);\n    const ph_ = c2_ * _vₓ + _c2 * vₓ_ + abs($ph);\n    const $pi = $d2 * $vᵧ;\n    const pi = qmq(d2, vᵧ);\n    const pi_ = d2_ * _vᵧ + _d2 * vᵧ_ + abs($pi);\n    const $pj = $pe + $pf;\n    const pj = qaq(pe, pf);\n    const pj_ = pe_ + pf_ + abs($pj);\n    const $pk = $pj + $pg;\n    const pk = qaq(pj, pg);\n    const pk_ = pj_ + pg_ + abs($pk);\n    const $pl = $ph + $pi;\n    const pl = qaq(ph, pi);\n    const pl_ = ph_ + pi_ + abs($pl);\n    const $v2 = $pk + $pl;\n    const v2 = qaq(pk, pl);\n    const v2_ = pk_ + pl_ + abs($v2);\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\n    //const v1 =\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\n    //    c1*vₓ  +\n    //    d1*vᵧ;\n    const $pm = $c0c1 * $vₓₓ;\n    const pm = qmq(c0c1, vₓₓ);\n    const pm_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * abs($pm);\n    const $pn = $d0d1 * $vᵧᵧ;\n    const pn = qmq(d0d1, vᵧᵧ);\n    const pn_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * abs($pn);\n    const $po = $c0d1 + $c1d0;\n    const po = qaq(c0d1, c1d0);\n    const _po = abs($po);\n    const po_ = _c0d1_ + _c1d0_ + _po;\n    const $pp = $po * $vₓᵧ;\n    const pp = qmq(po, vₓᵧ);\n    const pp_ = po_ * _vₓᵧ + _po * vₓᵧ_ + 2 * abs($pp);\n    const $pq = 2 * ($pm + $pn);\n    const pq = qm2(qaq(pm, pn));\n    const pq_ = 2 * (pm_ + pn_) + abs($pq);\n    const $pr = $c1 * $vₓ;\n    const pr = qmq(c1, vₓ);\n    const pr_ = _c1 * vₓ_ + 2 * abs($pr);\n    const $ps = $d1 * $vᵧ;\n    const ps = qmq(d1, vᵧ);\n    const ps_ = _d1 * vᵧ_ + 2 * abs($ps);\n    const $pt = $pq + $pp;\n    const pt = qaq(pq, pp);\n    const pt_ = pq_ + pp_ + abs($pt);\n    const $pu = $pr + $ps;\n    const pu = qaq(pr, ps);\n    const pu_ = pr_ + ps_ + abs($pu);\n    const $v1 = $pt + $pu;\n    const v1 = qaq(pt, pu);\n    const v1_ = pt_ + pu_ + abs($v1);\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \n    // b0**2*v_yy + b0*v_y + v_0\n    //const v0 =\n    //    (c0*c0)*vₓₓ + \n    //    (c0*d0)*vₓᵧ + \n    //    (d0*d0)*vᵧᵧ + \n    //    c0*vₓ  +         \n    //    d0*vᵧ  +\n    //    v;\n    const $pv = $c0c0 * $vₓₓ;\n    const pv = qmq(c0c0, vₓₓ);\n    const pv_ = _c0c0 * vₓₓ_ + 2 * abs($pv);\n    const $pw = $c0d0 * $vₓᵧ;\n    const pw = qmq(c0d0, vₓᵧ);\n    const pw_ = _c0d0 * vₓᵧ_ + 2 * abs($pw);\n    const $px = $d0d0 * $vᵧᵧ;\n    const px = qmq(d0d0, vᵧᵧ);\n    const px_ = _d0d0 * vᵧᵧ_ + 2 * abs($px);\n    const $py = c0 * $vₓ;\n    const py = qmd(c0, vₓ);\n    const py_ = _c0 * vₓ_ + abs($py);\n    const $pz = d0 * $vᵧ;\n    const pz = qmd(d0, vᵧ);\n    const pz_ = _d0 * vᵧ_ + abs($pz);\n    const $q1 = $pv + $pw;\n    const q1 = qaq(pv, pw);\n    const q1_ = pv_ + pw_ + abs($q1);\n    const $q2 = $q1 + $px;\n    const q2 = qaq(q1, px);\n    const q2_ = q1_ + px_ + abs($q2);\n    const $q3 = $py + $pz;\n    const q3 = qaq(py, pz);\n    const q3_ = py_ + pz_ + abs($q3);\n    const $q4 = $q2 + $q3;\n    const q4 = qaq(q2, q3);\n    const q4_ = q2_ + q3_ + abs($q4);\n    const $v0 = $q4 + $v;\n    const v0 = qaq(q4, v);\n    const v0_ = q4_ + v_ + abs($v0);\n    return {\n        coeffs: [v4, v3, v2, v1, v0],\n        errBound: [γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez2-bez2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez3Dd: () => (/* binding */ getCoeffsBez2Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of an order\n * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).\n *\n * The returned polynomial degree will be 6\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n  * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez2Bez3Dd(ps1, ps2) {\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\n    const $vₓₓ = vₓₓ[1];\n    const $vₓᵧ = vₓᵧ[1];\n    const $vᵧᵧ = vᵧᵧ[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const _vₓₓ = abs($vₓₓ);\n    const _vₓᵧ = abs($vₓᵧ);\n    const _vᵧᵧ = abs($vᵧᵧ);\n    const _vₓ = abs($vₓ);\n    const _vᵧ = abs($vᵧ);\n    const $c1 = c1[1];\n    const $c2 = c2[1];\n    const $c3 = c3[1];\n    const $d1 = d1[1];\n    const $d2 = d2[1];\n    const $d3 = d3[1];\n    const _c0 = abs(c0);\n    const _c1 = abs($c1);\n    const _c2 = abs($c2);\n    const _c3 = abs($c3);\n    const _d0 = abs(d0);\n    const _d1 = abs($d1);\n    const _d2 = abs($d2);\n    const _d3 = abs($d3);\n    const $c0c0 = c0 * c0;\n    const $c0c1 = c0 * $c1;\n    const $c0c2 = c0 * $c2;\n    const $c0c3 = c0 * $c3;\n    const $c0d0 = c0 * d0;\n    const $c0d1 = c0 * $d1;\n    const $c0d2 = c0 * $d2;\n    const $c0d3 = c0 * $d3;\n    const $c1c1 = $c1 * $c1;\n    const $c1c2 = $c1 * $c2;\n    const $c1c3 = $c1 * $c3;\n    const $c1d0 = $c1 * d0;\n    const $c1d1 = $c1 * $d1;\n    const $c1d2 = $c1 * $d2;\n    const $c1d3 = $c1 * $d3;\n    const $c2d1 = $c2 * $d1;\n    const $c2c2 = $c2 * $c2;\n    const $c2c3 = $c2 * $c3;\n    const $c2d0 = $c2 * d0;\n    const $c2d2 = $c2 * $d2;\n    const $c2d3 = $c2 * $d3;\n    const $c3c3 = $c3 * $c3;\n    const $c3d0 = $c3 * d0;\n    const $c3d1 = $c3 * $d1;\n    const $c3d2 = $c3 * $d2;\n    const $c3d3 = $c3 * $d3;\n    const $d0d0 = d0 * d0;\n    const $d0d1 = d0 * $d1;\n    const $d0d2 = d0 * $d2;\n    const $d0d3 = d0 * $d3;\n    const $d1d1 = $d1 * $d1;\n    const $d1d2 = $d1 * $d2;\n    const $d3d3 = $d3 * $d3;\n    const $d2d2 = $d2 * $d2;\n    const $d2d3 = $d2 * $d3;\n    const $d1d3 = $d1 * $d3;\n    const c0c0 = tp(c0, c0); // error free\n    const _c0c0 = abs($c0c0);\n    const c0c1 = qmd(c0, c1);\n    const _c0c1 = abs($c0c1);\n    const c0c1_ = _c0 * c1_ + _c0c1;\n    const c0c2 = qmd(c0, c2);\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\n    const c0c3 = qmd(c0, c3);\n    const c0c3_ = _c0 * c3_ + abs($c0c3);\n    const c0d0 = tp(c0, d0); // error free\n    const _c0d0 = abs($c0d0);\n    const c0d1 = qmd(c0, d1);\n    const c0d1_ = _c0 * d1_ + abs($c0d1);\n    const c0d2 = qmd(c0, d2);\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\n    const c0d3 = qmd(c0, d3);\n    const c0d3_ = _c0 * d3_ + abs($c0d3);\n    const c1c1 = qmq(c1, c1);\n    const c1c1_ = c1_ * _c1 + _c1 * c1_ + 2 * abs($c1c1);\n    const c1c2 = qmq(c1, c2);\n    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * abs($c1c2);\n    const c1c3 = qmq(c1, c3);\n    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * abs($c1c3);\n    const c1d0 = qmd(d0, c1);\n    const c1d0_ = _d0 * c1_ + abs($c1d0);\n    const c1d1 = qmq(c1, d1);\n    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * abs($c1d1);\n    const c1d2 = qmq(c1, d2);\n    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * abs($c1d2);\n    const c1d3 = qmq(c1, d3);\n    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * abs($c1d3);\n    const c2d1 = qmq(c2, d1);\n    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * abs($c2d1);\n    const c2c2 = qmq(c2, c2);\n    const c2c2_ = c2_ * _c2 + _c2 * c2_ + 2 * abs($c2c2);\n    const c2c3 = qmq(c2, c3);\n    const _c2c3 = abs($c2c3);\n    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * _c2c3;\n    const c2d0 = qmd(d0, c2);\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\n    const c2d2 = qmq(c2, d2);\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\n    const c2d3 = qmq(c2, d3);\n    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * abs($c2d3);\n    const c3c3 = qmq(c3, c3);\n    const _c3c3 = abs($c3c3);\n    const c3c3_ = c3_ * _c3 + _c3 * c3_ + 2 * _c3c3;\n    const c3d0 = qmd(d0, c3);\n    const c3d0_ = _d0 * c3_ + abs($c3d0);\n    const c3d1 = qmq(c3, d1);\n    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * abs($c3d1);\n    const c3d2 = qmq(c3, d2);\n    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * abs($c3d2);\n    const c3d3 = qmq(c3, d3);\n    const _c3d3 = abs($c3d3);\n    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * _c3d3;\n    const d0d0 = tp(d0, d0); // error free\n    const _d0d0 = abs($d0d0);\n    const d0d1 = qmd(d0, d1);\n    const _d0d1 = abs($d0d1);\n    const d0d1_ = _d0 * d1_ + _d0d1;\n    const d0d2 = qmd(d0, d2);\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\n    const d0d3 = qmd(d0, d3);\n    const d0d3_ = _d0 * d3_ + abs($d0d3);\n    const d1d1 = qmq(d1, d1);\n    const d1d1_ = d1_ * _d1 + _d1 * d1_ + 2 * abs($d1d1);\n    const d1d2 = qmq(d1, d2);\n    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * abs($d1d2);\n    const d3d3 = qmq(d3, d3);\n    const _d3d3 = abs($d3d3);\n    const d3d3_ = d3_ * _d3 + _d3 * d3_ + 2 * _d3d3;\n    const d2d2 = qmq(d2, d2);\n    const d2d2_ = d2_ * _d2 + _d2 * d2_ + 2 * abs($d2d2);\n    const d2d3 = qmq(d2, d3);\n    const _d2d3 = abs($d2d3);\n    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * _d2d3;\n    const d1d3 = qmq(d1, d3);\n    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * abs($d1d3);\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\n    //const v6 =\n    //    c3c3*vₓₓ +\n    //    c3d3*vₓᵧ +\n    //    d3d3*vᵧᵧ;\n    const $p1 = $c3c3 * $vₓₓ;\n    const p1 = qmq(c3c3, vₓₓ);\n    const p1_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * abs($p1);\n    const $p2 = $c3d3 * $vₓᵧ;\n    const p2 = qmq(c3d3, vₓᵧ);\n    const p2_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * abs($p2);\n    const $p3 = $d3d3 * $vᵧᵧ;\n    const p3 = qmq(d3d3, vᵧᵧ);\n    const p3_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * abs($p3);\n    const $p4 = $p1 + $p2;\n    const p4 = qaq(p1, p2);\n    const p4_ = p1_ + p2_ + abs($p4);\n    const $v6 = $p4 + $p3;\n    const v6 = qaq(p4, p3);\n    const v6_ = p4_ + p3_ + abs($v6);\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\n    //const v5 =\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\n    //    vₓᵧ*(c2d3 + c3d2);\n    const $p5 = $c2c3 * $vₓₓ;\n    const p5 = qmq(c2c3, vₓₓ);\n    const p5_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * abs($p5);\n    const $p6 = $d2d3 * $vᵧᵧ;\n    const p6 = qmq(d2d3, vᵧᵧ);\n    const p6_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * abs($p6);\n    const $p7 = $p5 + $p6;\n    const p7 = qaq(p5, p6);\n    const p7_ = p5_ + p6_ + abs($p7);\n    const $p8 = $c2d3 + $c3d2;\n    const p8 = qaq(c2d3, c3d2);\n    const _p8 = abs($p8);\n    const p8_ = c2d3_ + c3d2_ + _p8;\n    const $p9 = $p8 * $vₓᵧ;\n    const p9 = qmq(p8, vₓᵧ);\n    const p9_ = p8_ * _vₓᵧ + _p8 * vₓᵧ_ + 2 * abs($p9);\n    const $v5 = 2 * $p7 + $p9;\n    const v5 = qaq(qm2(p7), p9);\n    const v5_ = 2 * p7_ + p9_ + abs($v5);\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\n    //const v4 =\n    //    (2*c1c3 + c2c2)*vₓₓ +\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\n    const $pa = 2 * $c1c3 + $c2c2;\n    const pa = qaq(qm2(c1c3), c2c2);\n    const _pa = abs($pa);\n    const pa_ = 2 * c1c3_ + c2c2_ + abs($pa);\n    const $pb = 2 * $d1d3 + $d2d2;\n    const pb = qaq(qm2(d1d3), d2d2);\n    const _pb = abs($pb);\n    const pb_ = 2 * d1d3_ + d2d2_ + abs($pb);\n    const $pc = $c1d3 + $c2d2;\n    const pc = qaq(c1d3, c2d2);\n    const pc_ = c1d3_ + c2d2_ + abs($pc);\n    const $pd = $pc + $c3d1;\n    const pd = qaq(pc, c3d1);\n    const _pd = abs($pd);\n    const pd_ = pc_ + c3d1_ + _pd;\n    const $pe = $pa * $vₓₓ;\n    const pe = qmq(pa, vₓₓ);\n    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * abs($pe);\n    const $pf = $pb * $vᵧᵧ;\n    const pf = qmq(pb, vᵧᵧ);\n    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * abs($pf);\n    const $pg = $pe + $pf;\n    const pg = qaq(pe, pf);\n    const pg_ = pe_ + pf_ + abs($pg);\n    const $rp = $pd * $vₓᵧ;\n    const rp = qmq(pd, vₓᵧ);\n    const rp_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * abs($rp);\n    const $v4 = $pg + $rp;\n    const v4 = qaq(pg, rp);\n    const v4_ = pg_ + rp_ + abs($v4);\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\n    //const v3 =\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\n    //    c3*vₓ +\n    //    d3*vᵧ;\n    const $ph = $c0c3 + $c1c2;\n    const ph = qaq(c0c3, c1c2);\n    const _ph = abs($ph);\n    const ph_ = c0c3_ + c1c2_ + _ph;\n    const $pi = $d0d3 + $d1d2;\n    const pi = qaq(d0d3, d1d2);\n    const _pi = abs($pi);\n    const pi_ = d0d3_ + d1d2_ + _pi;\n    const $pj = $c0d3 + $c1d2;\n    const pj = qaq(c0d3, c1d2);\n    const pj_ = c0d3_ + c1d2_ + abs($pj);\n    const $pk = $c2d1 + $c3d0;\n    const pk = qaq(c2d1, c3d0);\n    const pk_ = c2d1_ + c3d0_ + abs($pk);\n    const $pl = $pj + $pk;\n    const pl = qaq(pj, pk);\n    const _pl = abs($pl);\n    const pl_ = pj_ + pk_ + _pl;\n    const $pm = $ph * $vₓₓ;\n    const pm = qmq(ph, vₓₓ);\n    const pm_ = ph_ * _vₓₓ + _ph * vₓₓ_ + 2 * abs($pm);\n    const $pn = $pi * $vᵧᵧ;\n    const pn = qmq(pi, vᵧᵧ);\n    const pn_ = pi_ * _vᵧᵧ + _pi * vᵧᵧ_ + 2 * abs($pn);\n    const $po = 2 * ($pm + $pn);\n    const po = qm2(qaq(pm, pn));\n    const po_ = 2 * (pm_ + pn_) + abs($po);\n    const $pp = $pl * $vₓᵧ;\n    const pp = qmq(pl, vₓᵧ);\n    const pp_ = pl_ * _vₓᵧ + _pl * vₓᵧ_ + 2 * abs($pp);\n    const $rn = $c3 * $vₓ;\n    const rn = qmq(c3, vₓ);\n    const rn_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * abs($rn);\n    const $ro = $d3 * $vᵧ;\n    const ro = qmq(d3, vᵧ);\n    const ro_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * abs($ro);\n    const $pq = $rn + $ro;\n    const pq = qaq(rn, ro);\n    const pq_ = rn_ + ro_ + abs($pq);\n    const $pr = $po + $pp;\n    const pr = qaq(po, pp);\n    const pr_ = po_ + pp_ + abs($pr);\n    const $v3 = $pr + $pq;\n    const v3 = qaq(pr, pq);\n    const v3_ = pr_ + pq_ + abs($v3);\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\n    //const v2 =\n    //    (2*c0c2 + c1c1)*vₓₓ +\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\n    //    c2*vₓ +\n    //    d2*vᵧ;\n    const $ps = 2 * $c0c2 + $c1c1;\n    const ps = qaq(qm2(c0c2), c1c1);\n    const _ps = abs($ps);\n    const ps_ = 2 * c0c2_ + c1c1_ + _ps;\n    const $pt = 2 * $d0d2 + $d1d1;\n    const pt = qaq(qm2(d0d2), d1d1);\n    const _pt = abs($pt);\n    const pt_ = 2 * d0d2_ + d1d1_ + _pt;\n    const $pu = $c0d2 + $c1d1;\n    const pu = qaq(c0d2, c1d1);\n    const pu_ = c0d2_ + c1d1_ + abs($pu);\n    const $pv = $pu + $c2d0;\n    const pv = qaq(pu, c2d0);\n    const _pv = abs($pv);\n    const pv_ = pu_ + c2d0_ + _pv;\n    const $pw = $ps * $vₓₓ;\n    const pw = qmq(ps, vₓₓ);\n    const pw_ = ps_ * _vₓₓ + _ps * vₓₓ_ + 2 * abs($pw);\n    const $px = $pt * $vᵧᵧ;\n    const px = qmq(pt, vᵧᵧ);\n    const px_ = pt_ * _vᵧᵧ + _pt * vᵧᵧ_ + 2 * abs($px);\n    const $py = $pv * $vₓᵧ;\n    const py = qmq(pv, vₓᵧ);\n    const py_ = pv_ * _vₓᵧ + _pv * vₓᵧ_ + 2 * abs($py);\n    const $pz = $pw + $px;\n    const pz = qaq(pw, px);\n    const pz_ = pw_ + px_ + abs($pz);\n    const $r1 = $pz + $py;\n    const r1 = qaq(pz, py);\n    const r1_ = pz_ + py_ + abs($r1);\n    const $r2 = $c2 * $vₓ;\n    const r2 = qmq(c2, vₓ);\n    const r2_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * abs($r2);\n    const $r3 = $d2 * $vᵧ;\n    const r3 = qmq(d2, vᵧ);\n    const r3_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * abs($r3);\n    const $r4 = $r2 + $r3;\n    const r4 = qaq(r2, r3);\n    const r4_ = r2_ + r3_ + abs($r4);\n    const $v2 = $r1 + $r4;\n    const v2 = qaq(r1, r4);\n    const v2_ = r1_ + r4_ + abs($v2);\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\n    //const v1 =\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    (c0d1 + c1d0)*vₓᵧ +\n    //    c1*vₓ +\n    //    d1*vᵧ;\n    const $r5 = $c0c1 * $vₓₓ;\n    const r5 = qmq(c0c1, vₓₓ);\n    const r5_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($r5);\n    const $r6 = $d0d1 * $vᵧᵧ;\n    const r6 = qmq(d0d1, vᵧᵧ);\n    const r6_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($r6);\n    const $r7 = $c0d1 + $c1d0;\n    const r7 = qaq(c0d1, c1d0);\n    const _r7 = abs($r7);\n    const r7_ = c0d1_ + c1d0_ + _r7;\n    const $r8 = $r7 * $vₓᵧ;\n    const r8 = qmq(r7, vₓᵧ);\n    const r8_ = r7_ * _vₓᵧ + _r7 * vₓᵧ_ + 2 * abs($r8);\n    const $r9 = 2 * ($r5 + $r6);\n    const r9 = qm2(qaq(r5, r6));\n    const r9_ = 2 * (r5_ + r6_) + abs($r9);\n    const $ra = $r9 + $r8;\n    const ra = qaq(r9, r8);\n    const ra_ = r9_ + r8_ + abs($ra);\n    const $rb = $c1 * $vₓ;\n    const rb = qmq(c1, vₓ);\n    const rb_ = c1_ * _vₓ + _c1 * vₓ_ + 2 * abs($rb);\n    const $rc = $d1 * $vᵧ;\n    const rc = qmq(d1, vᵧ);\n    const rc_ = d1_ * _vᵧ + _d1 * vᵧ_ + 2 * abs($rc);\n    const $rd = $rb + $rc;\n    const rd = qaq(rb, rc);\n    const rd_ = rb_ + rc_ + abs($rd);\n    const $v1 = $ra + $rd;\n    const v1 = qaq(ra, rd);\n    const v1_ = ra_ + rd_ + abs($v1);\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\n    //const v0 =\n    //    c0c0*vₓₓ +\n    //    c0d0*vₓᵧ +\n    //    d0d0*vᵧᵧ +\n    //    c0*vₓ +\n    //    d0*vᵧ +\n    //    v;\n    const $re = $c0c0 * $vₓₓ;\n    const re = qmq(c0c0, vₓₓ);\n    const re_ = _c0c0 * vₓₓ_ + 2 * abs($re);\n    const $rf = $c0d0 * $vₓᵧ;\n    const rf = qmq(c0d0, vₓᵧ);\n    const rf_ = _c0d0 * vₓᵧ_ + 2 * abs($rf);\n    const $rg = $d0d0 * $vᵧᵧ;\n    const rg = qmq(d0d0, vᵧᵧ);\n    const rg_ = _d0d0 * vᵧᵧ_ + 2 * abs($rg);\n    const $rh = c0 * $vₓ;\n    const rh = qmd(c0, vₓ);\n    const rh_ = _c0 * vₓ_ + abs($rh);\n    const $ri = d0 * $vᵧ;\n    const ri = qmd(d0, vᵧ);\n    const ri_ = _d0 * vᵧ_ + abs($ri);\n    const $rj = $re + $rf;\n    const rj = qaq(re, rf);\n    const rj_ = re_ + rf_ + abs($rj);\n    const $rk = $rj + $rg;\n    const rk = qaq(rj, rg);\n    const rk_ = rj_ + rg_ + abs($rk);\n    const $rl = $rh + $ri;\n    const rl = qaq(rh, ri);\n    const rl_ = rh_ + ri_ + abs($rl);\n    const $rm = $rk + $rl;\n    const rm = qaq(rk, rl);\n    const rm_ = rk_ + rl_ + abs($rm);\n    const $v0 = $rm + $v;\n    const v0 = qaq(rm, v);\n    const v0_ = rm_ + v_ + abs($v0);\n    return {\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\n        errBound: [γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez2-bez3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez1Dd: () => (/* binding */ getCoeffsBez3Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of an order\n * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).\n *\n * The returned polynomial degree will be 3\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez3Bez1Dd(ps1, ps2) {\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\n    const $vₓₓₓ = vₓₓₓ[1];\n    const $vₓₓᵧ = vₓₓᵧ[1];\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\n    const $vₓₓ = vₓₓ[1];\n    const $vₓᵧ = vₓᵧ[1];\n    const $vᵧᵧ = vᵧᵧ[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const $c1 = c1[1];\n    const $d1 = d1[1];\n    const _c0 = abs(c0);\n    const _c1 = abs($c1);\n    const _d0 = abs(d0);\n    const _d1 = abs($d1);\n    const $c0c0 = c0 * c0;\n    const $c0c1 = c0 * $c1;\n    const $c0d0 = c0 * d0;\n    const $c0d1 = c0 * $d1;\n    const $c1c1 = $c1 * $c1;\n    const $c1d0 = $c1 * d0;\n    const $c1d1 = $c1 * $d1;\n    const $d0d0 = d0 * d0;\n    const $d0d1 = d0 * $d1;\n    const $d1d1 = $d1 * $d1;\n    const c0c0 = tp(c0, c0); // error free\n    const c0c1 = qmd(c0, c1);\n    const c0c1_ = abs($c0c1);\n    const c0d0 = tp(c0, d0); // error free\n    const c0d1 = qmd(c0, d1);\n    const c0d1_ = abs($c0d1);\n    const c1c1 = qmq(c1, c1);\n    const c1c1_ = 2 * abs($c1c1);\n    const c1d0 = qmd(d0, c1);\n    const c1d0_ = abs($c1d0);\n    const c1d1 = qmq(c1, d1);\n    const c1d1_ = 2 * abs($c1d1);\n    const d0d0 = tp(d0, d0); // error free\n    const d0d1 = qmd(d0, d1);\n    const d0d1_ = abs($d0d1);\n    const d1d1 = qmq(d1, d1);\n    const d1d1_ = 2 * abs($d1d1);\n    const _c0c0 = abs($c0c0);\n    const _c0c1 = abs($c0c1);\n    const _c0d0 = abs($c0d0);\n    const _c0d1 = abs($c0d1);\n    const _c1c1 = abs($c1c1);\n    const _c1d0 = abs($c1d0);\n    const _c1d1 = abs($c1d1);\n    const _d0d0 = abs($d0d0);\n    const _d0d1 = abs($d0d1);\n    const _d1d1 = abs($d1d1);\n    const $z1 = c0 * $vₓₓₓ;\n    const z1 = qmd(c0, vₓₓₓ);\n    const z1_ = _c0 * vₓₓₓ_ + abs($z1);\n    const $za = 3 * c0;\n    const za = tp(3, c0);\n    const _za = abs($za);\n    const $z7 = $za * $vₓₓₓ;\n    const z7 = qmq(za, vₓₓₓ);\n    const z7_ = _za * vₓₓₓ_ + 2 * abs($z7);\n    const $z2 = c0 * $vₓₓᵧ;\n    const z2 = qmd(c0, vₓₓᵧ);\n    const z2_ = _c0 * vₓₓᵧ_ + abs($z2);\n    const $z3 = d0 * $vₓₓᵧ;\n    const z3 = qmd(d0, vₓₓᵧ);\n    const z3_ = _d0 * vₓₓᵧ_ + abs($z3);\n    const $z4 = c0 * $vₓᵧᵧ;\n    const z4 = qmd(c0, vₓᵧᵧ);\n    const z4_ = _c0 * vₓᵧᵧ_ + abs($z4);\n    const $z5 = d0 * $vₓᵧᵧ;\n    const z5 = qmd(d0, vₓᵧᵧ);\n    const z5_ = _d0 * vₓᵧᵧ_ + abs($z5);\n    const $z6 = d0 * $vᵧᵧᵧ;\n    const z6 = qmd(d0, vᵧᵧᵧ);\n    const z6_ = _d0 * vᵧᵧᵧ_ + abs($z6);\n    const $zb = 3 * d0;\n    const zb = tp(3, d0);\n    const _zb = abs($zb);\n    const $z8 = $zb * $vᵧᵧᵧ;\n    const z8 = qmq(zb, vᵧᵧᵧ);\n    const z8_ = _zb * vᵧᵧᵧ_ + 2 * abs($z8);\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\n    //const v3 =\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\n    const $u1 = $c1 * $vₓₓₓ;\n    const u1 = qmq(c1, vₓₓₓ);\n    const u1_ = _c1 * vₓₓₓ_ + 2 * abs($u1);\n    const $u2 = $c1 * $vₓᵧᵧ;\n    const u2 = qmq(c1, vₓᵧᵧ);\n    const u2_ = _c1 * vₓᵧᵧ_ + 2 * abs($u2);\n    const $u3 = $d1 * $vₓₓᵧ;\n    const u3 = qmq(d1, vₓₓᵧ);\n    const u3_ = _d1 * vₓₓᵧ_ + 2 * abs($u3);\n    const $u4 = $d1 * $vᵧᵧᵧ;\n    const u4 = qmq(d1, vᵧᵧᵧ);\n    const u4_ = _d1 * vᵧᵧᵧ_ + 2 * abs($u4);\n    const $u5 = $u1 + $u3;\n    const u5 = qaq(u1, u3);\n    const _u5 = abs($u5);\n    const u5_ = u1_ + u3_ + _u5;\n    const $u6 = $u2 + $u4;\n    const u6 = qaq(u2, u4);\n    const _u6 = abs($u6);\n    const u6_ = u2_ + u4_ + _u6;\n    const $u7 = $c1c1 * $u5;\n    const u7 = qmq(c1c1, u5);\n    const u7_ = c1c1_ * _u5 + _c1c1 * u5_ + 2 * abs($u7);\n    const $u8 = $d1d1 * $u6;\n    const u8 = qmq(d1d1, u6);\n    const u8_ = d1d1_ * _u6 + _d1d1 * u6_ + 2 * abs($u8);\n    const $v3 = $u7 + $u8;\n    const v3 = qaq(u7, u8);\n    const v3_ = u7_ + u8_ + abs($v3);\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\n    //const v2 =\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\n    //const v2 =\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\n    const $u9 = $z7 + $z3;\n    const u9 = qaq(z7, z3);\n    const u9_ = z7_ + z3_ + abs($u9);\n    const $ua = 2 * ($z2 + $z5);\n    const ua = qm2(qaq(z2, z5));\n    const ua_ = 2 * (z2_ + z5_) + abs($ua);\n    const $ub = $z4 + $z8;\n    const ub = qaq(z4, z8);\n    const ub_ = z4_ + z8_ + abs($ub);\n    const $uc = $u9 + $vₓₓ;\n    const uc = qaq(u9, vₓₓ);\n    const _uc = abs($uc);\n    const uc_ = u9_ + vₓₓ_ + _uc;\n    const $ud = $ua + $vₓᵧ;\n    const ud = qaq(ua, vₓᵧ);\n    const _ud = abs($ud);\n    const ud_ = ua_ + vₓᵧ_ + _ud;\n    const $ue = $ub + $vᵧᵧ;\n    const ue = qaq(ub, vᵧᵧ);\n    const _ue = abs($ue);\n    const ue_ = ub_ + vᵧᵧ_ + _ue;\n    const $uf = $c1c1 * $uc;\n    const uf = qmq(c1c1, uc);\n    const uf_ = c1c1_ * _uc + _c1c1 * uc_ + 2 * abs($uf);\n    const $ug = $c1d1 * $ud;\n    const ug = qmq(c1d1, ud);\n    const ug_ = c1d1_ * _ud + _c1d1 * ud_ + 2 * abs($ug);\n    const $uh = $d1d1 * $ue;\n    const uh = qmq(d1d1, ue);\n    const uh_ = d1d1_ * _ue + _d1d1 * ue_ + 2 * abs($uh);\n    const $ui = $uf + $ug;\n    const ui = qaq(uf, ug);\n    const ui_ = uf_ + ug_ + abs($ui);\n    const $v2 = $ui + $uh;\n    const v2 = qaq(ui, uh);\n    const v2_ = ui_ + uh_ + abs($v2);\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\n    //const v1 =\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\n    //    vₓ*c1 +\n    //    vᵧ*d1;\n    const $uj = 2 * ($z3 + $vₓₓ);\n    const uj = qm2(qaq(z3, vₓₓ));\n    const uj_ = 2 * (z3_ + vₓₓ_) + abs($uj);\n    const $uk = 2 * ($z4 + $vᵧᵧ);\n    const uk = qm2(qaq(z4, vᵧᵧ));\n    const uk_ = 2 * (z4_ + vᵧᵧ_) + abs($uk);\n    const $un = $z7 + $uj;\n    const un = qaq(z7, uj);\n    const _un = abs($un);\n    const un_ = z7_ + uj_ + _un;\n    const $uo = $z8 + $uk;\n    const uo = qaq(z8, uk);\n    const _uo = abs($uo);\n    const uo_ = z8_ + uk_ + _uo;\n    const $up = $z2 + $vₓᵧ;\n    const up = qaq(z2, vₓᵧ);\n    const _up = abs($up);\n    const up_ = z2_ + vₓᵧ_ + _up;\n    const $uq = $z5 + $vₓᵧ;\n    const uq = qaq(z5, vₓᵧ);\n    const _uq = abs($uq);\n    const uq_ = z5_ + vₓᵧ_ + _uq;\n    const $ur = $c0c1 * $un;\n    const ur = qmq(c0c1, un);\n    const ur_ = c0c1_ * _un + _c0c1 * un_ + 2 * abs($ur);\n    const $us = $d0d1 * $uo;\n    const us = qmq(d0d1, uo);\n    const us_ = d0d1_ * _uo + _d0d1 * uo_ + 2 * abs($us);\n    const $ut = $c0d1 * $up;\n    const ut = qmq(c0d1, up);\n    const ut_ = c0d1_ * _up + _c0d1 * up_ + 2 * abs($ut);\n    const $uu = $c1d0 * $uq;\n    const uu = qmq(c1d0, uq);\n    const uu_ = c1d0_ * _uq + _c1d0 * uq_ + 2 * abs($uu);\n    const $uv = $c1 * $vₓ;\n    const uv = qmq(c1, vₓ);\n    const uv_ = _c1 * vₓ_ + 2 * abs($uv);\n    const $uw = $d1 * $vᵧ;\n    const uw = qmq(d1, vᵧ);\n    const uw_ = _d1 * vᵧ_ + 2 * abs($uw);\n    const $ux = $ur + $us;\n    const ux = qaq(ur, us);\n    const ux_ = ur_ + us_ + abs($ux);\n    const $uy = $ut + $uu;\n    const uy = qaq(ut, uu);\n    const uy_ = ut_ + uu_ + abs($uy);\n    const $uz = $ux + $uy;\n    const uz = qaq(ux, uy);\n    const uz_ = ux_ + uy_ + abs($uz);\n    const $u0 = $uv + $uw;\n    const u0 = qaq(uv, uw);\n    const u0_ = uv_ + uw_ + abs($u0);\n    const $v1 = $uz + $u0;\n    const v1 = qaq(uz, u0);\n    const v1_ = uz_ + u0_ + abs($v1);\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\n    //const v0 =\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\n    //    c0d0*vₓᵧ +\n    //    c0*vₓ    +\n    //    d0*vᵧ    +\n    //    v;\n    //const v0 =\n    //    c0c0*(z1 + z3 + vₓₓ) +\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\n    //    c0d0*vₓᵧ +\n    //    c0*vₓ    +\n    //    d0*vᵧ    +\n    //    v;\n    const $f1 = $z1 + $z3;\n    const f1 = qaq(z1, z3);\n    const f1_ = z1_ + z3_ + abs($f1);\n    const $f2 = $z6 + $z4;\n    const f2 = qaq(z6, z4);\n    const f2_ = z6_ + z4_ + abs($f2);\n    const $f3 = $f1 + $vₓₓ;\n    const f3 = qaq(f1, vₓₓ);\n    const _f3 = abs($f3);\n    const f3_ = f1_ + vₓₓ_ + _f3;\n    const $f4 = $f2 + $vᵧᵧ;\n    const f4 = qaq(f2, vᵧᵧ);\n    const _f4 = abs($f4);\n    const f4_ = f2_ + vᵧᵧ_ + _f4;\n    const $f5 = $c0c0 * $f3;\n    const f5 = qmq(c0c0, f3);\n    const f5_ = _c0c0 * f3_ + 2 * abs($f5);\n    const $f6 = $d0d0 * $f4;\n    const f6 = qmq(d0d0, f4);\n    const f6_ = _d0d0 * f4_ + 2 * abs($f6);\n    const $f7 = $c0d0 * $vₓᵧ;\n    const f7 = qmq(c0d0, vₓᵧ);\n    const f7_ = _c0d0 * vₓᵧ_ + 2 * abs($f7);\n    const $f8 = $f5 + $f6;\n    const f8 = qaq(f5, f6);\n    const f8_ = f5_ + f6_ + abs($f8);\n    const $f9 = $f8 + $f7;\n    const f9 = qaq(f8, f7);\n    const f9_ = f8_ + f7_ + abs($f9);\n    const $fa = c0 * $vₓ;\n    const fa = qmd(c0, vₓ);\n    const fa_ = _c0 * vₓ_ + abs($fa);\n    const $fb = d0 * $vᵧ;\n    const fb = qmd(d0, vᵧ);\n    const fb_ = _d0 * vᵧ_ + abs($fb);\n    const $fc = $fa + $fb;\n    const fc = qaq(fa, fb);\n    const fc_ = fa_ + fb_ + abs($fc);\n    const $fd = $f9 + $fc;\n    const fd = qaq(f9, fc);\n    const fd_ = f9_ + fc_ + abs($fd);\n    const $v0 = $fd + $v;\n    const v0 = qaq(fd, v);\n    const v0_ = fd_ + v_ + abs($v0);\n    return {\n        coeffs: [v3, v2, v1, v0],\n        errBound: [γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez3-bez1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez2Dd: () => (/* binding */ getCoeffsBez3Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of an order\n * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).\n *\n * The returned polynomial degree will be 6\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez3Bez2Dd(ps1, ps2) {\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\n    const $vₓₓₓ = vₓₓₓ[1];\n    const $vₓₓᵧ = vₓₓᵧ[1];\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\n    const $vₓₓ = vₓₓ[1];\n    const $vₓᵧ = vₓᵧ[1];\n    const $vᵧᵧ = vᵧᵧ[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const _vₓₓₓ = abs($vₓₓₓ);\n    const _vₓₓᵧ = abs($vₓₓᵧ);\n    const _vₓᵧᵧ = abs($vₓᵧᵧ);\n    const _vᵧᵧᵧ = abs($vᵧᵧᵧ);\n    const _vₓₓ = abs($vₓₓ);\n    const _vᵧᵧ = abs($vᵧᵧ);\n    const _vₓᵧ = abs($vₓᵧ);\n    const _vₓ = abs($vₓ);\n    const _vᵧ = abs($vᵧ);\n    const $c1 = c1[1];\n    const $c2 = c2[1];\n    const $d1 = d1[1];\n    const $d2 = d2[1];\n    const _c0 = abs(c0);\n    const _c1 = abs($c1);\n    const _c2 = abs($c2);\n    const _d0 = abs(d0);\n    const _d1 = abs($d1);\n    const _d2 = abs($d2);\n    const $c0c0 = c0 * c0;\n    const $c0c1 = c0 * $c1;\n    const $c0c2 = c0 * $c2;\n    const $c0d0 = c0 * d0;\n    const $c0d1 = c0 * $d1;\n    const $c0d2 = c0 * $d2;\n    const $c1c1 = $c1 * $c1;\n    const $c1c2 = $c1 * $c2;\n    const $c1d0 = $c1 * d0;\n    const $c1d1 = $c1 * $d1;\n    const $c1d2 = $c1 * $d2;\n    const $c2d1 = $c2 * $d1;\n    const $c2c2 = $c2 * $c2;\n    const $c2d0 = $c2 * d0;\n    const $c2d2 = $c2 * $d2;\n    const $d0d0 = d0 * d0;\n    const $d0d1 = d0 * $d1;\n    const $d0d2 = d0 * $d2;\n    const $d1d1 = $d1 * $d1;\n    const $d1d2 = $d1 * $d2;\n    const $d2d2 = $d2 * $d2;\n    const c0c0 = tp(c0, c0); // error free\n    const c0c1 = qmd(c0, c1);\n    const c0c1_ = abs($c0c1);\n    const c0c2 = qmd(c0, c2);\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\n    const c0d0 = tp(c0, d0); // error free\n    const c0d1 = qmd(c0, d1);\n    const c0d1_ = abs($c0d1);\n    const c0d2 = qmd(c0, d2);\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\n    const c1c1 = qmq(c1, c1);\n    const c1c1_ = 2 * abs($c1c1);\n    const c1c2 = qmq(c1, c2);\n    const c1c2_ = _c1 * c2_ + 2 * abs($c1c2);\n    const c1d0 = qmd(d0, c1);\n    const c1d0_ = abs($c1d0);\n    const c1d1 = qmq(c1, d1);\n    const c1d1_ = 2 * abs($c1d1);\n    const c1d2 = qmq(c1, d2);\n    const c1d2_ = _c1 * d2_ + 2 * abs($c1d2);\n    const c2d1 = qmq(c2, d1);\n    const c2d1_ = c2_ * _d1 + 2 * abs($c2d1);\n    const c2c2 = qmq(c2, c2);\n    const c2c2_ = 2 * (c2_ * _c2 + abs($c2c2));\n    const c2d0 = qmd(d0, c2);\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\n    const c2d2 = qmq(c2, d2);\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\n    const d0d0 = tp(d0, d0); // error free\n    const d0d1 = qmd(d0, d1);\n    const d0d1_ = abs($d0d1);\n    const d0d2 = qmd(d0, d2);\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\n    const d1d1 = qmq(d1, d1);\n    const d1d1_ = 2 * abs($d1d1);\n    const d1d2 = qmq(d1, d2);\n    const d1d2_ = _d1 * d2_ + 2 * abs($d1d2);\n    const d2d2 = qmq(d2, d2);\n    const d2d2_ = 2 * (d2_ * _d2 + abs($d2d2));\n    const _c0c0 = abs($c0c0);\n    const _c0c1 = abs($c0c1);\n    const _c0d0 = abs($c0d0);\n    const _c0d1 = abs($c0d1);\n    const _c1c2 = abs($c1c2);\n    const _c2c2 = abs($c2c2);\n    const _c2d2 = abs($c2d2);\n    const _c1d0 = abs($c1d0);\n    const _d0d0 = abs($d0d0);\n    const _d0d1 = abs($d0d1);\n    const _d1d2 = abs($d1d2);\n    const _d2d2 = abs($d2d2);\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\n    //const v6 =\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\n    const e1 = qmq(c2, vₓₓₓ);\n    const $e1 = $c2 * $vₓₓₓ;\n    const e1_ = c2_ * _vₓₓₓ + _c2 * vₓₓₓ_ + 2 * abs($e1);\n    const e2 = qmq(c2, vₓᵧᵧ);\n    const $e2 = $c2 * $vₓᵧᵧ;\n    const e2_ = c2_ * _vₓᵧᵧ + _c2 * vₓᵧᵧ_ + 2 * abs($e2);\n    const e3 = qmq(d2, vₓₓᵧ);\n    const $e3 = $d2 * $vₓₓᵧ;\n    const e3_ = d2_ * _vₓₓᵧ + _d2 * vₓₓᵧ_ + 2 * abs($e3);\n    const e4 = qmq(d2, vᵧᵧᵧ);\n    const $e4 = $d2 * $vᵧᵧᵧ;\n    const e4_ = d2_ * _vᵧᵧᵧ + _d2 * vᵧᵧᵧ_ + 2 * abs($e4);\n    const $e5 = $e1 + $e3;\n    const e5 = qaq(e1, e3);\n    const _e5 = abs($e5);\n    const e5_ = e1_ + e3_ + _e5;\n    const $e6 = $e2 + $e4;\n    const e6 = qaq(e2, e4);\n    const _e6 = abs($e6);\n    const e6_ = e2_ + e4_ + _e6;\n    const $e7 = $c2c2 * $e5;\n    const e7 = qmq(c2c2, e5);\n    const e7_ = c2c2_ * _e5 + _c2c2 * e5_ + 2 * abs($e7);\n    const $e8 = $d2d2 * $e6;\n    const e8 = qmq(d2d2, e6);\n    const e8_ = d2d2_ * _e6 + _d2d2 * e6_ + 2 * abs($e8);\n    const $v6 = $e7 + $e8;\n    const v6 = qaq(e7, e8);\n    const v6_ = e7_ + e8_ + abs($v6);\n    ///\n    const $z1 = $c0c2 + $c1c1;\n    const z1 = qaq(c0c2, c1c1);\n    const _z1 = abs($z1);\n    const z1_ = c0c2_ + c1c1_ + _z1;\n    const $z2 = $d0d2 + $d1d1;\n    const z2 = qaq(d0d2, d1d1);\n    const _z2 = abs($z2);\n    const z2_ = d0d2_ + d1d1_ + _z2;\n    const $z3 = 2 * $c0c2 + $c1c1;\n    const _z3 = abs($z3);\n    const z3 = qaq(qm2(c0c2), c1c1);\n    const z3_ = 2 * c0c2_ + c1c1_ + _z3;\n    const $z4 = 2 * $d0d2 + $d1d1;\n    const z4 = qaq(qm2(d0d2), d1d1);\n    const _z4 = abs($z4);\n    const z4_ = 2 * d0d2_ + d1d1_ + _z4;\n    const $z5 = 2 * $c1d1 + $c2d0;\n    const z5 = qaq(qm2(c1d1), c2d0);\n    const _z5 = abs($z5);\n    const z5_ = 2 * c1d1_ + c2d0_ + _z5;\n    const $z6 = 2 * $c1d1 + $c0d2;\n    const z6 = qaq(qm2(c1d1), c0d2);\n    const _z6 = abs($z6);\n    const z6_ = 2 * c1d1_ + c0d2_ + _z6;\n    const $z7 = 2 * $c2d0 + $c1d1;\n    const z7 = qaq(qm2(c2d0), c1d1);\n    const z7_ = 2 * c2d0_ + c1d1_ + abs($z7);\n    const $z8 = 6 * $c0c2 + $c1c1;\n    const $q1 = 6 * $c0c2;\n    const q1 = qmd(6, c0c2);\n    const q1_ = 6 * c0c2_ + abs($q1);\n    const z8 = qaq(q1, c1c1);\n    const z8_ = q1_ + c1c1_ + abs($q1 + $c1c1);\n    const $z9 = 6 * $d0d2 + $d1d1;\n    const $q2 = 6 * $d0d2;\n    const q2 = qmd(6, d0d2);\n    const q2_ = 6 * d0d2_ + abs($q2);\n    const z9 = qaq(q2, d1d1);\n    const z9_ = q2_ + d1d1_ + abs($q2 + $d1d1);\n    const $za = $c1d2 + $c2d1;\n    const za = qaq(c1d2, c2d1);\n    const _za = abs($za);\n    const za_ = c1d2_ + c2d1_ + _za;\n    const $zb = $c0d2 + $c2d0;\n    const zb = qaq(c0d2, c2d0);\n    const zb_ = c0d2_ + c2d0_ + abs($zb);\n    const $zc = 2 * $c1d0 + $c0d1;\n    const zc = qaq(qm2(c1d0), c0d1);\n    const zc_ = 2 * c1d0_ + c0d1_ + abs($zc);\n    const $zd = 2 * $c0d1 + $c1d0;\n    const zd = qaq(qm2(c0d1), c1d0);\n    const zd_ = 2 * c0d1_ + c1d0_ + abs($zd);\n    const $zf = $c0d2 + $c1d1;\n    const zf = qaq(c0d2, c1d1);\n    const zf_ = c0d2_ + c1d1_ + abs($zf);\n    const $ze = $zf + $c2d0;\n    const ze = qaq(zf, c2d0);\n    const _ze = abs($ze);\n    const ze_ = zf_ + c2d0_ + _ze;\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\n    //const v5 =\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\n    const $s0 = 3 * $c2c2;\n    const s0 = qmd(3, c2c2);\n    const s0_ = 3 * c2c2_ + abs($s0);\n    const _s0 = abs($s0);\n    const $t1 = 3 * $d2d2;\n    const t1 = qmd(3, d2d2);\n    const t1_ = 3 * d2d2_ + abs($t1);\n    const _t1 = abs($t1);\n    const $s1 = $s0 * $vₓₓₓ;\n    const s1 = qmq(s0, vₓₓₓ);\n    const s1_ = s0_ * _vₓₓₓ + _s0 * vₓₓₓ_ + 2 * abs($s1);\n    const $s2 = $c2c2 * $vₓₓᵧ;\n    const s2 = qmq(c2c2, vₓₓᵧ);\n    const s2_ = c2c2_ * _vₓₓᵧ + _c2c2 * vₓₓᵧ_ + 2 * abs($s2);\n    const $s3 = 2 * $c2d2 * $vₓₓᵧ;\n    const s3 = qm2(qmq(c2d2, vₓₓᵧ));\n    const s3_ = 2 * (c2d2_ * _vₓₓᵧ + _c2d2 * vₓₓᵧ_ + abs($s3));\n    const $s4 = 2 * $c2d2 * $vₓᵧᵧ;\n    const s4 = qm2(qmq(c2d2, vₓᵧᵧ));\n    const s4_ = 2 * (c2d2_ * _vₓᵧᵧ + _c2d2 * vₓᵧᵧ_ + abs($s4));\n    const $s5 = $d2d2 * $vₓᵧᵧ;\n    const s5 = qmq(d2d2, vₓᵧᵧ);\n    const s5_ = d2d2_ * _vₓᵧᵧ + _d2d2 * vₓᵧᵧ_ + 2 * abs($s5);\n    const $s6 = $t1 * $vᵧᵧᵧ;\n    const s6 = qmq(t1, vᵧᵧᵧ);\n    const s6_ = t1_ * _vᵧᵧᵧ + _t1 * vᵧᵧᵧ_ + 2 * abs($s6);\n    const $s7 = $s1 + $s3;\n    const s7 = qaq(s1, s3);\n    const s7_ = s1_ + s3_ + abs($s7);\n    const $s8 = $s2 + $s4;\n    const s8 = qaq(s2, s4);\n    const s8_ = s2_ + s4_ + abs($s8);\n    const $s9 = $s7 + $s5;\n    const s9 = qaq(s7, s5);\n    const s9_ = s7_ + s5_ + abs($s9);\n    const $sa = $s8 + $s6;\n    const sa = qaq(s8, s6);\n    const sa_ = s8_ + s6_ + abs($sa);\n    const $sb = $c1 * $s9;\n    const sb = qmq(c1, s9);\n    const sb_ = _c1 * s9_ + abs($sb);\n    const $sc = $d1 * $sa;\n    const sc = qmq(d1, sa);\n    const sc_ = _d1 * sa_ + abs($sc);\n    const $v5 = $sb + $sc;\n    const v5 = qaq(sb, sc);\n    const v5_ = sb_ + sc_ + abs($v5);\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\n    //const v4 =\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\n    //    vₓₓ*c2c2 +\n    //    vᵧᵧ*d2d2 +\n    //    vₓᵧ*c2d2;\n    //const v4 =\n    //    (3*c2)*z1*vₓₓₓ + \n    //    (3*d2)*z2*vᵧᵧᵧ + \n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\n    //    vₓₓ*c2c2 +\n    //    vᵧᵧ*d2d2 +\n    //    vₓᵧ*c2d2;\n    const $sd = $d2 * $z3;\n    const sd = qmq(d2, z3);\n    const sd_ = d2_ * _z3 + _d2 * z3_ + 2 * abs($sd);\n    const $se = $d2 * $z6;\n    const se = qmq(d2, z6);\n    const se_ = d2_ * _z6 + _d2 * z6_ + 2 * abs($se);\n    const $sf = $c2 * $z5;\n    const sf = qmq(c2, z5);\n    const sf_ = c2_ * _z5 + _c2 * z5_ + 2 * abs($sf);\n    const $sg = $c2 * $z4;\n    const sg = qmq(c2, z4);\n    const sg_ = c2_ * _z4 + _c2 * z4_ + 2 * abs($sg);\n    const $q3 = 3 * $c2;\n    const q3 = qmd(3, c2);\n    const _q3 = abs($q3);\n    const q3_ = 3 * c2_ + _q3;\n    const $sh = $q3 * $z1;\n    const sh = qmq(q3, z1);\n    const _sh = abs($sh);\n    const sh_ = q3_ * _z1 + _q3 * z1_ + _sh;\n    const $q4 = 3 * $d2;\n    const q4 = qmd(3, d2);\n    const _q4 = abs($q4);\n    const q4_ = 3 * d2_ + _q4;\n    const $si = $q4 * $z2;\n    const si = qmq(q4, z2);\n    const _si = abs($si);\n    const si_ = q4_ * _z2 + _q4 * z2_ + _si;\n    const $sj = $sd + $sf;\n    const sj = qaq(sd, sf);\n    const _sj = abs($sj);\n    const sj_ = sd_ + sf_ + _sj;\n    const $sk = $se + $sg;\n    const sk = qaq(se, sg);\n    const _sk = abs($sk);\n    const sk_ = se_ + sg_ + _sk;\n    const $sl = $sh * $vₓₓₓ;\n    const sl = qmq(sh, vₓₓₓ);\n    const sl_ = sh_ * _vₓₓₓ + _sh * vₓₓₓ_ + 2 * abs($sl);\n    const $sm = $si * $vᵧᵧᵧ;\n    const sm = qmq(si, vᵧᵧᵧ);\n    const sm_ = si_ * _vᵧᵧᵧ + _si * vᵧᵧᵧ_ + 2 * abs($sm);\n    const $sn = $sj * $vₓₓᵧ;\n    const sn = qmq(sj, vₓₓᵧ);\n    const sn_ = sj_ * _vₓₓᵧ + _sj * vₓₓᵧ_ + 2 * abs($sn);\n    const $so = $sk * $vₓᵧᵧ;\n    const so = qmq(sk, vₓᵧᵧ);\n    const so_ = sk_ * _vₓᵧᵧ + _sk * vₓᵧᵧ_ + 2 * abs($so);\n    const $sp = $sl + $sm;\n    const sp = qaq(sl, sm);\n    const sp_ = sl_ + sm_ + abs($sp);\n    const $sq = $sn + $so;\n    const sq = qaq(sn, so);\n    const sq_ = sn_ + so_ + abs($sq);\n    const $sr = $c2c2 * $vₓₓ;\n    const sr = qmq(c2c2, vₓₓ);\n    const sr_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * abs($sr);\n    const $ss = $d2d2 * $vᵧᵧ;\n    const ss = qmq(d2d2, vᵧᵧ);\n    const ss_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * abs($ss);\n    const $st = $c2d2 * $vₓᵧ;\n    const st = qmq(c2d2, vₓᵧ);\n    const st_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * abs($st);\n    const $su = $sr + $ss;\n    const su = qaq(sr, ss);\n    const su_ = sr_ + ss_ + abs($su);\n    const $sv = $sp + $sq;\n    const sv = qaq(sp, sq);\n    const sv_ = sp_ + sq_ + abs($sv);\n    const $sw = $su + $st;\n    const sw = qaq(su, st);\n    const sw_ = su_ + st_ + abs($sw);\n    const $v4 = $sv + $sw;\n    const v4 = qaq(sv, sw);\n    const v4_ = sv_ + sw_ + abs($v4);\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \n    // 2*b1*b2*v_yy\n    //const v3 =\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\n    //const v3 =\n    //    c1*z8*vₓₓₓ +\n    //    d1*z9*vᵧᵧᵧ +        \n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\n    //    za*vₓᵧ;\n    const $sx = $c1 * $z8;\n    const sx = qmq(c1, z8);\n    const _sx = _c1 * z8_ + 2 * abs($sx);\n    const sx_ = 2 * _sx;\n    const $sy = $d1 * $z9;\n    const sy = qmq(d1, z9);\n    const _sy = _d1 * z9_ + 2 * abs($sy);\n    const sy_ = 2 * _sy;\n    const $sz = 2 * c0 * $za;\n    const sz = qmd(2 * c0, za);\n    const sz_ = 2 * _c0 * za_ + abs($sz);\n    const $o1 = 2 * $d1 * $zb;\n    const o1 = qmq(qm2(d1), zb);\n    const o1_ = 2 * _d1 * zb_ + 2 * abs($o1);\n    const $o2 = $c1 * $z7;\n    const o2 = qmq(c1, z7);\n    const o2_ = _c1 * z7_ + 2 * abs($o2);\n    const $o3 = $c1 * $z4;\n    const o3 = qmq(c1, z4);\n    const o3_ = _c1 * z4_ + 2 * abs($o3);\n    const $o4 = $sz + $o2;\n    const o4 = qaq(sz, o2);\n    const _o4 = sz_ + o2_ + abs($o4);\n    const o4_ = sz_ + o2_ + _o4;\n    const $o5 = $o1 + $o3;\n    const o5 = qaq(o1, o3);\n    const _o5 = o1_ + o3_ + abs($o5);\n    const o5_ = o1_ + o3_ + _o5;\n    const $o6 = $d1d2 * $vᵧᵧ;\n    const o6 = qmq(d1d2, vᵧᵧ);\n    const o6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * abs($o6);\n    const $o7 = $c1c2 * $vₓₓ;\n    const o7 = qmq(c1c2, vₓₓ);\n    const o7_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * abs($o7);\n    const $o8 = $za * $vₓᵧ;\n    const o8 = qmq(za, vₓᵧ);\n    const o8_ = za_ * _vₓᵧ + _za * vₓᵧ_ + 2 * abs($o8);\n    const $o9 = $o6 + $o7;\n    const o9 = qaq(o6, o7);\n    const o9_ = o6_ + o7_ + abs($o9);\n    const $oa = $sx * $vₓₓₓ;\n    const oa = qmq(sx, vₓₓₓ);\n    const oa_ = sx_ * _vₓₓₓ + _sx * vₓₓₓ_ + 2 * abs($oa);\n    const $ob = $o4 * $vₓₓᵧ;\n    const ob = qmq(o4, vₓₓᵧ);\n    const ob_ = o4_ * _vₓₓᵧ + _o4 * vₓₓᵧ_ + 2 * abs($ob);\n    const $oc = $sy * $vᵧᵧᵧ;\n    const oc = qmq(sy, vᵧᵧᵧ);\n    const oc_ = sy_ * _vᵧᵧᵧ + _sy * vᵧᵧᵧ_ + 2 * abs($oc);\n    const $od = $o5 * $vₓᵧᵧ;\n    const od = qmq(o5, vₓᵧᵧ);\n    const od_ = o5_ * _vₓᵧᵧ + _o5 * vₓᵧᵧ_ + 2 * abs($od);\n    const $oe = $oa + $oc;\n    const oe = qaq(oa, oc);\n    const oe_ = oa_ + oc_ + abs($oe);\n    const $og = $ob + $od;\n    const og = qaq(ob, od);\n    const og_ = ob_ + od_ + abs($og);\n    const $oh = $oe + $og;\n    const oh = qaq(oe, og);\n    const oh_ = oe_ + og_ + abs($oh);\n    const $oi = 2 * $o9 + $o8;\n    const oi = qaq(qm2(o9), o8);\n    const oi_ = 2 * o9_ + o8_ + abs($oi);\n    const $v3 = $oh + $oi;\n    const v3 = qaq(oh, oi);\n    const v3_ = oh_ + oi_ + abs($v3);\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\n    //const v2 =\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\n    //    (2*c0c2 + c1c1)*vₓₓ +\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\n    //    c2*vₓ +\n    //    d2*vᵧ;\n    //const v2 =\n    //    (3*c0*z1)*vₓₓₓ +\n    //    (3*d0*z2)*vᵧᵧᵧ +\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\n    //    z3*vₓₓ +\n    //    z4*vᵧᵧ +\n    //    ze*vₓᵧ +\n    //    c2*vₓ +\n    //    d2*vᵧ;\n    const $q5 = 3 * c0;\n    const _q5 = abs($q5);\n    const q5 = tp(3, c0); // error free\n    const $oj = $q5 * $z1;\n    const oj = qmq(q5, z1);\n    const _oj = abs($oj);\n    const oj_ = _q5 * z1_ + 2 * abs($oj);\n    const $q6 = 3 * d0;\n    const _q6 = abs($q6);\n    const q6 = tp(3, d0); // error free\n    const $ok = $q6 * $z2;\n    const ok = qmq(q6, z2);\n    const _ok = abs($ok);\n    const ok_ = _q6 * z2_ + 2 * abs($ok);\n    const $ol = c0 * $z6;\n    const ol = qmd(c0, z6);\n    const ol_ = _c0 * z6_ + abs($ol);\n    const $om = c0 * $z4;\n    const om = qmd(c0, z4);\n    const om_ = _c0 * z4_ + abs($om);\n    const $on = d0 * $z3;\n    const on = qmd(d0, z3);\n    const on_ = _d0 * z3_ + abs($on);\n    const $oo = d0 * $z5;\n    const oo = qmd(d0, z5);\n    const oo_ = _d0 * z5_ + abs($oo);\n    const $op = $ol + $on;\n    const op = qaq(ol, on);\n    const _op = abs($op);\n    const op_ = ol_ + on_ + _op;\n    const $oq = $om + $oo;\n    const oq = qaq(om, oo);\n    const _oq = abs($oq);\n    const oq_ = om_ + oo_ + _oq;\n    const $or = $oj * $vₓₓₓ;\n    const or = qmq(oj, vₓₓₓ);\n    const or_ = oj_ * _vₓₓₓ + _oj * vₓₓₓ_ + 2 * abs($or);\n    const $os = $ok * $vᵧᵧᵧ;\n    const os = qmq(ok, vᵧᵧᵧ);\n    const os_ = ok_ * _vᵧᵧᵧ + _ok * vᵧᵧᵧ_ + 2 * abs($os);\n    const $ot = $op * $vₓₓᵧ;\n    const ot = qmq(op, vₓₓᵧ);\n    const ot_ = op_ * _vₓₓᵧ + _op * vₓₓᵧ_ + 2 * abs($ot);\n    const $ou = $oq * $vₓᵧᵧ;\n    const ou = qmq(oq, vₓᵧᵧ);\n    const ou_ = oq_ * _vₓᵧᵧ + _oq * vₓᵧᵧ_ + 2 * abs($ou);\n    const $ov = $z3 * $vₓₓ;\n    const ov = qmq(z3, vₓₓ);\n    const ov_ = z3_ * _vₓₓ + _z3 * vₓₓ_ + 2 * abs($ov);\n    const $ow = $z4 * $vᵧᵧ;\n    const ow = qmq(z4, vᵧᵧ);\n    const ow_ = z4_ * _vᵧᵧ + _z4 * vᵧᵧ_ + 2 * abs($ow);\n    const $ox = $ze * $vₓᵧ;\n    const ox = qmq(ze, vₓᵧ);\n    const ox_ = ze_ * _vₓᵧ + _ze * vₓᵧ_ + 2 * abs($ox);\n    const $oy = $c2 * $vₓ;\n    const oy = qmq(c2, vₓ);\n    const oy_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * abs($oy);\n    const $oz = $d2 * $vᵧ;\n    const oz = qmq(d2, vᵧ);\n    const oz_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * abs($oz);\n    const $p1 = $or + $os;\n    const p1 = qaq(or, os);\n    const p1_ = or_ + os_ + abs($p1);\n    const $p2 = $ot + $ou;\n    const p2 = qaq(ot, ou);\n    const p2_ = ot_ + ou_ + abs($p2);\n    const $p3 = $ov + $ow;\n    const p3 = qaq(ov, ow);\n    const p3_ = ov_ + ow_ + abs($p3);\n    const $p4 = $p1 + $p2;\n    const p4 = qaq(p1, p2);\n    const p4_ = p1_ + p2_ + abs($p4);\n    const $p5 = $p3 + $ox;\n    const p5 = qaq(p3, ox);\n    const p5_ = p3_ + ox_ + abs($p5);\n    const $p6 = $oy + $oz;\n    const p6 = qaq(oy, oz);\n    const p6_ = oy_ + oz_ + abs($p6);\n    const $p7 = $p4 + $p5;\n    const p7 = qaq(p4, p5);\n    const p7_ = p4_ + p5_ + abs($p7);\n    const $v2 = $p7 + $p6;\n    const v2 = qaq(p7, p6);\n    const v2_ = p7_ + p6_ + abs($v2);\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\n    //const v1 =\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\n    //    c1*vₓ + d1*vᵧ;\n    //const v1 =\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\n    //    c0*zc*vₓₓᵧ +\n    //    d0*zd*vₓᵧᵧ +\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\n    //    c1*vₓ + d1*vᵧ;\n    const $p8 = $q5 * $c0c1;\n    const p8 = qmq(q5, c0c1);\n    const _p8 = abs($p8);\n    const p8_ = _q5 * c0c1_ + 2 * _p8;\n    const $p9 = $q6 * $d0d1;\n    const p9 = qmq(q6, d0d1);\n    const _p9 = abs($p9);\n    const p9_ = _q6 * d0d1_ + 2 * _p9;\n    const $pa = c0 * $zc;\n    const pa = qmd(c0, zc);\n    const _pa = abs($pa);\n    const pa_ = _c0 * zc_ + abs($pa);\n    const $pb = d0 * $zd;\n    const pb = qmd(d0, zd);\n    const _pb = abs($pb);\n    const pb_ = _d0 * zd_ + abs($pb);\n    const $pc = $c0c1 * $vₓₓ;\n    const pc = qmq(c0c1, vₓₓ);\n    const pc_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($pc);\n    const $pd = $d0d1 * $vᵧᵧ;\n    const pd = qmq(d0d1, vᵧᵧ);\n    const pd_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($pd);\n    const $pe = $c0d1 * $vₓᵧ;\n    const pe = qmq(c0d1, vₓᵧ);\n    const pe_ = c0d1_ * _vₓᵧ + _c0d1 * vₓᵧ_ + 2 * abs($pe);\n    const $pf = $c1d0 * $vₓᵧ;\n    const pf = qmq(c1d0, vₓᵧ);\n    const pf_ = c1d0_ * _vₓᵧ + _c1d0 * vₓᵧ_ + 2 * abs($pf);\n    const $pg = 2 * ($pc + $pd);\n    const pg = qm2(qaq(pc, pd));\n    const pg_ = 2 * (pc_ + pd_) + abs($pg);\n    const $ph = $pe + $pf;\n    const ph = qaq(pe, pf);\n    const ph_ = pe_ + pf_ + abs($ph);\n    const $pi = $c1 * $vₓ;\n    const pi = qmq(c1, vₓ);\n    const pi_ = _c1 * vₓ_ + 2 * abs($pi);\n    const $pj = $d1 * $vᵧ;\n    const pj = qmq(d1, vᵧ);\n    const pj_ = _d1 * vᵧ_ + 2 * abs($pj);\n    const $pk = $p8 * $vₓₓₓ;\n    const pk = qmq(p8, vₓₓₓ);\n    const pk_ = p8_ * _vₓₓₓ + _p8 * vₓₓₓ_ + 2 * abs($pk);\n    const $pl = $p9 * $vᵧᵧᵧ;\n    const pl = qmq(p9, vᵧᵧᵧ);\n    const pl_ = p9_ * _vᵧᵧᵧ + _p9 * vᵧᵧᵧ_ + 2 * abs($pl);\n    const $pm = $pa * $vₓₓᵧ;\n    const pm = qmq(pa, vₓₓᵧ);\n    const pm_ = pa_ * _vₓₓᵧ + _pa * vₓₓᵧ_ + 2 * abs($pm);\n    const $pn = $pb * $vₓᵧᵧ;\n    const pn = qmq(pb, vₓᵧᵧ);\n    const pn_ = pb_ * _vₓᵧᵧ + _pb * vₓᵧᵧ_ + 2 * abs($pn);\n    const $po = $pk + $pl;\n    const po = qaq(pk, pl);\n    const po_ = pk_ + pl_ + abs($po);\n    const $pp = $pm + $pn;\n    const pp = qaq(pm, pn);\n    const pp_ = pm_ + pn_ + abs($pp);\n    const $pq = $po + $pp;\n    const pq = qaq(po, pp);\n    const pq_ = po_ + pp_ + abs($pq);\n    const $pr = $pg + $ph;\n    const pr = qaq(pg, ph);\n    const pr_ = pg_ + ph_ + abs($pr);\n    const $ps = $pi + $pj;\n    const ps = qaq(pi, pj);\n    const ps_ = pi_ + pj_ + abs($ps);\n    const $pt = $pq + $pr;\n    const pt = qaq(pq, pr);\n    const pt_ = pq_ + pr_ + abs($pt);\n    const $v1 = $pt + $ps;\n    const v1 = qaq(pt, ps);\n    const v1_ = pt_ + ps_ + abs($v1);\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\n    //const v0 =\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\n    //    c0d0*vₓᵧ +\n    //    c0*vₓ +\n    //    d0*vᵧ +\n    //    v;\n    const $pu = c0 * $vₓₓₓ;\n    const pu = qmd(c0, vₓₓₓ);\n    const pu_ = _c0 * vₓₓₓ_ + abs($pu);\n    const $pv = c0 * $vₓᵧᵧ;\n    const pv = qmd(c0, vₓᵧᵧ);\n    const pv_ = _c0 * vₓᵧᵧ_ + abs($pv);\n    const $pw = d0 * $vₓₓᵧ;\n    const pw = qmd(d0, vₓₓᵧ);\n    const pw_ = _d0 * vₓₓᵧ_ + abs($pw);\n    const $px = d0 * $vᵧᵧᵧ;\n    const px = qmd(d0, vᵧᵧᵧ);\n    const px_ = _d0 * vᵧᵧᵧ_ + abs($px);\n    const $py = $pu + $pw;\n    const py = qaq(pu, pw);\n    const py_ = pu_ + pw_ + abs($py);\n    const $pz = $pv + $px;\n    const pz = qaq(pv, px);\n    const pz_ = pv_ + px_ + abs($pz);\n    const $u1 = $py + $vₓₓ;\n    const u1 = qaq(py, vₓₓ);\n    const _u1 = abs($u1);\n    const u1_ = py_ + vₓₓ_ + _u1;\n    const $u2 = $pz + $vᵧᵧ;\n    const u2 = qaq(pz, vᵧᵧ);\n    const _u2 = abs($u2);\n    const u2_ = pz_ + vᵧᵧ_ + _u2;\n    const $u3 = $c0c0 * $u1;\n    const u3 = qmq(c0c0, u1);\n    const u3_ = _c0c0 * u1_ + 2 * abs($u3);\n    const $u4 = $d0d0 * $u2;\n    const u4 = qmq(d0d0, u2);\n    const u4_ = _d0d0 * u2_ + 2 * abs($u4);\n    const $u5 = $c0d0 * $vₓᵧ;\n    const u5 = qmq(c0d0, vₓᵧ);\n    const u5_ = _c0d0 * vₓᵧ_ + 2 * abs($u5);\n    const $u6 = c0 * $vₓ;\n    const u6 = qmd(c0, vₓ);\n    const u6_ = _c0 * vₓ_ + abs($u6);\n    const $u7 = d0 * $vᵧ;\n    const u7 = qmd(d0, vᵧ);\n    const u7_ = _d0 * vᵧ_ + abs($u7);\n    const $u8 = $u3 + $u4;\n    const u8 = qaq(u3, u4);\n    const u8_ = u3_ + u4_ + abs($u8);\n    const $u9 = $u8 + $u5;\n    const u9 = qaq(u8, u5);\n    const u9_ = u8_ + u5_ + abs($u9);\n    const $ua = $u6 + $u7;\n    const ua = qaq(u6, u7);\n    const ua_ = u6_ + u7_ + abs($ua);\n    const $ub = $u9 + $ua;\n    const ub = qaq(u9, ua);\n    const ub_ = u9_ + ua_ + abs($ub);\n    const $v0 = $ub + $v;\n    const v0 = qaq(ub, v);\n    const v0_ = ub_ + v_ + abs($v0);\n    return {\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\n        errBound: [γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez3-bez2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez3Dd: () => (/* binding */ getCoeffsBez3Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the intersection points of 2 order\n * 3 bezier curves (i.e. 2 cubic bezier curves).\n *\n * The returned polynomial degree will be 9\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double-double precision\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez3Bez3Dd(ps1, ps2) {\n    //--------------------------------------------------------------------------\n    // `var` -> a variable\n    // `$var` -> the double precision approximation to `var`\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\n    // `_var_` -> means both absolute value and absolute error bound\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\n    // * the returned errors need to be multiplied by 3γ² to get the true error\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\n    //   due to multiplication by 3*γ² and not 3*u²\n    //--------------------------------------------------------------------------\n    // examples: (all?)\n    // ----------------\n    // let qmd === ddMultDouble2, etc.\n    //\n    // ---------------\n    // 1. double-double X by double\n    // ---------------\n    // qmd(a,b);  // both `a` and `b` is error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\n    //                           === 0|b| + |a|0 + |a*b|\n    //                           === |a*b|\n    //\n    // ---------------\n    // 2a. double-double +/- double-double\n    // ---------------\n    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\n    //                           === _a_ + _b_ + |a+b|\n    //\n    // ---------------\n    // 2b. double-double +/- double-double\n    // ---------------\n    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\n    //                           === 2*_a + 2*_b + |a+b|\n    //                           === 2*(_a + _b) + |a+b| OR\n    //                           === a_ + b_ + |a+b|\n    //\n    // ---------------\n    // 3a. double-double X double-double\n    // ---------------\n    // qmq(a,b);  // both `a` and `b` error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\n    //                           === 0|b| + |a|0 + 2|a*b|\n    //                           === 2|a*b| \n    //\n    // ---------------\n    // 3b. double-double X double-double\n    // ---------------\n    // qmq(a,b);  // both `a` and `b` not error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\n    //\n    // ---------------\n    // 3b. double-double X double-double\n    // ---------------\n    // qmq(a,b);  // both `a` not error-free and `b` error-free\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\n    //                           === a_|b| + 2|a*b| \n    //\n    // ---------------\n    // 4a. double-double +/- double\n    // ---------------\n    // qad(a,b);  // both `a` and `b` error-free\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\n    //                           === 0 + 0 + |a+b|\n    //                           === |a+b| \n    //--------------------------------------------------------------------------\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\n    const $vₓₓₓ = vₓₓₓ[1];\n    const $vₓₓᵧ = vₓₓᵧ[1];\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\n    const $vₓₓ = vₓₓ[1];\n    const $vₓᵧ = vₓᵧ[1];\n    const $vᵧᵧ = vᵧᵧ[1];\n    const $vₓ = vₓ[1];\n    const $vᵧ = vᵧ[1];\n    const $v = v[1];\n    const _vₓₓₓ = abs($vₓₓₓ);\n    const _vₓₓᵧ = abs($vₓₓᵧ);\n    const _vₓᵧᵧ = abs($vₓᵧᵧ);\n    const _vᵧᵧᵧ = abs($vᵧᵧᵧ);\n    const _vₓₓ = abs($vₓₓ);\n    const _vₓᵧ = abs($vₓᵧ);\n    const _vᵧᵧ = abs($vᵧᵧ);\n    const _vₓ = abs($vₓ);\n    const _vᵧ = abs($vᵧ);\n    const _v = abs($v);\n    const $c1 = c1[1];\n    const $c2 = c2[1];\n    const $c3 = c3[1];\n    const $d1 = d1[1];\n    const $d2 = d2[1];\n    const $d3 = d3[1];\n    const _c0 = abs(c0);\n    const _c1 = abs($c1);\n    const _c2 = abs($c2);\n    const _c3 = abs($c3);\n    const _d0 = abs(d0);\n    const _d1 = abs($d1);\n    const _d2 = abs($d2);\n    const _d3 = abs($d3);\n    const $c0c0 = c0 * c0;\n    const $c0c1 = c0 * $c1;\n    const $c0c2 = c0 * $c2;\n    const $c0c3 = c0 * $c3;\n    const $c0d0 = c0 * d0;\n    const $c0d1 = c0 * $d1;\n    const $c0d2 = c0 * $d2;\n    const $c0d3 = c0 * $d3;\n    const $c1c1 = $c1 * $c1;\n    const $c1c2 = $c1 * $c2;\n    const $c1c3 = $c1 * $c3;\n    const $c1d0 = $c1 * d0;\n    const $c1d1 = $c1 * $d1;\n    const $c1d2 = $c1 * $d2;\n    const $c1d3 = $c1 * $d3;\n    const $c2d1 = $c2 * $d1;\n    const $c2c2 = $c2 * $c2;\n    const $c2c3 = $c2 * $c3;\n    const $c2d0 = $c2 * d0;\n    const $c2d2 = $c2 * $d2;\n    const $c2d3 = $c2 * $d3;\n    const $c3c3 = $c3 * $c3;\n    const $c3d0 = $c3 * d0;\n    const $c3d1 = $c3 * $d1;\n    const $c3d2 = $c3 * $d2;\n    const $c3d3 = $c3 * $d3;\n    const $d0d0 = d0 * d0;\n    const $d0d1 = d0 * $d1;\n    const $d0d2 = d0 * $d2;\n    const $d0d3 = d0 * $d3;\n    const $d1d1 = $d1 * $d1;\n    const $d1d2 = $d1 * $d2;\n    const $d3d3 = $d3 * $d3;\n    const $d2d2 = $d2 * $d2;\n    const $d2d3 = $d2 * $d3;\n    const $d1d3 = $d1 * $d3;\n    const c0c0 = tp(c0, c0); // error free\n    const c0c1 = qmd(c0, c1);\n    const c0c1_ = _c0 * c1_ + abs($c0c1);\n    const c0c2 = qmd(c0, c2);\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\n    const c0c3 = qmd(c0, c3);\n    const c0c3_ = _c0 * c3_ + abs($c0c3);\n    const c0d0 = tp(c0, d0); // error free\n    const c0d1 = qmd(c0, d1);\n    const c0d1_ = _c0 * d1_ + abs($c0d1);\n    const c0d2 = qmd(c0, d2);\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\n    const c0d3 = qmd(c0, d3);\n    const c0d3_ = _c0 * d3_ + abs($c0d3);\n    const c1c1 = qmq(c1, c1);\n    const _c1c1 = abs($c1c1);\n    const c1c1_ = 2 * (c1_ * _c1 + _c1c1);\n    const c1c2 = qmq(c1, c2);\n    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * abs($c1c2);\n    const c1c3 = qmq(c1, c3);\n    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * abs($c1c3);\n    const c1d0 = qmd(d0, c1);\n    const c1d0_ = _d0 * c1_ + abs($c1d0);\n    const c1d1 = qmq(c1, d1);\n    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * abs($c1d1);\n    const c1d2 = qmq(c1, d2);\n    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * abs($c1d2);\n    const c1d3 = qmq(c1, d3);\n    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * abs($c1d3);\n    const c2d1 = qmq(c2, d1);\n    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * abs($c2d1);\n    const c2c2 = qmq(c2, c2);\n    const _c2c2 = abs($c2c2);\n    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);\n    const c2c3 = qmq(c2, c3);\n    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * abs($c2c3);\n    const c2d0 = qmd(d0, c2);\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\n    const c2d2 = qmq(c2, d2);\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\n    const c2d3 = qmq(c2, d3);\n    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * abs($c2d3);\n    const c3c3 = qmq(c3, c3);\n    const c3c3_ = 2 * (c3_ * _c3 + abs($c3c3));\n    const c3d0 = qmd(d0, c3);\n    const c3d0_ = _d0 * c3_ + abs($c3d0);\n    const c3d1 = qmq(c3, d1);\n    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * abs($c3d1);\n    const c3d2 = qmq(c3, d2);\n    const _c3d2 = abs($c3d2);\n    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * _c3d2;\n    const c3d3 = qmq(c3, d3);\n    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * abs($c3d3);\n    const d0d0 = tp(d0, d0); // error free\n    const d0d1 = qmd(d0, d1);\n    const d0d1_ = _d0 * d1_ + abs($d0d1);\n    const d0d2 = qmd(d0, d2);\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\n    const d0d3 = qmd(d0, d3);\n    const d0d3_ = _d0 * d3_ + abs($d0d3);\n    const d1d1 = qmq(d1, d1);\n    const _d1d1 = abs($d1d1);\n    const d1d1_ = 2 * (d1_ * _d1 + _d1d1);\n    const d1d2 = qmq(d1, d2);\n    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * abs($d1d2);\n    const d3d3 = qmq(d3, d3);\n    const d3d3_ = 2 * (d3_ * _d3 + abs($d3d3));\n    const d2d2 = qmq(d2, d2);\n    const _d2d2 = abs($d2d2);\n    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);\n    const d2d3 = qmq(d2, d3);\n    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * abs($d2d3);\n    const d1d3 = qmq(d1, d3);\n    const _d1d3 = abs($d1d3);\n    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * _d1d3;\n    const _c0c0 = abs($c0c0);\n    const _c0c1 = abs($c0c1);\n    const _c2c3 = abs($c2c3);\n    const _c3c3 = abs($c3c3);\n    const _c3d3 = abs($c3d3);\n    const _c0d0 = abs($c0d0);\n    const _d0d0 = abs($d0d0);\n    const _d0d1 = abs($d0d1);\n    const _d2d3 = abs($d2d3);\n    const _d3d3 = abs($d3d3);\n    //-----------------------\n    //const v9 =  \n    //    (c3*c3c3)*vₓₓₓ + \n    //    (c3*d3d3)*vₓᵧᵧ + \n    //    (d3*c3c3)*vₓₓᵧ + \n    //    (d3*d3d3)*vᵧᵧᵧ;\n    //-----------------------\n    const $g1 = $c3 * $c3c3;\n    const g1 = qmq(c3, c3c3);\n    const _g1 = _c3 * _c3c3;\n    const g1_ = c3_ * _c3c3 + _c3 * c3c3_ + 2 * _g1;\n    const $g2 = $c3 * $d3d3;\n    const g2 = qmq(c3, d3d3);\n    const _g2 = _c3 * _d3d3;\n    const g2_ = c3_ * _d3d3 + _c3 * d3d3_ + 2 * _g2;\n    const $g3 = $d3 * $c3c3;\n    const g3 = qmq(d3, c3c3);\n    const _g3 = _d3 * _c3c3;\n    const g3_ = d3_ * _c3c3 + _d3 * c3c3_ + 2 * _g3;\n    const $g4 = $d3 * $d3d3;\n    const g4 = qmq(d3, d3d3);\n    const _g4 = _d3 * _d3d3;\n    const g4_ = d3_ * _d3d3 + _d3 * d3d3_ + 2 * _g4;\n    const $g5 = $g1 * $vₓₓₓ;\n    const g5 = qmq(g1, vₓₓₓ);\n    const g5_ = g1_ * _vₓₓₓ + _g1 * vₓₓₓ_ + 2 * abs($g5);\n    const $g6 = $g2 * $vₓᵧᵧ;\n    const g6 = qmq(g2, vₓᵧᵧ);\n    const g6_ = g2_ * _vₓᵧᵧ + _g2 * vₓᵧᵧ_ + 2 * abs($g6);\n    const $g7 = $g3 * $vₓₓᵧ;\n    const g7 = qmq(g3, vₓₓᵧ);\n    const g7_ = g3_ * _vₓₓᵧ + _g3 * vₓₓᵧ_ + 2 * abs($g7);\n    const $g8 = $g4 * $vᵧᵧᵧ;\n    const g8 = qmq(g4, vᵧᵧᵧ);\n    const g8_ = g4_ * _vᵧᵧᵧ + _g4 * vᵧᵧᵧ_ + 2 * abs($g8);\n    const $g9 = $g5 + $g6;\n    const g9 = qaq(g5, g6);\n    const g9_ = g5_ + g6_ + abs($g9);\n    const $ga = $g7 + $g8;\n    const ga = qaq(g7, g8);\n    const ga_ = g7_ + g8_ + abs($ga);\n    const $v9 = $g9 + $ga;\n    const v9 = qaq(g9, ga);\n    const v9_ = g9_ + ga_ + abs($v9);\n    //-----------------------\n    //const v8 =  \n    //    2*c2*c3d3*vₓₓᵧ + \n    //    2*c3*d2d3*vₓᵧᵧ + \n    //      c2*d3d3*vₓᵧᵧ + \n    //      d2*c3c3*vₓₓᵧ + \n    //    3*c2*c3c3*vₓₓₓ + \n    //    3*d2*d3d3*vᵧᵧᵧ;  \n    //-----------------------\n    const $w1 = 2 * $c2d3 + $c3d2;\n    const _w1 = abs($w1);\n    const w1 = qaq(qm2(c2d3), c3d2);\n    const w1_ = 2 * c2d3_ + c3d2_ + _w1;\n    const $w2 = 2 * $c3d2 + $c2d3;\n    const _w2 = abs($w2);\n    const w2 = qaq(qm2(c3d2), c2d3);\n    const w2_ = 2 * c3d2_ + c2d3_ + abs($w2);\n    const $w3 = $c3 * $w1;\n    const _w3 = abs($w3);\n    const w3 = qmq(c3, w1);\n    const w3_ = c3_ * _w1 + _c3 * w1_ + 2 * _w3;\n    const $w4 = $d3 * $w2;\n    const _w4 = abs($w4);\n    const w4 = qmq(d3, w2);\n    const w4_ = d3_ * _w2 + _d3 * w2_ + 2 * _w4;\n    const $w5 = $c2 * $c3c3;\n    const _w5 = abs($w5);\n    const w5 = qmq(c2, c3c3);\n    const w5_ = c2_ * _c3c3 + _c2 * c3c3_ + 2 * _w5;\n    const $w6 = $d2 * $d3d3;\n    const _w6 = abs($w6);\n    const w6 = qmq(d2, d3d3);\n    const w6_ = d2_ * _d3d3 + _d2 * d3d3_ + 2 * _w6;\n    const $w7 = $vₓₓₓ * $w5;\n    const w7 = qmq(vₓₓₓ, w5);\n    const w7_ = w5_ * _vₓₓₓ + _vₓₓₓ * w5_ + 2 * abs($w7);\n    const $u1 = $vᵧᵧᵧ * $w6;\n    const u1 = qmq(vᵧᵧᵧ, w6);\n    const u1_ = w6_ * _vᵧᵧᵧ + _vᵧᵧᵧ * w6_ + 2 * abs($u1);\n    const $u2 = $vₓₓᵧ * $w3;\n    const u2 = qmq(vₓₓᵧ, w3);\n    const u2_ = w3_ * _vₓₓᵧ + _vₓₓᵧ * w3_ + 2 * abs($u2);\n    const $u3 = $vₓᵧᵧ * $w4;\n    const u3 = qmq(vₓᵧᵧ, w4);\n    const u3_ = w4_ * _vₓᵧᵧ + _vₓᵧᵧ * w4_ + 2 * abs($u3);\n    const $u4 = $u2 + $u3;\n    const u4 = qaq(u2, u3);\n    const u4_ = u2_ + u3_ + abs($u4);\n    const $u5 = 3 * ($w7 + $u1);\n    const u5 = qmd(3, qaq(w7, u1));\n    const u5_ = 3 * (w7_ + u1_) + 2 * abs($u5);\n    const $v8 = $u4 + $u5;\n    const v8 = qaq(u4, u5);\n    const v8_ = u4_ + u5_ + abs($v8);\n    //-----------------------\n    //const v7 =  \n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\n    //-----------------------\n    const $o1 = $c1 * $c3d3;\n    const o1 = qmq(c1, c3d3);\n    const o1_ = c1_ * _c3d3 + _c1 * c3d3_ + 2 * abs($o1);\n    const $o2 = $d1 * $c3c3;\n    const o2 = qmq(d1, c3c3);\n    const o2_ = d1_ * _c3c3 + _d1 * c3c3_ + 2 * abs($o2);\n    const $o3 = $c2 * $d2d3;\n    const o3 = qmq(c2, d2d3);\n    const o3_ = c2_ * _d2d3 + _c2 * d2d3_ + 2 * abs($o3);\n    const $o4 = $c1 * $d3d3;\n    const o4 = qmq(c1, d3d3);\n    const o4_ = c1_ * _d3d3 + _c1 * d3d3_ + 2 * abs($o4);\n    const $o5 = $c2 * $c3d2;\n    const o5 = qmq(c2, c3d2);\n    const o5_ = c2_ * _c3d2 + _c2 * c3d2_ + 2 * abs($o5);\n    const $o6 = $d3 * $c2c2;\n    const o6 = qmq(d3, c2c2);\n    const o6_ = d3_ * _c2c2 + _d3 * c2c2_ + 2 * abs($o6);\n    const $o7 = $c3 * $d1d3;\n    const o7 = qmq(c3, d1d3);\n    const o7_ = c3_ * _d1d3 + _c3 * d1d3_ + 2 * abs($o7);\n    const $o8 = $d2 * $c3d2;\n    const o8 = qmq(d2, c3d2);\n    const o8_ = d2_ * _c3d2 + _d2 * c3d2_ + 2 * abs($o8);\n    const $w8 = $o1 + $o5;\n    const w8 = qaq(o1, o5);\n    const w8_ = o1_ + o5_ + abs($w8);\n    const $w9 = $o2 + $o6;\n    const w9 = qaq(o2, o6);\n    const w9_ = o2_ + o6_ + abs($w9);\n    const $wa = $o3 + $o7;\n    const wa = qaq(o3, o7);\n    const wa_ = o3_ + o7_ + abs($wa);\n    const $wb = $o4 + $o8;\n    const wb = qaq(o4, o8);\n    const wb_ = o4_ + o8_ + abs($wb);\n    const $wc = $c1c3 + $c2c2;\n    const wc = qaq(c1c3, c2c2);\n    const _wc = abs($wc);\n    const wc_ = c1c3_ + c2c2_ + _wc;\n    const $wd = $d1d3 + $d2d2;\n    const _wd = abs($wd);\n    const wd = qaq(d1d3, d2d2);\n    const wd_ = d1d3_ + d2d2_ + _wd;\n    const $we = 2 * $w8 + $w9;\n    const we = qaq(qm2(w8), w9);\n    const _we = abs($we);\n    const we_ = 2 * w8_ + w9_ + _we;\n    const $wf = 2 * $wa + $wb;\n    const wf = qaq(qm2(wa), wb);\n    const _wf = abs($wf);\n    const wf_ = 2 * wa_ + wb_ + _wf;\n    const $wg = $vₓₓᵧ * $we;\n    const wg = qmq(vₓₓᵧ, we);\n    const wg_ = vₓₓᵧ_ * _we + _vₓₓᵧ * we_ + 2 * abs($wg);\n    const $wh = $vₓᵧᵧ * $wf;\n    const wh = qmq(vₓᵧᵧ, wf);\n    const wh_ = vₓᵧᵧ_ * _wf + _vₓᵧᵧ * wf_ + 2 * abs($wh);\n    const $wi = $c3 * $wc;\n    const wi = qmq(c3, wc);\n    const _wi = abs($wi);\n    const wi_ = c3_ * _wc + _c3 * wc_ + 2 * _wi;\n    const $wj = $d3 * $wd;\n    const wj = qmq(d3, wd);\n    const _wj = abs($wj);\n    const wj_ = d3_ * _wd + _d3 * wd_ + 2 * _wj;\n    const $wk = $vₓₓₓ * $wi;\n    const wk = qmq(vₓₓₓ, wi);\n    const wk_ = vₓₓₓ_ * _wi + _vₓₓₓ * wi_ + 2 * abs($wk);\n    const $wl = $vᵧᵧᵧ * $wj;\n    const wl = qmq(vᵧᵧᵧ, wj);\n    const wl_ = vᵧᵧᵧ_ * _wj + _vᵧᵧᵧ * wj_ + 2 * abs($wl);\n    const $wm = $wg + $wh;\n    const wm = qaq(wg, wh);\n    const wm_ = wg_ + wh_ + abs($wm);\n    const $wn = 3 * ($wk + $wl);\n    const wn = qmd(3, qaq(wk, wl));\n    const wn_ = 3 * (wk_ + wl_) + 2 * abs($wn);\n    const $v7 = $wm + $wn;\n    const v7 = qaq(wm, wn);\n    const v7_ = wm_ + wn_ + abs($v7);\n    //const v6 =\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\n    //    vₓₓ *c3c3 +\n    //    vᵧᵧ *d3d3 +\n    //    vₓᵧ *c3d3;\n    const $wo = $c2d3 + $c3d2;\n    const wo = qaq(c2d3, c3d2);\n    const _wo = abs($wo);\n    const wo_ = c2d3_ + c3d2_ + _wo;\n    const $zc = $d2 * $c2c2;\n    const zc = qmq(d2, c2c2);\n    const zc_ = d2_ * _c2c2 + _d2 * c2c2_ + 2 * abs($zc);\n    const $zd = 2 * $c1 * $wo;\n    const zd = qm2(qmq(c1, wo));\n    const zd_ = 2 * (c1_ * _wo + _c1 * wo_ + 2 * abs($zd));\n    const $wp = $zc + $zd;\n    const wp = qaq(zc, zd);\n    const wp_ = zc_ + zd_ + abs($wp);\n    const $wq = 2 * ($c0d3 + $c2d1);\n    const wq = qm2(qaq(c0d3, c2d1));\n    const wq_ = 2 * (c0d3_ + c2d1_) + abs($wq);\n    const $wr = $wq + $c3d0;\n    const _wr = abs($wr);\n    const wr = qaq(wq, c3d0);\n    const wr_ = wq_ + c3d0_ + _wr;\n    const $ze = $c3 * $wr;\n    const ze = qmq(c3, wr);\n    const ze_ = c3_ * _wr + _c3 * wr_ + 2 * abs($ze);\n    const $ws = $wp + $ze;\n    const ws = qaq(wp, ze);\n    const _ws = abs($ws);\n    const ws_ = wp_ + ze_ + _ws;\n    const $zf = $c2 * $d2d2;\n    const zf = qmq(c2, d2d2);\n    const zf_ = c2_ * _d2d2 + _c2 * d2d2_ + 2 * abs($zf);\n    const $zg = 2 * $d1 * $wo;\n    const zg = qm2(qmq(d1, wo));\n    const zg_ = 2 * (d1_ * _wo + _d1 * wo_ + abs($zg));\n    const $wt = $zf + $zg;\n    const wt = qaq(zf, zg);\n    const wt_ = zf_ + zg_ + abs($wt);\n    const $wu = 2 * ($c1d2 + $c3d0);\n    const wu = qm2(qaq(c1d2, c3d0));\n    const wu_ = 2 * (c1d2_ + c3d0_) + abs($wu);\n    const $wv = $wu + $c0d3;\n    const wv = qaq(wu, c0d3);\n    const _wv = abs($wv);\n    const wv_ = wu_ + c0d3_ + _wv;\n    const $zh = $d3 * $wv;\n    const zh = qmq(d3, wv);\n    const zh_ = d3_ * _wv + _d3 * wv_ + 2 * abs($zh);\n    const $ww = $wt + $zh;\n    const ww = qaq(wt, zh);\n    const _ww = abs($ww);\n    const ww_ = wt_ + zh_ + _ww;\n    const $wx = $c2 * $c2c2;\n    const wx = qmq(c2, c2c2);\n    const wx_ = c2_ * _c2c2 + _c2 * c2c2_ + 2 * abs($wx);\n    const $wy = 2 * $c1c2 + $c0c3;\n    const wy = qaq(qm2(c1c2), c0c3);\n    const _wy = abs($wy);\n    const wy_ = 2 * c1c2_ + c0c3_ + _wy;\n    const $q1 = 3 * $c3;\n    const q1 = qmd(3, c3);\n    const _q1 = abs($q1);\n    const q1_ = 3 * c3_ + _q1;\n    const $wz = $q1 * $wy;\n    const wz = qmq(q1, wy);\n    const wz_ = q1_ * _wy + _q1 * wy_ + 2 * abs($wz);\n    const $z1 = $wx + $wz;\n    const z1 = qaq(wx, wz);\n    const _z1 = abs($z1);\n    const z1_ = wx_ + wz_ + _z1;\n    const $z2 = $d2 * $d2d2;\n    const z2 = qmq(d2, d2d2);\n    const z2_ = d2_ * _d2d2 + _d2 * d2d2_ + 2 * abs($z2);\n    const $z3 = 2 * $d1d2 + $d0d3;\n    const z3 = qaq(qm2(d1d2), d0d3);\n    const _z3 = abs($z3);\n    const z3_ = 2 * d1d2_ + d0d3_ + _z3;\n    const $q2 = 3 * $d3;\n    const q2 = qmd(3, d3);\n    const _q2 = abs($q2);\n    const q2_ = 3 * d3_ + _q2;\n    const $z4 = $q2 * $z3;\n    const z4 = qmq(q2, z3);\n    const z4_ = q2_ * _z3 + _q2 * z3_ + 2 * abs($z4);\n    const $z5 = $z2 + $z4;\n    const z5 = qaq(z2, z4);\n    const _z5 = abs($z5);\n    const z5_ = z2_ + z4_ + _z5;\n    const $zi = $vₓₓᵧ * $ws;\n    const zi = qmq(vₓₓᵧ, ws);\n    const zi_ = vₓₓᵧ_ * _ws + _vₓₓᵧ * ws_ + 2 * abs($zi);\n    const $zj = $vₓᵧᵧ * $ww;\n    const zj = qmq(vₓᵧᵧ, ww);\n    const zj_ = vₓᵧᵧ_ * _ww + _vₓᵧᵧ * ww_ + 2 * abs($zj);\n    const $z6 = $zi + $zj;\n    const z6 = qaq(zi, zj);\n    const z6_ = zi_ + zj_ + abs($z6);\n    const $zk = $vₓₓₓ * $z1;\n    const zk = qmq(vₓₓₓ, z1);\n    const zk_ = vₓₓₓ_ * _z1 + _vₓₓₓ * z1_ + 2 * abs($zk);\n    const $zl = $vᵧᵧᵧ * $z5;\n    const zl = qmq(vᵧᵧᵧ, z5);\n    const zl_ = vᵧᵧᵧ_ * _z5 + _vᵧᵧᵧ * z5_ + 2 * abs($zl);\n    const $z7 = $zk + $zl;\n    const z7 = qaq(zk, zl);\n    const z7_ = zk_ + zl_ + abs($z7);\n    const $zm = $vₓₓ * $c3c3;\n    const zm = qmq(c3c3, vₓₓ);\n    const zm_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * abs($zm);\n    const $zn = $vᵧᵧ * $d3d3;\n    const zn = qmq(d3d3, vᵧᵧ);\n    const zn_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * abs($zn);\n    const $z8 = $zm + $zn;\n    const z8 = qaq(zm, zn);\n    const z8_ = zm_ + zn_ + abs($z8);\n    const $z9 = $vₓᵧ * $c3d3;\n    const z9 = qmq(c3d3, vₓᵧ);\n    const z9_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * abs($z9);\n    const $za = $z6 + $z7;\n    const za = qaq(z6, z7);\n    const za_ = z6_ + z7_ + abs($za);\n    const $zb = $z8 + $z9;\n    const zb = qaq(z8, z9);\n    const zb_ = z8_ + z9_ + abs($zb);\n    const $v6 = $za + $zb;\n    const v6 = qaq(za, zb);\n    const v6_ = za_ + zb_ + abs($v6);\n    //const r4 = c2d2 + c3d1;\n    //const r5 = c1d3 + c2d2;\n    //const v5 =\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\n    //    vₓᵧ*wo +\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\n    const $r4 = $c2d2 + $c3d1;\n    const r4 = qaq(c2d2, c3d1);\n    const _r4 = abs($r4);\n    const r4_ = c2d2_ + c3d1_ + _r4;\n    const $r5 = $c1d3 + $c2d2;\n    const r5 = qaq(c1d3, c2d2);\n    const _r5 = abs($r5);\n    const r5_ = c1d3_ + c2d2_ + _r5;\n    const $k1 = c0 * $wo;\n    const k1 = qmd(c0, wo);\n    const k1_ = _c0 * wo_ + abs($k1);\n    const $k2 = d0 * $wo;\n    const k2 = qmd(d0, wo);\n    const k2_ = _d0 * wo_ + abs($k2);\n    const $k3 = $c1 * $r4;\n    const k3 = qmq(c1, r4);\n    const k3_ = c1_ * _r4 + _c1 * r4_ + 2 * abs($k3);\n    const $k4 = $d1 * $r5;\n    const k4 = qmq(d1, r5);\n    const k4_ = d1_ * _r5 + _d1 * r5_ + 2 * abs($k4);\n    const $k5 = 2 * $c3d0 + $c2d1;\n    const k5 = qaq(qm2(c3d0), c2d1);\n    const _k5 = abs($k5);\n    const k5_ = 2 * c3d0_ + c2d1_ + _k5;\n    const $k6 = 2 * $c0d3 + $c1d2;\n    const k6 = qaq(qm2(c0d3), c1d2);\n    const _k6 = abs($k6);\n    const k6_ = 2 * c0d3_ + c1d2_ + _k6;\n    const $k7 = $d3 * $c1c1;\n    const k7 = qmq(d3, c1c1);\n    const k7_ = d3_ * _c1c1 + _d3 * c1c1_ + 2 * abs($k7);\n    const $k8 = $c3 * $d1d1;\n    const k8 = qmq(c3, d1d1);\n    const k8_ = c3_ * _d1d1 + _c3 * d1d1_ + 2 * abs($k8);\n    const $k9 = $c2 * $k5;\n    const k9 = qmq(c2, k5);\n    const k9_ = c2_ * _k5 + _c2 * k5_ + 2 * abs($k9);\n    const $ka = $d2 * $k6;\n    const ka = qmq(d2, k6);\n    const ka_ = d2_ * _k6 + _d2 * k6_ + 2 * abs($ka);\n    const $kb = 2 * ($k1 + $k3);\n    const kb = qm2(qaq(k1, k3));\n    const kb_ = 2 * (k1_ + k3_) + abs($kb);\n    const $kc = 2 * ($k2 + $k4);\n    const kc = qm2(qaq(k2, k4));\n    const kc_ = 2 * (k2_ + k4_) + abs($kc);\n    const $kd = 2 * c0 * $c2c3;\n    const kd = qm2(qmd(c0, c2c3));\n    const kd_ = 2 * _c0 * c2c3_ + abs($kd);\n    const $ke = 2 * d0 * $d2d3;\n    const ke = qm2(qmd(d0, d2d3));\n    const ke_ = 2 * _d0 * d2d3_ + abs($ke);\n    const $kf = $c1 * $wc;\n    const kf = qmq(c1, wc);\n    const kf_ = c1_ * _wc + _c1 * wc_ + 2 * abs($kf);\n    const $kg = $d1 * $wd;\n    const kg = qmq(d1, wd);\n    const kg_ = d1_ * _wd + _d1 * wd_ + 2 * abs($kg);\n    const $kh = $vₓₓ * $c2c3;\n    const kh = qmq(c2c3, vₓₓ);\n    const kh_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * abs($kh);\n    const $ki = $vᵧᵧ * $d2d3;\n    const ki = qmq(d2d3, vᵧᵧ);\n    const ki_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * abs($ki);\n    const $kj = $kb + $k7;\n    const kj = qaq(kb, k7);\n    const _kj = abs($kj);\n    const kj_ = kb_ + k7_ + _kj;\n    const $kk = $kc + $k8;\n    const kk = qaq(kc, k8);\n    const _kk = abs($kk);\n    const kk_ = kc_ + k8_ + _kk;\n    const $kl = $kj + $k9;\n    const kl = qaq(kj, k9);\n    const _kl = abs($kl);\n    const kl_ = kj_ + k9_ + _kl;\n    const $km = $kk + $ka;\n    const km = qaq(kk, ka);\n    const _km = abs($km);\n    const km_ = kk_ + ka_ + _km;\n    const $kn = $kd + $kf;\n    const kn = qaq(kd, kf);\n    const _kn = abs($kn);\n    const kn_ = kd_ + kf_ + _kn;\n    const $ko = $ke + $kg;\n    const ko = qaq(ke, kg);\n    const _ko = abs($ko);\n    const ko_ = ke_ + kg_ + _ko;\n    const $kp = 2 * ($kh + $ki);\n    const kp = qm2(qaq(kh, ki));\n    const kp_ = 2 * (kh_ + ki_) + abs($kp);\n    const $kq = $vₓₓᵧ * $kl;\n    const kq = qmq(vₓₓᵧ, kl);\n    const kq_ = vₓₓᵧ_ * _kl + _vₓₓᵧ * kl_ + 2 * abs($kq);\n    const $kr = $vₓᵧᵧ * $km;\n    const kr = qmq(vₓᵧᵧ, km);\n    const kr_ = vₓᵧᵧ_ * _km + _vₓᵧᵧ * km_ + 2 * abs($kr);\n    const $ks = $vₓₓₓ * $kn;\n    const ks = qmq(vₓₓₓ, kn);\n    const ks_ = vₓₓₓ_ * _kn + _vₓₓₓ * kn_ + 2 * abs($ks);\n    const $kt = $vᵧᵧᵧ * $ko;\n    const kt = qmq(vᵧᵧᵧ, ko);\n    const kt_ = vᵧᵧᵧ_ * _ko + _vᵧᵧᵧ * ko_ + 2 * abs($kt);\n    const $ku = $kq + $kr;\n    const ku = qaq(kq, kr);\n    const ku_ = kq_ + kr_ + abs($ku);\n    const $kv = 3 * ($ks + $kt);\n    const kv = qmd(3, qaq(ks, kt));\n    const kv_ = 3 * (ks_ + kt_) + 2 * abs($kv);\n    const $kw = $vₓᵧ * $wo;\n    const kw = qmq(vₓᵧ, wo);\n    const kw_ = vₓᵧ_ * _wo + _vₓᵧ * wo_ + 2 * abs($kw);\n    const $kx = $ku + $kv;\n    const kx = qaq(ku, kv);\n    const kx_ = ku_ + kv_ + abs($kx);\n    const $ky = $kw + $kp;\n    const ky = qaq(kw, kp);\n    const ky_ = kw_ + kp_ + abs($ky);\n    const $v5 = $kx + $ky;\n    const v5 = qaq(kx, ky);\n    const v5_ = kx_ + ky_ + abs($v5);\n    //const r1 = c1d3 + r4;\n    //const r2 = 2*c1c3 + c2c2;\n    //const r3 = 2*d1d3 + d2d2;\n    //const v4 =\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\n    //    vₓᵧ*r1 +\n    //    vₓₓ*r2 +\n    //    vᵧᵧ*r3;\n    const $r1 = $c1d3 + $r4;\n    const r1 = qaq(c1d3, r4);\n    const _r1 = abs($r1);\n    const r1_ = c1d3_ + r4_ + _r1;\n    const $r2 = 2 * $c1c3 + $c2c2;\n    const r2 = qaq(qm2(c1c3), c2c2);\n    const _r2 = abs($r2);\n    const r2_ = 2 * c1c3_ + c2c2_ + _r2;\n    const $r3 = 2 * $d1d3 + $d2d2;\n    const r3 = qaq(qm2(d1d3), d2d2);\n    const _r3 = abs($r3);\n    const r3_ = 2 * d1d3_ + d2d2_ + _r3;\n    const $s1 = 2 * c0 * $r1;\n    const s1 = qmd(2 * c0, r1);\n    const s1_ = 2 * _c0 * r1_ + abs($s1);\n    const $s2 = 2 * d0 * $r1;\n    const s2 = qmd(2 * d0, r1);\n    const s2_ = 2 * _d0 * r1_ + abs($s2);\n    const $s5 = $c1d2 + 2 * $c2d1;\n    const s5 = qaq(c1d2, qm2(c2d1));\n    const _s5 = abs($s5);\n    const s5_ = c1d2_ + 2 * c2d1_ + _s5;\n    const $s6 = $c2d1 + 2 * $c1d2;\n    const s6 = qaq(c2d1, qm2(c1d2));\n    const _s6 = abs($s6);\n    const s6_ = c2d1_ + 2 * c1d2_ + _s6;\n    const $s3 = d0 * $r2;\n    const s3 = qmd(d0, r2);\n    const s3_ = _d0 * r2_ + abs($s3);\n    const $s4 = c0 * $r3;\n    const s4 = qmd(c0, r3);\n    const s4_ = _c0 * r3_ + abs($s4);\n    const $s7 = $c1 * $s5;\n    const s7 = qmq(c1, s5);\n    const s7_ = c1_ * _s5 + _c1 * s5_ + 2 * abs($s7);\n    const $s8 = $d1 * $s6;\n    const s8 = qmq(d1, s6);\n    const s8_ = d1_ * _s6 + _d1 * s6_ + 2 * abs($s8);\n    const $s9 = c0 * $r2;\n    const s9 = qmd(c0, r2);\n    const s9_ = _c0 * r2_ + abs($s9);\n    const $sa = d0 * $r3;\n    const sa = qmd(d0, r3);\n    const sa_ = _d0 * r3_ + abs($sa);\n    const $sb = $c2 * $c1c1;\n    const sb = qmq(c2, c1c1);\n    const sb_ = c2_ * _c1c1 + _c2 * c1c1_ + 2 * abs($sb);\n    const $sc = $d2 * $d1d1;\n    const sc = qmq(d2, d1d1);\n    const sc_ = d2_ * _d1d1 + _d2 * d1d1_ + 2 * abs($sc);\n    const $sd = $s1 + $s3;\n    const sd = qaq(s1, s3);\n    const sd_ = s1_ + s3_ + abs($sd);\n    const $se = $s2 + $s4;\n    const se = qaq(s2, s4);\n    const se_ = s2_ + s4_ + abs($se);\n    const $sf = $sd + $s7;\n    const sf = qaq(sd, s7);\n    const _sf = abs($sf);\n    const sf_ = sd_ + s7_ + _sf;\n    const $sg = $se + $s8;\n    const sg = qaq(se, s8);\n    const _sg = abs($sg);\n    const sg_ = se_ + s8_ + _sg;\n    const $sh = $s9 + $sb;\n    const sh = qaq(s9, sb);\n    const _sh = abs($sh);\n    const sh_ = s9_ + sb_ + _sh;\n    const $si = $sa + $sc;\n    const si = qaq(sa, sc);\n    const _si = abs($si);\n    const si_ = sa_ + sc_ + _si;\n    const $sj = $vₓₓᵧ * $sf;\n    const sj = qmq(vₓₓᵧ, sf);\n    const sj_ = vₓₓᵧ_ * _sf + _vₓₓᵧ * sf_ + 2 * abs($sj);\n    const $sk = $vₓᵧᵧ * $sg;\n    const sk = qmq(vₓᵧᵧ, sg);\n    const sk_ = vₓᵧᵧ_ * _sg + _vₓᵧᵧ * sg_ + 2 * abs($sk);\n    const $sl = $vₓₓₓ * $sh;\n    const sl = qmq(vₓₓₓ, sh);\n    const sl_ = vₓₓₓ_ * _sh + _vₓₓₓ * sh_ + 2 * abs($sl);\n    const $sm = $vᵧᵧᵧ * $si;\n    const sm = qmq(vᵧᵧᵧ, si);\n    const sm_ = vᵧᵧᵧ_ * _si + _vᵧᵧᵧ * si_ + 2 * abs($sm);\n    const $sn = $sl + $sm;\n    const _sn = abs($sn);\n    const sn = qaq(sl, sm);\n    const sn_ = sl_ + sm_ + _sn;\n    const $so = $sj + $sk;\n    const so = qaq(sj, sk);\n    const so_ = sj_ + sk_ + abs($so);\n    const $sp = $so + 3 * $sn;\n    const sp = qaq(so, qmd(3, sn));\n    const sp_ = so_ + 3 * (sn_ + _sn) + abs($sp);\n    const $ss = $vₓᵧ * $r1;\n    const ss = qmq(vₓᵧ, r1);\n    const ss_ = vₓᵧ_ * _r1 + _vₓᵧ * r1_ + 2 * abs($ss);\n    const $st = $vₓₓ * $r2;\n    const st = qmq(vₓₓ, r2);\n    const st_ = vₓₓ_ * _r2 + _vₓₓ * r2_ + 2 * abs($st);\n    const $sq = $ss + $st;\n    const sq = qaq(ss, st);\n    const sq_ = ss_ + st_ + abs($sq);\n    const $su = $vᵧᵧ * $r3;\n    const su = qmq(vᵧᵧ, r3);\n    const su_ = vᵧᵧ_ * _r3 + _vᵧᵧ * r3_ + 2 * abs($su);\n    const $sr = $sq + $su;\n    const sr = qaq(sq, su);\n    const sr_ = sq_ + su_ + abs($sr);\n    const $v4 = $sp + $sr;\n    const v4 = qaq(sp, sr);\n    const v4_ = sp_ + sr_ + abs($v4);\n    //const r6 = c1d2 + c2d1;\n    //const r7 = c3d0 + c0d3;\n    //const r8 = c1c2 + c0c3;\n    //const r9 = d1d2 + d0d3;\n    //const v3 =\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\n    //    vₓᵧ*(r7 + r6) +\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\n    //    vₓ*c3 + vᵧ*d3;\n    const $r6 = $c1d2 + $c2d1;\n    const r6 = qaq(c1d2, c2d1);\n    const r6_ = c1d2_ + c2d1_ + abs($r6);\n    const $r7 = $c3d0 + $c0d3;\n    const r7 = qaq(c3d0, c0d3);\n    const r7_ = c3d0_ + c0d3_ + abs($r7);\n    const $r8 = $c1c2 + $c0c3;\n    const r8 = qaq(c1c2, c0c3);\n    const r8_ = c1c2_ + c0c3_ + abs($r8);\n    const _r8 = abs($r8);\n    const $r9 = $d1d2 + $d0d3;\n    const r9 = qaq(d1d2, d0d3);\n    const r9_ = d1d2_ + d0d3_ + abs($r9);\n    const _r9 = abs($r9);\n    const $m1 = 2 * $r6 + $c3d0;\n    const m1 = qaq(qm2(r6), c3d0);\n    const m1_ = 2 * r6_ + c3d0_ + abs($m1);\n    const $m2 = 2 * $r6 + $c0d3;\n    const m2 = qaq(qm2(r6), c0d3);\n    const m2_ = 2 * r6_ + c0d3_ + abs($m2);\n    const $m3 = 2 * $c2d0 + $c1d1;\n    const m3 = qaq(qm2(c2d0), c1d1);\n    const _m3 = abs($m3);\n    const m3_ = 2 * c2d0_ + c1d1_ + _m3;\n    const $m4 = 2 * $c0d2 + $c1d1;\n    const m4 = qaq(qm2(c0d2), c1d1);\n    const _m4 = abs($m4);\n    const m4_ = 2 * c0d2_ + c1d1_ + _m4;\n    const $m5 = $r8 + $c1c2;\n    const m5 = qaq(r8, c1c2);\n    const m5_ = r8_ + c1c2_ + abs($m5);\n    const $m6 = $r9 + $d1d2;\n    const m6 = qaq(r9, d1d2);\n    const m6_ = r9_ + d1d2_ + abs($m6);\n    const $q3 = 3 * c0;\n    const q3 = tp(3, c0); // error free\n    const $m7 = $q3 * $m5;\n    const m7 = qmq(q3, m5);\n    const m7_ = abs($q3) * m5_ + 2 * abs($m7);\n    const $q4 = 3 * d0;\n    const q4 = tp(3, d0); // error free\n    const $m8 = $q4 * $m6;\n    const m8 = qmq(q4, m6);\n    const m8_ = abs($q4) * m6_ + 2 * abs($m8);\n    const $m9 = $c1 * $c1c1;\n    const m9 = qmq(c1, c1c1);\n    const m9_ = c1_ * _c1c1 + _c1 * c1c1_ + 2 * abs($m9);\n    const $ma = $d1 * $d1d1;\n    const ma = qmq(d1, d1d1);\n    const ma_ = d1_ * _d1d1 + _d1 * d1d1_ + 2 * abs($ma);\n    const $mb = $vₓₓ * $r8;\n    const mb = qmq(vₓₓ, r8);\n    const mb_ = vₓₓ_ * _r8 + _vₓₓ * r8_ + abs($mb);\n    const $mc = $vᵧᵧ * $r9;\n    const mc = qmq(vᵧᵧ, r9);\n    const mc_ = vᵧᵧ_ * _r9 + _vᵧᵧ * r9_ + abs($mc);\n    const $md = $m1 + $r7;\n    const md = qaq(m1, r7);\n    const md_ = m1_ + r7_ + abs($md);\n    const $me = $m2 + $r7;\n    const me = qaq(m2, r7);\n    const me_ = m2_ + r7_ + abs($me);\n    const $mf = c0 * $md;\n    const mf = qmd(c0, md);\n    const mf_ = _c0 * md_ + abs($mf);\n    const $mg = d0 * $me;\n    const mg = qmd(d0, me);\n    const mg_ = _d0 * me_ + abs($mg);\n    const $mh = $c1 * $m3;\n    const mh = qmq(c1, m3);\n    const mh_ = c1_ * _m3 + _c1 * m3_ + 2 * abs($mh);\n    const $mi = $d1 * $m4;\n    const mi = qmq(d1, m4);\n    const mi_ = d1_ * _m4 + _d1 * m4_ + 2 * abs($mi);\n    const $mj = $c3 * $vₓ;\n    const mj = qmq(c3, vₓ);\n    const mj_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * abs($mj);\n    const $mk = $d3 * $vᵧ;\n    const mk = qmq(d3, vᵧ);\n    const mk_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * abs($mk);\n    const $ml = $mf + $mh;\n    const ml = qaq(mf, mh);\n    const _ml = abs($ml);\n    const ml_ = mf_ + mh_ + _ml;\n    const $mm = $mg + $mi;\n    const mm = qaq(mg, mi);\n    const _mm = abs($mm);\n    const mm_ = mg_ + mi_ + _mm;\n    const $mn = $m7 + $m9;\n    const mn = qaq(m7, m9);\n    const _mn = abs($mn);\n    const mn_ = m7_ + m9_ + _mn;\n    const $mo = $m8 + $ma;\n    const mo = qaq(m8, ma);\n    const _mo = abs($mo);\n    const mo_ = m8_ + ma_ + _mo;\n    const $mp = $r7 + $r6;\n    const mp = qaq(r7, r6);\n    const _mp = abs($mp);\n    const mp_ = r7_ + r6_ + _mp;\n    const $mq = 2 * ($mb + $mc);\n    const mq = qm2(qaq(mb, mc));\n    const mq_ = 2 * (mb_ + mc_) + abs($mq);\n    const $mr = $vₓₓᵧ * $ml;\n    const mr = qmq(vₓₓᵧ, ml);\n    const mr_ = vₓₓᵧ_ * _ml + _vₓₓᵧ * ml_ + 2 * abs($mr);\n    const $ms = $vₓᵧᵧ * $mm;\n    const ms = qmq(vₓᵧᵧ, mm);\n    const ms_ = vₓᵧᵧ_ * _mm + _vₓᵧᵧ * mm_ + 2 * abs($ms);\n    const $mt = $vₓₓₓ * $mn;\n    const mt = qmq(vₓₓₓ, mn);\n    const mt_ = vₓₓₓ_ * _mn + _vₓₓₓ * mn_ + 2 * abs($mt);\n    const $mu = $vᵧᵧᵧ * $mo;\n    const mu = qmq(vᵧᵧᵧ, mo);\n    const mu_ = vᵧᵧᵧ_ * _mo + _vᵧᵧᵧ * mo_ + 2 * abs($mu);\n    const $mv = $vₓᵧ * $mp;\n    const mv = qmq(vₓᵧ, mp);\n    const mv_ = vₓᵧ_ * _mp + _vₓᵧ * mp_ + 2 * abs($mv);\n    const $mw = $mr + $ms;\n    const mw = qaq(mr, ms);\n    const mw_ = mr_ + ms_ + abs($mw);\n    const $mx = $mt + $mu;\n    const mx = qaq(mt, mu);\n    const mx_ = mt_ + mu_ + abs($mx);\n    const $my = $mv + $mq;\n    const my = qaq(mv, mq);\n    const my_ = mv_ + mq_ + abs($my);\n    const $mz = $mj + $mk;\n    const mz = qaq(mj, mk);\n    const mz_ = mj_ + mk_ + abs($mz);\n    const $n1 = $mw + $mx;\n    const n1 = qaq(mw, mx);\n    const n1_ = mw_ + mx_ + abs($n1);\n    const $n2 = $my + $mz;\n    const n2 = qaq(my, mz);\n    const n2_ = my_ + mz_ + abs($n2);\n    const $v3 = $n1 + $n2;\n    const v3 = qaq(n1, n2);\n    const v3_ = n1_ + n2_ + abs($v3);\n    //const ra = c1d1 + c2d0;\n    //const rb = c1d1 + c0d2;\n    //const v2 =\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\n    //    vₓᵧ*(ra + c0d2) +\n    //    vₓₓ*(2*c0c2 + c1c1) + \n    //    vᵧᵧ*(2*d0d2 + d1d1) +\n    //    c2*vₓ + d2*vᵧ;\n    const $ra = $c1d1 + $c2d0;\n    const ra = qaq(c1d1, c2d0);\n    const ra_ = c1d1_ + c2d0_ + abs($ra);\n    const $rb = $c1d1 + $c0d2;\n    const rb = qaq(c1d1, c0d2);\n    const rb_ = c1d1_ + c0d2_ + abs($rb);\n    const $l1 = 2 * $ra + $c0d2;\n    const l1 = qaq(qm2(ra), c0d2);\n    const l1_ = 2 * ra_ + c0d2_ + abs($l1);\n    const $l2 = 2 * $rb + $c2d0;\n    const l2 = qaq(qm2(rb), c2d0);\n    const l2_ = 2 * rb_ + c2d0_ + abs($l2);\n    const $l3 = c0 * $l1;\n    const l3 = qmd(c0, l1);\n    const l3_ = _c0 * l1_ + abs($l3);\n    const $l4 = d0 * $c1c1;\n    const l4 = qmd(d0, c1c1);\n    const l4_ = _d0 * c1c1_ + abs($l4);\n    const $l5 = d0 * $l2;\n    const l5 = qmd(d0, l2);\n    const l5_ = _d0 * l2_ + abs($l5);\n    const $l6 = c0 * $d1d1;\n    const l6 = qmd(c0, d1d1);\n    const l6_ = _c0 * d1d1_ + abs($l6);\n    const $l7 = c0 * $c1c1;\n    const l7 = qmd(c0, c1c1);\n    const l7_ = _c0 * c1c1_ + abs($l7);\n    const $l8 = $c2 * $c0c0;\n    const l8 = qmq(c2, c0c0);\n    const l8_ = c2_ * _c0c0 + 2 * abs($l8);\n    const $l9 = d0 * $d1d1;\n    const l9 = qmd(d0, d1d1);\n    const l9_ = _d0 * d1d1_ + abs($l9);\n    const $la = $d2 * $d0d0;\n    const la = qmq(d2, d0d0);\n    const la_ = d2_ * _d0d0 + 2 * abs($la);\n    const $lb = $l3 + $l4;\n    const lb = qaq(l3, l4);\n    const _lb = l3_ + l4_ + abs($lb);\n    const lb_ = l3_ + l4_ + _lb;\n    const $lc = $l5 + $l6;\n    const lc = qaq(l5, l6);\n    const _lc = l5_ + l6_ + abs($lc);\n    const lc_ = l5_ + l6_ + _lc;\n    const $ld = $l7 + $l8;\n    const ld = qaq(l7, l8);\n    const _ld = abs($ld);\n    const ld_ = l7_ + l8_ + _ld;\n    const $le = $l9 + $la;\n    const le = qaq(l9, la);\n    const _le = abs($le);\n    const le_ = l9_ + la_ + _le;\n    const $lf = $vₓₓₓ * $ld;\n    const lf = qmq(vₓₓₓ, ld);\n    const lf_ = vₓₓₓ_ * _ld + _vₓₓₓ * ld_ + 2 * abs($lf);\n    const $lg = $vᵧᵧᵧ * $le;\n    const lg = qmq(vᵧᵧᵧ, le);\n    const lg_ = vᵧᵧᵧ_ * _le + _vᵧᵧᵧ * le_ + 2 * abs($lg);\n    const $lh = 3 * ($lf + $lg);\n    const lh = qmd(3, qaq(lf, lg));\n    const lh_ = 3 * (lf_ + lg_) + 2 * abs($lh);\n    const $li = $ra + $c0d2;\n    const li = qaq(ra, c0d2);\n    const _li = abs($li);\n    const li_ = ra_ + c0d2_ + _li;\n    const $lj = 2 * $c0c2 + $c1c1;\n    const lj = qaq(qm2(c0c2), c1c1);\n    const _lj = abs($lj);\n    const lj_ = 2 * c0c2_ + c1c1_ + _lj;\n    const $lk = 2 * $d0d2 + $d1d1;\n    const lk = qaq(qm2(d0d2), d1d1);\n    const _lk = abs($lk);\n    const lk_ = 2 * d0d2_ + d1d1_ + _lk;\n    const $ll = $vₓₓᵧ * $lb;\n    const ll = qmq(vₓₓᵧ, lb);\n    const ll_ = vₓₓᵧ_ * _lb + _vₓₓᵧ * lb_ + 2 * abs($ll);\n    const $lm = $vₓᵧᵧ * $lc;\n    const lm = qmq(vₓᵧᵧ, lc);\n    const lm_ = vₓᵧᵧ_ * _lc + _vₓᵧᵧ * lc_ + 2 * abs($lm);\n    const $ln = $vₓᵧ * $li;\n    const ln = qmq(vₓᵧ, li);\n    const ln_ = vₓᵧ_ * _li + _vₓᵧ * li_ + 2 * abs($ln);\n    const $lo = $vₓₓ * $lj;\n    const lo = qmq(vₓₓ, lj);\n    const lo_ = vₓₓ_ * _lj + _vₓₓ * lj_ + 2 * abs($lo);\n    const $lp = $vᵧᵧ * $lk;\n    const lp = qmq(vᵧᵧ, lk);\n    const lp_ = vᵧᵧ_ * _lk + _vᵧᵧ * lk_ + 2 * abs($lp);\n    const $lq = $c2 * $vₓ;\n    const lq = qmq(c2, vₓ);\n    const lq_ = c2_ * _vₓ + _c2 * vₓ_ + abs($lq);\n    const $lr = $d2 * $vᵧ;\n    const lr = qmq(d2, vᵧ);\n    const lr_ = d2_ * _vᵧ + _d2 * vᵧ_ + abs($lr);\n    const $ls = $lq + $lr;\n    const ls = qaq(lq, lr);\n    const ls_ = lq_ + lr_ + abs($ls);\n    const $lt = $ll + $lm;\n    const lt = qaq(ll, lm);\n    const lt_ = ll_ + lm_ + abs($lt);\n    const $lu = $lh + $ln;\n    const lu = qaq(lh, ln);\n    const lu_ = lh_ + ln_ + abs($lu);\n    const $lv = $lo + $lp;\n    const lv = qaq(lo, lp);\n    const lv_ = lo_ + lp_ + abs($lv);\n    const $lw = $lt + $lu;\n    const lw = qaq(lt, lu);\n    const lw_ = lt_ + lu_ + abs($lw);\n    const $lx = $lv + $ls;\n    const lx = qaq(lv, ls);\n    const lx_ = lv_ + ls_ + abs($lx);\n    const $v2 = $lw + $lx;\n    const v2 = qaq(lw, lx);\n    const v2_ = lw_ + lx_ + abs($v2);\n    //const rc = c1d0 + c0d1;\n    //const v1 =\n    //    vₓₓᵧ*c0*(rc + c1d0) +\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\n    //    vₓᵧ*rc +\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    c1*vₓ + d1*vᵧ ;\n    const $rc = $c1d0 + $c0d1;\n    const rc = qaq(c1d0, c0d1);\n    const _rc = abs($rc);\n    const rc_ = c1d0_ + c0d1_ + _rc;\n    const $rd = c0 * $vₓₓᵧ;\n    const rd = qmd(c0, vₓₓᵧ);\n    const _rd = abs($rd);\n    const rd_ = _c0 * vₓₓᵧ_ + _rd;\n    const $re = d0 * $vₓᵧᵧ;\n    const re = qmd(d0, vₓᵧᵧ);\n    const _re = abs($re);\n    const re_ = _d0 * vₓᵧᵧ_ + _re;\n    const $rf = $rc + $c1d0;\n    const rf = qaq(rc, c1d0);\n    const _rf = abs($rf);\n    const rf_ = rc_ + c1d0_ + _rf;\n    const $rg = $rc + $c0d1;\n    const rg = qaq(rc, c0d1);\n    const _rg = abs($rg);\n    const rg_ = rc_ + c0d1_ + _rg;\n    const $rx = $c1 * $c0c0;\n    const rx = qmq(c1, c0c0);\n    const _rx = abs($rx);\n    const rx_ = c1_ * _c0c0 + 2 * _rx;\n    const $rh = $rx * $vₓₓₓ;\n    const rh = qmq(rx, vₓₓₓ);\n    const rh_ = rx_ * _vₓₓₓ + _rx * vₓₓₓ_ + 2 * abs($rh);\n    const $ry = $d1 * $d0d0;\n    const ry = qmq(d1, d0d0);\n    const _ry = abs($ry);\n    const ry_ = d1_ * _d0d0 + 2 * _ry;\n    const $ri = $ry * $vᵧᵧᵧ;\n    const ri = qmq(ry, vᵧᵧᵧ);\n    const ri_ = ry_ * _vᵧᵧᵧ + _ry * vᵧᵧᵧ_ + 2 * abs($ri);\n    const $rj = $vₓᵧ * $rc;\n    const rj = qmq(vₓᵧ, rc);\n    const rj_ = vₓᵧ_ * _rc + _vₓᵧ * rc_ + 2 * abs($rj);\n    const $rk = $c0c1 * $vₓₓ;\n    const rk = qmq(c0c1, vₓₓ);\n    const rk_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($rk);\n    const $rl = $d0d1 * $vᵧᵧ;\n    const rl = qmq(d0d1, vᵧᵧ);\n    const rl_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($rl);\n    const $rm = $rk + $rl;\n    const rm = qaq(rk, rl);\n    const rm_ = rk_ + rl_ + abs($rm);\n    const $rn = $c1 * $vₓ;\n    const rn = qmq(c1, vₓ);\n    const rn_ = c1_ * _vₓ + _c1 * vₓ_ + abs($rn);\n    const $ro = $d1 * $vᵧ;\n    const ro = qmq(d1, vᵧ);\n    const ro_ = d1_ * _vᵧ + _d1 * vᵧ_ + abs($ro);\n    const $rp = $rn + $ro;\n    const rp = qaq(rn, ro);\n    const rp_ = rn_ + ro_ + abs($rp);\n    const $rq = $rd * $rf;\n    const rq = qmq(rd, rf);\n    const rq_ = rd_ * _rf + _rd * rf_ + 2 * abs($rq);\n    const $rr = $re * $rg;\n    const rr = qmq(re, rg);\n    const rr_ = re_ * _rg + _re * rg_ + 2 * abs($rr);\n    const $rs = $rq + $rr;\n    const rs = qaq(rq, rr);\n    const rs_ = rq_ + rr_ + abs($rs);\n    const $rt = 3 * ($rh + $ri);\n    const rt = qmd(3, qaq(rh, ri));\n    const rt_ = 3 * (rh_ + ri_) + 2 * abs($rt);\n    const $ru = $rj + 2 * $rm;\n    const ru = qaq(rj, qm2(rm));\n    const ru_ = rj_ + 2 * rm_ + abs($ru);\n    const $rv = $rs + $rt;\n    const rv = qaq(rs, rt);\n    const rv_ = rs_ + rt_ + abs($rv);\n    const $rw = $ru + $rp;\n    const rw = qaq(ru, rp);\n    const rw_ = ru_ + rp_ + abs($rw);\n    const $v1 = $rv + $rw;\n    const v1 = qaq(rv, rw);\n    const v1_ = rv_ + rw_ + abs($v1);\n    //-----\n    // v0\n    //-----\n    const $t1 = c0 * $vₓₓₓ;\n    const t1 = qmd(c0, vₓₓₓ);\n    const t1_ = _c0 * vₓₓₓ_ + abs($t1);\n    const $t2 = d0 * $vₓₓᵧ;\n    const t2 = qmd(d0, vₓₓᵧ);\n    const t2_ = _d0 * vₓₓᵧ_ + abs($t2);\n    const $p4 = $t1 + $t2;\n    const p4 = qaq(t1, t2);\n    const p4_ = t1_ + t2_ + abs($p4);\n    const $t3 = c0 * $vₓᵧᵧ;\n    const t3 = qmd(c0, vₓᵧᵧ);\n    const t3_ = _c0 * vₓᵧᵧ_ + abs($t3);\n    const $t4 = d0 * $vᵧᵧᵧ;\n    const t4 = qmd(d0, vᵧᵧᵧ);\n    const t4_ = _d0 * vᵧᵧᵧ_ + abs($t4);\n    const $p5 = $t3 + $t4;\n    const p5 = qaq(t3, t4);\n    const p5_ = t3_ + t4_ + abs($p5);\n    const $p7 = $p4 + $vₓₓ;\n    const p7 = qaq(p4, vₓₓ);\n    const _p7 = abs($p7);\n    const p7_ = p4_ + vₓₓ_ + _p7;\n    const $p8 = $p5 + $vᵧᵧ;\n    const p8 = qaq(p5, vᵧᵧ);\n    const _p8 = abs($p8);\n    const p8_ = p5_ + vᵧᵧ_ + _p8;\n    const $pc = $c0c0 * $p7;\n    const pc = qmq(c0c0, p7);\n    const pc_ = _c0c0 * p7_ + 2 * abs($pc);\n    const $pd = $d0d0 * $p8;\n    const pd = qmq(d0d0, p8);\n    const pd_ = _d0d0 * p8_ + 2 * abs($pd);\n    const $p6 = $pc + $pd;\n    const p6 = qaq(pc, pd);\n    const p6_ = pc_ + pd_ + abs($p6);\n    const $pe = $c0d0 * $vₓᵧ;\n    const pe = qmq(c0d0, vₓᵧ);\n    const pe_ = _c0d0 * vₓᵧ_ + abs($pe);\n    const $p9 = $p6 + $pe;\n    const p9 = qaq(p6, pe);\n    const p9_ = p6_ + pe_ + abs($p9);\n    const $pf = c0 * $vₓ;\n    const pf = qmd(c0, vₓ);\n    const pf_ = _c0 * vₓ_ + abs($pf);\n    const $pg = d0 * $vᵧ;\n    const pg = qmd(d0, vᵧ);\n    const pg_ = _d0 * vᵧ_ + abs($pg);\n    const $pa = $pf + $pg;\n    const pa = qaq(pf, pg);\n    const pa_ = pf_ + pg_ + abs($pa);\n    const $pb = $p9 + $pa;\n    const pb = qaq(p9, pa);\n    const pb_ = p9_ + pa_ + abs($pb);\n    const $v0 = $pb + $v;\n    const v0 = qaq(pb, v);\n    const v0_ = pb_ + v_ + abs($v0);\n    return {\n        coeffs: [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0],\n        errBound: [γγ3 * v9_, γγ3 * v8_, γγ3 * v7_, γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez3-bez3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez1Exact: () => (/* binding */ getCoeffsBez1Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable whose roots are the parameter\n * values of the intersection points of two order 1 bezier curves (i.e. 2 lines).\n *\n * The returned polynomial degree will be 1\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez1Bez1Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps1);\n    // if both polynomials' linear terms are exactly zero then it really is a point\n    //if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\n    // This shouldn't happen due to being checked for earlier.\n    //}\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps2);\n    //if (eSign(c1) === 0 && eSign(d1) === 0) {\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\n    // This shouldn't happen due to being checked for earlier.\n    //}\n    const { vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 1\n    (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_5__.getImplicitForm1ExactPb)(ps1pb);\n    //const v1 = c1*vₓ + d1*vᵧ;\n    const p1 = epr(c1, vₓ);\n    const p2 = epr(d1, vᵧ);\n    const v1 = fes(p1, p2);\n    //const v0 = c0*vₓ + d0*vᵧ + v_0;\n    const p3 = sce(c0, vₓ);\n    const p4 = sce(d0, vᵧ);\n    const p5 = fes(p3, p4);\n    const v0 = fes(p5, v);\n    const r = [v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez1-bez1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez2Exact: () => (/* binding */ getCoeffsBez1Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs-bez1-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of an order\n * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).\n *\n * The returned polynomial degree will be 2\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez1Bez2Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps1);\n    // if both polynomials' linear terms are exactly zero then it really is a point\n    // if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\n    // This shouldn't happen due to being checked for earlier.\n    // }\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis2Exact)(ps2);\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez1Bez1Exact)(ps1, [ps2[0], ps2[2]]);\n    }\n    const { vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 1\n    (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_6__.getImplicitForm1ExactPb)(ps1pb);\n    // a2*v_x + b2*v_y\n    //const v2 = c2*vₓ + d2*vᵧ;\n    const p1 = epr(c2, vₓ);\n    const p2 = epr(d2, vᵧ);\n    const v2 = fes(p1, p2);\n    // a1*v_x + b1*v_y\n    //const v1 = c1*vₓ + d1*vᵧ;\n    const p3 = epr(c1, vₓ);\n    const p4 = epr(d1, vᵧ);\n    const v1 = fes(p3, p4);\n    // a0*v_x + b0*v_y + v_0\n    //const v0 = c0*vₓ + d0*vᵧ + v;\n    const p5 = sce(c0, vₓ);\n    const p6 = sce(d0, vᵧ);\n    const p7 = fes(p5, p6);\n    const v0 = fes(p7, v);\n    const r = [v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez1-bez2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez3Exact: () => (/* binding */ getCoeffsBez1Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs-bez1-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js\");\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of an order\n * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).\n *\n * The returned polynomial degree will be 3\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez1Bez3Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps1);\n    // if both polynomials' linear terms are exactly zero then it really is a point\n    // if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\n    // This shouldn't happen due to being checked for earlier.\n    // }\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis3Exact)(ps2);\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez1Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_6__.cubicToQuadratic)(ps2));\n    }\n    // it is a precondition that the curve really has order 1\n    // keep TypeScript happy; `getImplicitForm1ExactPb` cannot return `undefined` here\n    const { vₓ, vᵧ, v } = (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm1ExactPb)(ps1pb);\n    // a3*v_x + b3*v_y\n    //const v3 = c3*vₓ + d3*vᵧ;\n    const p1 = epr(c3, vₓ);\n    const p2 = epr(d3, vᵧ);\n    const v3 = fes(p1, p2);\n    // a2*v_x + b2*v_y\n    //const v2 = c2*vₓ + d2*vᵧ;\n    const p3 = epr(c2, vₓ);\n    const p4 = epr(d2, vᵧ);\n    const v2 = fes(p3, p4);\n    // a1*v_x + b1*v_y\n    //const v1 = c1*vₓ + d1*vᵧ;\n    const p5 = epr(c1, vₓ);\n    const p6 = epr(d1, vᵧ);\n    const v1 = fes(p5, p6);\n    // a0*v_x + b0*v_y + v_0\n    //const v0 = c0*vₓ + d0*vᵧ + v;\n    const p7 = sce(c0, vₓ);\n    const p8 = sce(d0, vᵧ);\n    const p9 = fes(p7, p8);\n    const v0 = fes(p9, v);\n    const r = [v3, v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez1-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez1Exact: () => (/* binding */ getCoeffsBez2Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez1-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of an order\n * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).\n *\n * The returned polynomial degree will be 2\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n  * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez2Bez1Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps1);\n    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;\n    // if both polynomials' quadratic terms are exactly zero then its really a line\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez1Bez1Exact)([ps1[0], ps1[2]], ps2);\n    }\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis1Exact)(ps2);\n    // if (eSign(c1) === 0 && eSign(d1) === 0) {\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\n    // This shouldn't happen due to being checked for earlier.\n    // }\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 2\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm2ExactPb)(ps1pb);\n    const c0c0 = tp(c0, c0);\n    const c0c1 = sce(c0, c1);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = sce(c0, d1);\n    const c1c1 = epr(c1, c1);\n    const c1d0 = sce(d0, c1);\n    const c1d1 = epr(c1, d1);\n    const d0d0 = tp(d0, d0);\n    const d0d1 = sce(d0, d1);\n    const d1d1 = epr(d1, d1);\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\n    const p1 = epr(c1c1, vₓₓ);\n    const p2 = epr(d1d1, vᵧᵧ);\n    const p3 = epr(c1d1, vₓᵧ);\n    const p4 = fes(p1, p2);\n    const v2 = fes(p4, p3);\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\n    const p5 = epr(c0c1, vₓₓ);\n    const p6 = epr(d0d1, vᵧᵧ);\n    const p7 = fes(c0d1, c1d0);\n    const pn = epr(p7, vₓᵧ);\n    const p8 = em2(fes(p5, p6));\n    const p9 = fes(p8, pn);\n    const pa = epr(c1, vₓ);\n    const pb = epr(d1, vᵧ);\n    const pc = fes(pa, pb);\n    const v1 = fes(p9, pc);\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\n    const pe = epr(c0c0, vₓₓ);\n    const pf = epr(c0d0, vₓᵧ);\n    const pg = epr(d0d0, vᵧᵧ);\n    const ph = fes(pe, pf);\n    const pi = fes(ph, pg);\n    const pj = sce(c0, vₓ);\n    const pk = sce(d0, vᵧ);\n    const pl = fes(pj, pk);\n    const pm = fes(pi, pl);\n    const v0 = fes(pm, v);\n    const r = [v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez2-bez1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez2Exact: () => (/* binding */ getCoeffsBez2Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez1-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js\");\n/* harmony import */ var _get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-coeffs-bez2-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of 2 order\n * 2 bezier curves (i.e. 2 quadratic bezier curves).\n *\n * The returned polynomial degree will be 4\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez2Bez2Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps1);\n    // if both polynomials' quadratic terms are exactly zero then its really a line\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez1Bez2Exact)([ps1[0], ps1[2]], ps2);\n    }\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps2);\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez2Bez1Exact)(ps1, [ps2[0], ps2[2]]);\n    }\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 2\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm2ExactPb)(ps1pb);\n    const c0c0 = tp(c0, c0);\n    const c0c1 = sce(c0, c1);\n    const c0c2 = sce(c0, c2);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = sce(c0, d1);\n    const c0d2 = sce(c0, d2);\n    const c1c1 = epr(c1, c1);\n    const c1c2 = epr(c1, c2);\n    const c1d0 = sce(d0, c1);\n    const c1d1 = epr(c1, d1);\n    const c1d2 = epr(c1, d2);\n    const c2d1 = epr(c2, d1);\n    const c2c2 = epr(c2, c2);\n    const c2d0 = sce(d0, c2);\n    const c2d2 = epr(c2, d2);\n    const d0d0 = tp(d0, d0);\n    const d0d1 = sce(d0, d1);\n    const d0d2 = sce(d0, d2);\n    const d1d1 = epr(d1, d1);\n    const d1d2 = epr(d1, d2);\n    const d2d2 = epr(d2, d2);\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\n    //const v4 = \n    //    (c2*c2)*vₓₓ +\n    //    (c2*d2)*vₓᵧ +\n    //    (d2*d2)*vᵧᵧ;\n    const p1 = epr(c2c2, vₓₓ);\n    const p2 = epr(c2d2, vₓᵧ);\n    const p3 = epr(d2d2, vᵧᵧ);\n    const p4 = fes(p1, p2);\n    const v4 = fes(p4, p3);\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\n    //const v3 =\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\n    const p5 = epr(c1c2, vₓₓ);\n    const p6 = epr(d1d2, vᵧᵧ);\n    const p7 = fes(c1d2, c2d1);\n    const p8 = epr(p7, vₓᵧ);\n    const p9 = em2(fes(p5, p6));\n    const v3 = fes(p9, p8);\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\n    //const v2 = \n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\n    //    c2*vₓ  +          \n    //    d2*vᵧ;\n    const pa = fes(em2(c0c2), c1c1);\n    const pb = fes(em2(d0d2), d1d1);\n    const pc = fes(c0d2, c1d1);\n    const pd = fes(pc, c2d0);\n    const pe = epr(pa, vₓₓ);\n    const pf = epr(pb, vᵧᵧ);\n    const pg = epr(pd, vₓᵧ);\n    const ph = epr(c2, vₓ);\n    const pi = epr(d2, vᵧ);\n    const pj = fes(pe, pf);\n    const pk = fes(pj, pg);\n    const pl = fes(ph, pi);\n    const v2 = fes(pk, pl);\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\n    //const v1 =\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\n    //    c1*vₓ  +\n    //    d1*vᵧ;\n    const pm = epr(c0c1, vₓₓ);\n    const pn = epr(d0d1, vᵧᵧ);\n    const po = fes(c0d1, c1d0);\n    const pp = epr(po, vₓᵧ);\n    const pq = em2(fes(pm, pn));\n    const pr = epr(c1, vₓ);\n    const ps = epr(d1, vᵧ);\n    const pt = fes(pq, pp);\n    const pu = fes(pr, ps);\n    const v1 = fes(pt, pu);\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \n    // b0**2*v_yy + b0*v_y + v_0\n    //const v0 =\n    //    (c0*c0)*vₓₓ + \n    //    (c0*d0)*vₓᵧ + \n    //    (d0*d0)*vᵧᵧ + \n    //    c0*vₓ  +         \n    //    d0*vᵧ  +\n    //    v;\n    const pv = epr(c0c0, vₓₓ);\n    const pw = epr(c0d0, vₓᵧ);\n    const px = epr(d0d0, vᵧᵧ);\n    const py = sce(c0, vₓ);\n    const pz = sce(d0, vᵧ);\n    const q1 = fes(pv, pw);\n    const q2 = fes(q1, px);\n    const q3 = fes(py, pz);\n    const q4 = fes(q2, q3);\n    const v0 = fes(q4, v);\n    const r = [v4, v3, v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez2-bez2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez3Exact: () => (/* binding */ getCoeffsBez2Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez1-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js\");\n/* harmony import */ var _get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-coeffs-bez2-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\n\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of an order\n * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).\n *\n * The returned polynomial degree will be 6\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez2Bez3Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps1);\n    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;\n    // if both polynomials' quadratic terms are exactly zero then its really a line\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez1Bez3Exact)([ps1[0], ps1[2]], ps2);\n    }\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps2);\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez2Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_9__.cubicToQuadratic)(ps2));\n    }\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 2\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm2ExactPb)(ps1pb);\n    const c0c0 = tp(c0, c0);\n    const c0c1 = sce(c0, c1);\n    const c0c2 = sce(c0, c2);\n    const c0c3 = sce(c0, c3);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = sce(c0, d1);\n    const c0d2 = sce(c0, d2);\n    const c0d3 = sce(c0, d3);\n    const c1c1 = epr(c1, c1);\n    const c1c2 = epr(c1, c2);\n    const c1c3 = epr(c1, c3);\n    const c1d0 = sce(d0, c1);\n    const c1d1 = epr(c1, d1);\n    const c1d2 = epr(c1, d2);\n    const c1d3 = epr(c1, d3);\n    const c2d1 = epr(c2, d1);\n    const c2c2 = epr(c2, c2);\n    const c2c3 = epr(c2, c3);\n    const c2d0 = sce(d0, c2);\n    const c2d2 = epr(c2, d2);\n    const c2d3 = epr(c2, d3);\n    const c3c3 = epr(c3, c3);\n    const c3d0 = sce(d0, c3);\n    const c3d1 = epr(c3, d1);\n    const c3d2 = epr(c3, d2);\n    const c3d3 = epr(c3, d3);\n    const d0d0 = tp(d0, d0);\n    const d0d1 = sce(d0, d1);\n    const d0d2 = sce(d0, d2);\n    const d0d3 = sce(d0, d3);\n    const d1d1 = epr(d1, d1);\n    const d1d2 = epr(d1, d2);\n    const d3d3 = epr(d3, d3);\n    const d2d2 = epr(d2, d2);\n    const d2d3 = epr(d2, d3);\n    const d1d3 = epr(d1, d3);\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\n    //const v6 =\n    //    c3c3*vₓₓ +\n    //    c3d3*vₓᵧ +\n    //    d3d3*vᵧᵧ;\n    const p1 = epr(c3c3, vₓₓ);\n    const p2 = epr(c3d3, vₓᵧ);\n    const p3 = epr(d3d3, vᵧᵧ);\n    const p4 = fes(p1, p2);\n    const v6 = fes(p4, p3);\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\n    //const v5 =\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\n    //    vₓᵧ*(c2d3 + c3d2);\n    const p5 = epr(c2c3, vₓₓ);\n    const p6 = epr(d2d3, vᵧᵧ);\n    const p7 = fes(p5, p6);\n    const p8 = fes(c2d3, c3d2);\n    const p9 = epr(p8, vₓᵧ);\n    const v5 = fes(em2(p7), p9);\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\n    //const v4 =\n    //    (2*c1c3 + c2c2)*vₓₓ +\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\n    const pa = fes(em2(c1c3), c2c2);\n    const pb = fes(em2(d1d3), d2d2);\n    const pc = fes(c1d3, c2d2);\n    const pd = fes(pc, c3d1);\n    const pe = epr(pa, vₓₓ);\n    const pf = epr(pb, vᵧᵧ);\n    const pg = fes(pe, pf);\n    const rp = epr(pd, vₓᵧ);\n    const v4 = fes(pg, rp);\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\n    //const v3 =\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\n    //    c3*vₓ +\n    //    d3*vᵧ;\n    const ph = fes(c0c3, c1c2);\n    const pi = fes(d0d3, d1d2);\n    const pj = fes(c0d3, c1d2);\n    const pk = fes(c2d1, c3d0);\n    const pl = fes(pj, pk);\n    const pm = epr(ph, vₓₓ);\n    const pn = epr(pi, vᵧᵧ);\n    const po = em2(fes(pm, pn));\n    const pp = epr(pl, vₓᵧ);\n    const rn = epr(c3, vₓ);\n    const ro = epr(d3, vᵧ);\n    const pq = fes(rn, ro);\n    const pr = fes(po, pp);\n    const v3 = fes(pr, pq);\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\n    //const v2 =\n    //    (2*c0c2 + c1c1)*vₓₓ +\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\n    //    c2*vₓ +\n    //    d2*vᵧ;\n    const ps = fes(em2(c0c2), c1c1);\n    const pt = fes(em2(d0d2), d1d1);\n    const pu = fes(c0d2, c1d1);\n    const pv = fes(pu, c2d0);\n    const pw = epr(ps, vₓₓ);\n    const px = epr(pt, vᵧᵧ);\n    const py = epr(pv, vₓᵧ);\n    const pz = fes(pw, px);\n    const r1 = fes(pz, py);\n    const r2 = epr(c2, vₓ);\n    const r3 = epr(d2, vᵧ);\n    const r4 = fes(r2, r3);\n    const v2 = fes(r1, r4);\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\n    //const v1 =\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    (c0d1 + c1d0)*vₓᵧ +\n    //    c1*vₓ +\n    //    d1*vᵧ;\n    const r5 = epr(c0c1, vₓₓ);\n    const r6 = epr(d0d1, vᵧᵧ);\n    const r7 = fes(c0d1, c1d0);\n    const r8 = epr(r7, vₓᵧ);\n    const r9 = em2(fes(r5, r6));\n    const ra = fes(r9, r8);\n    const rb = epr(c1, vₓ);\n    const rc = epr(d1, vᵧ);\n    const rd = fes(rb, rc);\n    const v1 = fes(ra, rd);\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\n    //const v0 =\n    //    c0c0*vₓₓ +\n    //    c0d0*vₓᵧ +\n    //    d0d0*vᵧᵧ +\n    //    c0*vₓ +\n    //    d0*vᵧ +\n    //    v;\n    const re = epr(c0c0, vₓₓ);\n    const rf = epr(c0d0, vₓᵧ);\n    const rg = epr(d0d0, vᵧᵧ);\n    const rh = sce(c0, vₓ);\n    const ri = sce(d0, vᵧ);\n    const rj = fes(re, rf);\n    const rk = fes(rj, rg);\n    const rl = fes(rh, ri);\n    const rm = fes(rk, rl);\n    const v0 = fes(rm, v);\n    const r = [v6, v5, v4, v3, v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez2-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez1Exact: () => (/* binding */ getCoeffsBez3Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez2-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\n\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of an order\n * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).\n *\n * The returned polynomial degree will be 3\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n  * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez3Bez1Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps1);\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\n    // if both polynomials' cubic terms are exactly zero then its really a quadratic\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez1Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps1), ps2);\n    }\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis1Exact)(ps2);\n    // if (eSign(c1) === 0 && eSign(d1) === 0) {\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\n    // This shouldn't happen due to being checked for earlier.\n    // }\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 3\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm3ExactPb)(ps1pb);\n    const c0c0 = tp(c0, c0);\n    const c0c1 = sce(c0, c1);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = sce(c0, d1);\n    const c1c1 = epr(c1, c1);\n    const c1d0 = sce(d0, c1);\n    const c1d1 = epr(c1, d1);\n    const d0d0 = tp(d0, d0);\n    const d0d1 = sce(d0, d1);\n    const d1d1 = epr(d1, d1);\n    const z1 = sce(c0, vₓₓₓ);\n    const z7 = epr(tp(3, c0), vₓₓₓ);\n    const z2 = sce(c0, vₓₓᵧ);\n    const z3 = sce(d0, vₓₓᵧ);\n    const z4 = sce(c0, vₓᵧᵧ);\n    const z5 = sce(d0, vₓᵧᵧ);\n    const z6 = sce(d0, vᵧᵧᵧ);\n    const z8 = epr(tp(3, d0), vᵧᵧᵧ);\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\n    //const v3 =\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\n    const u1 = epr(c1, vₓₓₓ);\n    const u2 = epr(c1, vₓᵧᵧ);\n    const u3 = epr(d1, vₓₓᵧ);\n    const u4 = epr(d1, vᵧᵧᵧ);\n    const u5 = fes(u1, u3);\n    const u6 = fes(u2, u4);\n    const u7 = epr(c1c1, u5);\n    const u8 = epr(d1d1, u6);\n    const v3 = fes(u7, u8);\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\n    //const v2 =\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\n    //const v2 =\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\n    const u9 = fes(z7, z3);\n    const ua = em2(fes(z2, z5));\n    const ub = fes(z4, z8);\n    const uc = fes(u9, vₓₓ);\n    const ud = fes(ua, vₓᵧ);\n    const ue = fes(ub, vᵧᵧ);\n    const uf = epr(c1c1, uc);\n    const ug = epr(c1d1, ud);\n    const uh = epr(d1d1, ue);\n    const ui = fes(uf, ug);\n    const v2 = fes(ui, uh);\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\n    //const v1 =\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\n    //    vₓ*c1 +\n    //    vᵧ*d1;\n    const uj = em2(fes(z3, vₓₓ));\n    const uk = em2(fes(z4, vᵧᵧ));\n    const un = fes(z7, uj);\n    const uo = fes(z8, uk);\n    const up = fes(z2, vₓᵧ);\n    const uq = fes(z5, vₓᵧ);\n    const ur = epr(c0c1, un);\n    const us = epr(d0d1, uo);\n    const ut = epr(c0d1, up);\n    const uu = epr(c1d0, uq);\n    const uv = epr(c1, vₓ);\n    const uw = epr(d1, vᵧ);\n    const ux = fes(ur, us);\n    const uy = fes(ut, uu);\n    const uz = fes(ux, uy);\n    const u0 = fes(uv, uw);\n    const v1 = fes(uz, u0);\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\n    //const v0 =\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\n    //    c0d0*vₓᵧ +\n    //    c0*vₓ    +\n    //    d0*vᵧ    +\n    //    v;\n    //const v0 =\n    //    c0c0*(z1 + z3 + vₓₓ) +\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\n    //    c0d0*vₓᵧ +\n    //    c0*vₓ    +\n    //    d0*vᵧ    +\n    //    v;\n    const f1 = fes(z1, z3);\n    const f2 = fes(z6, z4);\n    const f3 = fes(f1, vₓₓ);\n    const f4 = fes(f2, vᵧᵧ);\n    const f5 = epr(c0c0, f3);\n    const f6 = epr(d0d0, f4);\n    const f7 = epr(c0d0, vₓᵧ);\n    const f8 = fes(f5, f6);\n    const f9 = fes(f8, f7);\n    const fa = sce(c0, vₓ);\n    const fb = sce(d0, vᵧ);\n    const fc = fes(fa, fb);\n    const fd = fes(f9, fc);\n    const v0 = fes(fd, v);\n    const r = [v3, v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez3-bez1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez2Exact: () => (/* binding */ getCoeffsBez3Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez2-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coeffs-bez3-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of an order\n * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).\n *\n * The returned polynomial degree will be 6\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n  * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez3Bez2Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps1);\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\n    // if both polynomials' cubic terms are exactly zero then its really a quadratic\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez2Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps1), ps2);\n    }\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps2);\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\n        // the input bezier curve is in fact not quadratic but has order < 2\n        return (0,_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Bez1Exact)(ps1, [ps2[0], ps2[2]]);\n    }\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 3\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm3ExactPb)(ps1pb);\n    const c0c0 = tp(c0, c0);\n    const c0c1 = sce(c0, c1);\n    const c0c2 = sce(c0, c2);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = sce(c0, d1);\n    const c0d2 = sce(c0, d2);\n    const c1c1 = epr(c1, c1);\n    const c1c2 = epr(c1, c2);\n    const c1d0 = sce(d0, c1);\n    const c1d1 = epr(c1, d1);\n    const c1d2 = epr(c1, d2);\n    const c2d1 = epr(c2, d1);\n    const c2c2 = epr(c2, c2);\n    const c2d0 = sce(d0, c2);\n    const c2d2 = epr(c2, d2);\n    const d0d0 = tp(d0, d0);\n    const d0d1 = sce(d0, d1);\n    const d0d2 = sce(d0, d2);\n    const d1d1 = epr(d1, d1);\n    const d1d2 = epr(d1, d2);\n    const d2d2 = epr(d2, d2);\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\n    //const v6 =\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\n    const e1 = epr(c2, vₓₓₓ);\n    const e2 = epr(c2, vₓᵧᵧ);\n    const e3 = epr(d2, vₓₓᵧ);\n    const e4 = epr(d2, vᵧᵧᵧ);\n    const e5 = fes(e1, e3);\n    const e6 = fes(e2, e4);\n    const e7 = epr(c2c2, e5);\n    const e8 = epr(d2d2, e6);\n    const v6 = fes(e7, e8);\n    const z1 = fes(c0c2, c1c1);\n    const z2 = fes(d0d2, d1d1);\n    const z3 = fes(em2(c0c2), c1c1);\n    const z4 = fes(em2(d0d2), d1d1);\n    const z5 = fes(em2(c1d1), c2d0);\n    const z6 = fes(em2(c1d1), c0d2);\n    const z7 = fes(em2(c2d0), c1d1);\n    const z8 = fes(sce(6, c0c2), c1c1);\n    const z9 = fes(sce(6, d0d2), d1d1);\n    const za = fes(c1d2, c2d1);\n    const zb = fes(c0d2, c2d0);\n    const zc = fes(em2(c1d0), c0d1);\n    const zd = fes(em2(c0d1), c1d0);\n    const zf = fes(c0d2, c1d1);\n    const ze = fes(zf, c2d0);\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\n    //const v5 =\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\n    const s0 = sce(3, c2c2);\n    const t1 = sce(3, d2d2);\n    const s1 = epr(s0, vₓₓₓ);\n    const s2 = epr(c2c2, vₓₓᵧ);\n    const s3 = em2(epr(c2d2, vₓₓᵧ));\n    const s4 = em2(epr(c2d2, vₓᵧᵧ));\n    const s5 = epr(d2d2, vₓᵧᵧ);\n    const s6 = epr(t1, vᵧᵧᵧ);\n    const s7 = fes(s1, s3);\n    const s8 = fes(s2, s4);\n    const s9 = fes(s7, s5);\n    const sa = fes(s8, s6);\n    const sb = epr(c1, s9);\n    const sc = epr(d1, sa);\n    const v5 = fes(sb, sc);\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\n    //const v4 =\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\n    //    vₓₓ*c2c2 +\n    //    vᵧᵧ*d2d2 +\n    //    vₓᵧ*c2d2;\n    //const v4 =\n    //    (3*c2)*z1*vₓₓₓ + \n    //    (3*d2)*z2*vᵧᵧᵧ + \n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\n    //    vₓₓ*c2c2 +\n    //    vᵧᵧ*d2d2 +\n    //    vₓᵧ*c2d2;\n    const sd = epr(d2, z3);\n    const se = epr(d2, z6);\n    const sf = epr(c2, z5);\n    const sg = epr(c2, z4);\n    const sh = epr(sce(3, c2), z1);\n    const si = epr(sce(3, d2), z2);\n    const sj = fes(sd, sf);\n    const sk = fes(se, sg);\n    const sl = epr(sh, vₓₓₓ);\n    const sm = epr(si, vᵧᵧᵧ);\n    const sn = epr(sj, vₓₓᵧ);\n    const so = epr(sk, vₓᵧᵧ);\n    const sp = fes(sl, sm);\n    const sq = fes(sn, so);\n    const sr = epr(c2c2, vₓₓ);\n    const ss = epr(d2d2, vᵧᵧ);\n    const st = epr(c2d2, vₓᵧ);\n    const su = fes(sr, ss);\n    const sv = fes(sp, sq);\n    const sw = fes(su, st);\n    const v4 = fes(sv, sw);\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \n    // 2*b1*b2*v_yy\n    //const v3 =\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\n    //const v3 =\n    //    c1*z8*vₓₓₓ +\n    //    d1*z9*vᵧᵧᵧ +        \n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\n    //    za*vₓᵧ;\n    const sx = epr(c1, z8);\n    const sy = epr(d1, z9);\n    const sz = sce(2 * c0, za);\n    const o1 = epr(em2(d1), zb);\n    const o2 = epr(c1, z7);\n    const o3 = epr(c1, z4);\n    const o4 = fes(sz, o2);\n    const o5 = fes(o1, o3);\n    const o6 = epr(d1d2, vᵧᵧ);\n    const o7 = epr(c1c2, vₓₓ);\n    const o8 = epr(za, vₓᵧ);\n    const o9 = fes(o6, o7);\n    const oa = epr(sx, vₓₓₓ);\n    const ob = epr(o4, vₓₓᵧ);\n    const oc = epr(sy, vᵧᵧᵧ);\n    const od = epr(o5, vₓᵧᵧ);\n    const oe = fes(oa, oc);\n    const og = fes(ob, od);\n    const oh = fes(oe, og);\n    const oi = fes(em2(o9), o8);\n    const v3 = fes(oh, oi);\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\n    //const v2 =\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\n    //    (2*c0c2 + c1c1)*vₓₓ +\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\n    //    c2*vₓ    +\n    //    d2*vᵧ;\n    //const v2 =\n    //    (3*c0*z1)*vₓₓₓ +\n    //    (3*d0*z2)*vᵧᵧᵧ +\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\n    //    z3*vₓₓ +\n    //    z4*vᵧᵧ +\n    //    ze*vₓᵧ +\n    //    c2*vₓ    +\n    //    d2*vᵧ;\n    const oj = epr(tp(3, c0), z1);\n    const ok = epr(tp(3, d0), z2);\n    const ol = sce(c0, z6);\n    const om = sce(c0, z4);\n    const on = sce(d0, z3);\n    const oo = sce(d0, z5);\n    const op = fes(ol, on);\n    const oq = fes(om, oo);\n    const or = epr(oj, vₓₓₓ);\n    const os = epr(ok, vᵧᵧᵧ);\n    const ot = epr(op, vₓₓᵧ);\n    const ou = epr(oq, vₓᵧᵧ);\n    const ov = epr(z3, vₓₓ);\n    const ow = epr(z4, vᵧᵧ);\n    const ox = epr(ze, vₓᵧ);\n    const oy = epr(c2, vₓ);\n    const oz = epr(d2, vᵧ);\n    const p1 = fes(or, os);\n    const p2 = fes(ot, ou);\n    const p3 = fes(ov, ow);\n    const p4 = fes(p1, p2);\n    const p5 = fes(p3, ox);\n    const p6 = fes(oy, oz);\n    const p7 = fes(p4, p5);\n    const v2 = fes(p7, p6);\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\n    //const v1 =\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\n    //    c1*vₓ + d1*vᵧ;\n    //const v1 =\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\n    //    c0*zc*vₓₓᵧ +\n    //    d0*zd*vₓᵧᵧ +\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\n    //    c1*vₓ + d1*vᵧ;\n    const p8 = epr(tp(3, c0), c0c1);\n    const p9 = epr(tp(3, d0), d0d1);\n    const pa = sce(c0, zc);\n    const pb = sce(d0, zd);\n    const pc = epr(c0c1, vₓₓ);\n    const pd = epr(d0d1, vᵧᵧ);\n    const pe = epr(c0d1, vₓᵧ);\n    const pf = epr(c1d0, vₓᵧ);\n    const pg = em2(fes(pc, pd));\n    const ph = fes(pe, pf);\n    const pi = epr(c1, vₓ);\n    const pj = epr(d1, vᵧ);\n    const pk = epr(p8, vₓₓₓ);\n    const pl = epr(p9, vᵧᵧᵧ);\n    const pm = epr(pa, vₓₓᵧ);\n    const pn = epr(pb, vₓᵧᵧ);\n    const po = fes(pk, pl);\n    const pp = fes(pm, pn);\n    const pq = fes(po, pp);\n    const pr = fes(pg, ph);\n    const ps = fes(pi, pj);\n    const pt = fes(pq, pr);\n    const v1 = fes(pt, ps);\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\n    //const v0 =\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\n    //    c0d0*vₓᵧ +\n    //    c0*vₓ +\n    //    d0*vᵧ +\n    //    v;\n    const pu = sce(c0, vₓₓₓ);\n    const pv = sce(c0, vₓᵧᵧ);\n    const pw = sce(d0, vₓₓᵧ);\n    const px = sce(d0, vᵧᵧᵧ);\n    const py = fes(pu, pw);\n    const pz = fes(pv, px);\n    const u1 = fes(py, vₓₓ);\n    const u2 = fes(pz, vᵧᵧ);\n    const u3 = epr(c0c0, u1);\n    const u4 = epr(d0d0, u2);\n    const u5 = epr(c0d0, vₓᵧ);\n    const u6 = sce(c0, vₓ);\n    const u7 = sce(d0, vᵧ);\n    const u8 = fes(u3, u4);\n    const u9 = fes(u8, u5);\n    const ua = fes(u6, u7);\n    const ub = fes(u9, ua);\n    const v0 = fes(ub, v);\n    const r = [v6, v5, v4, v3, v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez3-bez2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez3Exact: () => (/* binding */ getCoeffsBez3Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coeffs-bez3-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez2-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\n\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\n/**\n * Returns an error-free polynomial in in 1 variable\n * whose roots are the parameter values of the intersection points of 2 order\n * 3 bezier curves (i.e. 2 cubic bezier curves).\n *\n * The returned polynomial degree will be 9\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps1\n * @param ps2\n *\n * @internal\n */\nfunction getCoeffsBez3Bez3Exact(ps1, ps2) {\n    /** ps1 in power bases */\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps1);\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\n    // if both polynomials' cubic terms are exactly zero then its really a quadratic\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez3Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps1), ps2);\n    }\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps2);\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\n        // the input bezier curve is in fact not cubic but has order < 3\n        return (0,_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps2));\n    }\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \n    // this type coercion is justified since we already checked that the\n    // curve really has order 3\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm3ExactPb)(ps1pb);\n    const c0c0 = tp(c0, c0);\n    const c0c1 = sce(c0, c1);\n    const c0c2 = sce(c0, c2);\n    const c0c3 = sce(c0, c3);\n    const c0d0 = tp(c0, d0);\n    const c0d1 = sce(c0, d1);\n    const c0d2 = sce(c0, d2);\n    const c0d3 = sce(c0, d3);\n    const c1c1 = epr(c1, c1);\n    const c1c2 = epr(c1, c2);\n    const c1c3 = epr(c1, c3);\n    const c1d0 = sce(d0, c1);\n    const c1d1 = epr(c1, d1);\n    const c1d2 = epr(c1, d2);\n    const c1d3 = epr(c1, d3);\n    const c2d1 = epr(c2, d1);\n    const c2c2 = epr(c2, c2);\n    const c2c3 = epr(c2, c3);\n    const c2d0 = sce(d0, c2);\n    const c2d2 = epr(c2, d2);\n    const c2d3 = epr(c2, d3);\n    const c3c3 = epr(c3, c3);\n    const c3d0 = sce(d0, c3);\n    const c3d1 = epr(c3, d1);\n    const c3d2 = epr(c3, d2);\n    const c3d3 = epr(c3, d3);\n    const d0d0 = tp(d0, d0);\n    const d0d1 = sce(d0, d1);\n    const d0d2 = sce(d0, d2);\n    const d0d3 = sce(d0, d3);\n    const d1d1 = epr(d1, d1);\n    const d1d2 = epr(d1, d2);\n    const d3d3 = epr(d3, d3);\n    const d2d2 = epr(d2, d2);\n    const d2d3 = epr(d2, d3);\n    const d1d3 = epr(d1, d3);\n    //const v9 =  \n    //    (c3*c3c3)*vₓₓₓ + \n    //    (c3*d3d3)*vₓᵧᵧ + \n    //    (d3*c3c3)*vₓₓᵧ + \n    //    (d3*d3d3)*vᵧᵧᵧ;  \n    const g1 = epr(c3, c3c3); // c3*c3c3\n    const g2 = epr(c3, d3d3); // c3*d3d3\n    const g3 = epr(d3, c3c3); // d3*c3c3\n    const g4 = epr(d3, d3d3); // d3*d3d3\n    const g5 = epr(g1, vₓₓₓ); // g1*vₓₓₓ\n    const g6 = epr(g2, vₓᵧᵧ); // g2*vₓᵧᵧ\n    const g7 = epr(g3, vₓₓᵧ); // g3*vₓₓᵧ \n    const g8 = epr(g4, vᵧᵧᵧ); // g4*vᵧᵧᵧ\n    const g9 = fes(g5, g6); // g5 + g6\n    const ga = fes(g7, g8); // g7 + g8\n    const v9 = fes(g9, ga); // g9 + ga\n    //const v8 =  \n    //    2*c2*c3d3*vₓₓᵧ + \n    //    2*c3*d2d3*vₓᵧᵧ + \n    //      c2*d3d3*vₓᵧᵧ + \n    //      d2*c3c3*vₓₓᵧ + \n    //    3*c2*c3c3*vₓₓₓ + \n    //    3*d2*d3d3*vᵧᵧᵧ;  \n    const w1 = fes(em2(c2d3), c3d2);\n    const w2 = fes(em2(c3d2), c2d3);\n    const w3 = epr(c3, w1);\n    const w4 = epr(d3, w2);\n    const w5 = epr(c2, c3c3);\n    const w6 = epr(d2, d3d3);\n    const w7 = epr(vₓₓₓ, w5);\n    const u1 = epr(vᵧᵧᵧ, w6);\n    const u2 = epr(vₓₓᵧ, w3);\n    const u3 = epr(vₓᵧᵧ, w4);\n    const u4 = fes(u2, u3);\n    const u5 = sce(3, fes(w7, u1));\n    const v8 = fes(u4, u5);\n    //const v7 =  \n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\n    const o1 = epr(c1, c3d3);\n    const o2 = epr(d1, c3c3);\n    const o3 = epr(c2, d2d3);\n    const o4 = epr(c1, d3d3);\n    const o5 = epr(c2, c3d2);\n    const o6 = epr(d3, c2c2);\n    const o7 = epr(c3, d1d3);\n    const o8 = epr(d2, c3d2);\n    const w8 = fes(o1, o5);\n    const w9 = fes(o2, o6);\n    const wa = fes(o3, o7);\n    const wb = fes(o4, o8);\n    const wc = fes(c1c3, c2c2);\n    const wd = fes(d1d3, d2d2);\n    const we = fes(em2(w8), w9);\n    const wf = fes(em2(wa), wb);\n    const wg = epr(vₓₓᵧ, we);\n    const wh = epr(vₓᵧᵧ, wf);\n    const wi = epr(c3, wc);\n    const wj = epr(d3, wd);\n    const wk = epr(vₓₓₓ, wi);\n    const wl = epr(vᵧᵧᵧ, wj);\n    const wm = fes(wg, wh);\n    const wn = sce(3, fes(wk, wl));\n    const v7 = fes(wm, wn);\n    //const v6 =\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\n    //    vₓₓ *c3c3 +\n    //    vᵧᵧ *d3d3 +\n    //    vₓᵧ *c3d3;\n    const wo = fes(c2d3, c3d2);\n    const zc = epr(d2, c2c2);\n    const zd = em2(epr(c1, wo));\n    const wp = fes(zc, zd);\n    const wq = em2(fes(c0d3, c2d1));\n    const wr = fes(wq, c3d0);\n    const ze = epr(c3, wr);\n    const ws = fes(wp, ze);\n    const zf = epr(c2, d2d2);\n    const zg = em2(epr(d1, wo));\n    const wt = fes(zf, zg);\n    const wu = em2(fes(c1d2, c3d0));\n    const wv = fes(wu, c0d3);\n    const zh = epr(d3, wv);\n    const ww = fes(wt, zh);\n    const wx = epr(c2, c2c2);\n    const wy = fes(em2(c1c2), c0c3);\n    const wz = epr(sce(3, c3), wy);\n    const z1 = fes(wx, wz);\n    const z2 = epr(d2, d2d2);\n    const z3 = fes(em2(d1d2), d0d3);\n    const z4 = epr(sce(3, d3), z3);\n    const z5 = fes(z2, z4);\n    const zi = epr(vₓₓᵧ, ws);\n    const zj = epr(vₓᵧᵧ, ww);\n    const z6 = fes(zi, zj);\n    const zk = epr(vₓₓₓ, z1);\n    const zl = epr(vᵧᵧᵧ, z5);\n    const z7 = fes(zk, zl);\n    const zm = epr(c3c3, vₓₓ);\n    const zn = epr(d3d3, vᵧᵧ);\n    const z8 = fes(zm, zn);\n    const z9 = epr(c3d3, vₓᵧ);\n    const za = fes(z6, z7);\n    const zb = fes(z8, z9);\n    const v6 = fes(za, zb);\n    //const r4 = c2d2 + c3d1;\n    //const r5 = c1d3 + c2d2;\n    //const v5 =\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\n    //    vₓᵧ*wo +\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\n    const r4 = fes(c2d2, c3d1);\n    const r5 = fes(c1d3, c2d2);\n    const k1 = sce(c0, wo);\n    const k2 = sce(d0, wo);\n    const k3 = epr(c1, r4);\n    const k4 = epr(d1, r5);\n    const k5 = fes(em2(c3d0), c2d1);\n    const k6 = fes(em2(c0d3), c1d2);\n    const k7 = epr(d3, c1c1);\n    const k8 = epr(c3, d1d1);\n    const k9 = epr(c2, k5);\n    const ka = epr(d2, k6);\n    const kb = em2(fes(k1, k3));\n    const kc = em2(fes(k2, k4));\n    const kd = em2(sce(c0, c2c3));\n    const ke = em2(sce(d0, d2d3));\n    const kf = epr(c1, wc);\n    const kg = epr(d1, wd);\n    const kh = epr(c2c3, vₓₓ);\n    const ki = epr(d2d3, vᵧᵧ);\n    const kj = fes(kb, k7);\n    const kk = fes(kc, k8);\n    const kl = fes(kj, k9);\n    const km = fes(kk, ka);\n    const kn = fes(kd, kf);\n    const ko = fes(ke, kg);\n    const kp = em2(fes(kh, ki));\n    const kq = epr(vₓₓᵧ, kl);\n    const kr = epr(vₓᵧᵧ, km);\n    const ks = epr(vₓₓₓ, kn);\n    const kt = epr(vᵧᵧᵧ, ko);\n    const ku = fes(kq, kr);\n    const kv = sce(3, fes(ks, kt));\n    const kw = epr(vₓᵧ, wo);\n    const kx = fes(ku, kv);\n    const ky = fes(kw, kp);\n    const v5 = fes(kx, ky);\n    //const r1 = c1d3 + r4;\n    //const r2 = 2*c1c3 + c2c2;\n    //const r3 = 2*d1d3 + d2d2;\n    //const v4 =\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\n    //    vₓᵧ*r1 +\n    //    vₓₓ*r2 +\n    //    vᵧᵧ*r3;\n    const r1 = fes(c1d3, r4);\n    const r2 = fes(em2(c1c3), c2c2);\n    const r3 = fes(em2(d1d3), d2d2);\n    const s1 = sce((2 * c0), r1);\n    const s2 = sce((2 * d0), r1);\n    const s5 = fes(c1d2, em2(c2d1));\n    const s6 = fes(c2d1, em2(c1d2));\n    const s3 = sce(d0, r2);\n    const s4 = sce(c0, r3);\n    const s7 = epr(c1, s5);\n    const s8 = epr(d1, s6);\n    const s9 = sce(c0, r2);\n    const sa = sce(d0, r3);\n    const sb = epr(c2, c1c1);\n    const sc = epr(d2, d1d1);\n    const sd = fes(s1, s3);\n    const se = fes(s2, s4);\n    const sf = fes(sd, s7);\n    const sg = fes(se, s8);\n    const sh = fes(s9, sb);\n    const si = fes(sa, sc);\n    const sj = epr(vₓₓᵧ, sf);\n    const sk = epr(vₓᵧᵧ, sg);\n    const sl = epr(vₓₓₓ, sh);\n    const sm = epr(vᵧᵧᵧ, si);\n    const sn = fes(sl, sm);\n    const so = fes(sj, sk);\n    const sp = fes(so, sce(3, sn));\n    const ss = epr(vₓᵧ, r1);\n    const st = epr(vₓₓ, r2);\n    const sq = fes(ss, st);\n    const su = epr(vᵧᵧ, r3);\n    const sr = fes(sq, su);\n    const v4 = fes(sp, sr);\n    //const r6 = c1d2 + c2d1;\n    //const r7 = c3d0 + c0d3;\n    //const r8 = c1c2 + c0c3;\n    //const r9 = d1d2 + d0d3;\n    //const v3 =\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\n    //    vₓᵧ*(r7 + r6) +\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\n    //    vₓ*c3 + vᵧ*d3;\n    const r6 = fes(c1d2, c2d1);\n    const r7 = fes(c3d0, c0d3);\n    const r8 = fes(c1c2, c0c3);\n    const r9 = fes(d1d2, d0d3);\n    const m1 = fes(em2(r6), c3d0);\n    const m2 = fes(em2(r6), c0d3);\n    const m3 = fes(em2(c2d0), c1d1);\n    const m4 = fes(em2(c0d2), c1d1);\n    const m5 = fes(r8, c1c2);\n    const m6 = fes(r9, d1d2);\n    const m7 = epr(tp(3, c0), m5);\n    const m8 = epr(tp(3, d0), m6);\n    const m9 = epr(c1, c1c1);\n    const ma = epr(d1, d1d1);\n    const mb = epr(vₓₓ, r8);\n    const mc = epr(vᵧᵧ, r9);\n    const md = fes(m1, r7);\n    const me = fes(m2, r7);\n    const mf = sce(c0, md);\n    const mg = sce(d0, me);\n    const mh = epr(c1, m3);\n    const mi = epr(d1, m4);\n    const mj = epr(c3, vₓ);\n    const mk = epr(d3, vᵧ);\n    const ml = fes(mf, mh);\n    const mm = fes(mg, mi);\n    const mn = fes(m7, m9);\n    const mo = fes(m8, ma);\n    const mp = fes(r7, r6);\n    const mq = em2(fes(mb, mc));\n    const mr = epr(vₓₓᵧ, ml);\n    const ms = epr(vₓᵧᵧ, mm);\n    const mt = epr(vₓₓₓ, mn);\n    const mu = epr(vᵧᵧᵧ, mo);\n    const mv = epr(vₓᵧ, mp);\n    const mw = fes(mr, ms);\n    const mx = fes(mt, mu);\n    const my = fes(mv, mq);\n    const mz = fes(mj, mk);\n    const n1 = fes(mw, mx);\n    const n2 = fes(my, mz);\n    const v3 = fes(n1, n2);\n    //const ra = c1d1 + c2d0;\n    //const rb = c1d1 + c0d2;\n    //const v2 =\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\n    //    vₓᵧ*(ra + c0d2) +\n    //    vₓₓ*(2*c0c2 + c1c1) + \n    //    vᵧᵧ*(2*d0d2 + d1d1) +\n    //    c2*vₓ + d2*vᵧ;\n    const ra = fes(c1d1, c2d0);\n    const rb = fes(c1d1, c0d2);\n    const l1 = fes(em2(ra), c0d2);\n    const l2 = fes(em2(rb), c2d0);\n    const l3 = sce(c0, l1);\n    const l4 = sce(d0, c1c1);\n    const l5 = sce(d0, l2);\n    const l6 = sce(c0, d1d1);\n    const l7 = sce(c0, c1c1);\n    const l8 = epr(c2, c0c0);\n    const l9 = sce(d0, d1d1);\n    const la = epr(d2, d0d0);\n    const lb = fes(l3, l4);\n    const lc = fes(l5, l6);\n    const ld = fes(l7, l8);\n    const le = fes(l9, la);\n    const lf = epr(vₓₓₓ, ld);\n    const lg = epr(vᵧᵧᵧ, le);\n    const lh = sce(3, fes(lf, lg));\n    const li = fes(ra, c0d2);\n    const lj = fes(em2(c0c2), c1c1);\n    const lk = fes(em2(d0d2), d1d1);\n    const ll = epr(vₓₓᵧ, lb);\n    const lm = epr(vₓᵧᵧ, lc);\n    const ln = epr(vₓᵧ, li);\n    const lo = epr(vₓₓ, lj);\n    const lp = epr(vᵧᵧ, lk);\n    const lq = epr(c2, vₓ);\n    const lr = epr(d2, vᵧ);\n    const ls = fes(lq, lr);\n    const lt = fes(ll, lm);\n    const lu = fes(lh, ln);\n    const lv = fes(lo, lp);\n    const lw = fes(lt, lu);\n    const lx = fes(lv, ls);\n    const v2 = fes(lw, lx);\n    //const rc = c1d0 + c0d1;\n    //const v1 =\n    //    vₓₓᵧ*c0*(rc + c1d0) +\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\n    //    vₓᵧ*rc +\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\n    //    c1*vₓ + d1*vᵧ ;\n    const rc = fes(c1d0, c0d1);\n    const rd = sce(c0, vₓₓᵧ);\n    const re = sce(d0, vₓᵧᵧ);\n    const rf = fes(rc, c1d0);\n    const rg = fes(rc, c0d1);\n    const rx = epr(c1, c0c0);\n    const rh = epr(rx, vₓₓₓ);\n    const ry = epr(d1, d0d0);\n    const ri = epr(ry, vᵧᵧᵧ);\n    const rj = epr(vₓᵧ, rc);\n    const rk = epr(c0c1, vₓₓ);\n    const rl = epr(d0d1, vᵧᵧ);\n    const rm = fes(rk, rl);\n    const rn = epr(c1, vₓ);\n    const ro = epr(d1, vᵧ);\n    const rp = fes(rn, ro);\n    const rq = epr(rd, rf);\n    const rr = epr(re, rg);\n    const rs = fes(rq, rr);\n    const rt = sce(3, fes(rh, ri));\n    const ru = fes(rj, em2(rm));\n    const rv = fes(rs, rt);\n    const rw = fes(ru, rp);\n    const v1 = fes(rv, rw);\n    // v0\n    const t1 = sce(c0, vₓₓₓ);\n    const t2 = sce(d0, vₓₓᵧ);\n    const p4 = fes(t1, t2);\n    const t3 = sce(c0, vₓᵧᵧ);\n    const t4 = sce(d0, vᵧᵧᵧ);\n    const p5 = fes(t3, t4);\n    const p7 = fes(p4, vₓₓ);\n    const p8 = fes(p5, vᵧᵧ);\n    const pc = epr(c0c0, p7);\n    const pd = epr(d0d0, p8);\n    const p6 = fes(pc, pd);\n    const pe = epr(c0d0, vₓᵧ);\n    const p9 = fes(p6, pe);\n    const pf = sce(c0, vₓ);\n    const pg = sce(d0, vᵧ);\n    const pa = fes(pf, pg);\n    const pb = fes(p9, pa);\n    const v0 = fes(pb, v);\n    const r = [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0];\n    return r;\n}\n\n//# sourceMappingURL=get-coeffs-bez3-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBezBez: () => (/* binding */ getCoeffsBezBez)\n/* harmony export */ });\n/* harmony import */ var _double_double_get_coeffs_bez1_bez1_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez1-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez1_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez1-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez1_dd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez1-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez1_bez2_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez2-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez2_dd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez2-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez2_dd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez2-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez1_bez3_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez3-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez3_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez3-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez3_dd_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez3-dd.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js\");\n/* harmony import */ var _exact_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez1-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez2-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez3_bez3_exact_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst coeffFunctionsDd = [\n    [_double_double_get_coeffs_bez1_bez1_dd_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsBez1Bez1Dd, _double_double_get_coeffs_bez1_bez2_dd_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsBez1Bez2Dd, _double_double_get_coeffs_bez1_bez3_dd_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBez1Bez3Dd],\n    [_double_double_get_coeffs_bez2_bez1_dd_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez2Bez1Dd, _double_double_get_coeffs_bez2_bez2_dd_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez2Bez2Dd, _double_double_get_coeffs_bez2_bez3_dd_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez2Bez3Dd],\n    [_double_double_get_coeffs_bez3_bez1_dd_js__WEBPACK_IMPORTED_MODULE_6__.getCoeffsBez3Bez1Dd, _double_double_get_coeffs_bez3_bez2_dd_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez3Bez2Dd, _double_double_get_coeffs_bez3_bez3_dd_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez3Bez3Dd]\n];\nconst coeffFunctionsExact = [\n    [_exact_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez1Bez1Exact, _exact_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_10__.getCoeffsBez1Bez2Exact, _exact_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_11__.getCoeffsBez1Bez3Exact],\n    [_exact_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_12__.getCoeffsBez2Bez1Exact, _exact_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_13__.getCoeffsBez2Bez2Exact, _exact_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_14__.getCoeffsBez2Bez3Exact],\n    [_exact_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_15__.getCoeffsBez3Bez1Exact, _exact_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_16__.getCoeffsBez3Bez2Exact, _exact_get_coeffs_bez3_bez3_exact_js__WEBPACK_IMPORTED_MODULE_17__.getCoeffsBez3Bez3Exact]\n];\n/**\n * Returns an object with properties containing (1) the coefficients (in double-double\n * precision) of a polynomial in 1 variable whose roots are the parameter values\n * (of the second curve) of the intersection points of two given order 1, 2 or 3 bezier curves (i.e. lines,\n * quadratic and cubic bezier curves), (2) the coefficientwise error bound of the polyomial,\n * and (3) a function that returns the *exact* polynomial coefficients as\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions.\n *\n * The returned polynomial coefficients are given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * if there is an infinite number of intersections `undefined` is returned\n * * intermediate calculations are done in double-double precision with\n * fallback to infinite precision (bar underflow / overflow)\n *\n * @param ps1\n * @param ps2\n *\n * @doc mdx\n */\nfunction getCoeffsBezBez(ps1, ps2) {\n    const { coeffs, errBound } = coeffFunctionsDd[ps1.length - 2][ps2.length - 2](ps1, ps2);\n    const getPExact = () => coeffFunctionsExact[ps1.length - 2][ps2.length - 2](ps1, ps2);\n    return { coeffs, errBound, getPExact };\n}\n\n//# sourceMappingURL=get-coeffs-bez-bez.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPFromBox: () => (/* binding */ getPFromBox)\n/* harmony export */ });\n/** @internal */\nfunction getPFromBox(box) {\n    const tl = box[0];\n    const br = box[1];\n    return [\n        (tl[0] + br[0]) / 2,\n        (tl[1] + br[1]) / 2,\n    ];\n}\n\n//# sourceMappingURL=x.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circleBezierIntersection: () => (/* binding */ circleBezierIntersection)\n/* harmony export */ });\n/* harmony import */ var _double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-double/get-coeffs-dd.js */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js\");\n/* harmony import */ var _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./exact/get-coeffs-exact.js */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var _get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-circle-bezier-intersection-error-counters.js */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../bezier-bezier-intersection/x.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n\n\n\n\n\n\n\n/** @internal */\nconst γγ6 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γγ\"])(6);\n/**\n * Returns the intersection between a circle and linear, quadratic or cubic bezier\n * curve.\n *\n * The algorithm employed uses advanced techniques such\n * as floating point error bounding, adaptive multi-precision floating\n * point arithmetic, pre-filtering of easy cases, certified root finding and\n * algebraic implicitization of the curves in order to find *guaranteed* accurate\n * results (see points below)\n *\n * * the bezier curve's parameter `t` values are retuned in objects very\n * similar to the type [[X]]\n * * this algorithm is mathematically guaranteed accurate to within\n * `4 * Number.EPSILON` in the `t` parameter values of the bezier curve\n *\n * @param circle a circle given as the object `{ center: number[], radius: number }`\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction circleBezierIntersection(circle, ps) {\n    let poly;\n    let _polyE;\n    let getCoeffsExact;\n    if (ps.length === 4) {\n        poly = (0,_double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsCubicDd)(circle, ps);\n        _polyE = (0,_get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsCubicErrorCounters)(circle, ps);\n        getCoeffsExact = _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsCubicExact;\n    }\n    else if (ps.length === 3) {\n        poly = (0,_double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsQuadraticDd)(circle, ps);\n        _polyE = (0,_get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsQuadraticErrorCounters)(circle, ps);\n        getCoeffsExact = _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsQuadraticExact;\n    }\n    else if (ps.length === 2) {\n        poly = (0,_double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsLinearDd)(circle, ps);\n        _polyE = (0,_get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsLinearErrorCounters)(circle, ps);\n        getCoeffsExact = _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsLinearExact;\n    }\n    else {\n        throw new Error('The given bezier curve must be of order 1, 2 or 3.');\n    }\n    const polyE = _polyE.map(e => γγ6 * e);\n    const ris = ((0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(poly, 0, 1, polyE, () => getCoeffsExact(circle, ps), true) ||\n        [{ tS: 0.5, tE: 0.5, multiplicity: 1 }]);\n    return ris.map(ri => {\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(ps, [ri.tS, ri.tE]);\n        return { p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__.getPFromBox)(box), box, t: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(ri), ri };\n    });\n}\n\n//# sourceMappingURL=circle-bezier-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsCubicDd: () => (/* binding */ getCoeffsCubicDd),\n/* harmony export */   getCoeffsLinearDd: () => (/* binding */ getCoeffsLinearDd),\n/* harmony export */   getCoeffsQuadraticDd: () => (/* binding */ getCoeffsQuadraticDd)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qmn2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultByNeg2;\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\n/**\n * @param circle a circle\n * @param ps a cubic bezier curve\n *\n * @internal\n */\nfunction getCoeffsCubicDd(circle, ps) {\n    const { radius: r, center: [cx, cy] } = circle;\n    const [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Dd)(ps);\n    // a3*a3 + b3*b3\n    const t6 = qaq(qmq(a3, a3), qmq(b3, b3));\n    // 2*(a2*a3 + b2*b3)\n    const t5 = qm2(qaq(qmq(a2, a3), qmq(b2, b3)));\n    // 2*(a1*a3 + b1*b3) + (a2*a2 + b2*b2)\n    const t4 = qaq(qm2(qaq(qmq(a1, a3), qmq(b1, b3))), qaq(qmq(a2, a2), qmq(b2, b2)));\n    // ((2*a0*a3 + 2*a1*a2) + (2*b0*b3 + 2*b1*b2)) + (-2*a3*cx + -2*b3*cy)\n    const t3 = qaq(qaq(qaq(qmd(2 * a0, a3), qmq(qm2(a1), a2)), qaq(qmd(2 * b0, b3), qmq(qm2(b1), b2))), qaq(qmd(-2 * cx, a3), qmd(-2 * cy, b3)));\n    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)\n    const t2 = qaq(qaq(qaq(qmd(2 * a0, a2), qmd(2 * b0, b2)), qaq(qmq(a1, a1), qmq(b1, b1))), qaq(qmd(-2 * cx, a2), qmd(-2 * cy, b2)));\n    // (2*a0*a1 + 2*b0*b1) - (2*a1*cx + 2*b1*cy)\n    const t1 = qdifq(qaq(qmd(2 * a0, a1), qmd(2 * b0, b1)), qaq(qmd(2 * cx, a1), qmd(2 * cy, b1)));\n    // - 2*(a0*cx + b0*cy) + (((a0**2 + b0**2) + (cx**2 + cy**2)) - r**2)\n    const t0 = qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), // -2*(a0*cx + b0*cy)\n    qdifq(qaq(qaq(tp(a0, a0), tp(b0, b0)), // a0**2 + b0**2\n    qaq(tp(cx, cx), tp(cy, cy)) // cx**2 + cy**2\n    ), tp(r, r) // r**2\n    ));\n    return [t6, t5, t4, t3, t2, t1, t0];\n}\n/**\n * @param circle a circle\n * @param ps a quadratic bezier curve\n *\n * @internal\n */\nfunction getCoeffsQuadraticDd(circle, ps) {\n    const { radius: r, center: [cx, cy] } = circle;\n    const [[a2, a1, [, a0]], [b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Dd)(ps);\n    // a2*a2 + b2*b2\n    const t4 = qaq(qmq(a2, a2), qmq(b2, b2));\n    // 2*a1*a2 + 2*b1*b2 \n    const t3 = qaq(qmq(qm2(a1), a2), qmq(qm2(b1), b2));\n    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)\n    const t2 = qaq(qaq(qaq(qmd(2 * a0, a2), qmd(2 * b0, b2)), qaq(qmq(a1, a1), qmq(b1, b1))), qaq(qmd(-2 * cx, a2), qmd(-2 * cy, b2)));\n    // (2*a0*a1 + 2*b0*b1) + (-2*a1*cx + -2*b1*cy)\n    const t1 = qaq(qaq(qmd(2 * a0, a1), qmd(2 * b0, b1)), qaq(qmd(-2 * cx, a1), qmd(-2 * cy, b1)));\n    // ((a0*a0 + b0*b0) + (-2*a0*cx + -2*b0*cy)) + ((cx*cx + cy*cy) - r*r)\n    const t0 = qaq(qaq(qaq(tp(a0, a0), tp(b0, b0)), qaq(tp(-2 * a0, cx), tp(-2 * b0, cy))), qdifq(qaq(tp(cx, cx), tp(cy, cy)), tp(r, r)));\n    return [t4, t3, t2, t1, t0];\n}\n/**\n * @param circle a circle\n * @param ps a linear bezier curve\n *\n * @internal\n */\nfunction getCoeffsLinearDd(circle, ps) {\n    const { radius: r, center: [cx, cy] } = circle;\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Dd)(ps);\n    // a1**2 + b1**2\n    const t2 = qaq(qmq(a1, a1), qmq(b1, b1));\n    // 2*((a0*a1 + b0*b1) - (a1*cx + b1*cy))\n    const t1 = qm2(qdifq(qaq(qmd(a0, a1), qmd(b0, b1)), qaq(qmd(cx, a1), qmd(cy, b1))));\n    // ((-2*a0*cx + -2*b0*cy) + (a0*a0 + b0*b0)) + ((cx*cx + cy*cy) - r*r)\n    const t0 = qaq(qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), qaq(tp(a0, a0), tp(b0, b0))), qdifq(qaq(tp(cx, cx), tp(cy, cy)), tp(r, r)));\n    return [t2, t1, t0];\n}\n\n//# sourceMappingURL=get-coeffs-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsCubicExact: () => (/* binding */ getCoeffsCubicExact),\n/* harmony export */   getCoeffsLinearExact: () => (/* binding */ getCoeffsLinearExact),\n/* harmony export */   getCoeffsQuadraticExact: () => (/* binding */ getCoeffsQuadraticExact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-calculate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst calc = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eCalculate;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion;\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of a circle\n * and a cubic bezier curve.\n *\n * The returned polynomial degree will be 6\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n *\n * @param circle a circle\n * @param ps a cubic bezier curve\n *\n * @internal\n */\nfunction getCoeffsCubicExact(circle, ps) {\n    const { radius: r, center: c } = circle;\n    const [cx, cy] = c;\n    //const [[a3,a2,a1,x0], [b3,b2,b1,y0]] = toPowerBasis3Exact(ps);\n    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3Exact)(ps);\n    //const a0 = [x0];\n    //const b0 = [y0];\n    // (a3**2 + b3**2)*t**6 + \n    const t6 = calc([\n        [a3, a3],\n        [b3, b3]\n    ]);\n    // (2*a2*a3 + 2*b2*b3)*t**5 + \n    const t5 = sce(calc([\n        [a2, a3],\n        [b2, b3]\n    ]), 2);\n    // (2*a1*a3 + a2**2 + 2*b1*b3 + b2**2)*t**4 + \n    const t4 = calc([\n        [[2], a1, a3], [a2, a2], [[2], b1, b3], [b2, b2]\n    ]);\n    // (2*a0*a3 + 2*a1*a2 - 2*a3*cx + 2*b0*b3 + 2*b1*b2 - 2*b3*cy)*t**3 + \n    const t3 = sce(calc([\n        [a0, a3], [a1, a2], [[-1], a3, [cx]], [b0, b3], [b1, b2], [[-1], b3, [cy]]\n    ]), 2);\n    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + \n    const t2 = calc([\n        [[2], a0, a2], [a1, a1], [[-2], a2, [cx]], [[2], b0, b2], [b1, b1], [[-2], b2, [cy]]\n    ]);\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \n    const t1 = sce(calc([\n        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]\n    ]), 2);\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\n    const t0 = calc([\n        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],\n        [tp(cx, cx)], [tp(cy, cy)], [tp(-r, r)]\n    ]);\n    return [t6, t5, t4, t3, t2, t1, t0];\n}\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of a circle\n * and a quadratic bezier curve.\n *\n * The returned polynomial degree will be 4\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * **precondition:** none\n * * the returned polynomial coefficients are exact (i.e. error-free)\n *\n * @param circle a circle\n * @param ps a quadratic bezier curve\n */\nfunction getCoeffsQuadraticExact(circle, ps) {\n    const { radius: r, center: c } = circle;\n    const [cx, cy] = c;\n    const [[a2, a1, a0], [b2, b1, b0]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2Exact)(ps);\n    //const a0 = [x0];\n    //const b0 = [y0];\n    // (a2**2 + b2**2)*t**4 + \n    const t4 = calc([\n        [a2, a2],\n        [b2, b2]\n    ]);\n    // (2*a1*a2 + 2*b1*b2)*t**3 + \n    const t3 = sce(calc([\n        [a1, a2],\n        [b1, b2]\n    ]), 2);\n    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + \n    const t2 = calc([\n        [[2], a0, a2], [a1, a1], [[-2], a2, [cx]], [[2], b0, b2], [b1, b1], [[-2], b2, [cy]]\n    ]);\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \n    const t1 = sce(calc([\n        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]\n    ]), 2);\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\n    const t0 = calc([\n        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],\n        [tp(cx, cx)], [tp(cy, cy)], [tp(-r, r)]\n    ]);\n    return [t4, t3, t2, t1, t0];\n}\n/**\n * Returns an error-free polynomial in 1 variable\n * whose roots are the parameter values of the intersection points of a circle\n * and a linear bezier curve (i.e. a line).\n *\n * The returned polynomial degree will be 2\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * **precondition:** none\n * * the returned polynomial coefficients are exact (i.e. error-free)\n *\n * @param circle a circle\n * @param ps a linear bezier curve\n */\nfunction getCoeffsLinearExact(circle, ps) {\n    const { radius: r, center: c } = circle;\n    const [cx, cy] = c;\n    const [[a1, a0], [b1, b0]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1Exact)(ps);\n    //const a0 = [x0];\n    //const b0 = [y0];\n    // (a1**2 + b1**2)*t**2 +\n    const t2 = calc([\n        [a1, a1],\n        [b1, b1]\n    ]);\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \n    const t1 = sce(calc([\n        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]\n    ]), 2);\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\n    const t0 = calc([\n        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],\n        [tp(cx, cx)], [tp(cy, cy)], [tp(-r, r)]\n    ]);\n    return [t2, t1, t0];\n}\n\n//# sourceMappingURL=get-coeffs-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsCubicErrorCounters: () => (/* binding */ getCoeffsCubicErrorCounters),\n/* harmony export */   getCoeffsLinearErrorCounters: () => (/* binding */ getCoeffsLinearErrorCounters),\n/* harmony export */   getCoeffsQuadraticErrorCounters: () => (/* binding */ getCoeffsQuadraticErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n\nconst abs = Math.abs;\n/**\n * @param circle a circle\n * @param ps a cubic bezier curve\n *\n * ```\n * // (1 x γ) the error counters for double precision!\n * // (6 x γγ) the error counters for double-double precision!\n * return [\n *      t6_,  // <8>\n *      t5_,  // <8>\n *      t4_,  // <9>\n *      t3_,  // <9>\n *      t2_,  // <8>\n *      t1_,  // <5>\n *      t0_   // <5>\n * ];\n * ```\n *\n * @internal\n */\nfunction getCoeffsCubicErrorCounters(circle, ps) {\n    const { radius: r, center: [cx, cy] } = circle;\n    const [[a3_, a2_, a1_, /*0*/], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))\n    [b3_, b2_, b1_, /*0*/] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3ErrorCounters)(ps);\n    const p0 = ps[0];\n    const a0_ = abs(p0[0]);\n    const b0_ = abs(p0[1]);\n    const cx_ = abs(cx);\n    const cy_ = abs(cy);\n    // a3*a3 + b3*b3\n    // <8> <-- <8>(<7>(<3>a3*<3>a3) + <7>(<3>b3*<3>b3))\n    const t6_ = a3_ * a3_ + b3_ * b3_;\n    // 2*a2*a3 + 2*b2*b3\n    // <8> <-- 2*a2*a3 + 2*b2*b3\n    const t5_ = 2 * (a2_ * a3_ + b2_ * b3_);\n    // (2*a1*a3 + 2*b1*b3) + (a2*a2 + b2*b2)\n    // <9> <-- <9>(<7>(2*(<6>a1*a3 + <6>b1*b3)) + <8>(<7>a2*a2 + <7>b2*b2))\n    const t4_ = 2 * (a1_ * a3_ + b1_ * b3_) + (a2_ * a2_ + b2_ * b2_);\n    // ((2*a0*a3 + 2*a1*a2) + (2*b0*b3 + 2*b1*b2)) + (-2*a3*cx + -2*b3*cy)\n    // 2*(((a0*a3 + a1*a2) + (b0*b3 + b1*b2)) + (a3*cx + b3*cy))\n    // <9> <-- 2*<9>(<8>(<7>(<4>a0*a3 + <6>a1*a2) + <7>(<4>b0*b3 + <6>b1*b2)) + <5>(<4>(a3*cx) + <4>(b3*cy)))\n    const t3_ = 2 * (((a0_ * a3_ + a1_ * a2_) + (b0_ * b3_ + b1_ * b2_)) + (a3_ * cx_ + b3_ * cy_));\n    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)\n    // (2*(a0*a2 + b0*b2) + (a1*a1 + b1*b1)) + -2*(a2*cx + b2*cy)\n    // <8> <-- <8>(<7>(2*<5>(<4>(a0*a2) + <4>(b0*b2)) + <6>(<5>(a1*a1) + <5>(b1*b1))) + <5>(-2*(<4>(a2*cx) + <4>(b2*cy))))\n    const t2_ = (2 * (a0_ * a2_ + b0_ * b2_) + (a1_ * a1_ + b1_ * b1_)) + 2 * (a2_ * cx_ + b2_ * cy_);\n    // (2*a0*a1 + 2*b0*b1) - (2*a1*cx + 2*b1*cy)\n    // 2*(a0*a1 + b0*b1) - 2*(a1*cx + b1*cy);\n    // <5> <-- <5>(<4>(2*(<3>(a0*a1) + <3>b0*b1)) - <4>(2*(<3>(a1*cx) + <3>(b1*cy))));\n    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));\n    // - 2*(a0*cx + b0*cy) + (((a0**2 + b0**2) + (cx**2 + cy**2)) - r**2)\n    // <5> <--  <5>(<2>(-2*(<1>(a0*cx) + <1>(b0*cy))) + <4>(<3>(<2>(<1>(a0**2) + <1>(b0**2)) + <2>(<1>(cx**2) + <1>(cy**2))) - <1>(r**2)));\n    const t0_ = 2 * (a0_ * cx_ + b0_ * cy_) + (((a0_ * a0_ + b0_ * b0_) + (cx_ * cx_ + cy_ * cy_)) + r * r);\n    return [\n        t6_,\n        t5_,\n        t4_,\n        t3_,\n        t2_,\n        t1_,\n        t0_ // <5>\n    ];\n}\n/**\n * @param circle a circle\n * @param ps a quadratic bezier curve\n *\n * @internal\n *\n * ```\n * return [\n *      t4_,  // <6>\n *      t3_,  // <5>\n *      t2_,  // <6>\n *      t1_,  // <4>\n *      t0_   // <4>\n * ];\n * ```\n */\nfunction getCoeffsQuadraticErrorCounters(circle, ps) {\n    const { radius: r, center: [cx, cy] } = circle;\n    const [[a2_, a1_, /*0*/], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))\n    [b2_, b1_, /*0*/] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2ErrorCounters)(ps);\n    const p0 = ps[0];\n    const a0_ = abs(p0[0]);\n    const b0_ = abs(p0[1]);\n    const cx_ = abs(cx);\n    const cy_ = abs(cy);\n    // <6> <-- <6>(<5>(a2*a2) + <5>(b2*b2))\n    const t4_ = a2_ * a2_ + b2_ * b2_;\n    // 2*a1*a2 + 2*b1*b2\n    // <5> <-- <5>(2*(<4>(a1*a2) + <4>(b1*b2)))\n    const t3_ = 2 * (a1_ * a2_ + b1_ * b2_);\n    // <6> <-- <6>(<5>(2*<4>(<3<(a0*a2) + <3<(b0*b2)) + <4>(<3<(a1*a1) + <3<(b1*b1))) + -2*<4>(<3>(a2*cx) + <3>(b2*cy)))\n    const t2_ = (2 * (a0_ * a2_ + b0_ * b2_) + (a1_ * a1_ + b1_ * b1_)) + 2 * (a2_ * cx_ + b2_ * cy_);\n    // <4> <-- <4>(2*(<3>(<2>(a0*a1) + <2>(b0*b1))) + -2*<3>(<2>(a1*cx) + <2>(b1*cy)))\n    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));\n    // (a0*a0 + b0*b0) + (-2*a0*cx + -2*b0*cy) + (cx*cx + cy*cy) - r*r\n    // <4> <-- <4>(<3>(<2>(<1>(a0*a0) + <1>(b0*b0)) + <2>(-2*(<1>(a0*cx) + <1>(b0*cy)))) + <3>(<2>(<1>(cx*cx) + <1>(cy*cy)) - <1>(r*r)))\n    const t0_ = ((a0_ * a0_ + b0_ * b0_) + 2 * (a0_ * cx_ + b0_ * cy_)) + ((cx_ * cx_ + cy_ * cy_) + r * r);\n    return [t4_, t3_, t2_, t1_, t0_];\n}\n/**\n * @param circle a circle\n * @param ps a linear bezier curve\n *\n * @internal\n *\n * ```\n * return [\n *      t2_,  // <4>\n *      t1_,  // <4>\n *      t0_   // <4>\n * ];\n * ```\n */\nfunction getCoeffsLinearErrorCounters(circle, ps) {\n    const { radius: r, center: [cx, cy] } = circle;\n    const [[a1_, /*0*/], // <1>a1_, <0>a0_  (a0_ is just abs(a0))\n    [b1_, /*0*/] // <1>b1_, <0>b0_  (b0_ is just abs(b0))\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1ErrorCounters)(ps);\n    const p0 = ps[0];\n    const a0_ = abs(p0[0]);\n    const b0_ = abs(p0[1]);\n    const cx_ = abs(cx);\n    const cy_ = abs(cy);\n    // <4> <-- <4>(<3>(a1*a1) + <3>(b1*b1))\n    const t2_ = a1_ * a1_ + b1_ * b1_;\n    // <4> <-- <4>(2*(<3>(<2>(a0*a1) + <2>(b0*b1)) - <3>(<2>(a1*cx) + <2>(b1*cy))))\n    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));\n    // <4> <-- <4>(<3>(-2*<2>(<1>(a0*cx) + <1>(b0*cy)) + <2>(a0*a0 + b0*b0)) + <3>(<2>(cx*cx + cy*cy) - <1>(r*r)))\n    const t0_ = (2 * (a0_ * cx_ + b0_ * cy_) + (a0_ * a0_ + b0_ * b0_)) + ((cx_ * cx_ + cy_ * cy_) + r * r);\n    return [t2_, t1_, t0_];\n}\n\n//# sourceMappingURL=get-circle-bezier-intersection-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bAbs: () => (/* binding */ bAbs)\n/* harmony export */ });\n/** @internal */\nfunction bAbs(n) {\n    return n < 0n ? -n : n;\n}\n\n//# sourceMappingURL=b-abs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bCbrt: () => (/* binding */ bCbrt)\n/* harmony export */ });\n/* harmony import */ var _b_abs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-abs.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js\");\n/* harmony import */ var _b_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-sign.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js\");\n\n\nconst { round, cbrt } = Math;\n/**\n * Returns the cube root of a bigint.\n *\n * * see https://stackoverflow.com/a/53684036/2010061\n *\n * * **precondition**: the given bigint must be a perfect cube\n *\n * @internal\n */\nfunction bCbrt(n) {\n    const sgn = (0,_b_sign_js__WEBPACK_IMPORTED_MODULE_0__.bSign)(n);\n    n = (0,_b_abs_js__WEBPACK_IMPORTED_MODULE_1__.bAbs)(n);\n    if (n <= 1n) {\n        return sgn * n;\n    }\n    let x0 = BigInt(round(cbrt(Number(n))));\n    while (true) {\n        const x1 = (2n * x0 + n / (x0 * x0)) / 3n;\n        if (x1 === x0) {\n            return sgn * x0;\n        }\n        x0 = x1;\n    }\n}\n\n//# sourceMappingURL=b-cbrt.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bSign: () => (/* binding */ bSign)\n/* harmony export */ });\n/** @internal */\nfunction bSign(v) {\n    return v > 0n ? 1n : v < 0n ? -1n : 0n;\n}\n\n//# sourceMappingURL=b-sign.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bSqrt: () => (/* binding */ bSqrt)\n/* harmony export */ });\nconst { round, sqrt } = Math;\n/**\n * Returns the square root of a bigint.\n *\n * * see https://stackoverflow.com/a/53684036/2010061\n *\n * * **precondition**: the given bigint must be a perfect square\n *\n * @internal\n */\nfunction bSqrt(v) {\n    if (v <= 1n) {\n        if (v < 0n) {\n            throw new Error('square root of negative numbers are not allowed');\n        }\n        return v;\n    }\n    let x0 = BigInt(round(sqrt(Number(v))));\n    while (true) {\n        const x1 = (x0 + v / x0) >> 1n;\n        if (x1 === x0) {\n            return x0;\n        }\n        x0 = x1;\n    }\n}\n\n//# sourceMappingURL=b-sqrt.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bigintToExpansion: () => (/* binding */ bigintToExpansion)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\nconst maxSafe = BigInt(2 ** 53);\n/**\n * Returns the [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansion of the given bigint.\n *\n * * it is assumed that the given bigint doesn't cause floating point overflow\n *\n * @internal\n */\nfunction bigintToExpansion(b) {\n    if (b === 0n) {\n        return [0];\n    }\n    const e = [];\n    let i = 0;\n    let q = b;\n    while (q !== 0n) {\n        q = b / maxSafe;\n        const r = b % maxSafe;\n        e.push(Number(r) * 2 ** (i * 53));\n        b = q;\n        i++;\n    }\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompress)(e);\n}\n\n//# sourceMappingURL=bigint-to-expansion.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcExactCubeRoot: () => (/* binding */ calcExactCubeRoot)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js\");\n/* harmony import */ var _bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bigint-to-expansion.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js\");\n/* harmony import */ var _b_cbrt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./b-cbrt.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js\");\n/* harmony import */ var _sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sum-bigints.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js\");\n\n\n\n\n/**\n * * **precondition**: the given value must be a perfect cube\n *\n * @param a the rational value for which the square root is sought given as\n * `[N,D]` to represent the value `N/D` where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n * expansions\n *\n * @internal\n */\nfunction calcExactCubeRoot(a) {\n    const [NN, DD] = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.scaleFloatssToBigintss)(a).map(_sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__.sumBigints);\n    const gcd = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.bGcdInt)(NN, DD);\n    // the *exact* positive root `c` is given as the rational number `N/D` \n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n    const N = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_cbrt_js__WEBPACK_IMPORTED_MODULE_4__.bCbrt)(NN / gcd));\n    const D = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_cbrt_js__WEBPACK_IMPORTED_MODULE_4__.bCbrt)(DD / gcd));\n    return [N, D];\n}\n\n//# sourceMappingURL=calc-exact-cube-root.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcExactSquareRoot: () => (/* binding */ calcExactSquareRoot)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js\");\n/* harmony import */ var _bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bigint-to-expansion.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js\");\n/* harmony import */ var _b_sqrt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./b-sqrt.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js\");\n/* harmony import */ var _b_abs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./b-abs.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js\");\n/* harmony import */ var _sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sum-bigints.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js\");\n\n\n\n\n\n/**\n * * **precondition**: the given value must be a perfect square\n *\n * @param a the rational value for which the square root is sought given as\n * `[N,D]` to represent the value `N/D` where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n * expansions\n *\n * @internal\n */\nfunction calcExactSquareRoot(a) {\n    const [NN, DD] = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.scaleFloatssToBigintss)(a).map(_sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__.sumBigints);\n    const gcd = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.bGcdInt)(NN, DD);\n    // the *exact* positive root `c` is given as the rational number `N/D` \n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n    const N = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_sqrt_js__WEBPACK_IMPORTED_MODULE_4__.bSqrt)((0,_b_abs_js__WEBPACK_IMPORTED_MODULE_5__.bAbs)(NN / gcd)));\n    const D = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_sqrt_js__WEBPACK_IMPORTED_MODULE_4__.bSqrt)((0,_b_abs_js__WEBPACK_IMPORTED_MODULE_5__.bAbs)(DD / gcd)));\n    return [N, D];\n}\n\n//# sourceMappingURL=calc-exact-square-root.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureRange: () => (/* binding */ ensureRange)\n/* harmony export */ });\nconst eps = Number.EPSILON;\nconst u = eps / 2;\n/**\n * @param t\n * @param min1Sign\n *\n * @internal\n */\nfunction ensureRange(t, min1Sign) {\n    return (min1Sign < 0\n        ? (t < 1 ? t : 1 - u)\n        : min1Sign === 0\n            ? 1\n            : (t > 1 ? t : 1 + eps));\n}\n\n//# sourceMappingURL=ensure-range.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erCompare: () => (/* binding */ erCompare)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\n/**\n * Compares two expansion rationals.\n *\n * @internal\n */\nfunction erCompare(a, b) {\n    return ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult)(a[0], b[1]), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult)(a[1], b[0])) *\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(a[1]) *\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(b[1]));\n}\n\n//# sourceMappingURL=er-compare.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erEstimate: () => (/* binding */ erEstimate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-div.js\");\n\n/**\n * Estimates the result of the given expansion rational.\n *\n * * the sign of the returned result is guaranteed to be correct\n * * the result is guaranteed accurate to within 2 ulps\n *\n * @param a\n *\n * @internal\n */\nfunction erEstimate(a) {\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiv)(a[0], a[1], 2));\n}\n\n//# sourceMappingURL=er-estimate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erSign: () => (/* binding */ erSign)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\n/**\n * Returns the sign of the given expansion rational.\n *\n * @param a\n *\n * @internal\n */\nfunction erSign(a) {\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[1]);\n}\n\n//# sourceMappingURL=er-sign.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB: () => (/* binding */ getAB)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _ensure_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ensure-range.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js\");\n/* harmony import */ var _er_estimate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./er-estimate.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js\");\n/* harmony import */ var _er_sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./er-sign.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js\");\n\n\n\n\n/** @internal */\nfunction getAB(getTransform) {\n    return (psA, psB) => {\n        const xyA = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA);\n        const xyB = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psB);\n        const xyAR = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA.slice().reverse());\n        const xyBR = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psB.slice().reverse());\n        const d = getTransform(xyA, xyB);\n        const d_AR = getTransform(xyAR, xyB);\n        const d_BR = getTransform(xyA, xyBR);\n        const d_ARBR = getTransform(xyAR, xyBR);\n        // Get the *certified* sign of `tA_B0 - 1`.\n        const sgn_tA_B0_min1 = -(0,_er_sign_js__WEBPACK_IMPORTED_MODULE_1__.erSign)(d_AR);\n        const sgn_tA_B1_min1 = -(0,_er_sign_js__WEBPACK_IMPORTED_MODULE_1__.erSign)(d_ARBR);\n        const _tA_B0 = (0,_er_estimate_js__WEBPACK_IMPORTED_MODULE_2__.erEstimate)(d);\n        const _tA_B1 = (0,_er_estimate_js__WEBPACK_IMPORTED_MODULE_2__.erEstimate)(d_BR);\n        const tA_B0 = (0,_ensure_range_js__WEBPACK_IMPORTED_MODULE_3__.ensureRange)(_tA_B0, sgn_tA_B0_min1);\n        const tA_B1 = (0,_ensure_range_js__WEBPACK_IMPORTED_MODULE_3__.ensureRange)(_tA_B1, sgn_tA_B1_min1);\n        return [tA_B0, tA_B1];\n    };\n}\n\n//# sourceMappingURL=get-ab.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB1: () => (/* binding */ getAB1)\n/* harmony export */ });\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-ab.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js\");\n/* harmony import */ var _get_transform_1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-1.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js\");\n\n\n/** @internal */\nconst getAB1 = (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_0__.getAB)(_get_transform_1_js__WEBPACK_IMPORTED_MODULE_1__.getTransform1);\n\n//# sourceMappingURL=get-ab1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB2: () => (/* binding */ getAB2)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_transform_2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-transform-2.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _get_ab1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-ab1.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js\");\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-ab.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js\");\n\n\n\n\n\n/** @internal */\nfunction getAB2(psA, psB) {\n    const _xyA = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA);\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can't be zero else we would have had\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign)(_xyA[0][0]) === 0 ? 0 : (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign)(_xyA[1][0]) === 0 ? 1 : -1;\n    if (coord !== -1) {\n        const psA0c = psA[0][coord];\n        const psA2c = psA[2][coord];\n        const psB0c = psB[0][coord];\n        const psB2c = psB[2][coord];\n        return (0,_get_ab1_js__WEBPACK_IMPORTED_MODULE_2__.getAB1)([[psA0c, psA0c], [psA2c, psA2c]], [[psB0c, psB0c], [psB2c, psB2c]]);\n    }\n    return (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_3__.getAB)(_get_transform_2_js__WEBPACK_IMPORTED_MODULE_4__.getTransform2)(psA, psB);\n}\n\n//# sourceMappingURL=get-ab2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB3: () => (/* binding */ getAB3)\n/* harmony export */ });\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-ab.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js\");\n/* harmony import */ var _get_transform_3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-3.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js\");\n\n\n/** @internal */\nconst getAB3 = (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_0__.getAB)(_get_transform_3_js__WEBPACK_IMPORTED_MODULE_1__.getTransform3);\n\n//# sourceMappingURL=get-ab3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEndpointIntersections: () => (/* binding */ getEndpointIntersections)\n/* harmony export */ });\n/* harmony import */ var _bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../bezier-bezier-intersection/x.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js\");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transformation/reduce-order-if-possible.js */ \"./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js\");\n/* harmony import */ var _get_ab1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-ab1.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js\");\n/* harmony import */ var _get_ab2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-ab2.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js\");\n/* harmony import */ var _get_ab3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-ab3.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../sub-1-ulp.js */ \"./node_modules/flo-bezier3/node/sub-1-ulp.js\");\n/* harmony import */ var _add_1_ulp_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../add-1-ulp.js */ \"./node_modules/flo-bezier3/node/add-1-ulp.js\");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../boxes/intersect-boxes.js */ \"./node_modules/flo-bezier3/node/boxes/intersect-boxes.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Returns the intersection range (given as 2 intersections (`X`s)) where the\n * endpoints of the two given *algebraically identical* curves\n * overlap (provided they overlap, else an empty array is returned).\n *\n * * **precondition:** the two given curves must be *algebraically identical*\n * (i.e. identical except possibly for endpoints)\n *\n * * **precondition**: not all bezier control points collinear\n *\n * @param psA an order 1,2 or 3 bezier curve\n * @param psB another bezier curve\n *\n * @internal but still exported for backwards compatibility\n */\nfunction getEndpointIntersections(psA, psB, orderAlreadyReduced = false) {\n    if (!orderAlreadyReduced) {\n        psA = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__.reduceOrderIfPossible)(psA);\n        psB = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__.reduceOrderIfPossible)(psB);\n    }\n    // `psB.length` should equal `psB.length` (due to precondition)\n    const getABs = [, , _get_ab1_js__WEBPACK_IMPORTED_MODULE_1__.getAB1, _get_ab2_js__WEBPACK_IMPORTED_MODULE_2__.getAB2, _get_ab3_js__WEBPACK_IMPORTED_MODULE_3__.getAB3];\n    const [tA_B0, tA_B1] = getABs[psA.length](psA, psB);\n    const [tB_A0, tB_A1] = getABs[psA.length](psB, psA);\n    //------------------------------------------------\n    // Perform a simple unrolled sweep line algorithm\n    //------------------------------------------------\n    const infos = [\n        { tA: tA_B0, tB: 0, bez: 'B', start: true },\n        { tA: tA_B1, tB: 1, bez: 'B', start: false },\n        { tA: 0, tB: tB_A0, bez: 'A', start: true },\n        { tA: 1, tB: tB_A1, bez: 'A', start: false }\n    ].sort((a, b) => a.tA - b.tA);\n    if (infos[1].tA === infos[2].tA) {\n        const info = infos[1];\n        const tA = info.tA; // `tA` will be either exactly `0` or exactly `1`\n        const tB = info.tB; // `tB` will be either exactly `0` or exactly `1`\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psA, [tA, tA]);\n        return [{\n                p: box[0], kind: 4, box,\n                t1: tA, ri1: { tS: tA, tE: tA, multiplicity: 1 },\n                t2: tB, ri2: { tS: tB, tE: tB, multiplicity: 1 }\n            }];\n    }\n    if (infos[0].bez === infos[1].bez) {\n        return [];\n    }\n    const start = infos[1];\n    const end = infos[2];\n    const [tSAMin, tSAMax] = getMinMaxT(start.tA);\n    const [tSBMin, tSBMax] = getMinMaxT(start.tB);\n    const [tEAMin, tEAMax] = getMinMaxT(end.tA);\n    const [tEBMin, tEBMax] = getMinMaxT(end.tB);\n    const boxSA = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psA, [tSAMin, tSAMax]);\n    const boxSB = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psB, [tSBMin, tSBMax]);\n    const boxEA = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psA, [tEAMin, tEAMax]);\n    const boxEB = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psB, [tEBMin, tEBMax]);\n    const boxS = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__.intersectBoxes)(boxSA, boxSB);\n    const boxE = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__.intersectBoxes)(boxEA, boxEB);\n    const riSA = { tS: tSAMin, tE: tSAMax, multiplicity: 1 };\n    const riSB = { tS: tSBMin, tE: tSBMax, multiplicity: 1 };\n    const riEA = { tS: tEAMin, tE: tEAMax, multiplicity: 1 };\n    const riEB = { tS: tEBMin, tE: tEBMax, multiplicity: 1 };\n    return [\n        {\n            p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__.getPFromBox)(boxS), kind: 5, box: boxS,\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riSA), ri1: riSA,\n            t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riSB), ri2: riSB\n        }, {\n            p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__.getPFromBox)(boxE), kind: 5, box: boxE,\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riEA), ri1: riEA,\n            t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riEB), ri2: riEB\n        }\n    ];\n}\n/** @internal */\nfunction sub2Ulp(v) {\n    return (0,_sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_8__.sub1Ulp)((0,_sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_8__.sub1Ulp)(v));\n}\n/** @internal */\nfunction add2Ulp(v) {\n    return (0,_add_1_ulp_js__WEBPACK_IMPORTED_MODULE_9__.add1Ulp)((0,_add_1_ulp_js__WEBPACK_IMPORTED_MODULE_9__.add1Ulp)(v));\n}\n/** @internal */\nfunction getMinMaxT(t) {\n    if (t === 0 || t === 1) {\n        return [t, t];\n    }\n    const tMin = sub2Ulp(t);\n    const tMax = add2Ulp(t);\n    return [tMin, tMax];\n}\n\n//# sourceMappingURL=get-endpoint-intersections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTransform1: () => (/* binding */ getTransform1)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\n/** @internal */\nfunction getTransform1(_xyA, _xyB) {\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can't be zero else we would have had\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(_xyA[0][0]) === 0 ? 1 : 0;\n    const xyA = _xyA[coord];\n    const xyB = _xyB[coord];\n    return getTransformedTs1(xyA, xyB);\n}\n/**\n * Given two algebraically identical bezier curves (but with possibly different\n * endpoints) return the transformation parameters (the `c` and `d` in\n * `t = cx + d`) for transforming the second curve into the first so that it has\n * exactly the same control points but such that the parameter `t` values run\n * from `t0` to `t1` where `t0` and `t1` can be obtained via `t0 = -d/c`\n * and `t1 = (1 - d)/c` (or in reverse: `t0_ = d` and `t1_ = c + d`).\n *\n * * **precondition**: the given pair of bezier curves must be algebraically\n * identical, e.g. `ps = [[1,1],[2,2],[3,2],[3,-1]]`\n * and `ps_ = [[-1,-21],[-3.25,-29.25],[-6.625,-40.3125],[-11.546875,-55.03125]]`\n *\n * * **precondition**: the given pair of bezier curves are in lowest possible\n * order\n *\n * @internal\n */\nfunction getTransformedTs1(A, B) {\n    const [p1, p0] = A;\n    const [, r0] = B;\n    // The (over-determined) set of equations used to solve `c` and `d`\n    // (1)   r1 = c*p1       => c = r1/p1\n    // (2)   r0 = d*p1 + p0  => d = (r0 - p0)/p1\n    //---------------\n    // Calculate `d`\n    //---------------\n    // (1)   d = (r0 - p0)/p1\n    // the *exact* `d` is given as the rational number `N/D`\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n    return [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff)(r0, p0), p1];\n}\n\n//# sourceMappingURL=get-transform-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTransform2: () => (/* binding */ getTransform2)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var _er_compare_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./er-compare.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js\");\n/* harmony import */ var _calc_exact_square_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc-exact-square-root.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js\");\n\n\n\n/** @internal */\nfunction getTransform2(xyA, xyB) {\n    const [D1x, D2x] = getTransformedTs2(xyA[0], xyB[0]);\n    const [D1y, D2y] = getTransformedTs2(xyA[1], xyB[1]);\n    if ((0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D1x, D1y) === 0 ||\n        (0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D1x, D2y) === 0) {\n        return D1x;\n    }\n    if ((0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D2x, D1y) === 0 ||\n        (0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D2x, D2y) === 0) {\n        return D2x;\n    }\n    throw new Error('An unexpected error occured.');\n}\n/**\n * @param A A coordinate (x or y) of a bezier curve in power basis\n * @param B A coordinate (x or y) of another bezier curve in power basis\n *\n * @internal\n */\nfunction getTransformedTs2(A, B) {\n    const [p2, p1] = A;\n    const [r2, r1] = B;\n    // The (over-determined) set of equations used to solve `c` and `d`\n    // (1)   r2 = cc*p2\n    // (2)   r1 = c*p1 + 2*c*d*p2\n    // (3)   r0 = dd*p2 + d*p1 + p0\n    // Note that since `r2,r1,r0,p2,p1,p0` are rational we must have \n    // (non-trivially) that `c` is rational and thus `d` also rational.\n    //-----------------------------------\n    // Calculate `c` *exactly* using (1)\n    //-----------------------------------\n    // the *exact* positive root `c` is given as the rational number `N/D` \n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\n    const [N, D] = (0,_calc_exact_square_root_js__WEBPACK_IMPORTED_MODULE_1__.calcExactSquareRoot)([r2, p2]);\n    //-----------------------------------\n    // Calculate `d` *exactly* using (2)\n    //-----------------------------------\n    // (2)   r1 = c*p1 + 2*c*d*p2  =>\n    //       r1 = c*(p1 + 2*d*p2)  =>\n    // dA = (r1/c - p1)/(2*p2)\n    //    = r1/(c*2*p2) - c*p1/(c*2*p2)\n    //    = (r1 - c*p1)/(c*2*p2)\n    //    = (r1 - N*p1/D)/(N*2*p2/D)\n    //    = (D*r1 - N*p1)/(N*2*p2)\n    // dB = (r1/(-c) - p1)/(2*p2)\n    //    = r1/(-c*2*p2) - c*p1/(c*2*p2)\n    //    = (-r1 - c*p1)/(c*2*p2)\n    //    = (-r1 - N*p1/D)/(N*2*p2/D)\n    //    = (-r1*D - N*p1)/(N*2*p2)\n    return [\n        [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(r1, D), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(p1, N)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(N, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2)(p2))],\n        [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(r1, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eNegativeOf)(D)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(p1, N)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(N, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2)(p2))]\n    ].sort(_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare);\n}\n\n//# sourceMappingURL=get-transform-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTransform3: () => (/* binding */ getTransform3)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _calc_exact_cube_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc-exact-cube-root.js */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js\");\n\n\n/** @internal */\nfunction getTransform3(xyA, xyB) {\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can't be zero else we would have had\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(xyA[0][0]) === 0 ? 1 : 0;\n    const xyA_ = xyA[coord];\n    const xyB_ = xyB[coord];\n    return getTransformedTs3(xyA_, xyB_);\n}\n/**\n * Given two algebraically identical bezier curves (but with possibly different\n * endpoints) return the transformation parameters (the `c` and `d` in\n * `t = cx + d`) for transforming the second curve into the first so that it has\n * exactly the same control points but such that the parameter `t` values run\n * from `t0` to `t1` where `t0` and `t1` can be obtained via `t0 = -d/c`\n * and `t1 = (1 - d)/c` (or in reverse: `t0_ = d` and `t1_ = c + d`).\n *\n * * **precondition**: the given pair of bezier curves must be algebraically\n * identical, e.g. `ps = [[1,1],[2,2],[3,2],[3,-1]]`\n * and `ps_ = [[-1,-21],[-3.25,-29.25],[-6.625,-40.3125],[-11.546875,-55.03125]]`\n *\n * * **precondition**: the given pair of bezier curves are in lowest possible\n * order\n *\n * @internal\n */\nfunction getTransformedTs3(A, B) {\n    const [p3, p2] = A;\n    const [r3, r2] = B;\n    // The (over-determined) set of equations used to solve `c` and `d`\n    // (1)   r3 = p3*ccc\n    // (2)   r2 = 3*cc*p3*d + cc*p2\n    // (3)   r1 = 3*c*p3*dd + 2*c*p2*d + c*p1\n    // (4)   r0 = p3*ddd + p2*dd + p1*d + p0\n    //-------------------------\n    // Calculate `c` *exactly*\n    //-------------------------\n    const C = (0,_calc_exact_cube_root_js__WEBPACK_IMPORTED_MODULE_1__.calcExactCubeRoot)([r3, p3]);\n    //-------------------------\n    // Calculate `d` *exactly*\n    //-------------------------\n    // (2)   3*cc*p3*d + cc*p2 = r2\n    //  =>   d = (r2/cc - p2)/(3*p3)\n    const NN = eSquare(C[0]);\n    return [\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(r2, eSquare(C[1])), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(p2, NN)),\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.scaleExpansion2)(3, p3), NN)\n    ];\n}\n/** @internal */\nfunction eSquare(v) {\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(v, v);\n}\n\n//# sourceMappingURL=get-transform-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sumBigints: () => (/* binding */ sumBigints)\n/* harmony export */ });\n/** @internal */\nfunction sumBigints(vs) {\n    let total = 0n;\n    for (let i = 0; i < vs.length; i++) {\n        total += vs[i];\n    }\n    return total;\n}\n\n//# sourceMappingURL=sum-bigints.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierSelfIntersection: () => (/* binding */ bezierSelfIntersection)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-abs.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coefficients/double/get-coeffs-bez3-with-running-error.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js\");\n/* harmony import */ var _get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coefficients/exact/get-coeffs-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\n\n\n\n\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\nconst td = double_double__WEBPACK_IMPORTED_MODULE_3__.twoDiff;\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_3__.twoSum;\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_3__.ddNegativeOf;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\nconst qdivq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddDivDd;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.growExpansion;\nconst eps = Number.EPSILON;\nconst eps2 = 2 * eps;\nconst abs = Math.abs;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γ\"])(1);\n/**\n * Returns the unique self-intersection parameter `t` values of the given\n * bezier curve if they exist, else return `[]` (see also the `inRange`\n * parameter below).\n *\n * * only cubic (or higher order) bezier curves can have unique self-intersections\n * * this algorithm is mathematically guaranteed accurate to within an absolute\n * error of `4 * Number.EPSILON` for the returned `t` values satisfying `|t| <= 1`\n * or a relative error of the same `4 * Number.EPSILON` otherwise.\n * * **special case:** a cusp is considered a degenerate self-intersection and\n * the (duplicate) `t` values will be returned\n *\n * @param ps a bezier curve given as an array of its control points\n * @param inRange if `inRange === true` (the default) then return the two `t`\n * parameter values only if both are in [0,1] else return `[]`.\n * If `inRange === false` then return the (0,1 or 2) `t` values in `[0,1]` even\n * if only one is in that range.\n *\n * @doc mdx\n */\nfunction bezierSelfIntersection(ps, inRange = true) {\n    if (ps.length < 4) {\n        // lines and quadratics don't have uniqure self-intersections.\n        return [];\n    }\n    // First get fast naively calculated coefficients\n    const { coeffs: [a, b, c], errBound: [a_, b_, c_] } = (0,_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez3WithRunningError)(ps);\n    // if error in `a` cannot discern it from zero\n    if (abs(a) <= a_) {\n        // it is rare to get here \n        // check for sure if a === 0 exactly\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        //const a3 = (x3 - x0) + 3*(x1 - x2);\n        //const a2 = (x2 + x0) - 2*x1;\n        //const b3 = (y3 - y0) + 3*(y1 - y2);\n        //const b2 = (y2 + y0) - 2*y1;\n        const a3 = fes(td(x3, x0), sce(3, (td(x1, x2))));\n        const a2 = ge(ts(x2, x0), -2 * x1);\n        const b3 = fes(td(y3, y0), sce(3, (td(y1, y2))));\n        const b2 = ge(ts(y2, y0), -2 * y1);\n        const a2b3 = epr(a2, b3);\n        const a3b2 = epr(a3, b2);\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.eCompare)(a2b3, a3b2) === 0) {\n            // a === 0 => no roots possible! (also b === 0 always if a === 0)\n            // This type of curve is usually shaped like an S where both \n            // extreme curvatures are identical...\n            // ...this is an explicit cubic curve!\n            return [];\n        }\n    }\n    // `Discr` = discriminant = b^2 - 4ac\n    // calculate `Discr` and its absolute error Discr_\n    const bb = b * b;\n    const bb_ = 2 * b_ * abs(b) + γ1 * bb; // the error in b**2\n    const ac4 = 4 * a * c;\n    const ac4_ = 4 * (a_ * abs(c) + abs(a) * c_) + γ1 * abs(ac4);\n    const Discr = bb - ac4;\n    const Discr_ = bb_ + ac4_ + γ1 * abs(Discr);\n    // if the discriminant is smaller than negative the error bound then\n    // certainly there are no roots, i.e. no cusp and no self-intersections\n    if (Discr < -Discr_) {\n        // discriminant is definitely negative\n        return [];\n    }\n    // if the discriminant is definitely positive\n    if (Discr > Discr_) {\n        // calculate roots naively as a fast pre-filter\n        const { est: D, err: D_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.sqrtWithErr)(Discr, Discr_);\n        let q1;\n        if (b >= 0) {\n            // const r1 = (-b - D) / 2*a;\n            // const r2 = (2*c) / (-b - D);\n            q1 = -b - D;\n        }\n        else {\n            // const r2 = (-b + D) / 2*a;\n            // const r1 = (2*c) / (-b + D);\n            q1 = -b + D;\n        }\n        const q1_ = b_ + D_ + γ1 * abs(q1);\n        const { est: r1, err: r1_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.divWithErr)(q1, 2 * a, q1_, 2 * a_);\n        const { est: r2, err: r2_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.divWithErr)(2 * c, q1, 2 * c_, q1_);\n        // the actual 'filter' follows\n        if (inRange) {\n            // IF at least one root is not in [0,1]\n            // THEN no self-intersection (in [0,1])\n            if (r1 + r1_ < 0 || r1 - r1_ > 1 ||\n                r2 + r2_ < 0 || r2 - r2_ > 1) {\n                return [];\n            }\n        }\n        else {\n            // IF both roots not in [0,1] \n            // THEN no self-intersection (in [0,1])\n            if ((r1 + r1_ < 0 || r1 - r1_ > 1) &&\n                (r2 + r2_ < 0 || r2 - r2_ > 1)) {\n                return [];\n            }\n        }\n    }\n    // we need to check exactly - (a !== 0) at this point - tested for earlier\n    let [A, B, C] = (0,_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Exact)(ps);\n    // exact - Discr = b^2 - 4ac\n    const eDiscr = edif(epr(B, B), sce(4, epr(A, C)));\n    const sgnDiscr = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(eDiscr);\n    if (sgnDiscr < 0) {\n        // sgn < 0 => no real roots => no cusp or double point for t in [0,1]\n        return [];\n    }\n    if (sgnDiscr > 0) {\n        const D = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.ddSqrt)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(eDiscr));\n        A = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(A);\n        B = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(B);\n        C = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(C);\n        let nBD;\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(B) >= 0) {\n            nBD = qno(qaq(B, D));\n            //t1 = (-B - D) / (2*A);\n            //t2 = (2*C) / (-B - D);\n        }\n        else {\n            nBD = qaq(qno(B), D);\n            //t1 = (2*C) / (-B + D);\n            //t2 = (-B + D) / (2*A);\n        }\n        let t1 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_12__.eEstimate)(qdivq(nBD, qm2(A))); // max 1 ulps out\n        let t2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_12__.eEstimate)(qdivq(qm2(C), nBD)); // max 1 ulps out\n        if (inRange) {\n            // if any root is outside the range => no double point for t in [0,1]\n            if (t1 < -eps2 || t1 > 1 + eps2 ||\n                t2 < -eps2 || t2 > 1 + eps2) {\n                return [];\n            }\n        }\n        else {\n            // if both roots are outside the range => no double point for t in [0,1]\n            if ((t1 < -eps2 || t1 > 1 + eps2) &&\n                (t2 < -eps2 || t2 > 1 + eps2)) {\n                return [];\n            }\n        }\n        // coerce to 0/1\n        //t1 = (t1 >= -eps4 && t1 < 0)\n        //    ? 0\n        //    : (t1 > 1 && t1 <= 1 + eps4) ? 1 : t1;\n        //t2 = (t2 >= -eps4 && t2 < 0)\n        //    ? 0\n        //    : (t2 > 1 && t2 <= 1 + eps4) ? 1 : t2;\n        [t1, t2] = t1 < t2 ? [t1, t2] : [t2, t1];\n        return t1 >= 0 - eps2 && t1 <= 1 + eps2\n            ? t2 >= 0 - eps2 && t2 <= 1 + eps2\n                ? [t1, t2]\n                : [t1]\n            : t2 >= 0 - eps2 && t2 <= 1 + eps2\n                ? [t2]\n                : [];\n    }\n    // sign === 0 => cusp\n    // set t = b/d = b/-2a\n    const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_13__.eMultByNeg2)(A);\n    const sgnB = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(B);\n    const sgnD = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(d);\n    // if result is negative the cusp is outside the bezier endpoints\n    const sgn_ = sgnB * sgnD;\n    if (sgn_ < 0) {\n        return [];\n    }\n    // if result is > 1 the cusp is outside the bezier endpoints\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_14__.eAbs)(B), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_14__.eAbs)(d)) > 0) {\n        return [];\n    }\n    const qB = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(B);\n    const qd = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(d);\n    const qt = qdivq(qB, qd);\n    const t = qt[1] + qt[0];\n    return [t, t];\n}\n\n//# sourceMappingURL=bezier-self-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3WithRunningError: () => (/* binding */ getCoeffsBez3WithRunningError)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js\");\n\n\nconst abs = Math.abs;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γ\"])(1);\n/**\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\n * whose roots are the parameter values of the self-intersection points of the\n * given cubic bezier curve.\n *\n * The returned polynomial coefficients are given densely as an array of double\n * precision floating point numbers from highest to lowest power,\n * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double precision and this is\n * reflected in the error bound\n * * the error bound returned need **not** be scaled before use\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a cubic bezier curve.\n *\n * @internal\n */\nfunction getCoeffsBez3WithRunningError(ps) {\n    const { coeffs: [[a3, a2, a1], [b3, b2, b1]], errorBound: [[a3_, a2_], [b3_, b2_]] } = (0,_to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3WithRunningError)(ps);\n    const _a3 = abs(a3);\n    const _a2 = abs(a2);\n    const _a1 = abs(a1);\n    const _b3 = abs(b3);\n    const _b2 = abs(b2);\n    const _b1 = abs(b1);\n    const a2b3 = a2 * b3;\n    const a3b2 = a3 * b2;\n    const a3b1 = a3 * b1;\n    const a1b3 = a1 * b3;\n    const a2b1 = a2 * b1;\n    const a1b2 = a1 * b2;\n    // Note: a variable prepended with and underscore is an absolute value,\n    // postpended with an underscore denotes an absolute error (before \n    // multiplication by the round-off unit `u`) - both underscores present \n    // means it is both an absolute value and a round-off error.\n    const _a2b3 = abs(a2b3);\n    const _a3b2 = abs(a3b2);\n    const _a3b1 = abs(a3b1);\n    const _a1b3 = abs(a1b3);\n    const _a2b1 = abs(a2b1);\n    const _a1b2 = abs(a1b2);\n    const a2b3_ = a2_ * _b3 + _a2 * b3_ + _a2b3;\n    const a3b2_ = a3_ * _b2 + _a3 * b2_ + _a3b2;\n    const a3b1_ = a3_ * _b1 + _a3b1;\n    const a1b3_ = _a1 * b3_ + _a1b3;\n    const a2b1_ = a2_ * _b1 + _a2b1;\n    const a1b2_ = _a1 * b2_ + _a1b2;\n    const f4 = a2b3 - a3b2;\n    const _f4 = abs(f4);\n    const f4_ = a2b3_ + a3b2_ + _f4;\n    const f5 = a1b3 - a3b1;\n    const _f5 = abs(f5);\n    const f5_ = a1b3_ + a3b1_ + _f5;\n    const f6 = a2b1 - a1b2;\n    const _f6 = abs(f6);\n    const f6_ = a2b1_ + a1b2_ + _f6;\n    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\n    //const u2 = a2b3*(-2*a3b2 + a2b3) + a3b2*a3b2\n    //const u2 = (a2b3 - a3b2)*(a2b3 - a3b2)\n    const u2 = f4 * f4;\n    const u2_ = 2 * f4_ * _f4 + abs(u2);\n    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\n    //const u1 = a1*b3*-a3*b2 + a1*b3*a2*b3 + a3*b1*-a2*b3 + a3*b1*a3*b2\n    //const u1 = a1b3*(a2b3 - a3b2) - a3b1*(a2b3 - a3b2)\n    //const u1 = a1b3*f4 - a3b1*f4 = f4*(a1b3 - a3b1);\n    const u1 = f4 * f5;\n    const u1_ = f4_ * _f5 + _f4 * f5_ + abs(u1);\n    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\n    //const u0 = \n    //       a2b3*(a2b1 - a1b2) - a3b2*(a2b1 - a1b2) +\n    //       a1b3*(-2*a3b1 + a1b3) + a3b1*a3b1;\n    //const u0 = \n    //       f6*f4 + \n    //       (a1b3 - a3b1)*(a1b3 - a3b1);\n    //const u0 = f6*f4 + f5*f5;\n    const g7 = f6 * f4;\n    const g7_ = f6_ * _f4 + _f6 * f4_ + abs(g7);\n    const g9 = f5 * f5;\n    const g9_ = 2 * _f5 * f5_ + abs(g9);\n    const u0 = g7 + g9;\n    const u0_ = g7_ + g9_ + abs(u0);\n    // Solve: u2*t**2 + u1*t + u0 = 0\n    return {\n        coeffs: [u2, u1, u0],\n        errBound: [u2_, u1_, u0_].map(c => γ1 * c)\n    };\n}\n\n//# sourceMappingURL=get-coeffs-bez3-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Exact: () => (/* binding */ getCoeffsBez3Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\n/**\n * Returns an error-free polynomial in 1 variable whose roots are the parameter\n * values of the self-intersection points of the given cubic bezier curve.\n *\n * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * the returned polynomial coefficients are exact (i.e. error-free)\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\n *\n * @param ps a cubic bezier curve.\n *\n * @internal\n */\nfunction getCoeffsBez3Exact(ps) {\n    const [[a3, a2, a1], [b3, b2, b1]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3Exact)(ps);\n    const a2b3 = epr(a2, b3);\n    const a3b2 = epr(a3, b2);\n    const a3b1 = epr(a3, b1);\n    const a1b3 = epr(a1, b3);\n    const a2b1 = epr(a2, b1);\n    const a1b2 = epr(a1, b2);\n    const f4 = ediff(a2b3, a3b2);\n    const f5 = ediff(a1b3, a3b1);\n    const f6 = ediff(a2b1, a1b2);\n    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\n    const u2 = epr(f4, f4);\n    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\n    const u1 = epr(f4, f5);\n    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\n    const g7 = epr(f4, f6);\n    const g9 = epr(f5, f5);\n    const u0 = fes(g7, g9);\n    // Solve: u2*t**2 + u1*t + u0 = 0\n    return [u2, u1, u0];\n}\n\n//# sourceMappingURL=get-coeffs-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curvature: () => (/* binding */ curvature),\n/* harmony export */   \"κ\": () => (/* binding */ κ)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js\");\n\n\n\n/**\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\n * curve at a specific given parameter value `t`.\n *\n * * returns `Number.NaN` at a cusp - this can be tested for with `Number.isNaN`\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the curvature should be evaluated\n *\n * @doc mdx\n */\nfunction curvature(ps, t) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    const [ddX, ddY] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_2ndDerivative)(ps);\n    const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(dX, t);\n    const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(dY, t);\n    const ddx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(ddX, t);\n    const ddy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(ddY, t);\n    const a = dx * ddy - dy * ddx;\n    const b = Math.sqrt((dx * dx + dy * dy) ** 3);\n    return a / b;\n}\n/**\n * Alias for [[κ]].\n *\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\n * curve at a specific given parameter value `t`.\n *\n * * **alias**: [[curvature]]\n *\n * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the curvature should be evaluated\n *\n * @doc\n */\nconst κ = curvature;\n\n//# sourceMappingURL=curvature.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/dd-curvature.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/dd-curvature.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddCurvature: () => (/* binding */ ddCurvature)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double-double/dd-horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js\");\n\n\n\n\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\n/**\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\n * curve at a specific given parameter value `t`.\n *\n * * returns `Number.NaN` at a cusp - this can be tested for with `Number.isNaN`\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[[0],[0]],[[1],[1]],[[2],[1]],[[2],[0]]]`\n * @param t the parameter value where the curvature should be evaluated\n */\nfunction ddCurvature(ps, t) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivativeDd)(ps);\n    const [ddX, ddY] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_2ndDerivativeDd)(ps);\n    const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.ddHorner)(dX, t);\n    const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.ddHorner)(dY, t);\n    const ddx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.ddHorner)(ddX, t);\n    const ddy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.ddHorner)(ddY, t);\n    const a = qdq(qmq(dx, ddy), qmq(dy, ddx));\n    const _b = qaq(qmq(dx, dx), qmq(dy, dy));\n    const __b = qmq(_b, qmq(_b, _b));\n    const b = Math.sqrt(__b[1]);\n    const a_ = a[1];\n    return a_ / b;\n}\n\n//# sourceMappingURL=dd-curvature.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/dd-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/ds.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/ds.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ds: () => (/* binding */ ds)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\n\n/**\n * Returns `ds` (the length differential) for a linear, quadratic or cubic\n * bezier curve.\n *\n * * this function is curried\n *\n * @param ps an order 1, 2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value\n *\n * @internal\n */\nfunction ds(ps) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    return function (t) {\n        const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dX, t);\n        const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dY, t);\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n}\n\n//# sourceMappingURL=ds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/ds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/e-curvature.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/e-curvature.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eCurvature: () => (/* binding */ eCurvature)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js\");\n\n\n\n\n/**\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\n * curve at a specific given parameter value `t`.\n *\n * * returns `Number.NaN` at a cusp - this can be tested for with `Number.isNaN`\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[[0],[0]],[[1],[1]],[[2],[1]],[[2],[0]]]`\n * @param t the parameter value where the curvature should be evaluated\n */\nfunction eCurvature(ps, t) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivativeExact)(ps);\n    const [ddX, ddY] = (0,_to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_2ndDerivativeExact)(ps);\n    const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.eHorner)(dX, t);\n    const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.eHorner)(dY, t);\n    const ddx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.eHorner)(ddX, t);\n    const ddy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.eHorner)(ddY, t);\n    const a = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eCompress)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMult)(dx, ddy), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMult)(dy, ddx)));\n    const _b = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eCompress)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eAdd)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMult)(dx, dx), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMult)(dy, dy)));\n    const __b = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMult)(_b, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMult)(_b, _b));\n    const b = Math.sqrt(__b[__b.length - 1]);\n    const a_ = a[a.length - 1];\n    return a_ / b;\n}\n\n//# sourceMappingURL=e-curvature.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/e-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate2ndDerivativeAt0: () => (/* binding */ evaluate2ndDerivativeAt0)\n/* harmony export */ });\n/**\n * Returns the result, `[x,y]`, of evaluating the 2nd derivative of a linear,\n * quadratic or cubic bezier curve's power basis at `t === 0`.\n *\n * * uses double precision calculations internally\n *\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction evaluate2ndDerivativeAt0(ps) {\n    // Bitlength: If the coordinates of the control points are bit-aligned then the\n    // * max bitlength (incl bit shift) increase === 5 (for cubics)\n    // * max bitlength (incl bit shift) increase === 3 (for quadratics)\n    // * max bitlength (incl bit shift) increase === 0 (for lines)\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            6 * ((x2 + x0) - 2 * x1),\n            6 * ((y2 + y0) - 2 * y1)\n        ]; // max bitlength increase 5\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            2 * ((x2 + x0) - 2 * x1),\n            2 * ((y2 + y0) - 2 * y1)\n        ]; // max bitlength increase 3\n    }\n    if (ps.length <= 2) {\n        return [0, 0];\n    }\n    throw new Error('The given bezier curve must be of order <= 3');\n}\n\n//# sourceMappingURL=evaluate-2nd-derivative-at-0.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate2ndDerivativeAt1: () => (/* binding */ evaluate2ndDerivativeAt1)\n/* harmony export */ });\n/**\n * Returns the result, `[x,y]`, of evaluating the 2nd derivative of a linear,\n * quadratic or cubic bezier curve's power basis at `t === 1`.\n *\n * * uses double precision calculations internally\n *\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction evaluate2ndDerivativeAt1(ps) {\n    // Bitlength: If the coordinates of the control points are bit-aligned then the\n    // * max bitlength (incl bit shift) increase === 5 (for cubics)\n    // * max bitlength (incl bit shift) increase === 3 (for quadratics)\n    // * max bitlength (incl bit shift) increase === 0 (for lines)\n    if (ps.length === 4) {\n        const [, [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [\n            6 * ((x3 + x1) - 2 * x2),\n            6 * ((y3 + y1) - 2 * y2),\n        ]; // max bitlength increase 5\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            2 * ((x2 + x0) - 2 * x1),\n            2 * ((y2 + y0) - 2 * y1), // t^0\n        ]; // max bitlength increase 3\n    }\n    if (ps.length <= 2) {\n        return [0, 0]; // max bitlength increase 0\n    }\n    throw new Error('The given bezier curve must be of order <= 3');\n}\n\n//# sourceMappingURL=evaluate-2nd-derivative-at-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate2ndDerivative: () => (/* binding */ evaluate2ndDerivative)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\n\n/**\n * Returns the `[x,y]` value of the twice differentiated (with respect to `t`)\n * bezier curve's power basis when evaluated at `t`.\n *\n * * uses double precision calculations internally\n *\n * @param ps a cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the t parameter\n *\n * @doc mdx\n */\nfunction evaluate2ndDerivative(ps, t) {\n    const [ddPsX, ddPsY] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_2ndDerivative)(ps);\n    return [\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(ddPsX, t),\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(ddPsY, t)\n    ];\n}\n\n//# sourceMappingURL=evaluate-2nd-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate2ndDerivativeAt0Exact: () => (/* binding */ evaluate2ndDerivativeAt0Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.growExpansion;\n/**\n * Returns the *exact* result, `[x,y]`, of evaluating the 2nd derivative of a\n * linear, quadratic or cubic bezier curve's power basis at `t === 0`.\n *\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction evaluate2ndDerivativeAt0Exact(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            sce(6, ge(ts(x2, x0), -2 * x1)),\n            sce(6, ge(ts(y2, y0), -2 * y1))\n        ];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            ge(ts(2 * x2, 2 * x0), -4 * x1),\n            ge(ts(2 * y2, 2 * y0), -4 * y1)\n        ];\n    }\n    if (ps.length <= 2) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3');\n}\n\n//# sourceMappingURL=evaluate-2nd-derivative-at-0-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate2ndDerivativeAt1Exact: () => (/* binding */ evaluate2ndDerivativeAt1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.growExpansion;\n/**\n * Returns the *exact* result, `[x,y]`, of evaluating the 2nd derivative of a\n * linear, quadratic or cubic bezier curve's power basis at `t === 1`.\n *\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction evaluate2ndDerivativeAt1Exact(ps) {\n    if (ps.length === 4) {\n        const [, [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [\n            sce(6, ge(ts(x3, x1), -2 * x2)),\n            sce(6, ge(ts(y3, y1), -2 * y2))\n        ];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            ge(ts(2 * x2, 2 * x0), -4 * x1),\n            ge(ts(2 * y2, 2 * y0), -4 * y1)\n        ];\n    }\n    if (ps.length <= 2) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3');\n}\n\n//# sourceMappingURL=evaluate-2nd-derivative-at-1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate2ndDerivativeExact: () => (/* binding */ evaluate2ndDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n\n\n/**\n * Returns the *exact* result, `[x,y]`, of evaluating the 2nd derivative of a\n * linear, quadratic or cubic bezier curve's power basis at `t`.\n *\n * @param ps a cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the t parameter\n *\n * @doc mdx\n */\nfunction evaluate2ndDerivativeExact(ps, t) {\n    const [ddPsX, ddPsY] = (0,_to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_2ndDerivativeExact)(ps);\n    return [(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(ddPsX, t), (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(ddPsY, t)];\n}\n\n//# sourceMappingURL=evaluate-2nd-derivative-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauDd: () => (/* binding */ evalDeCasteljauDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\n/**\n * Returns the resulting point (in double-double precision) of evaluating the\n * given bezier curve at the given parameter `t` (given as a double-double\n * precision floating point number).\n *\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\n * with intermediate calculations done in double-double precision floating point\n * arithmetic.\n *\n * * to get an absolute error bound on the result call [[evalDeCasteljauError]]\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated (given in\n * double-double precision)\n *\n * @doc mdx\n **/\nfunction evalDeCasteljauDd(ps, t) {\n    if (t[0] === 0 && t[1] === 0) {\n        return ps[0].map(c => [0, c]);\n    }\n    else if (t[0] === 0 && t[1] === 1) {\n        return ps[ps.length - 1].map(c => [0, c]);\n    }\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        const a01 = qad(qmq(td(x1, x0), t), x0);\n        const a11 = qad(qmq(td(x2, x1), t), x1);\n        const a21 = qad(qmq(td(x3, x2), t), x2);\n        const a02 = qaq(a01, qmq(qdq(a11, a01), t));\n        const a12 = qaq(a11, qmq(qdq(a21, a11), t));\n        const x = qaq(a02, qmq(qdq(a12, a02), t));\n        const b01 = qad(qmq(td(y1, y0), t), y0);\n        const b11 = qad(qmq(td(y2, y1), t), y1);\n        const b21 = qad(qmq(td(y3, y2), t), y2);\n        const b02 = qaq(b01, qmq(qdq(b11, b01), t));\n        const b12 = qaq(b11, qmq(qdq(b21, b11), t));\n        const y = qaq(b02, qmq(qdq(b12, b02), t));\n        return [x, y];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        const a01 = qaq([0, x0], qmq(td(x1, x0), t));\n        const a11 = qaq([0, x1], qmq(td(x2, x1), t));\n        const x = qaq(a01, qmq(qdq(a11, a01), t));\n        const b01 = qaq([0, y0], qmq(td(y1, y0), t));\n        const b11 = qaq([0, y1], qmq(td(y2, y1), t));\n        const y = qaq(b01, qmq(qdq(b11, b01), t));\n        return [x, y];\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        const x = qad(qmq(td(x1, x0), t), x0);\n        const y = qad(qmq(td(y1, y0), t), y0);\n        return [x, y];\n    }\n    if (ps.length === 1) {\n        const [x, y] = ps[0];\n        return [[0, x], [0, y]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=eval-de-casteljau-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauWithErrDd: () => (/* binding */ evalDeCasteljauWithErrDd)\n/* harmony export */ });\n/* harmony import */ var _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../eval-de-casteljau-error.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eval-de-casteljau-dd.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst evalDeCasteljauDd = _eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauDd;\nconst evalDeCasteljauError = _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__[\"γγ\"])(3);\n/**\n * Returns the resulting point (in double-double precision) of evaluating the\n * given bezier curve at the given parameter `t` (including a coordinate-wise\n * error bound).\n *\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\n * in double-double precision floating point arithmetic.\n *\n * The resulting point is returned as `{ p: number[][], pE: number[] }`,\n * where `p` is the point `[x,y]` (with `x` and `y` in double-double precision)\n * and `pE` is the corresponding coordinate-wise absolute error bound of the\n * calculation.\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated\n *\n * @doc mdx\n **/\nfunction evalDeCasteljauWithErrDd(ps, t) {\n    const p = evalDeCasteljauDd(ps, t);\n    const pE = evalDeCasteljauError(ps, t);\n    if (ps.length === 4) {\n        return { p, pE: pE.map(e => 2 * 9 * γγ3 * e) };\n    }\n    if (ps.length === 3) {\n        return { p, pE: pE.map(e => 2 * 6 * γγ3 * e) };\n    }\n    if (ps.length === 2) {\n        return { p, pE: pE.map(e => 2 * 3 * γγ3 * e) };\n    }\n    if (ps.length === 1) {\n        return { p: [ps[0]], pE: [0, 0] };\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=eval-de-casteljau-with-err-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauWithErr: () => (/* binding */ evalDeCasteljauWithErr)\n/* harmony export */ });\n/* harmony import */ var _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../eval-de-casteljau-error.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst evalDeCasteljau = _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau;\nconst evalDeCasteljauError = _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__[\"γ\"])(1);\n/**\n * Returns the resulting point of evaluating the given bezier curve at the given\n * parameter `t` including a coordinate-wise error bound.\n *\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\n * in double precision floating point arithmetic\n *\n * The resulting point is returned as `{ p: number[], pE: number[] }`,\n * where `p` is the point `[x,y]` and `pE` is the corresponding coordinate-wise\n * absolute error bound of the calculation.\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated\n *\n * @doc mdx\n **/\nfunction evalDeCasteljauWithErr(ps, t) {\n    const p = evalDeCasteljau(ps, t);\n    const pE = evalDeCasteljauError(ps, [0, t]);\n    if (ps.length === 4) {\n        return { p, pE: pE.map(e => 9 * γ1 * e) };\n    }\n    if (ps.length === 3) {\n        return { p, pE: pE.map(e => 6 * γ1 * e) };\n    }\n    if (ps.length === 2) {\n        return { p, pE: pE.map(e => 3 * γ1 * e) };\n    }\n    if (ps.length === 1) {\n        return { p: ps[0], pE: [0, 0] };\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=eval-de-casteljau-with-err.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljau: () => (/* binding */ evalDeCasteljau)\n/* harmony export */ });\n/**\n * Returns the resulting point of evaluating the given bezier curve at the\n * given parameter `t`.\n *\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\n * in double precision floating point arithmetic\n *\n * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are\n * double precision floating point numbers.\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated\n *\n * @doc mdx\n **/\nfunction evalDeCasteljau(ps, t) {\n    if (t === 0) {\n        return ps[0];\n    }\n    else if (t === 1) {\n        return ps[ps.length - 1];\n    }\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        const a01 = x0 + (x1 - x0) * t;\n        const a11 = x1 + (x2 - x1) * t;\n        const a21 = x2 + (x3 - x2) * t;\n        const a02 = a01 + (a11 - a01) * t;\n        const a12 = a11 + (a21 - a11) * t;\n        const x = a02 + (a12 - a02) * t;\n        const b01 = y0 + (y1 - y0) * t;\n        const b11 = y1 + (y2 - y1) * t;\n        const b21 = y2 + (y3 - y2) * t;\n        const b02 = b01 + (b11 - b01) * t;\n        const b12 = b11 + (b21 - b11) * t;\n        const y = b02 + (b12 - b02) * t;\n        return [x, y];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        const a01 = x0 + (x1 - x0) * t;\n        const a11 = x1 + (x2 - x1) * t;\n        const x = a01 + (a11 - a01) * t;\n        const b01 = y0 + (y1 - y0) * t;\n        const b11 = y1 + (y2 - y1) * t;\n        const y = b01 + (b11 - b01) * t;\n        return [x, y];\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        const x = x0 + (x1 - x0) * t;\n        const y = y0 + (y1 - y0) * t;\n        return [x, y];\n    }\n    if (ps.length === 1) {\n        return ps[0];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=eval-de-casteljau.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluate: () => (/* binding */ evaluate)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\n\n/**\n * Returns the resulting point of evaluating the given bezier curve at the\n * given parameter `t`.\n *\n * * uses power bases conversion and subsequently [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)\n * to evaluate the polynomial in double precision floating point arithmetic.\n *\n * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are\n * double precision floating point numbers.\n *\n * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated\n *\n * @doc mdx\n */\nfunction evaluate(ps, t) {\n    const len = ps.length;\n    if (t === 0) {\n        return ps[0];\n    }\n    if (t === 1) {\n        return ps[len - 1];\n    }\n    const [X, Y] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis)(ps);\n    return [\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(X, t),\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(Y, t)\n    ];\n}\n\n//# sourceMappingURL=evaluate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauError: () => (/* binding */ evalDeCasteljauError)\n/* harmony export */ });\nconst abs = Math.abs;\n/**\n * Returns a representation of the error (from which an absolute error bound\n * can be calculated) when evaluating the given bezier curve at the parameter `t`\n * using [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm).\n *\n * The returned error representation needs to be multiplied with\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\n * or double-double). This is explained in more detail below. See\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n * p. 68 near the bottom.\n *\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\n *\n * The absolute erros below can be calculated as follows (where `<E>` are the\n * error counters as indicated in the comments of the return value below):\n *  * double precision: `<E> * (γ(1)) * result_`\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\n *\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\n * and `γγ(3) === 3.697785493223493e-32`.\n * The `T` in the error counter formula is the input error given as an error\n * counter on `t`. For example, if the exact `t` (let's call it `te`) is bounded\n * by `(|t| - 5u) < |te| < (|t| + 5u)` where `u === Number.EPSILON/2` then `T`\n * should be given as `5`. If `t` is exact then `T` is zero.\n *\n * ```\n * // for cubic bezier curves\n * return [\n * \tx_,  // <E> === 3T + 9\n * \ty_   // <E> === 3T + 9\n * ];\n * // for quadratic bezier curves\n * return [\n * \tx_,  // <E> === 2T + 6\n * \ty_   // <E> === 2T + 6\n * ];\n * // for linear bezier curves (i.e. lines)\n * return [\n * \tx_,  // <E> === T + 3\n * \ty_   // <E> === T + 3\n * ];\n * ```\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated (given in\n * double-double precision)\n *\n * @example\n * ```typescript\n * const ps = [[1.1,1.1],[2.3,2.3],[0.7,2.1],[3.11,-1.27]];  // some cubic bezier curve\n * const t = [0,0.1];  // some `t` in double-double precision, i.e. `t` equals `0.1`\n * const r = evalDeCasteljau(ps, t[1]) //=> [1.3828099999999999, 1.41623]\n * let error = evalDeCasteljauError(ps,t); //=> [2.32521, 2.3695700000000004]\n * const γ1 = 1*(Number.EPSILON)/(1-1*(Number.EPSILON));  // this is the error constant for double precision\n * error = error.map(c => γ1*c); //=> [5.163003358177322e-16, 5.261502344922066e-16]\n * // so, for instance, the *real* x coordinate of the point, i.e. `r[0]`, is somewhere between\n * // `1.3828099999999999 - 5.163003358177322e-16` and `1.3828099999999999 + 5.163003358177322e-16`, i.e.\n * // `1.3828099999999994 < r[0] < 1.3828100000000003`\n * ```\n *\n * @internal\n **/\nfunction evalDeCasteljauError(ps, t) {\n    if (t[0] === 0 && t[1] === 0) {\n        return [0, 0]; // No error\n    }\n    else if (t[0] === 0 && t[1] === 1) {\n        return [0, 0]; // No error\n    }\n    const t_ = abs(t[1]); // <T>\n    // <M> --> the cost of multiplication === <1> except for `qmq` in which\n    // case it is <2>. One might as well just double the error in the end for\n    // double-double precision calculations (thus losing 1 bit) and take \n    // <M> === 1 always. This simplifies the calculation a bit.\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        const _x0 = abs(x0); // <0>\n        const _y0 = abs(y0); // <0>\n        const _x1 = abs(x1); // <0>\n        const _y1 = abs(y1); // <0>\n        const _x2 = abs(x2); // <0>\n        const _y2 = abs(y2); // <0>\n        const _x3 = abs(x3); // <0>\n        const _y3 = abs(y3); // <0>\n        // a01<T+3> <-- <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\n        const a01_ = _x0 + (_x1 + _x0) * t_;\n        // a11<T+3> <-- <T+3>(x1 + <1>(<0>(x2 + x1)*<T>t));\n        const a11_ = _x1 + (_x2 + _x1) * t_;\n        // a21<T+3> <-- <T+3>(x2 + <1>(<0>(x3 + x2)*<T>t));\n        const a21_ = _x2 + (_x3 + _x2) * t_;\n        // a02<2T+6> <-- <2T+6>(<T+3>a01 + <2T+5>(<T+4>(<T+3>a11 + <T+3>a01)*<T>t));\n        const a02_ = a01_ + (a11_ + a01_) * t_;\n        // a12<2T+6> <-- <2T+6>(<T+3>a11 + <2T+5>(<T+4>(<T+3>a21 + <T+3>a11)*<T>t));\n        const a12_ = a11_ + (a21_ + a11_) * t_;\n        // x<3T+9> <-- <3T+9>(<2T+6>a02 + <3T+8>(<2T+7>(<2T+6>a12 + <2T+6>a02)*<T>t));\n        const x_ = a02_ + (a12_ + a02_) * t_;\n        const b01_ = _y0 + (_y1 + _y0) * t_;\n        const b11_ = _y1 + (_y2 + _y1) * t_;\n        const b21_ = _y2 + (_y3 + _y2) * t_;\n        const b02_ = b01_ + (b11_ + b01_) * t_;\n        const b12_ = b11_ + (b21_ + b11_) * t_;\n        const y_ = b02_ + (b12_ + b02_) * t_;\n        return [x_, y_];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        const _x0 = abs(x0);\n        const _y0 = abs(y0);\n        const _x1 = abs(x1);\n        const _y1 = abs(y1);\n        const _x2 = abs(x2);\n        const _y2 = abs(y2);\n        // <T+3>a01 <-- <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\n        const a01_ = _x0 + (_x1 + _x0) * t_;\n        // <T+3>a11 <-- <T+3>(x1 + <T+2>(<1>(x2 + x1)*<T>t));\n        const a11_ = _x1 + (_x2 + _x1) * t_;\n        // <2T+6>x <-- <2T+6>(<T+3>a01 + <2T+5>(<T+4>(<T+3>a11 + <T+3>a01)*<T>t));\n        const x_ = a01_ + (a11_ + a01_) * t_;\n        const b01_ = _y0 + (_y1 + _y0) * t_;\n        const b11_ = _y1 + (_y2 + _y1) * t_;\n        const y_ = b01_ + (b11_ + b01_) * t_;\n        return [x_, y_];\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        const _x0 = abs(x0);\n        const _y0 = abs(y0);\n        const _x1 = abs(x1);\n        const _y1 = abs(y1);\n        // <T+3>x = <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\n        const x_ = _x0 + (_x1 + _x0) * t_;\n        const y_ = _y0 + (_y1 + _y0) * t_;\n        return [x_, y_];\n    }\n    if (ps.length === 1) {\n        return [0, 0];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=eval-de-casteljau-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateExact: () => (/* binding */ evaluateExact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n\n\n/**\n * Returns the *exact* resulting point of evaluating the given bezier curve at\n * the given `t` parameter.\n *\n * * the result is returned as `[x,y]`, where `x` and `y` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\n * point expansions\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t\n *\n * @doc mdx\n */\nfunction evaluateExact(ps, t) {\n    if (t === 0) {\n        return [[ps[0][0]], [ps[0][1]]];\n    }\n    if (t === 1) {\n        return [[ps[ps.length - 1][0]], [ps[ps.length - 1][1]]];\n    }\n    const [X, Y] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(ps);\n    return [\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(X, t),\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(Y, t)\n    ];\n}\n\n//# sourceMappingURL=evaluate-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: () => (/* binding */ normal)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\n\n/**\n * Returns a normal vector (not necessarily of unit length) of a bezier curve\n * at a specific given parameter value `t` by simply taking the `tangent` at\n * that point and rotating it by 90 degrees.\n *\n * * uses double precision calculations internally\n *\n * @param ps a linear, quadratic or cubic bezier curve given by its ordered\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the normal should be evaluated\n *\n * @doc mdx\n */\nfunction normal(ps, t) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    return [\n        -(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dY, t),\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dX, t)\n    ];\n}\n\n//# sourceMappingURL=normal.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangentAt0: () => (/* binding */ tangentAt0)\n/* harmony export */ });\n/**\n * Returns the tangent vector (not necessarily of unit length) of an\n * order 0,1,2 or 3 bezier curve at `t === 0`, i.e.\n * returns the result, `[x,y]`, of evaluating the derivative of a linear,\n * quadratic or cubic bezier curve's power basis at `t === 0`.\n *\n * * uses double precision calculations internally\n *\n * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction tangentAt0(ps) {\n    // Bitlength: If the coordinates of the control points are grid-aligned then\n    // * max bitlength (incl bit shift) increase === 3 (for cubics)\n    // * max bitlength (incl bit shift) increase === 2 (for quadratics)\n    // * max bitlength (incl bit shift) increase === 1 (for lines)\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            3 * (x1 - x0),\n            3 * (y1 - y0)\n        ]; // max bitlength increase 3\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            2 * (x1 - x0),\n            2 * (y1 - y0),\n        ]; // max bitlength increase 2\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            x1 - x0,\n            y1 - y0,\n        ]; // max bitlength increase 1\n    }\n    if (ps.length === 1) {\n        return [0, 0];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=tangent-at-0.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangentAt1: () => (/* binding */ tangentAt1)\n/* harmony export */ });\n/**\n * Returns the tangent vector (not necessarily of unit length) of an\n * order 0,1,2 or 3 bezier curve at `t === 1`, i.e.\n * Returns the result, `[x,y]`, of evaluating the derivative of a linear,\n * quadratic or cubic bezier curve's power basis at `t === 1`.\n *\n * * uses double precision calculations internally\n *\n * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction tangentAt1(ps) {\n    // Bitlength: If the coordinates of the control points are grid-aligned then\n    // * max bitlength (incl bit shift) increase === 3 (for cubics)\n    // * max bitlength (incl bit shift) increase === 2 (for quadratics)\n    // * max bitlength (incl bit shift) increase === 1 (for lines)\n    if (ps.length === 4) {\n        const [x2, y2] = ps[2];\n        const [x3, y3] = ps[3];\n        return [\n            3 * (x3 - x2),\n            3 * (y3 - y2),\n        ]; // max bitlength increase 3\n    }\n    if (ps.length === 3) {\n        const [x1, y1] = ps[1];\n        const [x2, y2] = ps[2];\n        return [\n            2 * (x2 - x1),\n            2 * (y2 - y1),\n        ]; // max bitlength increase 2\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            x1 - x0,\n            y1 - y0\n        ]; // max bitlength increase 1\n    }\n    if (ps.length === 1) {\n        return [0, 0];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=tangent-at-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangent: () => (/* binding */ tangent)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n\n\n/**\n * Returns the tangent vector (not necessarily of unit length) of an\n * order 0,1,2 or 3 bezier curve at a specific given parameter value `t`, i.e.\n * returns the `[x,y]` value of the once differentiated (with respect to `t`)\n * bezier curve's power basis when evaluated at `t`.\n *\n * * uses double precision calculations internally\n *\n * @param ps a linear, quadratic or cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the t parameter\n *\n * @doc mdx\n */\nfunction tangent(ps, t) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\n    return [\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dX, t),\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dY, t)\n    ];\n}\n\n//# sourceMappingURL=tangent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangentAt0Exact: () => (/* binding */ tangentAt0Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\n/**\n * Returns the *exact* tangent vector (not necessarily of unit length) of an\n * order 0,1,2 or 3 bezier curve at `t === 0`, i.e.\n * returns the result, `[x,y]`, of evaluating the derivative of a linear,\n * quadratic or cubic bezier curve's power basis at `t === 0`.\n *\n * @param ps an order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction tangentAt0Exact(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            sce(3, td(x1, x0)),\n            sce(3, td(y1, y0))\n        ];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            td(2 * x1, 2 * x0),\n            td(2 * y1, 2 * y0),\n        ];\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            td(x1, x0),\n            td(y1, y0),\n        ];\n    }\n    if (ps.length === 1) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=tangent-at-0-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangentAt1Exact: () => (/* binding */ tangentAt1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\n/**\n * Returns the *exact* tangent vector (not necessarily of unit length) of an\n * order 0,1,2 or 3 bezier curve at `t === 1`, i.e.\n * returns the exact result (`[x,y]`) of evaluating the derivative of a linear,\n * quadratic or cubic bezier curve's power basis at `t === 1`.\n *\n * @param ps an order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction tangentAt1Exact(ps) {\n    if (ps.length === 4) {\n        const [x2, y2] = ps[2];\n        const [x3, y3] = ps[3];\n        return [\n            sce(3, td(x3, x2)),\n            sce(3, td(y3, y2))\n        ];\n    }\n    if (ps.length === 3) {\n        const [x1, y1] = ps[1];\n        const [x2, y2] = ps[2];\n        return [\n            td(2 * x2, 2 * x1),\n            td(2 * y2, 2 * y1),\n        ];\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            td(x1, x0),\n            td(y1, y0),\n        ];\n    }\n    if (ps.length === 1) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=tangent-at-1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangentExact: () => (/* binding */ tangentExact)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js\");\n\n\n/**\n * Returns the *exact* tangent vector (not necessarily of unit length) of an\n * order 0,1,2 or 3 bezier curve at a specific parameter `t`, i.e.\n * returns the `[x,y]` value of the once differentiated (with respect to `t`)\n * bezier curve's power basis when evaluated at `t`.\n *\n * @param ps a linear, quadratic or cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the t parameter\n *\n * @doc\n */\nfunction tangentExact(ps, t) {\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivativeExact)(ps);\n    return [(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(dX, t), (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(dY, t)];\n}\n\n//# sourceMappingURL=tangent-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTAtLength: () => (/* binding */ getTAtLength)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/brent.js\");\n/* harmony import */ var _global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/length/length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/length.js\");\n\n\n/**\n * Returns the `t` parameter value where the given bezier curve reaches the\n * given length `s` starting from `t = 0` and clipping at `t = 1.125`.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param s the length\n *\n * @doc mdx\n */\nfunction getTAtLength(ps, s) {\n    if (s === 0) {\n        return 0;\n    }\n    const lenAtT = (t) => (0,_global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_0__.length)([0, t], ps);\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.brent)(t => (lenAtT(t) - s), 0, 1.125);\n}\n\n//# sourceMappingURL=get-t-at-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tFromXY: () => (/* binding */ tFromXY)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js\");\n\n\n\n\n\n\nconst twoDiff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst { min, max } = Math;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Performs certified inversion, i.e. returns the `t` parameter value\n * interval(s) for the given `x` and `y` coordinates on the specified bezier\n * curve.\n *\n * * Only `t` values in `[0,1]` are returned.\n *\n * * see also [[closestPointOnBezier]] and [[closestPointOnBezierCertified]]\n *\n * **precondition**: `p` must be *exactly* on the curve for the result to be\n * certified\n *\n * * **certified** here means no `t` value can be missed but (in rare cases)\n * an extra 1 or 2 `t`s could be returned (e.g. for self-overlapping curves\n * and when the point is exactly on the point of self-intersection of the curve)\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n */\nfunction tFromXY(ps, p) {\n    if (ps.length === 4) {\n        return tFromXY3(ps, p);\n    }\n    if (ps.length === 3) {\n        return tFromXY2(ps, p);\n    }\n    if (ps.length === 2) {\n        return tFromXY1(ps, p);\n    }\n    if (ps.length === 1) {\n        const p1 = ps[0];\n        if (p1[0] === p[0] && p1[1] === p[1]) {\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\n        }\n        return [];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction tFromXY3(ps, p) {\n    const x = p[0];\n    const y = p[1];\n    // get power basis representation in double-double precision including error\n    // bound\n    const { coeffs: [_polyDdX, _polyDdY], errorBound: [polyX_, polyY_] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis3DdWithRunningError)(ps);\n    // pop the constant term off `x(t)`\n    const txDd = _polyDdX.pop()[1];\n    // subtract the x coordinate of the point\n    const polyDdX = [..._polyDdX, twoDiff(txDd, x)];\n    // pop the constant term off `y(t)`\n    const tyDd = _polyDdY.pop()[1];\n    // subtract the y coordinate of the point\n    const polyDdY = [..._polyDdY, twoDiff(tyDd, y)];\n    let pExactXY = undefined;\n    const getPExactX = () => {\n        if (pExactXY === undefined) {\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3Exact)(ps);\n        }\n        const _pExactX = pExactXY[0].slice(); // x coordinate\n        // pop the constant term off `x(t)`\n        const tx = _pExactX.pop();\n        const pExactX = [..._pExactX, twoDiff(tx[0], x)];\n        return pExactX;\n    };\n    const getPExactY = () => {\n        if (pExactXY === undefined) {\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3Exact)(ps);\n        }\n        const _pExactY = pExactXY[1].slice(); // y coordinate\n        // pop the constant term off `y(t)`\n        const ty = _pExactY.pop();\n        const pExactY = [..._pExactY, twoDiff(ty[0], y)];\n        return pExactY;\n    };\n    // max 3 roots\n    const xrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyDdX, 0, 1, polyX_.map(c => γγ3 * c), getPExactX, true);\n    // const xrsExp = xrs!.map(xr => refineK1(xr, getPExactX()));\n    // max 3 roots\n    const yrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyDdY, 0, 1, polyY_.map(c => γγ3 * c), getPExactY, true);\n    if (xrs === undefined) {\n        // the `x` value of the point is on the curve for all `t` values\n        // the curve must be a 'line' (can also be degenerate quadratic, etc.)\n        if (yrs === undefined) {\n            // the `y` value of the point is on the curve for all `t` values\n            // the curve must be a point\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\n        }\n        return yrs; //.map(r => [r.tS, r.tE]);\n    }\n    if (yrs === undefined) {\n        // the `y` value of the point is on the curve for all `t` values\n        // the curve must be a 'line' (can also be degenerate quadratic, etc.)        \n        return xrs;\n    }\n    // check for `t` value overlap \n    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (at point of \n    // self-intersection), 3 overlaps (for self-overlapping curve (that looks \n    // like a line))\n    // at this point `xrs !== undefined` and `yrs !== undefined`\n    const ris = [];\n    for (let i = 0; i < xrs.length; i++) {\n        const xr = xrs[i];\n        for (let j = 0; j < yrs.length; j++) {\n            const yr = yrs[j];\n            const r = combineRoots(xr, yr);\n            if (r !== undefined) {\n                ris.push(r);\n            }\n        }\n    }\n    return ris;\n}\n/** @internal */\nfunction tFromXY2(ps, p) {\n    const x = p[0];\n    const y = p[1];\n    // get power basis representation in double-double precision including error\n    // bound\n    const { coeffs: [_polyDdX, _polyDdY], errorBound: [polyX_, polyY_] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis2DdWithRunningError)(ps);\n    // pop the constant term off `x(t)`\n    const txDd = _polyDdX.pop()[1];\n    // subtract the x coordinate of the point\n    const polyDdX = [..._polyDdX, twoDiff(txDd, x)];\n    // pop the constant term off `y(t)`\n    const tyDd = _polyDdY.pop()[1];\n    // subtract the y coordinate of the point\n    const polyDdY = [..._polyDdY, twoDiff(tyDd, y)];\n    let pExactXY = undefined;\n    const getPExactX = () => {\n        if (pExactXY === undefined) {\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2Exact)(ps);\n        }\n        const _pExactX = pExactXY[0]; // x coordinate\n        // pop the constant term off `x(t)`\n        const tx = _pExactX.pop()[0];\n        const pExactX = [..._pExactX, twoDiff(tx, x)];\n        return pExactX;\n    };\n    const getPExactY = () => {\n        if (pExactXY === undefined) {\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2Exact)(ps);\n        }\n        const _pExactY = pExactXY[1]; // y coordinate\n        // pop the constant term off `y(t)`\n        const ty = _pExactY.pop()[0];\n        const pExactY = [..._pExactY, twoDiff(ty, y)];\n        return pExactY;\n    };\n    // max 2 roots\n    const xrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyDdX, 0, 1, polyX_.map(c => γγ3 * c), getPExactX, true);\n    // max 2 roots\n    const yrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyDdY, 0, 1, polyY_.map(c => γγ3 * c), getPExactY, true);\n    if (xrs === undefined) {\n        // the `x` value of the point is on the curve for all `t` values\n        // the curve must be a 'line'\n        if (yrs === undefined) {\n            // the `y` value of the point is on the curve for all `t` values\n            // the curve must be a point\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\n        }\n        return yrs;\n    }\n    if (yrs === undefined) {\n        // the `y` value of the point is on the curve for all `t` values\n        // the curve must be a 'line'\n        return xrs;\n    }\n    // check for `t` value overlap \n    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (for \n    // self-overlapping curve (that looks like a line))\n    // at this point `xrs !== undefined` and `yrs !== undefined`\n    const ris = [];\n    for (let i = 0; i < xrs.length; i++) {\n        const xr = xrs[i];\n        for (let j = 0; j < yrs.length; j++) {\n            const yr = yrs[j];\n            const r = combineRoots(xr, yr);\n            if (r !== undefined) {\n                ris.push(r);\n            }\n        }\n    }\n    return ris;\n}\n/** @internal */\nfunction tFromXY1(ps, p) {\n    const x = p[0];\n    const y = p[1];\n    // get power basis representation in double-double precision including error\n    // bound\n    const [_polyDdX, _polyDdY] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_5__.toPowerBasis1Dd)(ps);\n    // pop the constant term off `x(t)`\n    const txDd = _polyDdX.pop()[1];\n    // subtract the x coordinate of the point\n    const polyExactX = [..._polyDdX, twoDiff(txDd, x)];\n    // pop the constant term off `y(t)`\n    const tyDd = _polyDdY.pop()[1];\n    // subtract the y coordinate of the point\n    const polyExactY = [..._polyDdY, twoDiff(tyDd, y)];\n    // max 1 roots\n    const xrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyExactX, 0, 1, undefined, undefined, true);\n    // max 1 roots\n    const yrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyExactY, 0, 1, undefined, undefined, true);\n    if (xrs === undefined) {\n        // the `x` value of the point is on the curve for all `t` values\n        // the curve must be a vertical line\n        if (yrs === undefined) {\n            // the `y` value of the point is on the curve for all `t` values\n            // the curve must be a point\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\n        }\n        return yrs;\n    }\n    if (yrs === undefined) {\n        // the `y` value of the point is on the curve for all `t` values\n        // the curve must be horizontal line\n        return xrs; //.map(r => ({ tS: r.tS, tE: r.tE, multiplicity: 1 }));\n    }\n    // check for `t` value overlap \n    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (for \n    // self-overlapping curve (that looks like a line))\n    // at this point `xrs !== undefined` and `yrs !== undefined`\n    if (xrs.length === 0 || yrs.length === 0) {\n        return [];\n    }\n    // at this point `xrs.length === 1` and `yrs.length === 1`\n    const r = combineRoots(xrs[0], yrs[0]);\n    if (r === undefined) {\n        return [];\n    }\n    return [r];\n}\n/** @internal */\nfunction combineRoots(r, s) {\n    // case 1\n    if (r.tS <= s.tS) {\n        if (r.tE < s.tS) {\n            return undefined; // no overlap\n        }\n        return { tS: s.tS, tE: max(r.tE, s.tE), multiplicity: min(r.multiplicity, s.multiplicity) };\n    }\n    // case 2 - r.tS > s.tS\n    if (s.tE < r.tS) {\n        return undefined; // no overlap\n    }\n    return { tS: r.tS, tE: max(r.tE, s.tE), multiplicity: min(r.multiplicity, s.multiplicity) };\n}\n\n//# sourceMappingURL=t-from-xy.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointOnBezierCertified: () => (/* binding */ closestPointOnBezierCertified)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../intersection/bezier-bezier-intersection/x.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js\");\n/* harmony import */ var _root_interval_to_distance_squared_interval_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./root-interval-to-distance-squared-interval.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/root-interval-to-distance-squared-interval.js\");\n/* harmony import */ var _get_foot_points_polys_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-foot-points-polys-on-bezier-certified.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js\");\n\n\n\n\n\nconst { sqrt } = Math;\n/**\n * Returns the closest point(s) (and parameter `t` value(s)) on the given\n * bezier curve to the given point (with `t ∈ [0,1]`).\n *\n * * guaranteed accurate to within `4*Number.EPSILON` in the returned `t`\n * value(s)\n * * in some cases there can be more than one closest point, e.g. on the axis\n * of symmetry of a parabola\n * * the returned point(s) are objects with the following properties:\n *     * `p`: the best estimate point on the bezier curve (calculated from the root interval `ri`)\n *     * `t`: the best estimate `t` parameter value (calculated from the root interval `ri`)\n *     * `d`: the best estimate closest distance from the point to the bezier curve (calculated from the root interval `ri`)\n *     * `ri`: a root interval guaranteed to contain the actual `t` value\n *     * `box`: a small box guaranteed to contain the relevant point on the bezier curve\n *     * `dSquaredI`: a small squared distance interval guaranteed to contain the actual distance squared\n *        between the point and the bezier curve\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @doc\n */\nfunction closestPointOnBezierCertified(ps, p, lb = 0, ub = 1) {\n    // const ris = getFootPointsOnBezierCertified(ps,p);\n    const { polyDd, polyE, getPolyExact } = (0,_get_foot_points_polys_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_0__.getFootPointsOnBezierPolysCertified)(ps, p);\n    const ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)(polyDd, lb, ub, polyE, getPolyExact);\n    ris.push({ tS: lb, tE: lb, multiplicity: 1 });\n    ris.push({ tS: ub, tE: ub, multiplicity: 1 });\n    const infos = ris.map((ri) => {\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, [ri.tS, ri.tE]);\n        const dSquaredI = (0,_root_interval_to_distance_squared_interval_js__WEBPACK_IMPORTED_MODULE_3__.rootIntervalToDistanceSquaredInterval)(box, p);\n        return {\n            p: (0,_intersection_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_4__.getPFromBox)(box),\n            t: (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.mid)(ri),\n            d: (sqrt(dSquaredI[0]) + sqrt(dSquaredI[1])) / 2,\n            dSquaredI,\n            box,\n            ri\n        };\n    });\n    /** the minimum max interval value */\n    let minMax = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < infos.length; i++) {\n        const diMax = infos[i].dSquaredI[1];\n        if (diMax < minMax) {\n            minMax = diMax;\n        }\n    }\n    const closestPointInfos = [];\n    for (let i = 0; i < infos.length; i++) {\n        const info = infos[i];\n        if (info.dSquaredI[0] <= minMax) {\n            closestPointInfos.push(info);\n        }\n    }\n    return closestPointInfos;\n}\n\n//# sourceMappingURL=closest-point-on-bezier-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointOnBezier: () => (/* binding */ closestPointOnBezier)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-3.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js\");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-2.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js\");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-1.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\n\n\n\n\n\nconst sqrt = Math.sqrt;\n/**\n * Returns the closest point(s) (and parameter `t` value(s)) on the given\n * bezier curve to the given point (with `t ∈ [0,1]`).\n *\n * * intermediate calculations are done in double precision\n * * in some cases there can be more than one closest point, e.g. on the axis\n * of symmetry of a parabola (in which case only one of the points are returned)\n * * the returned point(s) are objects with the following properties:\n *     * `p`: the closest point on the bezier curve\n *     * `t`: the parameter value of the point on the bezier curve\n *     * `d`: the closest distance between the point and the bezier curve\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @doc mdx\n */\nfunction closestPointOnBezier(ps, p) {\n    let poly;\n    if (ps.length === 4) {\n        poly = (0,_get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3)(ps, p);\n    }\n    else if (ps.length === 3) {\n        poly = (0,_get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2)(ps, p);\n    }\n    else if (ps.length === 2) {\n        poly = (0,_get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1)(ps, p);\n    }\n    else if (ps.length === 1) {\n        return { p: ps[0], t: 0, d: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.distanceBetween)(ps[0], p) };\n    }\n    else {\n        throw new Error('The given bezier curve must be of order <= 3.');\n    }\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRoots)(poly, 0, 1);\n    ts.push(0);\n    ts.push(1);\n    // Get point with minimum distance\n    let minDSquared = Number.POSITIVE_INFINITY;\n    let minP = undefined;\n    for (const t of ts) {\n        const p_ = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljau)(ps, t);\n        const dSquared = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.squaredDistanceBetween)(p_, p);\n        if (dSquared < minDSquared) {\n            minDSquared = dSquared;\n            minP = { p: p_, t, d: sqrt(dSquared) };\n        }\n    }\n    // keep TypeScript happy; `minP` cannot be `undefined` here\n    return minP;\n}\n\n//# sourceMappingURL=closest-point-on-bezier.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   furthestPointOnBezier: () => (/* binding */ furthestPointOnBezier)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-3.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js\");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-2.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js\");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-1.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\n\n\n\n\n\nconst sqrt = Math.sqrt;\n/**\n * Returns the furthest point(s) (and parameter `t` value(s)) on the given\n * bezier curve to the given point (with `t ∈ [0,1]`).\n *\n * * intermediate calculations are done in double precision\n * * in some cases there can be more than one furthest point, e.g. on parts of\n * the axis of symmetry of a parabola (in which case only one of the points are returned)\n * * the returned point(s) are objects with the following properties:\n *     * `p`: the furthest point on the bezier curve\n *     * `t`: the parameter value of the point on the bezier curve\n *     * `d`: the furthest distance between the point and the bezier curve\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @doc mdx\n */\nfunction furthestPointOnBezier(ps, p) {\n    let poly;\n    if (ps.length === 4) {\n        poly = (0,_get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3)(ps, p);\n    }\n    else if (ps.length === 3) {\n        poly = (0,_get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2)(ps, p);\n    }\n    else if (ps.length === 2) {\n        poly = (0,_get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1)(ps, p);\n    }\n    else if (ps.length === 1) {\n        return { p: ps[0], t: 0, d: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.distanceBetween)(ps[0], p) };\n    }\n    else {\n        throw new Error('The given bezier curve must be of order <= 3.');\n    }\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRoots)(poly, 0, 1);\n    ts.push(0);\n    ts.push(1);\n    // Get point with minimum distance\n    let maxDSquared = Number.NEGATIVE_INFINITY;\n    let maxP = undefined;\n    for (const t of ts) {\n        const p_ = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljau)(ps, t);\n        const dSquared = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.squaredDistanceBetween)(p_, p);\n        if (dSquared > maxDSquared) {\n            maxDSquared = dSquared;\n            maxP = { p: p_, t, d: sqrt(dSquared) };\n        }\n    }\n    // keep TypeScript happy; `minP` cannot be `undefined` here\n    return maxP;\n}\n\n//# sourceMappingURL=furthest-point-on-bezier.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly1Dd: () => (/* binding */ getFootpointPoly1Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmn2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultByNeg2;\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\n/**\n * Returns the polynomial whose roots are all the `t` values on the given bezier\n * curve such that the line from the given point to the point on the bezier\n * evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * intermediate calculations are done (and the final result returned in)\n * double-double precision\n *\n * @param ps an order 1 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @internal\n */\nfunction getFootpointPoly1Dd(ps, p) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const [x, y] = p;\n    const xx0 = x0 - x;\n    const xx1 = x1 - x;\n    const yy0 = y0 - y;\n    const yy1 = y1 - y;\n    const x00 = tp(xx0, xx0);\n    const x01 = tp(xx0, xx1);\n    const x11 = tp(xx1, xx1);\n    const y00 = tp(yy0, yy0);\n    const y01 = tp(yy0, yy1);\n    const y11 = tp(yy1, yy1);\n    const s1 = qaq(x01, y01);\n    const s2 = qaq(y00, x00);\n    //const t1 = (x11 + y11) + (s2 - 2*s1)\n    const t1 = qaq(qaq(x11, y11), qaq(s2, qmn2(s1)));\n    //const t0 = s1 - s2;\n    const t0 = qdifq(s1, s2);\n    return [t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly2Dd: () => (/* binding */ getFootpointPoly2Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\n/**\n * Returns the polynomial whose roots are all the `t` values on the given bezier\n * curve such that the line from the given point to the point on the bezier\n * evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * intermediate calculations are done (and the final result returned in)\n * double-double precision\n *\n * @param ps an order 2 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @internal\n */\nfunction getFootpointPoly2Dd(ps, p) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const [x, y] = p;\n    const xx0 = td(x0, x);\n    const xx1 = td(x1, x);\n    const xx2 = td(x2, x);\n    const yy0 = td(y0, y);\n    const yy1 = td(y1, y);\n    const yy2 = td(y2, y);\n    const x00 = qmq(xx0, xx0);\n    const x01 = qmq(xx0, xx1);\n    const x02 = qmq(xx0, xx2);\n    const x11 = qmq(xx1, xx1);\n    const x12 = qmq(xx1, xx2);\n    const x22 = qmq(xx2, xx2);\n    const y00 = qmq(yy0, yy0);\n    const y01 = qmq(yy0, yy1);\n    const y02 = qmq(yy0, yy2);\n    const y11 = qmq(yy1, yy1);\n    const y12 = qmq(yy1, yy2);\n    const y22 = qmq(yy2, yy2);\n    const q1 = qaq(y02, qm2(y11));\n    const r1 = qaq(x02, qm2(x11));\n    //const t3 = ((y22 + y00) + 2*q1 - 4*(y12 + y01)) + \n    //           ((x22 + x00) + 2*r1 - 4*(x12 + x01));\n    const t3 = qaq(qdifq(qaq(qaq(y22, y00), qm2(q1)), qm4(qaq(y12, y01))), qdifq(qaq(qaq(x22, x00), qm2(r1)), qm4(qaq(x12, x01))));\n    //const t2 = 3*(((y12 - q1) + (3*y01 - y00)) + \n    //              ((x12 - r1) + (3*x01 - x00)));\n    const t2 = qmd(3, qaq(qaq(qdifq(y12, q1), qdifq(qmd(3, y01), y00)), qaq(qdifq(x12, r1), qdifq(qmd(3, x01), x00))));\n    //const t1 = (q1 - 3*(2*y01 - y00)) + \n    //           (r1 - 3*(2*x01 - x00));\n    const t1 = qaq(qdifq(q1, qmd(3, qdifq(qm2(y01), y00))), qdifq(r1, qmd(3, qdifq(qm2(x01), x00))));\n    //const t0 = (y01 - y00) + \n    //           (x01 - x00);\n    const t0 = qaq(qdifq(y01, y00), qdifq(x01, x00));\n    return [t3, t2, t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly3Dd: () => (/* binding */ getFootpointPoly3Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\n/**\n * Returns the polynomial whose roots are all the `t` values on the given bezier\n * curve such that the line from the given point to the point on the bezier\n * evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * intermediate calculations are done (and the final result returned in)\n * double-double precision\n *\n * @param ps an order 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @internal\n */\nfunction getFootpointPoly3Dd(ps, p) {\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const x3 = p3[0];\n    const y3 = p3[1];\n    const [x, y] = p;\n    const xx0 = td(x0, x); // exact\n    const xx1 = td(x1, x); // exact\n    const xx2 = td(x2, x); // exact\n    const xx3 = td(x3, x); // exact\n    const yy0 = td(y0, y); // exact\n    const yy1 = td(y1, y); // exact\n    const yy2 = td(y2, y); // exact\n    const yy3 = td(y3, y); // exact\n    const x00 = qmq(xx0, xx0);\n    const x01 = qmd(6, qmq(xx0, xx1));\n    const x02 = qmd(6, qmq(xx0, xx2));\n    const x03 = qm2(qmq(xx0, xx3));\n    const x11 = qmd(9, qmq(xx1, xx1));\n    const x12 = qmd(18, qmq(xx1, xx2));\n    const x13 = qmd(6, qmq(xx1, xx3));\n    const x22 = qmd(9, qmq(xx2, xx2));\n    const x23 = qmd(6, qmq(xx2, xx3));\n    const x33 = qmq(xx3, xx3);\n    const y00 = qmq(yy0, yy0);\n    const y01 = qmd(6, qmq(yy0, yy1));\n    const y02 = qmd(6, qmq(yy0, yy2));\n    const y03 = qm2(qmq(yy0, yy3));\n    const y11 = qmd(9, qmq(yy1, yy1));\n    const y12 = qmd(18, qmq(yy1, yy2));\n    const y13 = qmd(6, qmq(yy1, yy3));\n    const y22 = qmd(9, qmq(yy2, yy2));\n    const y23 = qmd(6, qmq(yy2, yy3));\n    const y33 = qmq(yy3, yy3);\n    const q1 = qaq(x13, x22);\n    const q2 = qaq(x03, x12);\n    const q3 = qaq(x02, x11);\n    const r1 = qaq(y13, y22);\n    const r2 = qaq(y03, y12);\n    const r3 = qaq(y02, y11);\n    // const t5 = 6*(((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) + \n    //               ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));\n    const t5 = qmd(6, qaq(qaq(qaq(qaq(qdq(x33, x23), qdq(x00, x01)), q1), qdq(q3, q2)), qaq(qaq(qaq(qdq(y33, y23), qdq(y00, y01)), r1), qdq(r3, r2))));\n    //const t4 = 5*((((x23 + 5*x01) + 3*q2) - 2*(q1 + 2*q3 + 3*x00)) +\n    //              (((y23 + 5*y01) + 3*r2) - 2*(r1 + 2*r3 + 3*y00)));\n    const t4 = qmd(5, qaq(qdq(qaq(qaq(x23, qmd(5, x01)), qmd(3, q2)), qm2(qaq(qaq(q1, qm2(q3)), qmd(3, x00)))), qdq(qaq(qaq(y23, qmd(5, y01)), qmd(3, r2)), qm2(qaq(qaq(r1, qm2(r3)), qmd(3, y00))))));\n    //const t3 = 4*(((q1 - 3*(q2 - 2*q3)) - 5*(2*x01 - 3*x00)) +\n    //              ((r1 - 3*(r2 - 2*r3)) - 5*(2*y01 - 3*y00)));\n    const t3 = qm4(qaq(qdq(qdq(q1, qmd(3, (qdq(q2, qm2(q3))))), qmd(5, qdq(qm2(x01), qmd(3, x00)))), qdq(qdq(r1, qmd(3, (qdq(r2, qm2(r3))))), qmd(5, qdq(qm2(y01), qmd(3, y00))))));\n    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\n    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\n    const t2 = qmd(3, qaq(qdq(q2, qm2(qdq(qm2(q3), qmd(5, qdq(x01, qm2(x00)))))), qdq(r2, qm2(qdq(qm2(r3), qmd(5, qdq(y01, qm2(y00))))))));\n    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +\n    //              (r3 - 5*(y01 - 3*y00)));\n    const t1 = qm2(qaq(qdq(q3, qmd(5, (qdq(x01, qmd(3, x00))))), qdq(r3, qmd(5, (qdq(y01, qmd(3, y00)))))));\n    //const t0 = ((x01 - 6*x00) +\n    //            (y01 - 6*y00));\n    const t0 = qaq(qdq(x01, qmd(6, x00)), qdq(y01, qmd(6, y00)));\n    return [t5, t4, t3, t2, t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPolyDd: () => (/* binding */ getFootpointPolyDd)\n/* harmony export */ });\n/* harmony import */ var _get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-footpoint-poly-1-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js\");\n/* harmony import */ var _get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-footpoint-poly-2-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js\");\n/* harmony import */ var _get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-footpoint-poly-3-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js\");\n\n\n\n/**\n * Returns the polynomial whose roots are all the `t` parameter values on the\n * given bezier curve such that the line from the given point to the point on\n * the bezier curve evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * intermediate calculations are done (and the final result returned in)\n * double-double precision\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n */\nfunction getFootpointPolyDd(ps, p) {\n    if (ps.length === 4) {\n        return (0,_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3Dd)(ps, p);\n    }\n    if (ps.length === 3) {\n        return (0,_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2Dd)(ps, p);\n    }\n    if (ps.length === 2) {\n        return (0,_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1Dd)(ps, p);\n    }\n    throw new Error('The given bezier curve must be of order 1,2 or 3');\n}\n\n//# sourceMappingURL=get-footpoint-poly-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly1: () => (/* binding */ getFootpointPoly1)\n/* harmony export */ });\n/** @internal */\nfunction getFootpointPoly1(ps, p) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const [xp, yp] = p;\n    const xx0 = x0 - xp;\n    const xx1 = x1 - xp;\n    const yy0 = y0 - yp;\n    const yy1 = y1 - yp;\n    const x01 = xx0 * xx1;\n    const y01 = yy0 * yy1;\n    const s1 = x01 + y01;\n    const s2 = yy0 * yy0 + xx0 * xx0;\n    const t1 = (xx1 * xx1 + yy1 * yy1) + (s2 - 2 * s1);\n    const t0 = s1 - s2;\n    return [t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly2: () => (/* binding */ getFootpointPoly2)\n/* harmony export */ });\n/** @internal */\nfunction getFootpointPoly2(ps, p) {\n    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    //const [xp, yp] = p;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const xp = p[0];\n    const yp = p[1];\n    const xx0 = x0 - xp;\n    const xx1 = x1 - xp;\n    const xx2 = x2 - xp;\n    const yy0 = y0 - yp;\n    const yy1 = y1 - yp;\n    const yy2 = y2 - yp;\n    const x00 = xx0 * xx0;\n    const x01 = xx0 * xx1;\n    const x02 = xx0 * xx2;\n    const x11 = xx1 * xx1;\n    const x12 = xx1 * xx2;\n    const x22 = xx2 * xx2;\n    const y00 = yy0 * yy0;\n    const y01 = yy0 * yy1;\n    const y02 = yy0 * yy2;\n    const y11 = yy1 * yy1;\n    const y12 = yy1 * yy2;\n    const y22 = yy2 * yy2;\n    const q1 = y02 + 2 * y11;\n    const r1 = x02 + 2 * x11;\n    const t3 = ((y22 + y00) + 2 * q1 - 4 * (y12 + y01)) +\n        ((x22 + x00) + 2 * r1 - 4 * (x12 + x01));\n    const t2 = 3 * (((y12 - q1) + (3 * y01 - y00)) +\n        ((x12 - r1) + (3 * x01 - x00)));\n    const t1 = (q1 - 3 * (2 * y01 - y00)) +\n        (r1 - 3 * (2 * x01 - x00));\n    const t0 = (y01 - y00) +\n        (x01 - x00);\n    return [t3, t2, t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly3: () => (/* binding */ getFootpointPoly3)\n/* harmony export */ });\n/** @internal */\nfunction getFootpointPoly3(ps, p) {\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    //const [xp, yp] = p;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const x3 = p3[0];\n    const y3 = p3[1];\n    const xp = p[0];\n    const yp = p[1];\n    const xx0 = x0 - xp;\n    const xx1 = x1 - xp;\n    const xx2 = x2 - xp;\n    const xx3 = x3 - xp;\n    const yy0 = y0 - yp;\n    const yy1 = y1 - yp;\n    const yy2 = y2 - yp;\n    const yy3 = y3 - yp;\n    const x00 = xx0 * xx0;\n    const x01 = 6 * xx0 * xx1;\n    const x02 = 6 * xx0 * xx2;\n    const x03 = 2 * xx0 * xx3;\n    const x11 = 9 * xx1 * xx1;\n    const x12 = 18 * xx1 * xx2;\n    const x13 = 6 * xx1 * xx3;\n    const x22 = 9 * xx2 * xx2;\n    const x23 = 6 * xx2 * xx3;\n    const x33 = xx3 * xx3;\n    const y00 = yy0 * yy0;\n    const y01 = 6 * yy0 * yy1;\n    const y02 = 6 * yy0 * yy2;\n    const y03 = 2 * yy0 * yy3;\n    const y11 = 9 * yy1 * yy1;\n    const y12 = 18 * yy1 * yy2;\n    const y13 = 6 * yy1 * yy3;\n    const y22 = 9 * yy2 * yy2;\n    const y23 = 6 * yy2 * yy3;\n    const y33 = yy3 * yy3;\n    const q1 = x13 + x22;\n    const q2 = x03 + x12;\n    const q3 = x02 + x11;\n    const r1 = y13 + y22;\n    const r2 = y03 + y12;\n    const r3 = y02 + y11;\n    const t5 = 6 * (((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) +\n        ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));\n    const t4 = 5 * ((((x23 + 5 * x01) + 3 * q2) - 2 * (q1 + 2 * q3 + 3 * x00)) +\n        (((y23 + 5 * y01) + 3 * r2) - 2 * (r1 + 2 * r3 + 3 * y00)));\n    const t3 = 4 * (((q1 - 3 * (q2 - 2 * q3)) - 5 * (2 * x01 - 3 * x00)) +\n        ((r1 - 3 * (r2 - 2 * r3)) - 5 * (2 * y01 - 3 * y00)));\n    const t2 = 3 * ((q2 - 2 * (2 * q3 - 5 * (x01 - 2 * x00))) +\n        (r2 - 2 * (2 * r3 - 5 * (y01 - 2 * y00))));\n    const t1 = 2 * ((q3 - 5 * (x01 - 3 * x00)) +\n        (r3 - 5 * (y01 - 3 * y00)));\n    const t0 = ((x01 - 6 * x00) +\n        (y01 - 6 * y00));\n    return [t5, t4, t3, t2, t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly: () => (/* binding */ getFootpointPoly)\n/* harmony export */ });\n/* harmony import */ var _get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-footpoint-poly-1.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js\");\n/* harmony import */ var _get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-footpoint-poly-2.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js\");\n/* harmony import */ var _get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-footpoint-poly-3.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js\");\n\n\n\n/**\n * Returns a polynomial in 1 variable whose roots are the parameter values of\n * the foot points on the given bezier curve of the given point.\n *\n * The returned polynomial coefficients are given densely as an array of\n * double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\n *\n * * intermediate calculations are done in double precision\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\n * @param p\n */\nfunction getFootpointPoly(ps, p) {\n    if (ps.length === 4) {\n        return (0,_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3)(ps, p);\n    }\n    if (ps.length === 3) {\n        return (0,_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2)(ps, p);\n    }\n    if (ps.length === 2) {\n        return (0,_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1)(ps, p);\n    }\n    throw new Error('The given bezier curve must be of order 1,2 or 3');\n}\n\n//# sourceMappingURL=get-footpoint-poly.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly1Exact: () => (/* binding */ getFootpointPoly1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\nconst emn2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultByNeg2;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eDiff;\n/**\n * Returns the *exact* polynomial whose roots are all the `t` values on the\n * given bezier curve such that the line from the given point to the point on\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\n * point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * @param ps an order 1 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @internal\n */\nfunction getFootpointPoly1Exact(ps, p) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const [x, y] = p;\n    const xx0 = td(x0, x);\n    const xx1 = td(x1, x);\n    const yy0 = td(y0, y);\n    const yy1 = td(y1, y);\n    const x00 = emult(xx0, xx0);\n    const x01 = emult(xx0, xx1);\n    const x11 = emult(xx1, xx1);\n    const y00 = emult(yy0, yy0);\n    const y01 = emult(yy0, yy1);\n    const y11 = emult(yy1, yy1);\n    const s1 = eadd(x01, y01);\n    const s2 = eadd(y00, x00);\n    //const t1 = x11 + y11 - 2*s1 + s2;\n    const t1 = eadd(eadd(x11, y11), eadd(emn2(s1), s2));\n    //const t0 = s1 - s2;\n    const t0 = ediff(s1, s2);\n    return [t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly2Exact: () => (/* binding */ getFootpointPoly2Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMultBy2;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eDiff;\n/**\n * Returns the result of multiplying a floating point expansion by 4.\n *\n * * **error free**\n *\n * * see [[Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n *\n * @param e a floating point expansion\n *\n * @internal\n */\nfunction em4(e) {\n    const e_ = [];\n    for (let i = 0; i < e.length; i++) {\n        e_.push(4 * e[i]);\n    }\n    return e_;\n}\n/**\n * Returns the *exact* polynomial whose roots are all the `t` values on the\n * given bezier curve such that the line from the given point to the point on\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\n * point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * @param ps an order 2 curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @internal\n */\nfunction getFootpointPoly2Exact(ps, p) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const [x, y] = p;\n    const xx0 = td(x0, x);\n    const xx1 = td(x1, x);\n    const xx2 = td(x2, x);\n    const yy0 = td(y0, y);\n    const yy1 = td(y1, y);\n    const yy2 = td(y2, y);\n    const x00 = emult(xx0, xx0);\n    const x01 = emult(xx0, xx1);\n    const x02 = emult(xx0, xx2);\n    const x11 = emult(xx1, xx1);\n    const x12 = emult(xx1, xx2);\n    const x22 = emult(xx2, xx2);\n    const y00 = emult(yy0, yy0);\n    const y01 = emult(yy0, yy1);\n    const y02 = emult(yy0, yy2);\n    const y11 = emult(yy1, yy1);\n    const y12 = emult(yy1, yy2);\n    const y22 = emult(yy2, yy2);\n    const q1 = eadd(y02, em2(y11));\n    const r1 = eadd(x02, em2(x11));\n    //const t3 = y22 + 2*q1 - 4*(y12 + y01) + y00 + \n    //           x22 + 2*r1 - 4*(x12 + x01) + x00;\n    const t3a = eadd(ediff(eadd(x22, em2(r1)), em4(eadd(x12, x01))), x00);\n    const t3b = eadd(ediff(eadd(y22, em2(q1)), em4(eadd(y12, y01))), y00);\n    const t3 = eadd(t3a, t3b);\n    //const t2 = 3*(y12 - q1 + 3*y01 - y00 + \n    //              x12 - r1 + 3*x01 - x00);\n    const t2a = eadd(ediff(x12, r1), ediff(sce(3, x01), x00));\n    const t2b = eadd(ediff(y12, q1), ediff(sce(3, y01), y00));\n    const t2 = sce(3, eadd(t2a, t2b));\n    //const t1 = q1 - 3*(2*y01 - y00) + \n    //           r1 - 3*(2*x01 - x00);\n    const t1a = ediff(q1, sce(3, ediff(em2(y01), y00)));\n    const t1b = ediff(r1, sce(3, ediff(em2(x01), x00)));\n    const t1 = eadd(t1a, t1b);\n    //const t0 = y01 - y00 + \n    //           x01 - x00;\n    const t0a = ediff(y01, y00);\n    const t0b = ediff(x01, x00);\n    const t0 = eadd(t0a, t0b);\n    return [t3, t2, t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly3Exact: () => (/* binding */ getFootpointPoly3Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMultBy2;\nconst emn2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultByNeg2;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eDiff;\n/**\n * Returns the *exact* polynomial whose roots are all the `t` values on the\n * given bezier curve such that the line from the given point to the point on\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\n * point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * @param ps an order 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n */\nfunction getFootpointPoly3Exact(ps, p) {\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const x3 = p3[0];\n    const y3 = p3[1];\n    const [x, y] = p;\n    const xx0 = td(x0, x);\n    const xx1 = td(x1, x);\n    const xx2 = td(x2, x);\n    const xx3 = td(x3, x);\n    const yy0 = td(y0, y);\n    const yy1 = td(y1, y);\n    const yy2 = td(y2, y);\n    const yy3 = td(y3, y);\n    const x00 = emult(xx0, xx0);\n    const x01 = sce(6, emult(xx0, xx1));\n    const x02 = sce(6, emult(xx0, xx2));\n    const x03 = em2(emult(xx0, xx3));\n    const x11 = sce(9, emult(xx1, xx1));\n    const x12 = sce(18, emult(xx1, xx2));\n    const x13 = sce(6, emult(xx1, xx3));\n    const x22 = sce(9, emult(xx2, xx2));\n    const x23 = sce(6, emult(xx2, xx3));\n    const x33 = emult(xx3, xx3);\n    const y00 = emult(yy0, yy0);\n    const y01 = sce(6, emult(yy0, yy1));\n    const y02 = sce(6, emult(yy0, yy2));\n    const y03 = em2(emult(yy0, yy3));\n    const y11 = sce(9, emult(yy1, yy1));\n    const y12 = sce(18, emult(yy1, yy2));\n    const y13 = sce(6, emult(yy1, yy3));\n    const y22 = sce(9, emult(yy2, yy2));\n    const y23 = sce(6, emult(yy2, yy3));\n    const y33 = emult(yy3, yy3);\n    const q1 = eadd(x13, x22);\n    const q2 = eadd(x03, x12);\n    const q3 = eadd(x02, x11);\n    const r1 = eadd(y13, y22);\n    const r2 = eadd(y03, y12);\n    const r3 = eadd(y02, y11);\n    //const t5 = 6*((x33 - x23 + q1 - q2 + q3 - x01 + x00) + \n    //              (y33 - y23 + r1 - r2 + r3 - y01 + y00));\n    const t5a = ediff(eadd(eadd(x33, x00), eadd(q1, q3)), (eadd(eadd(q2, x23), x01)));\n    const t5b = ediff(eadd(eadd(y33, y00), eadd(r1, r3)), (eadd(eadd(r2, y23), y01)));\n    const t5 = sce(6, eadd(t5a, t5b));\n    //const t4 = 5*((x23 - 2*(q1 + 2*q3 + 3*x00) + 3*q2 + 5*x01) +\n    //              (y23 - 2*(r1 + 2*r3 + 3*y00) + 3*r2 + 5*y01));\n    const t4a = eadd(emn2(eadd(eadd(q1, em2(q3)), sce(3, x00))), eadd(eadd(x23, sce(3, q2)), sce(5, x01)));\n    const t4b = eadd(emn2(eadd(eadd(r1, em2(r3)), sce(3, y00))), eadd(eadd(y23, sce(3, r2)), sce(5, y01)));\n    const t4 = sce(5, eadd(t4a, t4b));\n    //const t3 = 4*((q1 - 3*(q2 - 2*q3) - 5*(2*x01 - 3*x00)) +\n    //              (r1 - 3*(r2 - 2*r3) - 5*(2*y01 - 3*y00)));\n    const t3a = eadd(eadd(q1, sce(3, (ediff(em2(q3), q2)))), sce(5, (ediff(sce(3, x00), em2(x01)))));\n    const t3b = eadd(eadd(r1, sce(3, (ediff(em2(r3), r2)))), sce(5, (ediff(sce(3, y00), em2(y01)))));\n    const t3 = sce(4, eadd(t3a, t3b));\n    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\n    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\n    const t2a = ediff(q2, em2(ediff(em2(q3), sce(5, (ediff(x01, em2(x00)))))));\n    const t2b = ediff(r2, em2(ediff(em2(r3), sce(5, (ediff(y01, em2(y00)))))));\n    const t2 = sce(3, eadd(t2a, t2b));\n    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +\n    //              (r3 - 5*(y01 - 3*y00)));\n    const t1a = ediff(q3, sce(5, (ediff(x01, sce(3, x00)))));\n    const t1b = ediff(r3, sce(5, (ediff(y01, sce(3, y00)))));\n    const t1 = em2(eadd(t1a, t1b));\n    //const t0 = ((x01 - 6*x00) +\n    //            (y01 - 6*y00));\n    const t0a = ediff(x01, sce(6, x00));\n    const t0b = ediff(y01, sce(6, y00));\n    const t0 = eadd(t0a, t0b);\n    return [t5, t4, t3, t2, t1, t0];\n}\n\n//# sourceMappingURL=get-footpoint-poly-3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPolyExact: () => (/* binding */ getFootpointPolyExact)\n/* harmony export */ });\n/* harmony import */ var _get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-footpoint-poly-1-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js\");\n/* harmony import */ var _get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-footpoint-poly-2-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js\");\n/* harmony import */ var _get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-footpoint-poly-3-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js\");\n\n\n\n/**\n * Returns the *exact* polynomial whose roots are all the `t` values on the\n * given bezier curve such that the line from the given point to the point on\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\n *\n * * The returned polynomial coefficients are given densely as an array of\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\n * point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1],[3,5],[7,1]]`\n * @param p a point, e.g. `[1,2]`\n */\nfunction getFootpointPolyExact(ps, p) {\n    if (ps.length === 4) {\n        return (0,_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3Exact)(ps, p);\n    }\n    if (ps.length === 3) {\n        return (0,_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2Exact)(ps, p);\n    }\n    if (ps.length === 2) {\n        return (0,_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1Exact)(ps, p);\n    }\n    throw new Error('The given bezier curve must be of order 1,2 or 3');\n}\n\n//# sourceMappingURL=get-footpoint-poly-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClosestOnBezier1FromPointErrorCounters: () => (/* binding */ getClosestOnBezier1FromPointErrorCounters),\n/* harmony export */   getClosestOnBezier2FromPointErrorCounters: () => (/* binding */ getClosestOnBezier2FromPointErrorCounters),\n/* harmony export */   getClosestOnBezier3FromPointErrorCounters: () => (/* binding */ getClosestOnBezier3FromPointErrorCounters)\n/* harmony export */ });\nconst abs = Math.abs;\n/**\n * Returns a representation of the error when calculating the polynomial whose\n * roots are all the `t` values on the given bezier curve such that the line\n * from the given point to the point on the bezier evaluated at `t` is tangent\n * to the bezier at `t`.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * ```\n * return [\n *      t5_,  // <9>\n *      t4_,  // <10>\n *      t3_,  // <10>\n *      t2_,  // <10>\n *      t1_,  // <9>\n *      t0_   // <7>\n * ];\n * ```\n *\n * @internal\n */\nfunction getClosestOnBezier3FromPointErrorCounters(ps, p) {\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    //const [xp, yp] = p;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0_ = abs(p0[0]); // <0>  (error counters)\n    const y0_ = abs(p0[1]); // <0>\n    const x1_ = abs(p1[0]); // <0>\n    const y1_ = abs(p1[1]); // <0>\n    const x2_ = abs(p2[0]); // <0>\n    const y2_ = abs(p2[1]); // <0>\n    const x3_ = abs(p3[0]); // <0>\n    const y3_ = abs(p3[1]); // <0>\n    const xp_ = abs(p[0]); // <0>\n    const yp_ = abs(p[1]); // <0>\n    // <1>xx0 <-- <1>(x0 - xp);\n    const xx0_ = x0_ + xp_;\n    // <1>xx1 <-- <1>(x1 - xp);\n    const xx1_ = x1_ + xp_;\n    // <1>xx2 <-- <1>(x2 - xp);\n    const xx2_ = x2_ + xp_;\n    // <1>xx3 <-- <1>(x3 - xp);\n    const xx3_ = x3_ + xp_;\n    // <1>yy0 <-- <1>(y0 - yp);\n    const yy0_ = y0_ + yp_;\n    // <1>yy1 <-- <1>(y1 - yp);\n    const yy1_ = y1_ + yp_;\n    // <1>yy2 <-- <1>(y2 - yp);\n    const yy2_ = y2_ + yp_;\n    // <1>yy3 <-- <1>(y3 - yp);\n    const yy3_ = y3_ + yp_;\n    // <3>x00 <-- <3>(<1>xx0*<1>xx0);\n    const x00_ = xx0_ * xx0_;\n    // <4>x01 <-- <4>(6 *<3>(<1>xx0*<1>xx1));\n    const x01_ = 6 * xx0_ * xx1_;\n    // <4>x02 <-- <4>(6 *<3>(<1>xx0*<1>xx2));\n    const x02_ = 6 * xx0_ * xx2_;\n    // <3>x03 <-- 2 *<3>(<1>xx0*<1>xx3);\n    const x03_ = 2 * xx0_ * xx3_;\n    // <4>x11 <-- <4>(9 *<3>(<1>xx1*<1>xx1));\n    const x11_ = 9 * xx1_ * xx1_;\n    // <4>x12 <-- <4>(18*<3>(<1>xx1*<1>xx2));\n    const x12_ = 18 * xx1_ * xx2_;\n    // <4>x13 <-- <4>(6 *<3>(<1>xx1*<1>xx3));\n    const x13_ = 6 * xx1_ * xx3_;\n    // <4>x22 <-- <4>(9 *<3>(<1>xx2*<1>xx2));\n    const x22_ = 9 * xx2_ * xx2_;\n    // <4>x23 <-- <4>(6 *<3>(<1>xx2*<1>xx3));\n    const x23_ = 6 * xx2_ * xx3_;\n    // <3>x33 <--    <3>(<1>xx3*<1>xx3);\n    const x33_ = xx3_ * xx3_;\n    const y00_ = yy0_ * yy0_;\n    const y01_ = 6 * yy0_ * yy1_;\n    const y02_ = 6 * yy0_ * yy2_;\n    const y03_ = 2 * yy0_ * yy3_;\n    const y11_ = 9 * yy1_ * yy1_;\n    const y12_ = 18 * yy1_ * yy2_;\n    const y13_ = 6 * yy1_ * yy3_;\n    const y22_ = 9 * yy2_ * yy2_;\n    const y23_ = 6 * yy2_ * yy3_;\n    const y33_ = yy3_ * yy3_;\n    // <5>q1 <-- (5>(<4>x13 + <4>x22);\n    const q1_ = x13_ + x22_;\n    // <5>q2 <-- (5>(<3>x03 + <4>x12);\n    const q2_ = x03_ + x12_;\n    // <5>q3 <-- (5>(<4>x02 + <4>x11);\n    const q3_ = x02_ + x11_;\n    const r1_ = y13_ + y22_; // <5>\n    const r2_ = y03_ + y12_; // <5>\n    const r3_ = y02_ + y11_; // <5>\n    // <9>t5 <-- <9>(6*<8>(<7>(<6>(<5>(<4>(x33 - x23) + <4>(x00 - x01)) + <5>q1) + <6>(q3 - q2)) + \n    //                     <7>(<6>(<5>(<4>(y33 - y23) + <4>(y00 - y01)) + <5>r1) + <6>(r3 - r2))));\n    const t5_ = 6 * (((((x33_ + x23_) + (x00_ + x01_)) + q1_) + (q3_ + q2_)) +\n        ((((y33_ + y23_) + (y00_ + y01_)) + r1_) + (r3_ + r2_)));\n    // <10>t4 <-- <10>(5*<9>(<8>(<7>(<6>(x23 + <5>(5*x01)) + <6>(3*q2)) - 2*<7>(<6>(q1 + 2*q3) + <5>(3*x00))) +\n    //                       <8>(<7>(<6>(y23 + <5>(5*y01)) + <6>(3*r2)) - 2*<7>(<6>(r1 + 2*r3) + <5>(3*y00)))));\n    const t4_ = 5 * ((((x23_ + 5 * x01_) + 3 * q2_) + 2 * (q1_ + 2 * q3_ + 3 * x00_)) +\n        (((y23_ + 5 * y01_) + 3 * r2_) + 2 * (r1_ + 2 * r3_ + 3 * y00_)));\n    // <10>t3 <-- 4*<10>(<9>(<8>(q1 - <7>(3*<6>(q2 - 2*q3))) - <7>(5*<6>(2*x01 - <5>(3*x00)))) +\n    //                 <9>(<8>(r1 - <7>(3*<6>(r2 - 2*r3))) - <7>(5*<6>(2*y01 - <5>(3*y00)))))\n    const t3_ = 4 * (((q1_ + 3 * (q2_ + 2 * q3_)) + 5 * (2 * x01_ + 3 * x00_)) +\n        ((r1_ + 3 * (r2_ + 2 * r3_)) + 5 * (2 * y01_ + 3 * y00_)));\n    // <10>t2 <-- <10>(3*<9>(<8>(q2 - 2*<7>(2*q3 - <6>(5*<5>(x01 - 2*x00)))) +\n    //                       <8>(r2 - 2*<7>(2*r3 - <6>(5*<5>(y01 - 2*y00))))));\n    const t2_ = 3 * ((q2_ + 2 * (2 * q3_ + 5 * (x01_ + 2 * x00_))) +\n        (r2_ + 2 * (2 * r3_ + 5 * (y01_ + 2 * y00_))));\n    // <9>t1 <-- 2*<9>(<8>(q3 - <7>(5*<6>(x01 - <5>(3*x00)))) +\n    //                 <8>(r3 - <7>(5*<6>(y01 - <5>(3*y00)))));\n    const t1_ = 2 * ((q3_ + 5 * (x01_ + 3 * x00_)) +\n        (r3_ + 5 * (y01_ + 3 * y00_)));\n    // <7>t0 <-- <7>(<6>(x01 - <5>(6*x00)) +\n    //              <6>(y01 - <5>(6*y00)));\n    const t0_ = ((x01_ + 6 * x00_) +\n        (y01_ + 6 * y00_));\n    return [\n        t5_,\n        t4_,\n        t3_,\n        t2_,\n        t1_,\n        t0_ // <7>\n    ];\n}\n/**\n * Returns a representation of the error when calculating the polynomial whose\n * roots are all the `t` values on the given bezier curve such that the line\n * from the given point to the point on the bezier evaluated at `t` is tangent\n * to the bezier at `t`.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param p a point, e.g. `[1,2]`\n * ```\n * return [\n *      t3_,  // <7>\n *      t2_,  // <8>\n *      t1_,  // <7>\n *      t0_   // <5>\n * ];\n * ```\n *\n * @internal\n */\nfunction getClosestOnBezier2FromPointErrorCounters(ps, p) {\n    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    //const [xp, yp] = p;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0_ = abs(p0[0]); // <0>\n    const y0_ = abs(p0[1]); // <0>\n    const x1_ = abs(p1[0]); // <0>\n    const y1_ = abs(p1[1]); // <0>\n    const x2_ = abs(p2[0]); // <0>\n    const y2_ = abs(p2[1]); // <0>\n    const xp_ = abs(p[0]); // <0>\n    const yp_ = abs(p[1]); // <0>\n    // <1>xx0 <-- <1>(x0 - xp);\n    const xx0_ = x0_ + xp_;\n    // <1>xx1 <-- <1>(x1 - xp);\n    const xx1_ = x1_ + xp_;\n    // <1>xx2 <-- <1>(x2 - xp);\n    const xx2_ = x2_ + xp_;\n    // <1>yy0 <-- <1>(y0 - yp);\n    const yy0_ = y0_ + yp_;\n    // <1>yy1 <-- <1>(y1 - yp);\n    const yy1_ = y1_ + yp_;\n    // <1>yy2 <-- <1>(y2 - yp);\n    const yy2_ = y2_ + yp_;\n    // <3>x00 <-- <3>(xx0*xx0);\n    const x00_ = xx0_ * xx0_;\n    // <3>x01 <-- <3>(xx0*xx1);\n    const x01_ = xx0_ * xx1_;\n    // <3>x02 <-- <3>(xx0*xx2);\n    const x02_ = xx0_ * xx2_;\n    // <3>x11 <-- <3>(xx1*xx1);\n    const x11_ = xx1_ * xx1_;\n    // <3>x12 <-- <3>(xx1*xx2);\n    const x12_ = xx1_ * xx2_;\n    // <3>x22 <-- <3>(xx2*xx2);\n    const x22_ = xx2_ * xx2_;\n    const y00_ = yy0_ * yy0_;\n    const y01_ = yy0_ * yy1_;\n    const y02_ = yy0_ * yy2_;\n    const y11_ = yy1_ * yy1_;\n    const y12_ = yy1_ * yy2_;\n    const y22_ = yy2_ * yy2_;\n    // <4>q1 <-- <4>(y02 + 2*y11);\n    const q1_ = y02_ + 2 * y11_;\n    // <4>r1 <-- <4>(x02 + 2*x11);\n    const r1_ = x02_ + 2 * x11_;\n    // <7>t3 <-- <7>(<6>(<5>(<4>(y22 + y00) + 2*q1) - 4*<4>(y12 + y01))) + \n    //              (<6>(<5>(<4>(x22 + x00) + 2*r1) - 4*<4>(x12 + x01)));\n    const t3_ = ((y22_ + y00_) + 2 * q1_ + 4 * (y12_ + y01_)) +\n        ((x22_ + x00_) + 2 * r1_ + 4 * (x12_ + x01_));\n    // <8>t2 <-- <8>(3*<7>(<6>(<5>(y12 - q1) + <5>(<4>(3*y01) - y00)) + \n    //                     <6>(<5>(x12 - r1) + <5>(<4>(3*x01) - x00))));\n    const t2_ = 3 * (((y12_ + q1_) + (3 * y01_ + y00_)) +\n        ((x12_ + r1_) + (3 * x01_ + x00_)));\n    // <7>t1 <-- <7>(<6>(<4>q1 - <5>(3*<4>(2*y01 - y00))) + \n    //               <6>(<4>r1 - <5>(3*<4>(2*x01 - x00))));\n    const t1_ = (q1_ + 3 * (2 * y01_ + y00_)) +\n        (r1_ + 3 * (2 * x01_ + x00_));\n    // <5>t0 <-- <5>(<4>(y01 - y00) + \n    //              <4>(x01 - x00));\n    const t0_ = (y01_ + y00_) +\n        (x01_ + x00_);\n    return [\n        t3_,\n        t2_,\n        t1_,\n        t0_ // <5>\n    ];\n}\n/**\n * Returns a representation of the error when calculating the polynomial whose\n * roots are all the `t` values on the given bezier curve such that the line\n * from the given point to the point on the bezier evaluated at `t` is tangent\n * to the bezier at `t`.\n *\n * @param ps a linear bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param p a point, e.g. `[1,2]`\n *\n * ```\n * return [\n *     t1,  // <6>\n *     t0   // <5>\n * ];\n * ```\n *\n * @internal\n */\nfunction getClosestOnBezier1FromPointErrorCounters(ps, p) {\n    //const [[x0, y0], [x1, y1]] = ps;\n    //const [xp, yp] = p;\n    const p0 = ps[0];\n    const p1 = ps[1];\n    const x0_ = abs(p0[0]); // <0>\n    const y0_ = abs(p0[1]); // <0>\n    const x1_ = abs(p1[0]); // <0>\n    const y1_ = abs(p1[1]); // <0>\n    const xp_ = abs(p[0]); // <0>\n    const yp_ = abs(p[1]); // <0>\n    // <1>xx0 <-- <1>(x0 - xp);\n    const xx0_ = x0_ + xp_;\n    // <1>xx1 <-- <1>(x1 - xp);    \n    const xx1_ = x1_ + xp_;\n    // <1>yy0 <-- <1>(y0 - yp);    \n    const yy0_ = y0_ + yp_;\n    // <1>yy1 <-- <1>(y1 - yp);    \n    const yy1_ = y1_ + yp_;\n    // <3>x00 <-- <3>(xx0*xx0);\n    const x00_ = xx0_ * xx0_;\n    // <3>x01 <-- <3>(xx0*xx1);\n    const x01_ = xx0_ * xx1_;\n    // <3>x11 <-- <3>(xx1*xx1);\n    const x11_ = xx1_ * xx1_;\n    const y00_ = yy0_ * yy0_;\n    const y01_ = yy0_ * yy1_;\n    const y11_ = yy1_ * yy1_;\n    // <4>s1 <-- <4>(x01 + y01);\n    const s1_ = x01_ + y01_;\n    // <4>s2 <-- <4>(y00 + x00);\n    const s2_ = y00_ + x00_;\n    // <6>t1 = <6>(<4>(x11 + y11) + <5>(s2 - 2*s1));\n    const t1 = x11_ + y11_ + 2 * s1_ + s2_;\n    // <5>t0 = <5>(s1 - s2);\n    const t0 = s1_ + s2_;\n    return [\n        t1,\n        t0 // <5>\n    ];\n}\n\n//# sourceMappingURL=get-closest-on-bezier-from-point-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-on-bezier-certified.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-on-bezier-certified.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootPointsOnBezierCertified: () => (/* binding */ getFootPointsOnBezierCertified)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-3-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js\");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-2-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js\");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-1-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-3-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-2-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-1-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js\");\n/* harmony import */ var _get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs/get-closest-on-bezier-from-point-error-counters.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst γγ6 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γγ\"])(6);\n/**\n * Returns the footpoint(s) (and parameter `t` value(s)) on the\n * given bezier curve to the given point (with `t ∈ [0,1]`).\n *\n * * guaranteed accurate to within `4*Number.EPSILON` in the returned `t`\n * value(s)\n * * the returned point(s) are objects with the following properties:\n *     * `p`: the best estimate point on the bezier curve (calculated from the root interval `ri`)\n *     * `t`: the best estimate `t` parameter value (calculated from the root interval `ri`)\n *     * `d`: the best estimate closest distance from the point to the bezier curve (calculated from the root interval `ri`)\n *     * `ri`: a root interval guaranteed to contain the actual `t` value\n *     * `box`: a small box guaranteed to contain the relevant point on the bezier curve\n *     * `dSquaredI`: a small squared distance interval guaranteed to contain the actual distance squared\n *        between the point and the bezier curve\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @doc\n */\nfunction getFootPointsOnBezierCertified(ps, p, lb = 0, ub = 1) {\n    const order = ps.length - 1;\n    let ris;\n    if (order === 3) {\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly3Dd)(ps, p), lb, ub, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_3__.getClosestOnBezier3FromPointErrorCounters)(ps, p).map(e => 10 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_4__.getFootpointPoly3Exact)(ps, p));\n    }\n    else if (order === 2) {\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_5__.getFootpointPoly2Dd)(ps, p), lb, ub, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_3__.getClosestOnBezier2FromPointErrorCounters)(ps, p).map(e => 8 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_6__.getFootpointPoly2Exact)(ps, p));\n    }\n    else if (order === 1) {\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_7__.getFootpointPoly1Dd)(ps, p), lb, ub, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_3__.getClosestOnBezier1FromPointErrorCounters)(ps, p).map(e => 6 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_8__.getFootpointPoly1Exact)(ps, p));\n    }\n    else if (order === 0) {\n        return [];\n    }\n    else {\n        throw new Error('The given bezier curve must be of order <= 3');\n    }\n    return ris;\n}\n\n//# sourceMappingURL=get-foot-points-on-bezier-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-on-bezier-certified.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootPointsOnBezierPolysCertified: () => (/* binding */ getFootPointsOnBezierPolysCertified)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-3-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js\");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-2-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js\");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-1-dd.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-3-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-2-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-1-exact.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js\");\n/* harmony import */ var _get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/get-closest-on-bezier-from-point-error-counters.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\n\n\n\n\n\n\n\n\n\nconst γγ6 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γγ\"])(6);\n/**\n * Returns the footpoint(s) (and parameter `t` value(s)) on the\n * given bezier curve to the given point (with `t ∈ [0,1]`).\n *\n * * guaranteed accurate to within `4*Number.EPSILON` in the returned `t`\n * value(s)\n * * the returned point(s) are objects with the following properties:\n *     * `p`: the best estimate point on the bezier curve (calculated from the root interval `ri`)\n *     * `t`: the best estimate `t` parameter value (calculated from the root interval `ri`)\n *     * `d`: the best estimate closest distance from the point to the bezier curve (calculated from the root interval `ri`)\n *     * `ri`: a root interval guaranteed to contain the actual `t` value\n *     * `box`: a small box guaranteed to contain the relevant point on the bezier curve\n *     * `dSquaredI`: a small squared distance interval guaranteed to contain the actual distance squared\n *        between the point and the bezier curve\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param p a point, e.g. `[1,2]`\n *\n * @doc\n */\nfunction getFootPointsOnBezierPolysCertified(ps, p) {\n    const order = ps.length - 1;\n    if (order === 3) {\n        return {\n            polyDd: (0,_get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly3Dd)(ps, p),\n            polyE: (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_2__.getClosestOnBezier3FromPointErrorCounters)(ps, p).map(e => 10 * γγ6 * e),\n            getPolyExact: () => (0,_get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_3__.getFootpointPoly3Exact)(ps, p)\n        };\n    }\n    else if (order === 2) {\n        return {\n            polyDd: (0,_get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_4__.getFootpointPoly2Dd)(ps, p),\n            polyE: (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_2__.getClosestOnBezier2FromPointErrorCounters)(ps, p).map(e => 8 * γγ6 * e),\n            getPolyExact: () => (0,_get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_5__.getFootpointPoly2Exact)(ps, p)\n        };\n    }\n    else if (order === 1) {\n        return {\n            polyDd: (0,_get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_6__.getFootpointPoly1Dd)(ps, p),\n            polyE: (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_2__.getClosestOnBezier1FromPointErrorCounters)(ps, p).map(e => 6 * γγ6 * e),\n            getPolyExact: () => (0,_get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getFootpointPoly1Exact)(ps, p)\n        };\n    }\n    else if (order === 0) {\n        return {\n            polyDd: [[0, 1]],\n            polyE: [0],\n            getPolyExact: () => [[1]]\n        };\n    }\n    else {\n        throw new Error('The given bezier curve must be of order <= 3');\n    }\n}\n\n//# sourceMappingURL=get-foot-points-polys-on-bezier-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/root-interval-to-distance-squared-interval.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/root-interval-to-distance-squared-interval.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rootIntervalToDistanceSquaredInterval: () => (/* binding */ rootIntervalToDistanceSquaredInterval)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMult;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eAdd;\nconst eps = Number.EPSILON;\n/**\n * Returns the distance interval squared given the root interval (currently\n * ignoring multiplicity)\n *\n * @param box\n * @param p\n *\n * @internal\n */\nfunction rootIntervalToDistanceSquaredInterval(box, p) {\n    const bl = box[0];\n    const tr = box[1];\n    const minX = bl[0];\n    const minY = bl[1];\n    const maxX = tr[0];\n    const maxY = tr[1];\n    const x = p[0]; // <0>\n    const y = p[1]; // <0>\n    let minDSquared = Number.POSITIVE_INFINITY;\n    let maxDSquared = Number.NEGATIVE_INFINITY;\n    // for each corner of the interval box\n    for (const [a, b] of [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]]) {\n        /*\n        // distance to 1st corner of interval box - `distance² = x² + y²`\n        const dc1 = (a - x)**2 + (b - y)**2;\n        // max absolute roundoff error of `dc1`\n        // <4>dc1 <-- <4>(<3>(<1>(a - x)**2) + <3>(<1>((b - y)**2))\n        const dc1E = 4*γ1*((a + x)**2 + (b + y)**2);\n        const dc1Min = dc1 - dc1E;  // distance minus max error\n        const dc1Max = dc1 + dc1E;  // distance plus max error\n        */\n        /** distance to 1st corner of interval box - `distance² = x² + y²` */\n        const ax = td(a, x); // a - x\n        const by = td(b, y); // b - y\n        const dc1Exact = eadd(emult(ax, ax), emult(by, by)); // ax**2 + bx**2\n        const dc1 = estimate(dc1Exact);\n        const dc1Min = dc1 * (1 - eps); // distance minus max error\n        const dc1Max = dc1 * (1 + eps); // distance plus max error\n        if (dc1Min <= minDSquared) {\n            minDSquared = dc1Min;\n        }\n        if (dc1Max >= maxDSquared) {\n            maxDSquared = dc1Max;\n        }\n    }\n    return [minDSquared, maxDSquared];\n}\n\n//# sourceMappingURL=root-interval-to-distance-squared-interval.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/root-interval-to-distance-squared-interval.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/closest-distance-between-beziers.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/closest-distance-between-beziers.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointsBetweenBeziers: () => (/* binding */ closestPointsBetweenBeziers)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var _error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../error-analysis/max-abs-coordinate.js */ \"./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js\");\n/* harmony import */ var _get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-min-max-distance.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/get-min-max-distance.js\");\n/* harmony import */ var _distance_compare_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./distance-compare.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/distance-compare.js\");\n/* harmony import */ var _heap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../heap.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/heap.js\");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../transformation/split/from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../closest-and-furthest-point-on-bezier/closest-point-on-bezier.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js\");\n\n\n\n\n\n\n\n\n\n/** @internal */\nconst { min, max } = Math;\n// We need to calculate `dMin(A,B)`, the minimum distance between\n// bezier curves `A` and `B`.\n// Let: ωf(σ) = sup{ |f(t) − f(t′)| : t, t′ ∈ [a,b] with |t − t′| ≤ σ }\n// where: δS = max[ (1 ≤ i ≤ M+1)(ti − ti−1) ] is the maximum distance between \n// two consecutive parameter values\n// Lemma 2.1: \n//   h(A,S) ≤ ωf(δS/2) and\n//   h(B,T) ≤ ωg(δT/2)\n// Theorem 2.3: (both curves discretized)\n//   |h(S,T) − h(A,B)| ≤ max[ h(A,S), h(B,T) ] \n//                     ≤ max[ ωf(δS/2), ωg(δT/2) ]\n// (only A discretized)\n// |h(S,B) − h(A,B)| ≤ ωf(δS/2)\n/**\n * Calculates and returns an accurate approximation to the minimum distance\n * between the two given bezier curves. (Actually returns the parameter values\n * from which the distance can then easily be calculated.)\n *\n * * partially based off [Computing the Hausdorff distance between two sets of parametric curves](https://www.semanticscholar.org/paper/COMPUTING-THE-HAUSDORFF-DISTANCE-BETWEEN-TWO-SETS-Kim-McLean/d2bd6529c4b118e389e1db209d8f1bf7467f9016)\n *\n * @param A a bezier curve given by an ordered array of its\n * control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param B a bezier curve given by an ordered array of its\n * control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param tolerance optional; defaults to `Math.max(maxAbsCoordinate(A),maxAbsCoordinate(B))/1000_000`;\n * if the calculated absolute error bound is less than this, the result is\n * returned; this is *not* a hard tolerance and the bound can be less\n * accurate in hard cases (due to the `maxIterations` parameter). Luckily\n * however, specifically the upper bound will be very accurate due to\n * its fast convergence in such hard cases (see the paper)\n * @param maxIterations optional; defaults to `50`; if the desired guaranteed error bound\n * has not been achieved after `maxIterations` then the result will be returned\n *\n * @doc mdx\n */\nfunction closestPointsBetweenBeziers(A, B, tolerance, maxIterations = 50) {\n    if (A.length === 1) {\n        const cp = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[0]);\n        return [{ pA: { p: A[0], t: 0 }, pB: cp, d: cp.d }];\n    }\n    if (B.length === 1) {\n        const cp = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(A, B[0]);\n        return [{ pA: cp, pB: { p: B[0], t: 0 }, d: cp.d }];\n    }\n    if (A.length === 2 && B.length === 2) {\n        // Seperately handle the simple case of two lines\n        // Find minimum distance from endpoints of A to B:\n        const EA0 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[0]);\n        const EA1 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[1]);\n        // Find minimum distance from endpoints of B to A:\n        const EB0 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(A, B[0]);\n        const EB1 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(A, B[1]);\n        const cps = [EA0, EA1, EB0, EB1].sort((a, b) => a.d - b.d);\n        const d = cps[0].d;\n        const pwds = [];\n        if (EA0.d === d) {\n            pwds.push({ pA: { p: A[0], t: 0 }, pB: EA0, d });\n        }\n        if (EA1.d === d) {\n            pwds.push({ pA: { p: A[1], t: 1 }, pB: EA1, d });\n        }\n        if (EB0.d === d) {\n            pwds.push({ pA: EB0, pB: { p: B[0], t: 0 }, d });\n        }\n        if (EB1.d === d) {\n            pwds.push({ pA: EB1, pB: { p: B[1], t: 1 }, d });\n        }\n        return pwds;\n    }\n    const l = max((0,_error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_1__.maxAbsCoordinate)(A), (0,_error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_1__.maxAbsCoordinate)(B));\n    tolerance = tolerance || l / 1000000;\n    // an array of intervals\n    const [eL, eR] = calcHErrorBound(A, 0, 1);\n    const dL = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[0]).d;\n    const dR = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[A.length - 1]).d;\n    const initialInterval = {\n        tS: 0, tE: 1, dL, dR, eL, eR, pL: A[0], pR: A[A.length - 1]\n    };\n    // const heap = new Heap(distanceCompareMaxAsc);\n    const heap = new _heap_js__WEBPACK_IMPORTED_MODULE_2__.Heap(_distance_compare_js__WEBPACK_IMPORTED_MODULE_3__.distanceCompareMinDesc);\n    heap.insert(initialInterval);\n    let j = 0;\n    let bestUpperD = Number.POSITIVE_INFINITY;\n    let bestLowerD = Number.NEGATIVE_INFINITY;\n    let bestUpper;\n    while (true) {\n        // const interval = heap.heap[0];  // peek max\n        const interval = heap.heap[0]; // peek min\n        const { tS, tE, dL, dR, pL, pR } = interval;\n        const tM = (tS + tE) / 2;\n        const [eLL, eLR] = calcHErrorBound(A, tS, tM);\n        const [eRL, eRR] = calcHErrorBound(A, tM, tE);\n        //---- get dM ---------------------------\n        const pM = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_4__.evalDeCasteljau)(A, tM);\n        const pB = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, pM);\n        const dM = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.distanceBetween)(pM, pB.p);\n        //---------------------------------------\n        // const h = max(dL, dM, dR);\n        const d = min(dL, dM, dR);\n        if (d < bestUpperD) {\n            bestUpperD = d;\n            if (dL <= dM && dL <= dR) {\n                bestUpper = { pA: { p: pL, t: tS }, pB, d };\n            }\n            else if (dM <= dL && dM <= dR) {\n                bestUpper = { pA: { p: pM, t: tM }, pB, d };\n            }\n            else if (dR <= dL && dR <= dM) {\n                bestUpper = { pA: { p: pR, t: tE }, pB, d };\n            }\n        }\n        // bestHUpper = getMaxDistance(interval);\n        bestLowerD = (0,_get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_6__.getMinDistance)(interval);\n        if (bestUpperD - bestLowerD < tolerance) {\n            // The upper bound is by far the best approximation for difficult cases (see the paper).\n            return [bestUpper];\n        }\n        if (j++ > maxIterations) {\n            // The upper bound is by far the best approximation for difficult cases (see the paper).\n            return [bestUpper];\n        }\n        const iL = { tS: tS, tE: tM, dL: dL, dR: dM, eL: eLL, eR: eLR, pL: pL, pR: pM };\n        const iR = { tS: tM, tE: tE, dL: dM, dR: dR, eL: eRL, eR: eRR, pL: pM, pR: pR };\n        heap.swapMinOrMax(iL);\n        heap.insert(iR);\n    }\n}\n// Let: ωf(σ) = sup{ |f(t) − f(t′)| : t, t′ ∈ [a,b] with |t − t′| ≤ σ }\n//\n// |h(S,B) − h(A,B)| ≤ ωf(δS/2)\n// where: δS = max_(1≤i≤M+1)[ (ti − ti−1) ] is the maximum distance between \n// two consecutive parameter values\n/**\n * @internal\n */\nfunction calcHErrorBound(A, tS, tE) {\n    // To calculate an upper bound for ωf(δS/2) we can either check the max \n    // absolute tangent values on curve segments or use the control point \n    // lengths as an upper bound.\n    const tM = (tE + tS) / 2; // since the formula says `δS/2` so divide by 2\n    const psL = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_7__.fromTo)(A, tS, tM);\n    const psR = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_7__.fromTo)(A, tM, tE);\n    const eL = (0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_8__.controlPointLinesLength)(psL);\n    const eR = (0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_8__.controlPointLinesLength)(psR);\n    return [eL, eR];\n}\n\n//# sourceMappingURL=closest-distance-between-beziers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/closest-distance-between-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/distance-compare.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/distance-compare.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   distanceCompareMaxAsc: () => (/* binding */ distanceCompareMaxAsc),\n/* harmony export */   distanceCompareMinDesc: () => (/* binding */ distanceCompareMinDesc)\n/* harmony export */ });\n/* harmony import */ var _get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-min-max-distance.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/get-min-max-distance.js\");\n\n/**\n * @param a\n * @param b\n *\n * @internal\n */\nfunction distanceCompareMaxAsc(a, b) {\n    const diff = ((0,_get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_0__.getMaxDistance)(a) - (0,_get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_0__.getMaxDistance)(b));\n    if (diff !== 0) {\n        return diff;\n    }\n    return a.tS - b.tS;\n}\n/** @internal */\nfunction distanceCompareMinDesc(a, b) {\n    const diff = ((0,_get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_0__.getMinDistance)(b) - (0,_get_min_max_distance_js__WEBPACK_IMPORTED_MODULE_0__.getMinDistance)(a));\n    if (diff !== 0) {\n        return diff;\n    }\n    return a.tS - b.tS;\n}\n\n//# sourceMappingURL=distance-compare.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/distance-compare.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/get-min-max-distance.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/get-min-max-distance.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMaxDistance: () => (/* binding */ getMaxDistance),\n/* harmony export */   getMinDistance: () => (/* binding */ getMinDistance)\n/* harmony export */ });\nconst { min, max } = Math;\n/** @internal */\nfunction getMaxDistance(i) {\n    return max(i.dL + i.eL, i.dR + i.eR);\n}\n/** @internal */\nfunction getMinDistance(i) {\n    return min(i.dL - i.eL, i.dR - i.eR);\n}\n\n//# sourceMappingURL=get-min-max-distance.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/closest-distance-between-beziers/get-min-max-distance.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/equal.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/equal.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equal: () => (/* binding */ equal)\n/* harmony export */ });\n/**\n * Returns `true` if the two given bezier curves are exactly equal when compared\n * by value (deep equality), `false` otherwise\n *\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param ps2 another bezier curve\n *\n * @doc\n */\nfunction equal(ps1, ps2) {\n    if (ps1 === ps2) {\n        return true;\n    }\n    if (ps1.length !== ps2.length) {\n        return false;\n    }\n    for (let i = 0; i < ps1.length; i++) {\n        if (ps1[i][0] !== ps2[i][0] || ps1[i][1] !== ps2[i][1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/equal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInterfaceRotation: () => (/* binding */ getInterfaceRotation)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n\n\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\nconst ddAddDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst ddDiffDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\nconst { atan2 } = Math;\n/**\n * Returns the rotation angle (-𝜋 <= θ <= 𝜋 *guaranteed*) from some vector to\n * another vector considering them to both start at the same point.\n *\n * If one of the vectors is the zero vector then `0` is returned.\n *\n * It can also be imagined that the 2nd vector starts where the 1st one ends.\n *\n * Intermediate calculations are done in double precision in a numerically\n * stable manner.\n *\n * @param a the first 2d vector given as `[x,y]` where `x` and `y` are the\n * coordinates, e.g. `[2,3]`\n * @param b the second 2d vector\n */\nfunction getInterfaceRotation(a, b) {\n    const v1 = a[0];\n    const v2 = a[1];\n    const w1 = b[0];\n    const w2 = b[1];\n    const A = ddDiffDd(tp(w2, v1), tp(w1, v2))[1];\n    const B = ddAddDd(tp(w1, v1), tp(w2, v2))[1];\n    return atan2(A, B);\n}\n\n//# sourceMappingURL=get-interface-rotation.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMaxHausdorff: () => (/* binding */ getMaxHausdorff)\n/* harmony export */ });\n/** @internal */\nfunction getMaxHausdorff(i) {\n    return Math.max(i.hL + i.hEL, i.hR + i.hER);\n}\n\n//# sourceMappingURL=get-max-hausdorff.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hausdorffCompare: () => (/* binding */ hausdorffCompare)\n/* harmony export */ });\n/* harmony import */ var _get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-hausdorff.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js\");\n\n/**\n * @param a\n * @param b\n *\n * @internal\n */\nfunction hausdorffCompare(a, b) {\n    const diff = ((0,_get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_0__.getMaxHausdorff)(a) - (0,_get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_0__.getMaxHausdorff)(b));\n    if (diff !== 0) {\n        return diff;\n    }\n    //diff = a.tS - b.tS;\n    //if (diff !== 0) { return diff; }\n    //return a.tE - b.tE;\n    return a.tS - b.tS;\n}\n\n//# sourceMappingURL=hausdorff-compare.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hausdorffDistanceOneSided: () => (/* binding */ hausdorffDistanceOneSided)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../closest-and-furthest-point-on-bezier/closest-point-on-bezier.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js\");\n/* harmony import */ var _closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js\");\n/* harmony import */ var _error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../error-analysis/max-abs-coordinate.js */ \"./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js\");\n/* harmony import */ var _get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-max-hausdorff.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js\");\n/* harmony import */ var _hausdorff_compare_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hausdorff-compare.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js\");\n/* harmony import */ var _heap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../heap.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/heap.js\");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transformation/split/from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n\n\n\n\n\n\n\n\n\n\n/** @internal */\nconst max = Math.max;\n// We need to calculate `H(A,B)`, the two sided Hausdorff distance between\n// the bezier curves `A` and `B` which equals `max(h(A,B), h(B,A))`, where\n// `h(A,B)` is the one sided Hausdorff distance from `A` to `B`\n// Let: ωf(σ) = sup{ |f(t) − f(t′)| : t, t′ ∈ [a,b] with |t − t′| ≤ σ }\n// where: δS = max[ (1 ≤ i ≤ M+1)(ti − ti−1) ] is the maximum distance between \n// two consecutive parameter values\n// Lemma 2.1: \n//   h(A,S) ≤ ωf(δS/2) and\n//   h(B,T) ≤ ωg(δT/2)\n// Theorem 2.3: (both curves discretized)\n//   |h(S,T) − h(A,B)| ≤ max[ h(A,S), h(B,T) ] \n//                     ≤ max[ ωf(δS/2), ωg(δT/2) ]\n//  \n// (only A discretized)\n// |h(S,B) − h(A,B)| ≤ ωf(δS/2)\n/**\n * Calculates and returns an accurate approximation to the one-sided Hausdorff\n * distance from the bezier curve `A` to the bezier curve `B`.\n *\n * * partially based off [Computing the Hausdorff distance between two sets of parametric curves](https://www.semanticscholar.org/paper/COMPUTING-THE-HAUSDORFF-DISTANCE-BETWEEN-TWO-SETS-Kim-McLean/d2bd6529c4b118e389e1db209d8f1bf7467f9016)\n *\n * @param A a bezier curve (the 'from' curve) given by an ordered array of its\n * control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param B a bezier curve (the 'to' curve) given by an ordered array of its\n * control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param tolerance optional; defaults to `Math.max(maxAbsCoordinate(A),maxAbsCoordinate(B))/1000_000`;\n * if the calculated absolute error bound is less than this, the result is\n * returned; this is *not* a hard tolerance and the bound can be less\n * accurate in hard cases (due to the `maxIterations` parameter). Luckily\n * however, specifically the lower bound will be very accurate due to\n * its fast convergence in such hard cases (see the paper)\n * @param maxIterations optional; defaults to `50`; if the desired guaranteed error bound\n * has not been achieved after `maxIterations` then the result will be returned\n *\n * @doc mdx\n */\nfunction hausdorffDistanceOneSided(A, B, tolerance, maxIterations = 50) {\n    if (A.length === 1) {\n        return (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[0]).d;\n    }\n    if (B.length === 1) {\n        return (0,_closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_1__.furthestPointOnBezier)(A, B[0]).d;\n    }\n    if (A.length === 2 && B.length === 2) {\n        // Seperately handle the simple case of two lines\n        // Find minimum distance from endpoints of A to B:\n        const EA0 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[0]).d;\n        const EA1 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[A.length - 1]).d;\n        return EA0 > EA1 ? EA0 : EA1;\n    }\n    const l = max((0,_error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_2__.maxAbsCoordinate)(A), (0,_error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_2__.maxAbsCoordinate)(B));\n    tolerance = tolerance || l / 1000000;\n    // an array of intervals\n    const [eL, eR] = calcHErrorBound(A, 0, 1);\n    const d0 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[0]).d;\n    const d1 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, A[A.length - 1]).d;\n    const initialInterval = {\n        tS: 0, tE: 1,\n        hL: d0, hR: d1, hEL: eL, hER: eR\n    };\n    const heap = new _heap_js__WEBPACK_IMPORTED_MODULE_3__.Heap(_hausdorff_compare_js__WEBPACK_IMPORTED_MODULE_4__.hausdorffCompare);\n    heap.insert(initialInterval);\n    let j = 0;\n    let bestHUpper = Number.POSITIVE_INFINITY;\n    let bestHLower = Number.NEGATIVE_INFINITY;\n    while (true) {\n        const interval = heap.heap[0]; // peek max\n        const { tS, tE, hL, hR } = interval;\n        const tM = (tS + tE) / 2;\n        const [ELL, ELR] = calcHErrorBound(A, tS, tM);\n        const [ERL, ERR] = calcHErrorBound(A, tM, tE);\n        //---- get hM ---------------------------\n        const pM = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljau)(A, tM);\n        const pB = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(B, pM).p;\n        const hM = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.distanceBetween)(pM, pB);\n        //---------------------------------------\n        const h = max(hL, hM, hR);\n        if (h > bestHLower) {\n            bestHLower = h;\n        }\n        bestHUpper = (0,_get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_7__.getMaxHausdorff)(interval);\n        if (bestHUpper - bestHLower < tolerance) {\n            // The lower bound is by far the best approximation for difficult cases (see the paper).\n            return bestHLower;\n        }\n        if (j++ > maxIterations) {\n            // The lower bound is by far the best approximation for difficult cases (see the paper).\n            return bestHLower;\n        }\n        const iL = { tS, tE: tM, hL, hR: hM, hEL: ELL, hER: ELR };\n        const iR = { tS: tM, tE, hL: hM, hR, hEL: ERL, hER: ERR };\n        heap.swapMinOrMax(iL);\n        heap.insert(iR);\n    }\n}\n// Let: ωf(σ) = sup{ |f(t) − f(t′)| : t, t′ ∈ [a,b] with |t − t′| ≤ σ }\n//\n// |h(S,B) − h(A,B)| ≤ ωf(δS/2)\n// where: δS = max_(1≤i≤M+1)[ (ti − ti−1) ] is the maximum distance between \n// two consecutive parameter values\n/**\n * @internal\n */\nfunction calcHErrorBound(A, tS, tE) {\n    // To calculate an upper bound for ωf(δS/2) we can either check the max \n    // absolute tangent values on curve segments or use the control point \n    // lengths as an upper bound.\n    const tM = (tE + tS) / 2; // since the formula says `δS/2` so divide by 2\n    const psL = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_8__.fromTo)(A, tS, tM);\n    const psR = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_8__.fromTo)(A, tM, tE);\n    const eL = (0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_9__.controlPointLinesLength)(psL);\n    const eR = (0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_9__.controlPointLinesLength)(psR);\n    return [eL, eR];\n}\n\n//# sourceMappingURL=hausdorff-distance-one-sided.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hausdorffDistance: () => (/* binding */ hausdorffDistance)\n/* harmony export */ });\n/* harmony import */ var _hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hausdorff-distance-one-sided.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js\");\n\n/** @internal */\nconst max = Math.max;\n/**\n * Calculates and returns the (two-sided) Hausdorff distance between the bezier\n * curves `A` and `B` as `[min,max]` where `min` is the minimum\n * guaranteed and `max` is the maximum guaranteed Hausdorff distance. The `min`\n * value will be a *much* more accurate result in general.\n *\n * * partially based off [Computing the Hausdorff distance between two sets of parametric curves](https://www.semanticscholar.org/paper/COMPUTING-THE-HAUSDORFF-DISTANCE-BETWEEN-TWO-SETS-Kim-McLean/d2bd6529c4b118e389e1db209d8f1bf7467f9016)\n *\n * @param A a bezier curve given by an ordered array of its control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param B a bezier curve given by an ordered array of its control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param tolerance optional; defaults to `Math.max(maxAbsCoordinate(A),maxAbsCoordinate(B))/1000_000`;\n * if the calculated absolute error bound is less than this, the result is\n * returned; this is *not* a hard tolerance and the returned bound can be less\n * accurate in hard cases (due to the `maxIterations` parameter). Luckily\n * however, specifically the lower bound returned will be very accurate due to\n * its fast convergence in such hard cases (see the paper)\n * @param maxIterations optional; defaults to `50`; if the desired guaranteed error bound\n * has not been achieved after `maxIterations` then the result will be returned\n *\n * @doc mdx\n */\nfunction hausdorffDistance(A, B, tolerance, maxIterations) {\n    const AB = (0,_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_0__.hausdorffDistanceOneSided)(A, B, tolerance, maxIterations);\n    const BA = (0,_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_0__.hausdorffDistanceOneSided)(B, A, tolerance, maxIterations);\n    return max(AB, BA);\n}\n\n//# sourceMappingURL=hausdorff-distance.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/heap.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/heap.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heap: () => (/* binding */ Heap)\n/* harmony export */ });\n/**\n * see [Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))\n *\n * @internal\n */\nclass Heap {\n    compare;\n    heap = [];\n    constructor(compare) {\n        this.compare = compare;\n    }\n    insert(t) {\n        const heap = this.heap;\n        heap.push(t);\n        // Swim up\n        let i = heap.length - 1;\n        while (true) {\n            const parentIdx = (i - 1 - (i + 1) % 2) / 2;\n            if (parentIdx === -1) {\n                return;\n            }\n            const parent = heap[parentIdx];\n            if (this.compare(t, parent) < 0) {\n                break;\n            }\n            // Swap and update indexes and variables\n            heap[parentIdx] = t;\n            heap[i] = parent;\n            i = parentIdx;\n        }\n    }\n    popMax() {\n        const heap = this.heap;\n        const maxT = heap[0];\n        heap[0] = heap[heap.length - 1];\n        heap.length--;\n        this.swimDown();\n        return maxT;\n    }\n    swimDown() {\n        const heap = this.heap;\n        const len = heap.length;\n        let i = 0;\n        // Swim down\n        while (true) {\n            const leftIdx = 2 * i + 1;\n            if (leftIdx >= len) {\n                break; // there's no left or right child\n            }\n            const rightIdx = 2 * i + 2;\n            const swapIdx = (rightIdx >= len) || (this.compare(heap[leftIdx], heap[rightIdx]) > 0)\n                ? leftIdx\n                : rightIdx;\n            const swapChild = heap[swapIdx];\n            const parent = heap[i];\n            if (this.compare(parent, swapChild) > 0) {\n                break;\n            }\n            // Swap and update indexes\n            heap[swapIdx] = parent;\n            heap[i] = swapChild;\n            i = swapIdx;\n        }\n    }\n    swapMinOrMax(t) {\n        this.heap[0] = t;\n        this.swimDown();\n    }\n    /* ignore coverage */\n    static getParentIdx(i) { return (i - 1 - (i + 1) % 2) / 2; }\n    static getLeftChild(i) { return 2 * i + 1; }\n    static getRightChild(i) { return 2 * i + 2; }\n}\n\n//# sourceMappingURL=heap.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/heap.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension1: () => (/* binding */ isPointOnBezierExtension1)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\n\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eToDd;\nconst abs = Math.abs;\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γγ\"])(3);\n/**\n * Returns `true` if the given point is on the given line where\n * the parameter `t` is allowed to extend to ±infinity, i.e. `t` is an\n * element of `[-∞, +∞]`, `false` otherwise.\n *\n * * there are alternative implementations to this function, e.g. ccw, etc;\n * it is kept for symmetry with the order 2 and 3 implementations.\n *\n * @param ps a linear bezier curve (a line)\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n * expansions; if only double precision coordinates need to be provided then\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\n * of `1` and `2` set `p === [[1],[2]]`.\n *\n * @internal\n */\nfunction isPointOnBezierExtension1(ps, p) {\n    const [xe, ye] = p;\n    const lenX = xe.length;\n    const lenY = ye.length;\n    const x = xe[lenX - 1]; // get higest order double\n    const y = ye[lenY - 1]; // ...\n    const isDouble = (lenX === 1 && lenY === 1);\n    {\n        //---- pre-filter\n        const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm1DdWithRunningError)(ps);\n        // In the below a prefix underscore on a variable means absolute value, \n        // a postfix underscore means error bound (before multiplication by gamma).\n        // h (say height) is the the result of evaluating the implicit equation; if\n        // it is 0 we are on the curve, else we're not.\n        // const h = vₓ*x + vᵧ*y + v;\n        const xd = etodd(xe);\n        const yd = etodd(ye);\n        const _x = abs(x);\n        const _y = abs(y);\n        const _vₓ = abs(vₓ[1]);\n        const _vᵧ = abs(vᵧ[1]);\n        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\n        // and hence we need to divide the error by 3.\n        const x_ = _x / 3;\n        const y_ = _y / 3;\n        const $vₓx = vₓ[1] * x;\n        const vₓx = qmq(xd, vₓ);\n        const _vₓx = abs($vₓx);\n        const vₓx_ = _vₓ * x_ + 2 * _vₓx;\n        const $vᵧy = vᵧ[1] * y;\n        const vᵧy = qmq(yd, vᵧ);\n        const _vᵧy = abs($vᵧy);\n        const vᵧy_ = _vᵧ * y_ + 2 * _vᵧy;\n        // group the terms to reduce error, e.g. `v` usually has the highest bitlength\n        //const h = (vₓx + vᵧy) + v;\n        const q7 = qaq(vₓx, vᵧy);\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\n        const h = qaq(q7, v);\n        const h_ = q7_ + v_ + abs(h[1]);\n        // if the error is not too high too discern h away from zero\n        if (γγ3 * h_ < abs(estimate(h))) {\n            return false; // <-- prefilter applied\n        }\n    }\n    {\n        const implictForm = (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm1Exact)(ps);\n        if (implictForm === undefined) {\n            // both ps are the same point\n            return isDouble && x === ps[0][0] && y === ps[0][1];\n        }\n        const { vₓ, vᵧ, v } = implictForm;\n        const vₓx = epr(xe, vₓ);\n        const vᵧy = epr(ye, vᵧ);\n        // const h = vₓ*x + vᵧ*y + v;\n        const hh = fes(fes(vₓx, vᵧy), v);\n        return sign(hh) === 0; // <= calculation was exact\n    }\n}\n\n//# sourceMappingURL=is-point-on-bezier-extension-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension2: () => (/* binding */ isPointOnBezierExtension2)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../implicit-form/double/get-implicit-form2.js */ \"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../implicit-form/get-error-counters/get-implicit-form2-error-counters.js */ \"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eToDd;\nconst abs = Math.abs;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γ\"])(1);\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γγ\"])(3);\n/**\n * Returns `true` if the given point is on the given quadratic bezier curve where\n * the parameter `t` is allowed to extend to ±infinity, i.e. `t` is an element of\n * `[-∞, +∞]`, `false` otherwise.\n *\n * @param ps a quadratic bezier curve\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n * expansions; if only double precision coordinates need to be provided then\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\n * of `1` and `2` set `p === [[1],[2]]`.\n *\n * @internal\n */\nfunction isPointOnBezierExtension2(ps, p) {\n    const [xe, ye] = p;\n    const lenX = xe.length;\n    const lenY = ye.length;\n    const x = xe[lenX - 1]; // get higest order double\n    const y = ye[lenY - 1]; // ...\n    const isDouble = (lenX === 1 && lenY === 1);\n    //---- first pre-filter\n    {\n        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = (0,_implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm2)(ps);\n        const { vₓₓ_, // <5>\n        vₓᵧ_, // <5>\n        vᵧᵧ_, // <5>\n        vₓ_, // <8>\n        vᵧ_, // <8>\n        v_ // <10>\n         } = (0,_implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm2ErrorCounters)(ps);\n        // In the below a a postfix underscore means \n        // an error bound (>= absolute value)\n        // `h` (say height) is the the result of evaluating the implicit equation; if\n        // it is 0 we are on the curve, else we're not.\n        // In the below, if x is given as a double then the error counter on\n        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the\n        // error counter with a <D> so that for a point with double precion \n        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.\n        // `0` if we have only double precision coordinates, `1` otherwise\n        const D = isDouble ? 0 : 1;\n        const x_ = abs(x); // <D>x\n        const y_ = abs(y); // <D>y\n        const xx_ = x_ * x_; // <2D+1>xx\n        const xy_ = x_ * y_; // <2D+1>xy\n        const yy_ = y_ * y_; // <2D+1>yy\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\n        const h = (((vₓₓ * x * x + vₓᵧ * x * y) +\n            vᵧᵧ * y * y) +\n            (vₓ * x + vᵧ * y)) +\n            v;\n        // <D+12>h <-- <D+12>(<D+11>(<2D+9>(<2D+8> + <2D+7>) + <D+10>) + <10>);\n        const h_ = ((\n        // <2D+8>(<2D+7>(<5>vₓₓ*<2D+1>(xx)) + <2D+7>(<5>vₓᵧ*<2D+1>(xy)))\n        (vₓₓ_ * xx_ + vₓᵧ_ * xy_) +\n            // <2D+7>(<5>vᵧᵧ*<2D+1>(xy))\n            vᵧᵧ_ * yy_) + (\n        // <D+10>(<D+9>(<8>vₓ*<D>x) + <D+9>(<8>vᵧ*<D>y))\n        vₓ_ * x_ + vᵧ_ * y_)) +\n            // <10>v\n            v_;\n        // if the error is not too high too discern h away from zero\n        if ((D + 12) * γ1 * h_ < abs(h)) {\n            return false; // <-- prefilter applied\n        }\n    }\n    // error too high - const's try double-double precision\n    {\n        const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm2DdWithRunningError)(ps);\n        // In the below a prefix underscore on a variable means absolute value, \n        // a postfix underscore means error bound (before multiplication by gamma).\n        // h (say height) is the the result of evaluating the implicit equation; if\n        // it is 0 we are on the curve, else we're not.\n        // const h =\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\n        const xd = etodd(xe);\n        const yd = etodd(ye);\n        const _x = abs(x);\n        const _y = abs(y);\n        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\n        // and hence we need to divide the error by 3.\n        const x_ = _x / 3;\n        const y_ = _y / 3;\n        const xx = qmq(xd, xd);\n        const _xx = xx[1];\n        const xx_ = 2 * (_x * x_ + _xx);\n        const yy = qmq(yd, yd);\n        const _yy = yy[1];\n        const yy_ = 2 * (_y * y_ + _yy);\n        const xy = qmq(xd, yd);\n        const _xy = abs(xy[1]);\n        const xy_ = _x * y_ + x_ * _y + 2 * _xy;\n        const vₓₓxx = qmq(vₓₓ, xx);\n        const vₓₓxx_ = abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\n        const vₓᵧxy = qmq(vₓᵧ, xy);\n        const vₓᵧxy_ = abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\n        const vᵧᵧyy = qmq(vᵧᵧ, yy);\n        const vᵧᵧyy_ = abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\n        const vₓx = qmq(xd, vₓ);\n        const vₓx_ = abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * abs(vₓx[1]);\n        const vᵧy = qmq(yd, vᵧ);\n        const vᵧy_ = abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * abs(vᵧy[1]);\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\n        //const h = \n        //    (\n        //      ((vₓₓxx + vₓᵧxy) + vᵧᵧyy) + \n        //      (vₓx + vᵧy)\n        //    ) + \n        //    v;\n        const q4 = qaq(vₓₓxx, vₓᵧxy);\n        const q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\n        const q5 = qaq(q4, vᵧᵧyy);\n        const q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\n        const q7 = qaq(vₓx, vᵧy);\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\n        const q8 = qaq(q5, q7);\n        const q8_ = q5_ + q7_ + abs(q8[1]);\n        const h = qaq(q8, v);\n        const h_ = q8_ + v_ + abs(h[1]);\n        // if the error is not too high too discern h away from zero\n        if (γγ3 * h_ < abs(estimate(h))) {\n            return false; // <-- prefilter applied\n        }\n    }\n    // error still too high - let's go exact\n    {\n        const implictForm = (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm2Exact)(ps);\n        if (implictForm === undefined) {\n            // all ps are the same point\n            return isDouble && x === ps[0][0] && y === ps[0][1];\n        }\n        if (!implictForm.hasOwnProperty('vₓₓ')) {\n            implictForm.vₓₓ = [0];\n            implictForm.vₓᵧ = [0];\n            implictForm.vᵧᵧ = [0];\n        }\n        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;\n        // h (say height) is the the result of evaluating the implicit equation; \n        // if it is 0 we are on the curve, else we're not.\n        // const h =\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\n        const h = fes(fes(fes(epr(vₓₓ, epr(xe, xe)), epr(vₓᵧ, epr(xe, ye))), epr(vᵧᵧ, epr(ye, ye))), fes(fes(epr(xe, vₓ), epr(ye, vᵧ)), v));\n        return sign(h) === 0; // <= calculation was exact\n    }\n}\n\n//# sourceMappingURL=is-point-on-bezier-extension-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension3: () => (/* binding */ isPointOnBezierExtension3)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../implicit-form/double/get-implicit-form3.js */ \"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../implicit-form/get-error-counters/get-implicit-form3-error-counters.js */ \"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n\n\n\n\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\n\n\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eToDd;\nconst abs = Math.abs;\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γ\"])(1);\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γγ\"])(3);\n/**\n * Returns `true` if the given point is on the given cubic bezier curve where\n * the parameter, `t`, is allowed to extend to `±∞`, i.e. if `t ∈ (-∞, +∞)`,\n * `false` otherwise.\n *\n * @param ps a cubic bezier curve\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n * expansions; if only double precision coordinates need to be provided then\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\n * of `1` and `2` set `p === [[1],[2]]`.\n *\n * @internal\n */\nfunction isPointOnBezierExtension3(ps, p) {\n    const [xe, ye] = p;\n    const lenX = xe.length;\n    const lenY = ye.length;\n    const x = xe[lenX - 1]; // get higest order double\n    const y = ye[lenY - 1]; // ...\n    const isDouble = (lenX === 1 && lenY === 1);\n    //---- first pre-filter\n    {\n        // The below takes about 1.2 micro-seconds on a 1st gen i7 and Chrome 79\n        const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = (0,_implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm3)(ps);\n        const { vₓₓₓ_, // <11>\n        vₓₓᵧ_, // <12>\n        vₓᵧᵧ_, // <12>\n        vᵧᵧᵧ_, // <11>\n        vₓₓ_, // <19>\n        vₓᵧ_, // <18>\n        vᵧᵧ_, // <19>\n        vₓ_, // <22>\n        vᵧ_, // <22>\n        v_ // <24>\n         } = (0,_implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm3ErrorCounters)(ps);\n        // In the below a a postfix underscore means \n        // an error bound (>= absolute value)\n        // h (say height) is the the result of evaluating the implicit equation; if\n        // it is 0 we are on the curve, else we're not.\n        // const h =\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\n        // const h = \n        //    (\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\n        //    ) + \n        //    (\n        //        (vₓx + vᵧy) + \n        //        v\n        //    );\n        const xx = x * x;\n        const yy = y * y;\n        const h = (((vₓₓₓ * (xx * x) + vₓₓᵧ * (xx * y)) +\n            (vₓᵧᵧ * (x * yy) + vᵧᵧᵧ * (yy * y))) +\n            ((vₓₓ * xx + vₓᵧ * (x * y)) + vᵧᵧ * yy)) +\n            ((vₓ * x + vᵧ * y) +\n                v);\n        //-------------------\n        // Error calculation\n        //-------------------\n        // In the below, if x is given as a double then the error counter on\n        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the\n        // error counter with a <D> so that for a point with double precion \n        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.\n        // `0` if we have only double precision coordinates, `1` otherwise\n        const D = isDouble ? 0 : 1;\n        const x_ = abs(x); // <D>x\n        const y_ = abs(y); // <D>y\n        const xx_ = x_ * x_; // <2D+1>xx\n        const xy_ = x_ * y_; // <2D+1>xy\n        const yy_ = y_ * y_; // <2D+1>yy\n        // <D+26>h <-- <D+26>(<2D+24>(<3D+17>(<3D+16> + <3D+16>) + <2D+23>) + <D+25>(<D+24> + <24>))\n        const h_ = (\n        // <3D+16> <-- <3D+16>((<3D+14>(<11>vₓₓₓ*<3D+2>(xx*x)) + <3D+15>(<12>vₓₓᵧ*<3D+2>(xx*y)))) +\n        (vₓₓₓ_ * (xx_ * x_) + vₓₓᵧ_ * (xx_ * y_)) +\n            // <3D+16> <-- <3D+16>((<3D+15>(<12>vₓᵧᵧ*<3D+2>(x*yy)) + <3D+14>(<11>vᵧᵧᵧ*<3D+2>(yy*y)))) +\n            (vₓᵧᵧ_ * (x_ * yy_) + vᵧᵧᵧ_ * (yy_ * y_)) +\n            // <2D+23> <-- <2D+23>(<2D+22>(<2D+21>(<19>vₓₓ*<2D+1>xx) + <2D+20>(<18>vₓᵧ*<2D+1>(x*y))) + <2D+20>(<18>vᵧᵧ*<2D+1>yy))\n            ((vₓₓ_ * xx_ + vₓᵧ_ * (xy_)) + vᵧᵧ_ * yy_)) +\n            (\n            // <24> <-- <D+24>(<D+23>(<22>vₓ*<D>x) + <D+23>(<22>vᵧ*<D>y))\n            (vₓ_ * x_ + vᵧ_ * y_) +\n                // <24>\n                v_);\n        // if the error is not too high too discern `h` away from zero\n        if ((D + 26) * γ1 * h_ < abs(h)) {\n            return false; // <-- prefilter applied\n        }\n    }\n    // error too high - let's try double-double precision\n    {\n        // The below takes about 15 micro-seconds on a 1st gen i7 and Chrome 79\n        const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm3DdWithRunningError)(ps);\n        const _vₓₓₓ = abs(vₓₓₓ[1]);\n        const _vₓₓᵧ = abs(vₓₓᵧ[1]);\n        const _vₓᵧᵧ = abs(vₓᵧᵧ[1]);\n        const _vᵧᵧᵧ = abs(vᵧᵧᵧ[1]);\n        // In the below a prefix underscore on a variable means absolute value, \n        // a postfix underscore means error bound (before multiplication by gamma).\n        // h (say height) is the the result of evaluating the implicit equation; if\n        // it is 0 we are on the curve, else we're not.\n        // const h =\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\n        const xd = etodd(xe);\n        const yd = etodd(ye);\n        const _x = abs(x);\n        const _y = abs(y);\n        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\n        // and hence we need to divide the error by 3.\n        const x_ = _x / 3;\n        const y_ = _y / 3;\n        const xx = qmq(xd, xd);\n        const _xx = xx[1];\n        const xx_ = 2 * (_x * x_ + _xx);\n        const xxx = qmq(xd, xx);\n        const _xxx = abs(xxx[1]);\n        const xxx_ = _x * xx_ + x_ * _xx + 2 * _xxx;\n        const yy = qmq(yd, yd);\n        const _yy = yy[1];\n        const yy_ = 2 * (_y * y_ + _yy);\n        const yyy = qmq(yd, yy);\n        const _yyy = abs(yyy[1]);\n        const yyy_ = _y * yy_ + y_ * _yy + 2 * _yyy;\n        const xxy = qmq(yd, xx);\n        const _xxy = abs(xxy[1]);\n        const xxy_ = _y * xx_ + y_ * _xx + 2 * _xxy;\n        const xyy = qmq(xd, yy);\n        const _xyy = abs(xyy[1]);\n        const xyy_ = _x * yy_ + x_ * _yy + 2 * _xyy;\n        const xy = qmq(xd, yd);\n        const _xy = abs(xy[1]);\n        const xy_ = _x * y_ + x_ * _y + 2 * _xy;\n        const vₓₓₓxxx = qmq(vₓₓₓ, xxx);\n        const vₓₓₓxxx_ = _vₓₓₓ * xxx_ + vₓₓₓ_ * _xxx + 2 * abs(vₓₓₓxxx[1]);\n        const vₓₓᵧxxy = qmq(vₓₓᵧ, xxy);\n        const vₓₓᵧxxy_ = _vₓₓᵧ * xxy_ + vₓₓᵧ_ * _xxy + 2 * abs(vₓₓᵧxxy[1]);\n        const vₓᵧᵧxyy = qmq(vₓᵧᵧ, xyy);\n        const vₓᵧᵧxyy_ = _vₓᵧᵧ * xyy_ + vₓᵧᵧ_ * _xyy + 2 * abs(vₓᵧᵧxyy[1]);\n        const vᵧᵧᵧyyy = qmq(vᵧᵧᵧ, yyy);\n        const vᵧᵧᵧyyy_ = _vᵧᵧᵧ * yyy_ + vᵧᵧᵧ_ * _yyy + 2 * abs(vᵧᵧᵧyyy[1]);\n        const vₓₓxx = qmq(vₓₓ, xx);\n        const vₓₓxx_ = abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\n        const vₓᵧxy = qmq(vₓᵧ, xy);\n        const vₓᵧxy_ = abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\n        const vᵧᵧyy = qmq(vᵧᵧ, yy);\n        const vᵧᵧyy_ = abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\n        const vₓx = qmq(xd, vₓ);\n        const vₓx_ = abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * abs(vₓx[1]);\n        const vᵧy = qmq(yd, vᵧ);\n        const vᵧy_ = abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * abs(vᵧy[1]);\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\n        //const h = \n        //    (\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\n        //    ) + \n        //    (\n        //        (vₓx + vᵧy) + \n        //        v\n        //    );\n        const q1 = qaq(vₓₓₓxxx, vₓₓᵧxxy);\n        const q1_ = vₓₓₓxxx_ + vₓₓᵧxxy_ + abs(q1[1]);\n        const q2 = qaq(vₓᵧᵧxyy, vᵧᵧᵧyyy);\n        const q2_ = vₓᵧᵧxyy_ + vᵧᵧᵧyyy_ + abs(q2[1]);\n        const q3 = qaq(q1, q2);\n        const q3_ = q1_ + q2_ + abs(q3[1]);\n        const q4 = qaq(vₓₓxx, vₓᵧxy);\n        const q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\n        const q5 = qaq(q4, vᵧᵧyy);\n        const q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\n        const q6 = qaq(q3, q5);\n        const q6_ = q3_ + q5_ + abs(q6[1]);\n        const q7 = qaq(vₓx, vᵧy);\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\n        const q8 = qaq(q7, v);\n        const q8_ = q7_ + v_ + abs(q8[1]);\n        const h = qaq(q6, q8);\n        const h_ = q6_ + q8_ + abs(h[1]);\n        // if the error is not too high too discern h away from zero\n        if (γγ3 * h_ < abs(estimate(h))) {\n            return false; // <-- prefilter applied\n        }\n    }\n    // error still too high - const's go exact\n    {\n        // The below takes about 155 micro-seconds on a 1st gen i7 and Chrome 79\n        const implictForm = (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm3Exact)(ps);\n        if (implictForm === undefined) {\n            // all ps are the same point\n            return isDouble && x === ps[0][0] && y === ps[0][1];\n        }\n        if (!implictForm.hasOwnProperty('vₓₓₓ')) {\n            implictForm.vₓₓₓ = [0];\n            implictForm.vₓₓᵧ = [0];\n            implictForm.vₓᵧᵧ = [0];\n            implictForm.vᵧᵧᵧ = [0];\n        }\n        if (!implictForm.hasOwnProperty('vₓₓ')) {\n            implictForm.vₓₓ = [0];\n            implictForm.vₓᵧ = [0];\n            implictForm.vᵧᵧ = [0];\n        }\n        const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;\n        // `h` (say height) is the the result of evaluating the implicit \n        // equation; if it is 0 we are on the curve, else we're not.\n        // const h =\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\n        const xx = epr(xe, xe); // <= error free\n        const xxx = epr(xe, xx);\n        const yy = epr(ye, ye); // <= error free\n        const yyy = epr(ye, yy);\n        const xxy = epr(ye, xx);\n        const xyy = epr(xe, yy);\n        const xy = epr(xe, ye); // <= error free\n        const vₓₓₓxxx = epr(vₓₓₓ, xxx);\n        const vₓₓᵧxxy = epr(vₓₓᵧ, xxy);\n        const vₓᵧᵧxyy = epr(vₓᵧᵧ, xyy);\n        const vᵧᵧᵧyyy = epr(vᵧᵧᵧ, yyy);\n        const vₓₓxx = epr(vₓₓ, xx);\n        const vₓᵧxy = epr(vₓᵧ, xy);\n        const vᵧᵧyy = epr(vᵧᵧ, yy);\n        const vₓx = epr(xe, vₓ);\n        const vᵧy = epr(ye, vᵧ);\n        const q1 = fes(vₓₓₓxxx, vₓₓᵧxxy);\n        const q2 = fes(vₓᵧᵧxyy, vᵧᵧᵧyyy);\n        const q3 = fes(q1, q2);\n        const q4 = fes(vₓₓxx, vₓᵧxy);\n        const q5 = fes(q4, vᵧᵧyy);\n        const q6 = fes(q3, q5);\n        const q7 = fes(vₓx, vᵧy);\n        const q8 = fes(q7, v);\n        const h = fes(q6, q8);\n        return sign(h) === 0; // <= calculation was exact\n    }\n}\n\n//# sourceMappingURL=is-point-on-bezier-extension-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension: () => (/* binding */ isPointOnBezierExtension)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var _is_point_on_bezier_extension_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-point-on-bezier-extension-1.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js\");\n/* harmony import */ var _is_point_on_bezier_extension_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-point-on-bezier-extension-2.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js\");\n/* harmony import */ var _is_point_on_bezier_extension_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-point-on-bezier-extension-3.js */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js\");\n\n\n\n\n/**\n * Returns `true` if the given point is on the given bezier curve where the\n * parameter `t` is allowed to extend to ±∞, i.e. `t` is an element of\n * `(-∞, +∞)`, `false` otherwise.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\n * expansions; if only double precision coordinates need to be provided then\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\n * of `1` and `2` set `p === [[1],[2]]`.\n */\nfunction isPointOnBezierExtension(ps, p) {\n    if (ps.length === 4) {\n        return (0,_is_point_on_bezier_extension_3_js__WEBPACK_IMPORTED_MODULE_0__.isPointOnBezierExtension3)(ps, p);\n    }\n    if (ps.length === 3) {\n        return (0,_is_point_on_bezier_extension_2_js__WEBPACK_IMPORTED_MODULE_1__.isPointOnBezierExtension2)(ps, p);\n    }\n    if (ps.length === 2) {\n        return (0,_is_point_on_bezier_extension_1_js__WEBPACK_IMPORTED_MODULE_2__.isPointOnBezierExtension1)(ps, p);\n    }\n    if (ps.length === 1) {\n        const x = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eCompress)(p[0]);\n        const y = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eCompress)(p[1]);\n        return (x.length === 1 && y.length === 1 &&\n            x[0] === ps[0][0] && y[0] === ps[0][1]);\n    }\n    throw new Error('The given bezier curve must be of order <= 3');\n}\n\n//# sourceMappingURL=is-point-on-bezier-extension.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/sub-1-ulp.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-bezier3/node/sub-1-ulp.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sub1Ulp: () => (/* binding */ sub1Ulp)\n/* harmony export */ });\nconst { EPSILON: eps } = Number;\nconst u = eps / 2;\nconst es = (eps ** 2) / 2;\nconst ups = u + es;\n/**\n * Subtract one unit in the last place (ulp) from the given number\n *\n * * subnormal numbers (and 0) are returned unaltered\n * @internal\n */\nfunction sub1Ulp(n) {\n    return n > 0 ? n - n * ups : n + n * ups;\n}\n\n//# sourceMappingURL=sub-1-ulp.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/sub-1-ulp.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_1stDerivativeDd: () => (/* binding */ toPowerBasis_1stDerivativeDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_0__.twoSum; // error -> 0\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\n/**\n * Returns the derivative of the power basis representation of a bezier\n * curve of order cubic or less (with intermediate calculations done in\n * double-double precision).\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are in double-double precision\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_1stDerivativeDd(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3_1stDerivativeDd(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2_1stDerivativeDd(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1_1stDerivativeDd(ps);\n    }\n    if (ps.length === 1) {\n        return [[[0, 0]], [[0, 0]]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis3_1stDerivativeDd(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[\n            // 3*((x3 - x0) + 3*(x1 - x2)),\n            qmd(3, qaq(td(x3, x0), qmd(3, td(x1, x2)))),\n            // 6*((x2 + x0) - 2*x1),\n            qmd(6, qad(ts(x2, x0), -2 * x1)),\n            // 3*(x1 - x0)\n            qmd(3, td(x1, x0))\n        ], [\n            // 3*((y3 - y0) + 3*(y1 - y2)),\n            qmd(3, qaq(td(y3, y0), qmd(3, td(y1, y2)))),\n            // 6*((y2 + y0) - 2*y1),\n            qmd(6, qad(ts(y2, y0), -2 * y1)),\n            // 3*(y1 - y0)\n            qmd(3, td(y1, y0))\n        ]];\n}\n/** @internal */\nfunction toPowerBasis2_1stDerivativeDd(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [[\n            // 2*((x2 + x0) - 2*x1),\n            qad(ts(2 * x2, 2 * x0), -4 * x1),\n            // 2*(x1 - x0)\n            td(2 * x1, 2 * x0),\n        ], [\n            // 2*((y2 + y0) - 2*y1),\n            qad(ts(2 * y2, 2 * y0), -4 * y1),\n            // 2*(y1 - y0)\n            td(2 * y1, 2 * y0),\n        ]];\n}\n/** @internal */\nfunction toPowerBasis1_1stDerivativeDd(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            td(x1, x0),\n        ], [\n            td(y1, y0),\n        ]];\n}\n\n//# sourceMappingURL=to-power-basis-1st-derivative-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_1stDerivative: () => (/* binding */ toPowerBasis_1stDerivative)\n/* harmony export */ });\n/**\n * Returns the derivative of the power basis representation of a\n * bezier curve of order cubic or less (with intermediate calculations done in\n * double precision).\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_1stDerivative(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3_1stDerivative(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2_1stDerivative(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1_1stDerivative(ps);\n    }\n    if (ps.length === 1) {\n        return [[0], [0]];\n    }\n    throw new Error('The bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis3_1stDerivative(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[\n            3 * ((x3 - x0) + 3 * (x1 - x2)),\n            6 * ((x2 + x0) - 2 * x1),\n            3 * (x1 - x0)\n        ], [\n            3 * ((y3 - y0) + 3 * (y1 - y2)),\n            6 * ((y2 + y0) - 2 * y1),\n            3 * (y1 - y0)\n        ]];\n}\n/** @internal */\nfunction toPowerBasis2_1stDerivative(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [[\n            2 * ((x2 + x0) - 2 * x1),\n            2 * (x1 - x0)\n        ], [\n            2 * ((y2 + y0) - 2 * y1),\n            2 * (y1 - y0)\n        ]];\n}\n/** @internal */\nfunction toPowerBasis1_1stDerivative(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            x1 - x0\n        ], [\n            y1 - y0\n        ]];\n}\n\n//# sourceMappingURL=to-power-basis-1st-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_1stDerivativeExact: () => (/* binding */ toPowerBasis_1stDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoSum;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eAdd;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.growExpansion;\n/**\n * Returns the *exact* derivative of the power basis representation of a\n * bezier curve of order cubic or less.\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\n * expansions\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_1stDerivativeExact(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3_1stDerivativeExact(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2_1stDerivativeExact(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1_1stDerivativeExact(ps);\n    }\n    if (ps.length === 1) {\n        return [[[0]], [[0]]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis3_1stDerivativeExact(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[\n            sce(3, eadd(td(x3, x0), sce(3, td(x1, x2)))),\n            sce(6, ge(ts(x2, x0), -2 * x1)),\n            sce(3, td(x1, x0))\n        ], [\n            sce(3, eadd(td(y3, y0), sce(3, td(y1, y2)))),\n            sce(6, ge(ts(y2, y0), -2 * y1)),\n            sce(3, td(y1, y0))\n        ]];\n}\n/** @internal */\nfunction toPowerBasis2_1stDerivativeExact(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [[\n            ge(ts(2 * x2, 2 * x0), -4 * x1),\n            td(2 * x1, 2 * x0),\n        ], [\n            ge(ts(2 * y2, 2 * y0), -4 * y1),\n            td(2 * y1, 2 * y0),\n        ]];\n}\n/** @internal */\nfunction toPowerBasis1_1stDerivativeExact(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            td(x1, x0),\n        ], [\n            td(y1, y0),\n        ]];\n}\n\n//# sourceMappingURL=to-power-basis-1st-derivative-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_1stDerivativeErrorCounters: () => (/* binding */ toPowerBasis_1stDerivativeErrorCounters)\n/* harmony export */ });\n// For double precision the error bound === γ * <counter> * `error_`\n// For double-double precision the error bound === γγ3 * <counter> * `error_`\nconst abs = Math.abs;\n/**\n * Returns a representation of the error (from which an absolute error bound\n * can be calculated) when calculating the derivative of the power basis\n * representation of a bezier curve of order <= 3 (using\n * e.g. `toPowerBasis_1stDerivative` or `toPowerBasis_1stDerivativeDd`).\n *\n * The returned error representation needs to be multiplied with\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\n * or double-double). This is explained in more detail below. See\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n * p. 68 near the bottom.\n *\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\n *\n * The absolute erros below can be calculated as follows (where `<E>` are the\n * error counters as indicated in the comments of the return value below):\n *  * double precision: `<E> * (γ(1)) * result_`\n *  * double-double precision: `<E> * (γγ(3)) * result_`\n *\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\n * and `γγ(3) === 3.697785493223493e-32`.\n *\n * The `D` in the error counter formula is zero for double precision and 1 for\n * double-double precision.\n *\n * ```\n * // for cubic bezier curves\n * return [\n * \t[\n * \t\tX2,  // <E> === D+3 (D = 0 for double, 1 for double-double precision)\n * \t\tX1,  // <E> === D+2\n * \t\tX0   // <E> === D+3\n * \t],\n * \t[\n * \t\tY2,  // <E> === D+3\n * \t\tY1,  // <E> === D+2\n * \t\tY0   // <E> === D+3\n * \t]\n * ]\n *\n * // for quadratic bezier curves\n * return [\n * \t[\n * \t\tX1,  // <E> === D+1 (D = 0 for double, 1 for double-double precision)\n * \t\tX0   // <E> === D\n * \t],\n * \t[\n * \t\tY1,  // <E> === D+1\n * \t\tY0   // <E> === D\n * \t]\n * ];\n *\n * // for linear bezier curves (i.e. lines)\n * return [\n * \t[\n * \t\tX0_  // <E> === D (D = 0 for double, 1 for double-double precision)\n * \t],\n * \t[\n * \t\tY0_  // <E> === D\n * \t]\n * ];\n * ```\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc mdx\n */\nfunction toPowerBasis_1stDerivativeErrorCounters(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3_1stDerivativeErrorCounters(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2_1stDerivativeErrorCounters(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1_1stDerivativeErrorCounters(ps);\n    }\n    if (ps.length === 1) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis1_1stDerivativeErrorCounters(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    // If intermediate calculations are done in double precision then:\n    // `<D> === <1>` else if double-double precision then `<D> === <0>`.\n    return [\n        [\n            // <D> <= <D>(<0>x1 - <0>x0)\n            _x1 + _x0, // <D>\n        ], [\n            _y1 + _y0, // <D>\n        ]\n    ];\n}\n/** @internal */\nfunction toPowerBasis2_1stDerivativeErrorCounters(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    // If intermediate calculations are done in double precision then:\n    // `<D> === <1>` else if double-double precision then `<D> === <0>`.\n    return [\n        [\n            2 * ((_x2 + _x0) + 2 * _x1),\n            2 * (_x1 + _x0) // <D> <-- 2*<D>(x1 - x0)\n        ], [\n            2 * ((_y2 + _y0) + 2 * _y1),\n            2 * (_y1 + _y0)\n        ]\n    ];\n}\n/** @internal */\nfunction toPowerBasis3_1stDerivativeErrorCounters(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _x3 = abs(x3);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    const _y3 = abs(y3);\n    // If intermediate calculations are done in double precision then:\n    // `<D> === <1>` else if double-double precision then `<D> === <0>`.\n    return [\n        [\n            // <D+3> <-- <D+3>(3*(<D+2>(<D>(x3 - x0) + <D+1>(3*<D>(x1 - x2)))))\n            3 * ((_x3 + _x0) + 3 * (_x1 + _x2)),\n            // <D+2> <-- <D+2>(6*<D+1>(<D>(x2 + x0) - 2*x1))\n            6 * ((_x2 + _x0) + 2 * _x1),\n            // <D+1> <-- <D+1>(3*<D>(x1 - x0))\n            3 * (_x1 + _x0)\n        ], [\n            3 * ((_y3 + _y0) + 3 * (_y1 + _y2)),\n            6 * ((_y2 + _y0) + 2 * _y1),\n            3 * (_y1 + _y0)\n        ]\n    ];\n}\n\n//# sourceMappingURL=to-power-basis-1st-derivative-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_2ndDerivativeDd: () => (/* binding */ toPowerBasis_2ndDerivativeDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\n/**\n * Returns the 2nd derivative of the power basis representation of a bezier\n * curve of order cubic or less (with intermediate calculations done in\n * double-double precision).\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are in double-double precision\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_2ndDerivativeDd(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [[\n                qmd(6, (qaq(td(x3, x0), qmd(3, (td(x1, x2)))))),\n                qmd(6, (qad(td(x2, 2 * x1), x0)))\n            ], [\n                qmd(6, (qaq(td(y3, y0), qmd(3, (td(y1, y2)))))),\n                qmd(6, (qad(td(y2, 2 * y1), y0)))\n            ]];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [[\n                qad(td(2 * x2, 4 * x1), 2 * x0)\n            ], [\n                qad(td(2 * y2, 4 * y1), 2 * y0)\n            ]];\n    }\n    if (ps.length <= 2) {\n        return [[[0, 0]], [[0, 0]]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=to-power-basis-2nd-derivative-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_2ndDerivative: () => (/* binding */ toPowerBasis_2ndDerivative)\n/* harmony export */ });\n/**\n * Returns the 2nd derivative of the power basis representation of a\n * bezier curve of order cubic or less (with intermediate calculations done in\n * double precision).\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_2ndDerivative(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [[\n                6 * ((x3 - x0) + 3 * (x1 - x2)),\n                6 * ((x2 + x0) - 2 * x1)\n            ], [\n                6 * ((y3 - y0) + 3 * (y1 - y2)),\n                6 * ((y2 + y0) - 2 * y1)\n            ]];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [[\n                2 * (x2 - 2 * x1 + x0)\n            ], [\n                2 * (y2 - 2 * y1 + y0)\n            ]];\n    }\n    if (ps.length <= 2) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=to-power-basis-2nd-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_2ndDerivativeExact: () => (/* binding */ toPowerBasis_2ndDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eAdd;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.growExpansion;\n/**\n * Returns the *exact* 2nd derivative of the power basis representation of a\n * bezier curve of order cubic or less.\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\n * expansions\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_2ndDerivativeExact(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [[\n                sce(6, (eadd(td(x3, x0), sce(3, (td(x1, x2)))))),\n                sce(6, (ge(td(x2, 2 * x1), x0)))\n            ], [\n                sce(6, (eadd(td(y3, y0), sce(3, (td(y1, y2)))))),\n                sce(6, (ge(td(y2, 2 * y1), y0)))\n            ]];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [[\n                ge(td(2 * x2, 4 * x1), 2 * x0)\n            ], [\n                ge(td(2 * y2, 4 * y1), 2 * y0)\n            ]];\n    }\n    if (ps.length <= 2) {\n        return [[[0]], [[0]]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=to-power-basis-2nd-derivative-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_3rdDerivativeDd: () => (/* binding */ toPowerBasis_3rdDerivativeDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\n/**\n * Returns the 3rd derivative of the power basis representation of a bezier\n * curve of order cubic or less (with intermediate calculations done in\n * double-double precision).\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are in double-double precision\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_3rdDerivativeDd(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [[\n                qmd(6, qaq(td(x3, x0), qmd(3, td(x1, x2))))\n            ], [\n                qmd(6, qaq(td(y3, y0), qmd(3, td(y1, y2))))\n            ]];\n    }\n    if (ps.length <= 3) {\n        return [[[0, 0]], [[0, 0]]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n    // Side note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], \n    // then max(dddx)(t) <= 48*X for all t.\n}\n\n//# sourceMappingURL=to-power-basis-3rd-derivative-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_3rdDerivative: () => (/* binding */ toPowerBasis_3rdDerivative)\n/* harmony export */ });\n/**\n * Returns the 3rd derivative of the power basis representation of a bezier\n * curve of order cubic or less (with intermediate calculations done in\n * double precision).\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_3rdDerivative(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [[\n                6 * ((x3 - x0) + 3 * (x1 - x2))\n            ], [\n                6 * ((y3 - y0) + 3 * (y1 - y2))\n            ]];\n    }\n    if (ps.length <= 3) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n    // Side note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], \n    // then max(dddx)(t) <= 48*X for all t.\n}\n\n//# sourceMappingURL=to-power-basis-3rd-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_3rdDerivativeExact: () => (/* binding */ toPowerBasis_3rdDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eAdd;\n/**\n * Returns the *exact* 3rd derivative of the power basis representation of a\n * bezier curve of order cubic or less.\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\n * expansions\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis_3rdDerivativeExact(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [[\n                sce(6, eadd(td(x3, x0), sce(3, td(x1, x2))))\n            ], [\n                sce(6, eadd(td(y3, y0), sce(3, td(y1, y2))))\n            ]];\n    }\n    else if (ps.length <= 3) {\n        return [[[0]], [[0]]];\n    }\n    // Note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], then\n    // max(dddx)(t) <= 48*X for all t.\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=to-power-basis-3rd-derivative-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis1DdWithRunningError: () => (/* binding */ toPowerBasis1DdWithRunningError),\n/* harmony export */   toPowerBasis2DdWithRunningError: () => (/* binding */ toPowerBasis2DdWithRunningError),\n/* harmony export */   toPowerBasis3DdWithRunningError: () => (/* binding */ toPowerBasis3DdWithRunningError),\n/* harmony export */   toPowerBasisDdWithRunningError: () => (/* binding */ toPowerBasisDdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\nconst abs = Math.abs;\n/**\n * Returns the power basis representation of a bezier curve of order cubic or\n * less including a coefficient-wise absolute error bound that need to be multiplied\n * by `γγ(3)`\n *\n * * intermediate calculations done in double-double precision\n * * the error bound need to be multiplied by `γγ(3) === 3.697785493223493e-32` before use\n * * returns the power basis x and y coordinate polynomials from highest power\n * to lowest, e.g. if `x(t) = at^3 + bt^2 + ct + d`\n * and `y(t) = et^3 + ft^2 + gt + h` then the result is returned\n * as `[[a,b,c,d],[e,f,g,h]]`, where the `a,b,c,...` are in double-double\n * precision\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasisDdWithRunningError(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3DdWithRunningError(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2DdWithRunningError(ps);\n    }\n    if (ps.length === 2) {\n        return {\n            coeffs: toPowerBasis1DdWithRunningError(ps),\n            errorBound: [[0, 0], [0, 0]]\n        };\n    }\n    if (ps.length === 1) {\n        return {\n            coeffs: toPowerBasis0DdWithRunningError(ps),\n            errorBound: [[0], [0]]\n        };\n    }\n    throw new Error('The given bezier curve must be of order <= cubic.');\n}\n/** @internal */\nfunction toPowerBasis3DdWithRunningError(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // ----------------------------\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\n    // ----------------------------\n    const xa = td(x3, x0); // error free\n    const xb = td(x1, x2); // error free\n    const $xc = 3 * (x1 - x2);\n    const xc = qmd(3, xb);\n    const _xc_ = abs($xc);\n    const xx3 = qaq(xa, xc);\n    const xx3_ = _xc_ + abs(x3 - x0 + $xc);\n    // ----------------------------\n    // xx2 = 3*(x2 - 2*x1 + x0)\n    // ----------------------------\n    const xd = td(x2, 2 * x1); // error free\n    const xe = qad(xd, x0);\n    const _xe_ = abs(x2 - 2 * x1 + x0);\n    const xx2 = qmd(3, xe);\n    //const xx2_ = 3*_xe_ + 3*_xe_;\n    const xx2_ = 6 * _xe_;\n    // ----------------------------\n    // xx1 = 3*(x1 - x0)\n    // ----------------------------\n    const xg = td(x1, x0); // error free\n    const xx1 = qmd(3, xg);\n    const xx1_ = abs(3 * (x1 - x0));\n    // ----------------------------\n    // yy3 = y3 + 3*(y1 - y2) - y0\n    // ----------------------------\n    const ya = td(y3, y0); // error free\n    const yb = td(y1, y2); // error free\n    const $yc = 3 * (y1 - y2);\n    const yc = qmd(3, yb);\n    const _yc_ = abs($yc);\n    const yy3 = qaq(ya, yc);\n    const yy3_ = _yc_ + abs(y3 - y0 + $yc);\n    // ----------------------------\n    // yy2 = 3*(y2 - 2*y1 + y0)\n    // ----------------------------\n    const yd = td(y2, 2 * y1); // error free\n    const ye = qad(yd, y0);\n    const _ye_ = abs(y2 - 2 * y1 + y0);\n    const yy2 = qmd(3, ye);\n    //const yy2_ = 3*_ye_ + 3*_ye_;\n    const yy2_ = 6 * _ye_;\n    // ----------------------------\n    // yy1 = 3*(y1 - y0)\n    // ----------------------------\n    const yg = td(y1, y0); // error free\n    const yy1 = qmd(3, yg);\n    const yy1_ = abs(3 * (y1 - y0));\n    return {\n        coeffs: [[xx3, xx2, xx1, [0, x0]], [yy3, yy2, yy1, [0, y0]]],\n        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]\n    };\n}\n/** @internal */\nfunction toPowerBasis2DdWithRunningError(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    // ---------------------\n    // xx2 = x2 - 2*x1 + x0\n    // ---------------------\n    const $a = x2 - 2 * x1;\n    const a = td(x2, 2 * x1); // error free\n    const xx2 = qad(a, x0);\n    const xx2_ = abs($a + x0);\n    // ---------------------\n    // xx1 = 2*(x1 - x0)\n    // ---------------------\n    const xx1 = td(2 * x1, 2 * x0); // error free\n    // ---------------------\n    // yy2 = y2 - 2*y1 + y0\n    // ---------------------\n    const $b = y2 - 2 * y1;\n    const b = td(y2, 2 * y1); // error free\n    const yy2 = qad(b, y0);\n    const yy2_ = abs($b + y0);\n    // ---------------------\n    // yy1 = 2*(y1 - y0)\n    // ---------------------\n    const yy1 = td(2 * y1, 2 * y0); // error free\n    return {\n        coeffs: [[xx2, xx1, [0, x0]], [yy2, yy1, [0, y0]]],\n        errorBound: [[xx2_, 0, 0], [yy2_, 0, 0]]\n    };\n}\n/** @internal */\nfunction toPowerBasis1DdWithRunningError(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            td(x1, x0),\n            [0, x0]\n        ], [\n            td(y1, y0),\n            [0, y0]\n        ]];\n}\n/** @internal */\nfunction toPowerBasis0DdWithRunningError(ps) {\n    const [[x0, y0]] = ps;\n    return [[[0, x0]], [[0, y0]]];\n}\n\n//# sourceMappingURL=to-power-basis-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis0Dd: () => (/* binding */ toPowerBasis0Dd),\n/* harmony export */   toPowerBasis1Dd: () => (/* binding */ toPowerBasis1Dd),\n/* harmony export */   toPowerBasis2Dd: () => (/* binding */ toPowerBasis2Dd),\n/* harmony export */   toPowerBasis3Dd: () => (/* binding */ toPowerBasis3Dd),\n/* harmony export */   toPowerBasisDd: () => (/* binding */ toPowerBasisDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_0__.twoSum;\n/**\n * Returns the power basis representation of a bezier curve of order cubic or\n * less.\n *\n * * intermediate calculations are done in double-double precision\n * * returns the power basis x and y coordinate polynomials from highest power\n * to lowest, e.g. if `x(t) = at^3 + bt^2 + ct + d`\n * and `y(t) = et^3 + ft^2 + gt + h` then the result is returned\n * as `[[a,b,c,d],[e,f,g,h]]`, where the `a,b,c,...` are in double-double\n * precision\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasisDd(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3Dd(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2Dd(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1Dd(ps);\n    }\n    if (ps.length === 1) {\n        return toPowerBasis0Dd(ps);\n    }\n    throw new Error('The given bezier curve must be of order <= cubic.');\n}\n/** @internal */\nfunction toPowerBasis3Dd(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // ----------------------------\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\n    // ----------------------------\n    const xx3 = qaq(td(x3, x0), qmd(3, td(x1, x2)));\n    // ----------------------------\n    // xx2 = 3*((x2 + x0) - 2*x1)\n    // ----------------------------\n    const xx2 = qmd(3, qad(ts(x2, x0), -2 * x1));\n    // ----------------------------\n    // xx1 = 3*(x1 - x0)\n    // ----------------------------\n    const xx1 = qmd(3, td(x1, x0));\n    // ----------------------------\n    // yy3 = (y3 - y0) + 3*(y1 - y2)\n    // ----------------------------\n    const yy3 = qaq(td(y3, y0), qmd(3, td(y1, y2)));\n    // ----------------------------\n    // yy2 = 3*((y2 + y0) - 2*y1)\n    // ----------------------------\n    const yy2 = qmd(3, qad(ts(y2, y0), -2 * y1));\n    // ----------------------------\n    // yy1 = 3*(y1 - y0)\n    // ----------------------------\n    const yy1 = qmd(3, td(y1, y0));\n    return [[xx3, xx2, xx1, [0, x0]], [yy3, yy2, yy1, [0, y0]]];\n}\n/**\n * Only the quadratic monomial coefficient has an error, the others are exact.\n *\n * @internal\n */\nfunction toPowerBasis2Dd(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    // ---------------------\n    // xx2 = x2 + x0 - 2*x1\n    // ---------------------\n    const xx2 = qad(ts(x2, x0), -2 * x1);\n    // ---------------------\n    // xx1 = 2*(x1 - x0)\n    // ---------------------\n    const xx1 = td(2 * x1, 2 * x0); // error free\n    // ---------------------\n    // yy2 = y2 + y0 - 2*y1\n    // ---------------------\n    const yy2 = qad(ts(y2, y0), -2 * y1);\n    // ---------------------\n    // yy1 = 2*(y1 - y0)\n    // ---------------------\n    const yy1 = td(2 * y1, 2 * y0); // error free\n    return [[xx2, xx1, [0, x0]], [yy2, yy1, [0, y0]]];\n}\n/**\n * Exact for any bitlength.\n *\n * @internal\n */\nfunction toPowerBasis1Dd(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            td(x1, x0),\n            [0, x0]\n        ], [\n            td(y1, y0),\n            [0, y0]\n        ]];\n}\n/**\n * Exact for any bitlength.\n *\n * @internal\n */\nfunction toPowerBasis0Dd(ps) {\n    const [[x0, y0]] = ps;\n    return [[[0, x0]], [[0, y0]]];\n}\n\n//# sourceMappingURL=to-power-basis-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis1WithRunningError: () => (/* binding */ toPowerBasis1WithRunningError),\n/* harmony export */   toPowerBasis2WithRunningError: () => (/* binding */ toPowerBasis2WithRunningError),\n/* harmony export */   toPowerBasis3WithRunningError: () => (/* binding */ toPowerBasis3WithRunningError),\n/* harmony export */   toPowerBasisWithRunningError: () => (/* binding */ toPowerBasisWithRunningError)\n/* harmony export */ });\nconst abs = Math.abs;\n/**\n * Returns the power basis representation of a bezier curve of order cubic or\n * less including a coefficient-wise absolute error bound.\n *\n * * intermediate calculations are done in double precision\n * * the error bound need to be multiplied by `γ(1) === u/(1-u)`\n * where `u = Number.EPSILON/2` before use\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasisWithRunningError(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3WithRunningError(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2WithRunningError(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1WithRunningError(ps);\n    }\n    if (ps.length === 1) {\n        return toPowerBasis0WithRunningError(ps);\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis3WithRunningError(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // ----------------------------\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\n    // ----------------------------\n    const xa = x3 - x0;\n    const _xa_ = abs(xa);\n    const xb = x1 - x2;\n    const _xb_ = abs(xb);\n    const xc = 3 * xb;\n    const xc_ = 6 * _xb_; // === 3*_xb_ + 3*abs(xc)\n    const xx3 = xa + xc;\n    const xx3_ = _xa_ + xc_ + abs(xx3);\n    // ----------------------------\n    // xx2 = 3*((x2 + x0) - 2*x1)\n    // ----------------------------\n    const xd = x2 + x0;\n    const _xd_ = abs(xd);\n    const xe = xd - 2 * x1;\n    const _xe_ = _xd_ + abs(xe);\n    const xx2 = 3 * xe;\n    const xx2_ = 6 * _xe_; // 3*_xe_ + abs(xx2)\n    // ----------------------------\n    // xx1 = 3*(x1 - x0)\n    // ----------------------------\n    const xg = x1 - x0;\n    const _xg_ = abs(xg);\n    const xx1 = 3 * xg;\n    const xx1_ = 6 * _xg_; // 3*_xg_ + abs(3*xg)\n    // ------------------------------\n    // yy3 = (y3 - y0) + 3*(y1 - y2)\n    // ------------------------------\n    const ya = y3 - y0;\n    const _ya_ = abs(ya);\n    const yb = y1 - y2;\n    const _yb_ = abs(yb);\n    const yc = 3 * yb;\n    const yc_ = 6 * _yb_; // === 3*_yb_ + 3*abs(yc)\n    const yy3 = ya + yc;\n    const yy3_ = _ya_ + yc_ + abs(yy3);\n    // ----------------------------\n    // yy2 = 3*((y2 + y0) - 2*y1)\n    // ----------------------------\n    const yd = y2 + y0;\n    const _yd_ = abs(yd);\n    const ye = yd - 2 * y1;\n    const _ye_ = _yd_ + abs(ye);\n    const yy2 = 3 * ye;\n    const yy2_ = 6 * _ye_; // 3*_ye_ + abs(yy2)\n    // ----------------------------\n    // yy1 = 3*(y1 - y0)\n    // ----------------------------\n    const yg = y1 - y0;\n    const _yg_ = abs(yg);\n    const yy1 = 3 * yg;\n    const yy1_ = 6 * _yg_; // 3*_yg_ + abs(3*yg)\n    return {\n        coeffs: [[xx3, xx2, xx1, x0], [yy3, yy2, yy1, y0]],\n        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]\n    };\n}\n/** @internal */\nfunction toPowerBasis2WithRunningError(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    // ---------------------\n    // xx2 = (x2 + x0) - 2*x1\n    // ---------------------\n    const xa = x2 + x0;\n    const _xa_ = abs(xa);\n    const xx2 = xa - 2 * x1;\n    const xx2_ = _xa_ + abs(xx2);\n    // ---------------------\n    // xx1 = 2*(x1 - x0)\n    // ---------------------\n    const xx1 = 2 * (x1 - x0);\n    const xx1_ = abs(xx1);\n    // ---------------------\n    // yy2 = (y2 + y0) - 2*y1\n    // ---------------------\n    const ya = y2 + y0;\n    const _ya_ = abs(ya);\n    const yy2 = ya - 2 * y1;\n    const yy2_ = _ya_ + abs(yy2);\n    // ---------------------\n    // yy1 = 2*(y1 - y0)\n    // ---------------------\n    const yy1 = 2 * (y1 - y0);\n    const yy1_ = abs(yy1);\n    return {\n        coeffs: [[xx2, xx1, x0], [yy2, yy1, y0]],\n        errorBound: [[xx2_, xx1_, 0], [yy2_, yy1_, 0]]\n    };\n}\n/** @internal */\nfunction toPowerBasis1WithRunningError(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const xx1 = x1 - x0;\n    const xx1_ = abs(xx1);\n    const yy1 = y1 - y0;\n    const yy1_ = abs(yy1);\n    return {\n        coeffs: [[xx1, x0], [yy1, y0]],\n        errorBound: [[xx1_, 0], [yy1_, 0]]\n    };\n}\n/** @internal */\nfunction toPowerBasis0WithRunningError(ps) {\n    const [[x0, y0]] = ps;\n    return {\n        coeffs: [[x0], [y0]],\n        errorBound: [[0], [0]]\n    };\n}\n\n//# sourceMappingURL=to-power-basis-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis: () => (/* binding */ toPowerBasis),\n/* harmony export */   toPowerBasis0: () => (/* binding */ toPowerBasis0),\n/* harmony export */   toPowerBasis1: () => (/* binding */ toPowerBasis1),\n/* harmony export */   toPowerBasis2: () => (/* binding */ toPowerBasis2),\n/* harmony export */   toPowerBasis3: () => (/* binding */ toPowerBasis3)\n/* harmony export */ });\n/**\n * Returns the power basis representation of a bezier curve of order cubic or\n * less.\n *\n * * intermediate calculations are done in double precision\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasis(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1(ps);\n    }\n    if (ps.length === 1) {\n        return toPowerBasis0(ps);\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis3(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[\n            (x3 - x0) + 3 * (x1 - x2),\n            3 * ((x2 + x0) - 2 * x1),\n            3 * (x1 - x0),\n            x0\n        ], [\n            (y3 - y0) + 3 * (y1 - y2),\n            3 * ((y2 + y0) - 2 * y1),\n            3 * (y1 - y0),\n            y0\n        ]];\n}\n/** @internal */\nfunction toPowerBasis2(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [[\n            (x2 + x0) - 2 * x1,\n            2 * (x1 - x0),\n            x0\n        ], [\n            (y2 + y0) - 2 * y1,\n            2 * (y1 - y0),\n            y0\n        ]];\n}\n/** @internal */\nfunction toPowerBasis1(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            x1 - x0,\n            x0,\n        ], [\n            y1 - y0,\n            y0,\n        ]];\n}\n/** @internal */\nfunction toPowerBasis0(ps) {\n    const [[x0, y0]] = ps;\n    return [[x0], [y0]];\n}\n\n//# sourceMappingURL=to-power-basis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis0Exact: () => (/* binding */ toPowerBasis0Exact),\n/* harmony export */   toPowerBasis1Exact: () => (/* binding */ toPowerBasis1Exact),\n/* harmony export */   toPowerBasis2Exact: () => (/* binding */ toPowerBasis2Exact),\n/* harmony export */   toPowerBasis3Exact: () => (/* binding */ toPowerBasis3Exact),\n/* harmony export */   toPowerBasisExact: () => (/* binding */ toPowerBasisExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoSum;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.growExpansion;\nconst eAdd = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eAdd;\n/**\n * Returns the *exact* power basis representation of a bezier curve of order\n * cubic or less.\n *\n * * returns the resulting power basis x and y coordinate polynomials from\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\n * and `y(t) = dt^2 + et + f` then  the result is returned\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\n * expansions\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toPowerBasisExact(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3Exact(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2Exact(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1Exact(ps);\n    }\n    if (ps.length === 1) {\n        return toPowerBasis0Exact(ps);\n    }\n    throw new Error('The given bezier curve must be of order <= cubic.');\n}\n/** @internal */\nfunction toPowerBasis3Exact(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[\n            // (x3 - x0) + 3*(x1 - x2)\n            eAdd(td(x3, x0), sce(3, td(x1, x2))),\n            // OR\n            // (x3 - x0) - (2*x2 + x2) + (2*x1 + x1)\n            //eAdd(eAdd(td(x3,x0), ts(-2*x2, -x2)), ts(2*x1, x1))\n            // 3*((x2 + x0) - 2*x1)\n            sce(3, ge(ts(x2, x0), -2 * x1)),\n            // 3*(x1 - x0)\n            sce(3, td(x1, x0)),\n            // x0\n            [x0]\n        ], [\n            //ge(ge(sce(3, td(y1, y2)), y3), -y0),\n            eAdd(td(y3, y0), sce(3, td(y1, y2))),\n            //sce(3, ge(td(y2, 2*y1), y0)),\n            sce(3, ge(ts(y2, y0), -2 * y1)),\n            sce(3, td(y1, y0)),\n            [y0]\n        ]];\n}\n/** @internal */\nfunction toPowerBasis2Exact(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [[\n            // x2 - 2*x1 + x0\n            ge(ts(x2, x0), -2 * x1),\n            // 2*(x1 - x0)\n            td(2 * x1, 2 * x0),\n            //x0\n            [x0]\n        ], [\n            ge(ts(y2, y0), -2 * y1),\n            td(2 * y1, 2 * y0),\n            [y0]\n        ]];\n}\n/** @internal */\nfunction toPowerBasis1Exact(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [[\n            //x1 - x0,\n            td(x1, x0),\n            //x0\n            [x0]\n        ], [\n            td(y1, y0),\n            [y0]\n        ]];\n}\n/** @internal */\nfunction toPowerBasis0Exact(ps) {\n    const [[x0, y0]] = ps;\n    return [[[x0]], [[y0]]];\n}\n\n//# sourceMappingURL=to-power-basis-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis1ErrorCounters: () => (/* binding */ toPowerBasis1ErrorCounters),\n/* harmony export */   toPowerBasis2ErrorCounters: () => (/* binding */ toPowerBasis2ErrorCounters),\n/* harmony export */   toPowerBasis3ErrorCounters: () => (/* binding */ toPowerBasis3ErrorCounters),\n/* harmony export */   toPowerBasisErrorCounters: () => (/* binding */ toPowerBasisErrorCounters)\n/* harmony export */ });\n// Note: \n// Error counters of double-double will actually be slightly less but\n// we can use this for both double and double-double precision.\n// For double precision the error bound === γ * <counter> * `error_`\n// For double-double precision the error bound === γγ3 * <counter> * `error_`\nconst abs = Math.abs;\n/**\n * Returns a representation of the error (from which an absolute error bound\n * can be calculated) when calculating the power basis representation of a\n * bezier curve of order <= 3 (using e.g. `toPowerBasis` or `toPowerBasisDd`).\n *\n * The returned error representation needs to be multiplied with\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\n * or double-double). This is explained in more detail below. See\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n * p. 68 near the bottom.\n *\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\n *\n * The absolute erros below can be calculated as follows (where `<E>` are the\n * error counters as indicated in the comments of the return value below):\n *  * double precision: `<E> * (γ(1)) * result_`\n *  * double-double precision: `<E> * (γγ(3)) * result_`\n *\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\n * and `γγ(3) === 3.697785493223493e-32`.\n *\n * ```\n * // for cubic bezier curves\n * return [\n * \t[\n * \t\tx3,  // <E> === 3\n * \t\tx2,  // <E> === 3\n * \t\tx1,  // <E> === 2\n * \t\t0,\n * \t],\n * \t[\n * \t\ty3,  // <E> === 3\n * \t\ty2,  // <E> === 3\n * \t\ty1,  // <E> === 2\n * \t\t0,\n * \t]\n * ]\n *\n * // for quadratic bezier curves\n * return [\n * \t[\n * \t\tx2,  // <E> === 2\n * \t\tx1,  // <E> === 1\n * \t\t0,\n * \t],\n * \t[\n * \t\ty2,  // <E> === 2\n * \t\ty1,  // <E> === 1\n * \t\t0,\n * \t]\n * ];\n *\n * // for linear bezier curves (i.e. lines)\n * return [\n * \t[\n * \t\tx1_,  // <E> === 1\n * \t\tx0_   // <E> === 0\n * \t],\n * \t[\n * \t\ty1_,  // <E> === 1\n * \t\ty0_   // <E> === 0\n * \t]\n * ];\n * ```\n *\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc mdx\n */\nfunction toPowerBasisErrorCounters(ps) {\n    if (ps.length === 4) {\n        return toPowerBasis3ErrorCounters(ps);\n    }\n    if (ps.length === 3) {\n        return toPowerBasis2ErrorCounters(ps);\n    }\n    if (ps.length === 2) {\n        return toPowerBasis1ErrorCounters(ps);\n    }\n    if (ps.length === 1) {\n        return [[0], [0]];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n/** @internal */\nfunction toPowerBasis1ErrorCounters(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    return [\n        [\n            _x1 + _x0,\n            0,\n        ], [\n            _y1 + _y0,\n            0,\n        ]\n    ];\n}\n/** @internal */\nfunction toPowerBasis2ErrorCounters(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    return [\n        [\n            _x2 + _x0 + 2 * _x1,\n            2 * (_x1 + _x0),\n            0,\n        ], [\n            _y2 + _y0 + 2 * _y1,\n            2 * (_y1 + _y0),\n            0,\n        ]\n    ];\n}\n/** @internal */\nfunction toPowerBasis3ErrorCounters(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _x3 = abs(x3);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    const _y3 = abs(y3);\n    return [\n        [\n            _x3 + _x0 + 3 * (_x1 + _x2),\n            3 * (_x2 + _x0 + 2 * _x1),\n            3 * (_x1 + _x0),\n            0,\n        ], [\n            _y3 + _y0 + 3 * (_y1 + _y2),\n            3 * (_y2 + _y0 + 2 * _y1),\n            3 * (_y1 + _y0),\n            0,\n        ]\n    ];\n}\n\n//# sourceMappingURL=to-power-basis-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/clone.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/clone.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clone: () => (/* binding */ clone)\n/* harmony export */ });\n/**\n * Returns a clone of the given cubic bezier (with a different reference).\n *\n * @param ps a bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc\n */\nfunction clone(ps) {\n    const ps_ = [];\n    for (let i = 0; i < ps.length; i++) {\n        const p = ps[i];\n        ps_.push([p[0], p[1]]);\n    }\n    return ps_;\n}\n\n//# sourceMappingURL=clone.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/clone.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicToHybridQuadratic: () => (/* binding */ cubicToHybridQuadratic)\n/* harmony export */ });\n/**\n * Returns the hybrid quadratic version of the given cubic bezier. For a\n * definition of hybrid quadratic bezier curves please see\n * this [article](http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd)\n *\n * * returns an array of three quadratic bezier points where the\n * middle point is a 'hybrid' point represented as a line (itself represented\n * by two points (a linear bezier curve)) that can be evaluated at a different\n * `t` value (call it `th`). If evaluated at the same t value the result is the\n * same as evaluating the original cubic bezier at `t`.\n *\n * * the length of the linear bezier curve mentioned above is a measure of how\n * closely the cubic can be represented as a quadratic bezier curve.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction cubicToHybridQuadratic(ps) {\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [\n            [x0, y0],\n            [\n                [(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\n                [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]\n            ],\n            [x3, y3]\n        ];\n    }\n    throw new Error('The given bezier curve must be a cubic');\n}\n\n//# sourceMappingURL=cubic-to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicToQuadratic: () => (/* binding */ cubicToQuadratic)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.scaleExpansion;\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.twoSum;\n/**\n * Returns a quadratic approximation to the given cubic bezier curve.\n *\n * * the initial and final control points of the resulting bezier coincide with\n * that of the curve being approximated\n *\n * * if `preserveTangents` is `true` and the cubic's initial and final tangents\n * are parallel (and not coincident) then `undefined` is returned\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param preserveTangents optional; defaults to `false`; if `true` then the approximation\n * must also preserve the tangents of the cubic at the initial and final control\n * points\n *\n * @doc mdx\n */\nfunction cubicToQuadratic(ps, preserveTangents = false) {\n    // Note: if cubic is really a quad then\n    //   x3 + 3*(x1 - x2) === x0 && \n    //   y3 + 3*(y1 - y2) === y0\n    // Take the midpoint of the moving line of the hybrid quadratic version of \n    // the cubic as the new quadratic's middle control point.\n    if (!preserveTangents) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [\n            [x0, y0],\n            [\n                // [\n                //   (3*(x1 + x2) - (x0 + x3)) / 4, \n                //   (3*(y1 + y2) - (y0 + y3)) / 4\n                // ]\n                estimate(ediff(sce(ts(x1 / 4, x2 / 4), 3), ts(x0 / 4, x3 / 4))),\n                estimate(ediff(sce(ts(y1 / 4, y2 / 4), 3), ts(y0 / 4, y3 / 4)))\n            ],\n            [x3, y3]\n        ];\n    }\n    // At this point: `preserveTangents === true`\n    const [p0, p1, p2, p3] = ps;\n    const l1 = [p0, p1];\n    const l2 = [p3, p2];\n    const pM = llIntersection(l1, l2);\n    if (pM === undefined) {\n        return undefined;\n        //return [\n        //    p0,\n        //    [(p0[0] + p3[0])/2, (p0[1] + p3[1])/2],\n        //    p3\n        //];\n    }\n    return [p0, pM, p3];\n}\n/**\n * Returns the point of intersection of the given two lines or `undefined` if\n * the lines are parallel.\n *\n * * returns `undefined` *iff* the lines are *exactly* parallel\n *\n * @param l1\n * @param l2\n *\n * @internal\n */\nfunction llIntersection(l1, l2) {\n    const [[x1, y1], [x2, y2]] = l1;\n    const [[x3, y3], [x4, y4]] = l2;\n    const x1_ = td(x2, x1);\n    const y1_ = td(y2, y1);\n    const x2_ = td(x4, x3);\n    const y2_ = td(y4, y3);\n    const denom = ediff(epr(x2_, y1_), epr(y2_, x1_));\n    if (esign(denom) === 0) {\n        // definitely parallel\n        return undefined;\n    }\n    const x3_ = td(x3, x1);\n    const y3_ = td(y3, y1);\n    const b = ediff(epr(y3_, x1_), epr(x3_, y1_));\n    const bb = estimate(b) / estimate(denom);\n    return [\n        x3 + bb * estimate(x2_),\n        y3 + bb * estimate(y2_)\n    ];\n}\n\n//# sourceMappingURL=cubic-to-quadratic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lineToCubic: () => (/* binding */ lineToCubic)\n/* harmony export */ });\n/**\n * Returns a cubic bezier from the given line with evenly spaced control points.\n *\n * @param ps a 2d line represented by two points\n *\n * @doc mdx\n */\nfunction lineToCubic(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    const xInterval = (x1 - x0) / 3;\n    const yInterval = (y1 - y0) / 3;\n    return [\n        [x0, y0],\n        [x0 + xInterval, y0 + yInterval],\n        [x0 + xInterval * 2, y0 + yInterval * 2],\n        [x1, y1]\n    ];\n}\n\n//# sourceMappingURL=line-to-cubic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lineToQuadratic: () => (/* binding */ lineToQuadratic)\n/* harmony export */ });\n/**\n * Returns a quadratic bezier from the given line with evenly spaced control points.\n *\n * @param ps a 2d line represented by two points, e.g. `[[1,2],[3,4]]`\n *\n * @doc mdx\n */\nfunction lineToQuadratic(ps) {\n    const [[x0, y0], [x1, y1]] = ps;\n    return [\n        [x0, y0],\n        [(x0 + x1) / 2, (y0 + y1) / 2],\n        [x1, y1]\n    ];\n}\n\n//# sourceMappingURL=line-to-quadratic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   quadraticToCubic: () => (/* binding */ quadraticToCubic)\n/* harmony export */ });\n/**\n * Returns the cubic version of the given quadratic bezier curve (by degree\n * elevation).\n *\n * * quadratic bezier curves can always be represented exactly by cubics - the\n * converse is false\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n *\n * @doc mdx\n */\nfunction quadraticToCubic(ps) {\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [\n        [x0, y0],\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\n        [x2, y2]\n    ];\n}\n\n//# sourceMappingURL=quadratic-to-cubic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toCubic: () => (/* binding */ toCubic)\n/* harmony export */ });\n/* harmony import */ var _line_to_cubic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line-to-cubic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js\");\n/* harmony import */ var _quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quadratic-to-cubic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js\");\n\n\n/**\n * Returns a cubic bezier curve that is equivalent to the given linear or\n * quadratic bezier curve.\n *\n * Cubics are just returned unaltered.\n *\n * This function simply uses `lineToCubic` or `quadraticToCubic` internally.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc mdx\n */\nfunction toCubic(ps) {\n    if (ps.length === 4) { // Cubic\n        return ps;\n    }\n    if (ps.length === 3) { // Quadratic\n        return (0,_quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_0__.quadraticToCubic)(ps);\n    }\n    if (ps.length === 2) { // Linear\n        return (0,_line_to_cubic_js__WEBPACK_IMPORTED_MODULE_1__.lineToCubic)(ps);\n    }\n    if (ps.length === 1) { // Point\n        const p = ps[0];\n        return [p, p, p, p];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=to-cubic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/get-hodograph.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/get-hodograph.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHodograph: () => (/* binding */ getHodograph)\n/* harmony export */ });\n/**\n * Returns the hodograph of the given bezier curve.\n *\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n *\n * @doc mdx\n */\nfunction getHodograph(ps) {\n    // * **bitlength**: If the coordinates of the control points are bit-aligned then\n    // * max bitlength increase === 3, max shift === 3 (for cubics)\n    // * max bitlength increase === 1, max shift === 2 (for quadratics)\n    // * max bitlength increase === 1, max shift === 1 (for lines)\n    if (ps.length === 4) {\n        // cubic\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        return [\n            [3 * (x1 - x0), 3 * (y1 - y0)],\n            [3 * (x2 - x1), 3 * (y2 - y1)],\n            [3 * (x3 - x2), 3 * (y3 - y2)]\n        ];\n    }\n    if (ps.length === 3) {\n        // quadratic\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        return [\n            [2 * (x1 - x0), 2 * (y1 - y0)],\n            [2 * (x2 - x1), 2 * (y2 - y1)]\n        ];\n    }\n    if (ps.length === 2) {\n        // a line\n        const [[x0, y0], [x1, y1]] = ps;\n        return [\n            [x1 - x0, y1 - y0]\n        ];\n    }\n    throw new Error('The given bezier curve must be of order 1, 2 or 3.');\n}\n\n//# sourceMappingURL=get-hodograph.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/get-hodograph.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reduceOrderIfPossible: () => (/* binding */ reduceOrderIfPossible)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global-properties/classification/is-quad-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js\");\n/* harmony import */ var _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global-properties/classification/is-really-point.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js\");\n\n\n\n\n/**\n * Returns a reduced order version of the given bezier curve *if* it can be\n * represented as such without loss.\n *\n * Crucially, the reduced order bezier will have exactly the same `t` values\n * at specific `x` and `y` coordinates as the original.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc mdx\n */\nfunction reduceOrderIfPossible(ps) {\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_0__.isCubicReallyQuad)(ps)) {\n        ps = (0,_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__.cubicToQuadratic)(ps);\n    }\n    if (ps.length === 3 && (0,_global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_2__.isQuadReallyLine)(ps)) {\n        ps = [ps[0], ps[2]];\n    }\n    if (ps.length === 2 && (0,_global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__.isReallyPoint)(ps)) {\n        ps = [ps[0]];\n    }\n    return ps;\n}\n\n//# sourceMappingURL=reduce-order-if-possible.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/reverse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/reverse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reverse: () => (/* binding */ reverse)\n/* harmony export */ });\n/**\n * Returns the given points (e.g. bezier curve) in reverse order.\n *\n * Implementation details:\n * ```\n * const reverse = ps => ps.slice().reverse()\n * ```\n *\n * @param ps a bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction reverse(ps) {\n    return ps.slice().reverse();\n}\n\n//# sourceMappingURL=reverse.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/reverse.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromToInclErrorBound: () => (/* binding */ fromToInclErrorBound)\n/* harmony export */ });\n/* harmony import */ var _from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to/from-to-3-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js\");\n/* harmony import */ var _from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to/from-to-2-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js\");\n/* harmony import */ var _from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to/from-to-1-incl-error-bound.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js\");\n\n\n\nconst fromTo3 = _from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3InclErrorBound;\nconst fromTo2 = _from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__.fromTo2InclErrorBound;\nconst fromTo1 = _from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo1InclErrorBound;\n/**\n * Returns a bezier curve, `ps`, that starts and ends at the given `t` parameters\n * (starting at `tS` and ending at `tE`) including a matching coordinate-wise\n * error bound, `_ps`, that needs to be multiplied by `3u`, `5u` or `8u` (for\n * lines, quadratic or cubic bezier curves respectively) before use,\n * where `u === Number.EPSILON/2`.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @doc mdx\n */\nfunction fromToInclErrorBound(ps, tS, tE) {\n    if (ps.length === 4) {\n        return fromTo3(ps, tS, tE);\n    }\n    if (ps.length === 3) {\n        return fromTo2(ps, tS, tE);\n    }\n    if (ps.length === 2) {\n        return fromTo1(ps, tS, tE);\n    }\n    if (ps.length === 1) {\n        return { ps, _ps: [[0]] };\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=from-to-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo: () => (/* binding */ fromTo)\n/* harmony export */ });\n/* harmony import */ var _from_to_from_to_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to/from-to-3.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js\");\n/* harmony import */ var _from_to_from_to_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to/from-to-2.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js\");\n/* harmony import */ var _from_to_from_to_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to/from-to-1.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js\");\n\n\n\nconst fromTo3 = _from_to_from_to_3_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3;\nconst fromTo2 = _from_to_from_to_2_js__WEBPACK_IMPORTED_MODULE_1__.fromTo2;\nconst fromTo1 = _from_to_from_to_1_js__WEBPACK_IMPORTED_MODULE_2__.fromTo1;\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @doc mdx\n */\nfunction fromTo(ps, tS, tE) {\n    if (ps.length === 4) {\n        return fromTo3(ps, tS, tE);\n    }\n    if (ps.length === 3) {\n        return fromTo2(ps, tS, tE);\n    }\n    if (ps.length === 2) {\n        return fromTo1(ps, tS, tE);\n    }\n    if (ps.length === 1) {\n        return ps;\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n//# sourceMappingURL=from-to.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo1InclErrorBound: () => (/* binding */ fromTo1InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\n/** error free error bounds */\nconst psErrorFree = [[0, 0], [0, 0]];\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters\n * including an error bound (that needs to be multiplied by `3u` before use,\n * where `u === Number.EPSILON/2`).\n *\n * @param ps a linear bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo1InclErrorBound(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return { ps, _ps: psErrorFree };\n        }\n        return splitLeft1(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight1(ps, tS);\n    }\n    return splitAtBoth1(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given `t` parameter and ends\n * at `t === 1` including an error bound (that needs to be multiplied\n * by `3u`, where `u === Number.EPSILON/2`).\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight1(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1]] = ps; \n    const p0 = ps[0]; // exact\n    const p1 = ps[1]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const psR = [\n        [t * (x1 - x0) + x0,\n            t * (y1 - y0) + y0],\n        [x1,\n            y1] // yy1\n    ];\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _t = abs(t);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    // <3>xx0 <= <3>(<2>(t*<1>(x1 - x0)) + x0)\n    const _xx0 = _t * (_x1 + _x0) + _x0;\n    const _yy0 = _t * (_y1 + _y0) + _y0;\n    /** the coordinate-wise error bound */\n    //const psR_ = [\n    //    [3*u*_xx0, 3*u*_yy0],\n    //    [0, 0]\n    //];\n    const psR_ = [\n        [_xx0, _yy0],\n        [0, 0]\n    ];\n    return {\n        ps: psR,\n        _ps: psR_\n    };\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\n * parameter including an error bound (that needs to be multiplied by `3u`,\n * where `u === Number.EPSILON/2`).\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft1(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1]] = ps; \n    const p0 = ps[0]; // exact \n    const p1 = ps[1]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const psL = [\n        [x0,\n            y0],\n        [t * (x1 - x0) + x0,\n            t * (y1 - y0) + y0] // yy1\n    ];\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _t = abs(t);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    // <3>xx1 <= <3>(<2>(t*<1>(x1 - x0)) + x0)\n    const _xx1 = _t * (_x1 + _x0) + _x0;\n    const _yy1 = _t * (_y1 + _y0) + _y0;\n    /** the coordinate-wise error bound */\n    //const psL_ = [\n    //    [0, 0],\n    //    [3*u*_xx1, 3*u*_yy1],\n    //];\n    const psL_ = [\n        [0, 0],\n        [_xx1, _yy1],\n    ];\n    return {\n        ps: psL,\n        _ps: psL_\n    };\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters\n * including an error bound (that needs to be multiplied by `3u`, where\n * `u === Number.EPSILON/2`).\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth1(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1]] = ps; \n    const p0 = ps[0]; // exact\n    const p1 = ps[1]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const psB = [\n        [tS * (x1 - x0) + x0,\n            tS * (y1 - y0) + y0],\n        [tE * (x1 - x0) + x0,\n            tE * (y1 - y0) + y0] // yy1\n    ];\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _tS = abs(tS);\n    const _tE = abs(tE);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    // <3>xx0 <= <3>(<2>(tS*<1>(x1 - x0)) + x0)\n    const _xx0 = _tS * (_x1 + _x0) + _x0;\n    // <3>xx1\n    const _xx1 = _tE * (_x1 + _x0) + _x0;\n    const _yy0 = _tS * (_y1 + _y0) + _y0;\n    const _yy1 = _tE * (_y1 + _y0) + _y0;\n    /** the coordinate-wise error bound */\n    //const psR_ = [\n    //    [3*u*_xx0, 3*u*_yy0],\n    //    [0, 0]\n    //];\n    const psB_ = [\n        [_xx0, _yy0],\n        [_xx1, _yy1]\n    ];\n    return {\n        ps: psB,\n        _ps: psB_\n    };\n}\n\n//# sourceMappingURL=from-to-1-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo1: () => (/* binding */ fromTo1)\n/* harmony export */ });\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo1(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return ps;\n        }\n        return splitLeft1(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight1(ps, tS);\n    }\n    return splitAtBoth1(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given `t` parameter and ends\n * at `t === 1`.\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight1(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    // --------------------------------------------------------\n    return [\n        [t * (x1 - x0) + x0,\n            t * (y1 - y0) + y0],\n        [x1,\n            y1] // yy1\n    ];\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\n * parameter.\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft1(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    // --------------------------------------------------------\n    return [\n        [x0,\n            y0],\n        [t * (x1 - x0) + x0,\n            t * (y1 - y0) + y0] // yy1\n    ];\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth1(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    // --------------------------------------------------------\n    return [\n        [tS * (x1 - x0) + x0,\n            tS * (y1 - y0) + y0],\n        [tE * (x1 - x0) + x0,\n            tE * (y1 - y0) + y0] // yy1\n    ];\n}\n\n//# sourceMappingURL=from-to-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo2InclErrorBound: () => (/* binding */ fromTo2InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\n/** error free error bounds */\nconst psErrorFree = [[0, 0], [0, 0], [0, 0]];\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters\n * including an error bound (that needs to be multiplied by `5u`, where\n * `u === Number.EPSILON/2`).\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo2InclErrorBound(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return { ps, _ps: psErrorFree };\n        }\n        return splitLeft2(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight2(ps, tS);\n    }\n    return splitAtBoth2(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given t parameter and ends\n * at `t === 1` including an error bound (that needs to be multiplied\n * by `5u`, where `u === Number.EPSILON/2`).\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight2(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0]; // exact\n    const p1 = ps[1]; // exact\n    const p2 = ps[2]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    const x2 = p2[0];\n    const y2 = p2[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)\n    const xA = x0 - x1; // <1>xA\n    const xB = x2 - x1; // <1>xB\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const psR = [\n        [tt * (xA + xB) - (2 * t * xA - x0),\n            tt * (yA + yB) - (2 * t * yA - y0)],\n        [t * xB + x1,\n            t * yB + y1],\n        [x2,\n            y2] // yy2\n    ];\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _t = abs(t);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _xA = _x0 + _x1;\n    const _xB = _x2 + _x1;\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    const _yA = _y0 + _y1;\n    const _yB = _y2 + _y1;\n    // <5>xx0 <= <5>(<4>(<1>tt*<2>(<1>xA + <1>xB)) - <3>(<2>(2*t*<1>xA) - x0))\n    const _xx0 = tt * (_xA + _xB) + (2 * _t * _xA + _x0);\n    // <3>xx1 <= <3>(<2>(t*<1>xB) + x1)\n    const _xx1 = _t * _xB + _x1;\n    const _yy0 = tt * (_yA + _yB) + (2 * _t * _yA + _y0);\n    const _yy1 = 0;\n    /** the coordinate-wise error bound */\n    //const psR_ = [\n    //    [5*u*_xx0, 5*u*_yy0],\n    //    [3*u*_xx1, 3*u*_yy1],\n    //    [0, 0]\n    //];\n    const psR_ = [\n        [_xx0, _yy0],\n        [_xx1, _yy1],\n        [0, 0]\n    ];\n    return {\n        ps: psR,\n        _ps: psR_\n    };\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\n * parameter including an error bound (that needs to be multiplied by `5u`,\n * where `u === Number.EPSILON/2`).\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft2(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0]; // exact \n    const p1 = ps[1]; // exact\n    const p2 = ps[2]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    const x2 = p2[0];\n    const y2 = p2[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)\n    const xA = x0 - x1; // <1>xA\n    const yA = y0 - y1;\n    const psL = [\n        [x0,\n            y0],\n        [-t * xA + x0,\n            -t * yA + y0],\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0),\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\n    ];\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _t = abs(t);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _xA = _x0 + _x1;\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    const _yA = _y0 + _y1;\n    // <3>xx1 <= <3>(<2>(-t*<1>xA) + x0)\n    const _xx1 = _t * _xA + _x0;\n    // <5>xx2 <= <5>(<4>(<1>tt*<2>(<1>xA + <1>(x2 - x1))) - <3>(<2>(2*t*<1>xA) - x0))\n    const _xx2 = tt * (_xA + (_x2 + _x1)) + (2 * _t * _xA + _x0);\n    const _yy1 = _t * _yA + _y0;\n    const _yy2 = tt * (_yA + (_y2 + _y1)) + (2 * _t * _yA + _y0);\n    /** the coordinate-wise error bound */\n    //const psL_ = [\n    //    [0, 0],\n    //    [3*u*_xx1, 3*u*_yy1],\n    //    [5*u*_xx2, 5*u*_yy2],\n    //];\n    const psL_ = [\n        [0, 0],\n        [_xx1, _yy1],\n        [_xx2, _yy2]\n    ];\n    return {\n        ps: psL,\n        _ps: psL_\n    };\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters\n * including an error bound (that needs to be multiplied by `5u`, where\n * `u === Number.EPSILON/2`).\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth2(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0]; // exact\n    const p1 = ps[1]; // exact\n    const p2 = ps[2]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    const x2 = p2[0];\n    const y2 = p2[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const ttS = tS * tS; // <1>ttS  <= <0>tS<0>tS   (by counter rule 2)\n    const ttE = tE * tE; // ...\n    const tStE = tS * tE; // <1>tStE\n    const xA = x0 - x1; // <1>xA\n    const xB = x2 - x1; // <1>xB\n    const xC = xA + xB; // <2>xC\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const yC = yA + yB;\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _tS = abs(tS);\n    const _tE = abs(tE);\n    const _tStE = abs(tStE);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _xA = _x0 + _x1;\n    const _xC = _xA + _x2 + _x1;\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    const _yA = _y0 + _y1;\n    const _yC = _yA + _y2 + _y1;\n    // <5>xx0 = <5>(<4>(<1>ttS*<2>xC) - <3>(<2>(2*tS*<1>xA) - x0))\n    const _xx0 = ttS * _xC + (2 * _tS * _xA + _x0);\n    // <5>xx1 = <5>(<4>(<1>tStE*<2>xC) - <4>((<3>(<1>xA*<1>(tE + tS)) - x0)))\n    const _xx1 = _tStE * _xC + (_xA * (_tE + _tS) + _x0);\n    // <5>xx2 = <5>(<4>(<1>ttE*<2>xC) - <3>(<2>(2*tE*<1>xA) - x0))\n    const _xx2 = ttE * _xC + (2 * _tE * _xA + _x0);\n    const _yy0 = ttS * _yC + (2 * _tS * _yA + _y0);\n    const _yy1 = _tStE * yC + (_yA * (_tE + _tS) + _y0);\n    const _yy2 = ttE * _yC + (2 * _tE * _yA + _y0);\n    return {\n        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2]],\n        //ps_: [\n        //    [5*u*_xx0, 5*u*_yy0],\n        //    [5*u*_xx1, 5*u*_yy1],\n        //    [5*u*_xx2, 5*u*_yy2]\n        //]\n        _ps: [\n            [_xx0, _yy0],\n            [_xx1, _yy1],\n            [_xx2, _yy2]\n        ]\n    };\n}\n\n//# sourceMappingURL=from-to-2-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo2: () => (/* binding */ fromTo2)\n/* harmony export */ });\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo2(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return ps;\n        }\n        return splitLeft2(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight2(ps, tS);\n    }\n    return splitAtBoth2(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given t parameter and ends\n * at `t === 1`.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight2(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    // --------------------------------------------------------\n    const tt = t * t;\n    const xA = x0 - x1;\n    const xB = x2 - x1;\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    return [\n        [tt * (xA + xB) - (2 * t * xA - x0),\n            tt * (yA + yB) - (2 * t * yA - y0)],\n        [t * xB + x1,\n            t * yB + y1],\n        [x2,\n            y2] // yy2\n    ];\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\n * parameter.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft2(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    // --------------------------------------------------------\n    const tt = t * t;\n    const xA = x0 - x1;\n    const yA = y0 - y1;\n    return [\n        [x0,\n            y0],\n        [-t * xA + x0,\n            -t * yA + y0],\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0),\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\n    ];\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth2(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    // --------------------------------------------------------\n    const ttS = tS * tS;\n    const ttE = tE * tE;\n    const tStE = tS * tE;\n    const xA = x0 - x1;\n    const xB = x2 - x1;\n    const xC = xA + xB;\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const yC = yA + yB;\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2]];\n}\n\n//# sourceMappingURL=from-to-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo3InclErrorBound: () => (/* binding */ fromTo3InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\n/** error free error bounds */\nconst psErrorFree = [[0, 0], [0, 0], [0, 0], [0, 0]];\n/**\n * Returns a bezier curve that starts and ends at the given t parameters\n * including an error bound (that needs to be multiplied by `9u`, where\n * `u === Number.EPSILON/2`).\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo3InclErrorBound(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return { ps, _ps: psErrorFree };\n        }\n        return splitLeft3(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight3(ps, tS);\n    }\n    return splitAtBoth3(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given t parameter and ends\n * at `t === 1` including an error bound (that needs to be multiplied\n * by `9u`, where `u === Number.EPSILON/2`).\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight3(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x00 = p0[0];\n    const y00 = p0[1];\n    const x10 = p1[0];\n    const y10 = p1[1];\n    const x20 = p2[0];\n    const y20 = p2[1];\n    const x30 = p3[0];\n    const y30 = p3[1];\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const x01 = x00 - t * (x00 - x10);\n    const x11 = x10 - t * (x10 - x20);\n    const x21 = x20 - t * (x20 - x30);\n    const x02 = x01 - t * (x01 - x11);\n    const x12 = x11 - t * (x11 - x21);\n    const x03 = x02 - t * (x02 - x12);\n    const y01 = y00 - t * (y00 - y10);\n    const y11 = y10 - t * (y10 - y20);\n    const y21 = y20 - t * (y20 - y30);\n    const y02 = y01 - t * (y01 - y11);\n    const y12 = y11 - t * (y11 - y21);\n    const y03 = y02 - t * (y02 - y12);\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _t = abs(t);\n    const _x00 = abs(x00);\n    const _x10 = abs(x10);\n    const _x20 = abs(x20);\n    const _x30 = abs(x30);\n    const _y00 = abs(y00);\n    const _y10 = abs(y10);\n    const _y20 = abs(y20);\n    const _y30 = abs(y30);\n    const _x01 = _x00 + _t * (_x00 + _x10); // <3>x01 = <3>(x00 - <2>(t*<1>(x00 - x10)))\n    const _x11 = _x10 + _t * (_x10 + _x20); // <3>x11\n    const _x21 = _x20 + _t * (_x20 + _x30); // <3>x21\n    const _x02 = _x01 + _t * (_x01 + _x11); // <6>x02 = <6>(x01 - <5>(t*<4>(<3>x01 - <3>x11)))\n    const _x12 = _x11 + _t * (_x11 + _x21); // <6>x12\n    const _x03 = _x02 + _t * (_x02 + _x12); // <9>x03 = <9>(x02 - <8>(t*<7>(<6>x02 - <6>x12)))\n    const _y01 = _y00 + _t * (_y00 + _y10);\n    const _y11 = _y10 + _t * (_y10 + _y20);\n    const _y21 = _y20 + _t * (_y20 + _y30);\n    const _y02 = _y01 + _t * (_y01 + _y11);\n    const _y12 = _y11 + _t * (_y11 + _y21);\n    const _y03 = _y02 + _t * (_y02 + _y12);\n    return {\n        ps: [[x03, y03], [x12, y12], [x21, y21], [x30, y30]],\n        _ps: [\n            // the coordinate-wise error bounds\n            [_x03, _y03],\n            [_x12, _y12],\n            [_x21, _y21],\n            [0, 0] // [0, 0],\n        ]\n    };\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\n * parameter including an error bound (that needs to be multiplied by `9u`, where\n * `u === Number.EPSILON/2`).\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft3(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x00 = p0[0];\n    const y00 = p0[1];\n    const x10 = p1[0];\n    const y10 = p1[1];\n    const x20 = p2[0];\n    const y20 = p2[1];\n    const x30 = p3[0];\n    const y30 = p3[1];\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const x01 = x00 - t * (x00 - x10);\n    const x11 = x10 - t * (x10 - x20);\n    const x21 = x20 - t * (x20 - x30);\n    const x02 = x01 - t * (x01 - x11);\n    const x12 = x11 - t * (x11 - x21);\n    const x03 = x02 - t * (x02 - x12);\n    const y01 = y00 - t * (y00 - y10);\n    const y11 = y10 - t * (y10 - y20);\n    const y21 = y20 - t * (y20 - y30);\n    const y02 = y01 - t * (y01 - y11);\n    const y12 = y11 - t * (y11 - y21);\n    const y03 = y02 - t * (y02 - y12);\n    // -----------------------\n    // Calculate error bounds\n    // -----------------------\n    const _t = abs(t);\n    const _x00 = abs(x00);\n    const _x10 = abs(x10);\n    const _x20 = abs(x20);\n    const _x30 = abs(x30);\n    const _y00 = abs(y00);\n    const _y10 = abs(y10);\n    const _y20 = abs(y20);\n    const _y30 = abs(y30);\n    const _x01 = _x00 + _t * (_x00 + _x10); // <3>x01 = <3>(x00 - <2>(t*<1>(x00 - x10)))\n    const _x11 = _x10 + _t * (_x10 + _x20); // <3>x11\n    const _x21 = _x20 + _t * (_x20 + _x30); // <3>x21\n    const _x02 = _x01 + _t * (_x01 + _x11); // <6>x02 = <6>(x01 - <5>(t*<4>(<3>x01 - <3>x11)))\n    const _x12 = _x11 + _t * (_x11 + _x21); // <6>x12\n    const _x03 = _x02 + _t * (_x02 + _x12); // <9>x03 = <9>(x02 - <8>(t*<7>(<6>x02 - <6>x12)))\n    const _y01 = _y00 + _t * (_y00 + _y10);\n    const _y11 = _y10 + _t * (_y10 + _y20);\n    const _y21 = _y20 + _t * (_y20 + _y30);\n    const _y02 = _y01 + _t * (_y01 + _y11);\n    const _y12 = _y11 + _t * (_y11 + _y21);\n    const _y03 = _y02 + _t * (_y02 + _y12);\n    return {\n        ps: [[x00, y00], [x01, y01], [x02, y02], [x03, y03]],\n        _ps: [\n            // the coordinate-wise error bounds\n            [0, 0],\n            [_x01, _y01],\n            [_x02, _y02],\n            [_x03, _y03] // [9*u*_x03, 9*u*_y03]\n        ]\n    };\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters\n * including an error bound (that needs to be multiplied by `8u`, where\n * `u === Number.EPSILON/2`).\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth3(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1]; // exact\n    const p2 = ps[2];\n    const p3 = ps[3]; // exact\n    const x0 = p0[0];\n    const y0 = p0[1]; // exact\n    const x1 = p1[0];\n    const y1 = p1[1]; // exact\n    const x2 = p2[0];\n    const y2 = p2[1]; // exact\n    const x3 = p3[0];\n    const y3 = p3[1]; // exact\n    // --------------------------------------------------------\n    // error bound using counters <k>:\n    // counter rules:\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\n    //   2. <k>a<l>b = <k + l + 1>ab\n    //   3. fl(a) === <1>a\n    const ttS = tS * tS; // <1>ttS  <= <0>tS<0>tS   (by counter rule 2)\n    const tttS = tS * ttS; // <2>tttS <= <0>tS<1>ttS  (again by counter rule 2)\n    const ttE = tE * tE; // ...\n    const tttE = tE * ttE; // ...\n    const tStE = tS * tE; // <1>tStE\n    const xA = x0 - x1; // <1>xA\n    const xB = x2 - x1; // <1>xB\n    const xC = x3 - x0; // <1>xC\n    const xD = xA + xB; // <2>xD\n    const tSxA = tS * xA; // <2>tSxA\n    const tExA = tE * xA; // <2>tExA\n    const xC3xB = xC - 3 * xB; // <3>xC3xB = <3>(<1>xC - <2>(3*<1>xB))\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const yC = y3 - y0;\n    const yD = yA + yB;\n    const tSyA = tS * yA;\n    const tEyA = tE * yA;\n    const yC3yB = yC - 3 * yB;\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\n    // ----------------------------------------------\n    // Calculate error bounds\n    // ----------------------------------------------\n    const _tS = abs(tS);\n    const _tE = abs(tE);\n    const _tStE = abs(tStE);\n    const _tttS = abs(tttS);\n    const _tttE = abs(tttE);\n    const _x0 = abs(x0);\n    const _x1 = abs(x1);\n    const _x2 = abs(x2);\n    const _xA = _x0 + _x1;\n    const _xB = _x2 + _x1;\n    const _xD = _xA + _xB;\n    const _tSxA = _tS * _xA;\n    const _tExA = _tE * _xA;\n    const _xC3xB = abs(xC) + 3 * _xB;\n    const _y0 = abs(y0);\n    const _y1 = abs(y1);\n    const _y2 = abs(y2);\n    const _yA = _y0 + _y1;\n    const _yB = _y2 + _y1;\n    const _yD = _yA + _yB;\n    const _tSyA = _tS * _yA;\n    const _tEyA = _tE * _yA;\n    const _yC3yB = abs(yC) + 3 * _yB;\n    // <8>xx0 = <8>(<6>(<2>tttS*<3>xC3xB) + <7>(<6>(<1>(3*tS)*(<4>(<3>(tS*<2>xD) - <1>xA))) + x0));\n    const _xx0 = _tttS * _xC3xB + (3 * _tS * (_tS * _xD + _xA) + _x0);\n    // <7>xx1 = <7>(<6>(<1>tStE*<5>(<4>(tS*<3>xC3xB) + <2>(2*xD))) + <6>(<5>(<4>(<1>ttS*<2>xD) + x0) - <3>(<2>tExA + <2>(2*tSxA))));\n    const _xx1 = _tStE * (_tS * _xC3xB + 2 * _xD) + ((ttS * _xD + _x0) + (_tExA + 2 * _tSxA));\n    // <7>xx2 = <7>(<6>(<1>tStE*<5>(<4>(tE*<3>xC3xB) + <2>(2*xD))) + <6>(<5>(<4>(<1>ttE*<2>xD) + x0) - <3>(<2>(2*tExA) + <2>tSxA)));\n    const _xx2 = _tStE * (_tE * _xC3xB + 2 * _xD) + ((ttE * _xD + _x0) + (2 * _tExA + _tSxA));\n    // <8>xx3 = <8>(<6>(<2>tttE*<3>xC3xB) + <7>(<6>(<1>(3*tE)*(<4>(<3>(tE*<2>xD) - <1>xA))) + x0));\n    const _xx3 = _tttE * _xC3xB + (3 * _tE * (_tE * _xD + _xA) + _x0);\n    const _yy0 = _tttS * _yC3yB + (3 * _tS * (_tS * _yD + _yA) + _y0);\n    const _yy1 = _tStE * (_tS * _yC3yB + 2 * _yD) + ((ttS * _yD + _y0) + (_tEyA + 2 * _tSyA));\n    const _yy2 = _tStE * (_tE * _yC3yB + 2 * _yD) + ((ttE * _yD + _y0) + (2 * _tEyA + _tSyA));\n    const _yy3 = _tttE * _yC3yB + (3 * _tE * (_tE * _yD + _yA) + _y0);\n    return {\n        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]],\n        _ps: [\n            [_xx0, _yy0],\n            [_xx1, _yy1],\n            [_xx2, _yy2],\n            [_xx3, _yy3] // [8*u*_xx3, 8*u*_yy3]\n        ]\n    };\n}\n\n//# sourceMappingURL=from-to-3-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo3: () => (/* binding */ fromTo3)\n/* harmony export */ });\n/**\n * Returns a bezier curve that starts and ends at the given t parameters.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo3(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return ps;\n        }\n        return splitLeft3(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight3(ps, tS);\n    }\n    return splitAtBoth3(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given t parameter and ends\n * at `t === 1`.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight3(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x00 = p0[0];\n    const y00 = p0[1];\n    const x10 = p1[0];\n    const y10 = p1[1];\n    const x20 = p2[0];\n    const y20 = p2[1];\n    const x30 = p3[0];\n    const y30 = p3[1];\n    // --------------------------------------------------------\n    const x01 = x00 - t * (x00 - x10);\n    const x11 = x10 - t * (x10 - x20);\n    const x21 = x20 - t * (x20 - x30);\n    const x02 = x01 - t * (x01 - x11);\n    const x12 = x11 - t * (x11 - x21);\n    const x03 = x02 - t * (x02 - x12);\n    const y01 = y00 - t * (y00 - y10);\n    const y11 = y10 - t * (y10 - y20);\n    const y21 = y20 - t * (y20 - y30);\n    const y02 = y01 - t * (y01 - y11);\n    const y12 = y11 - t * (y11 - y21);\n    const y03 = y02 - t * (y02 - y12);\n    return [[x03, y03], [x12, y12], [x21, y21], [x30, y30]];\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\n * parameter.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft3(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x00 = p0[0];\n    const y00 = p0[1];\n    const x10 = p1[0];\n    const y10 = p1[1];\n    const x20 = p2[0];\n    const y20 = p2[1];\n    const x30 = p3[0];\n    const y30 = p3[1];\n    // --------------------------------------------------------\n    const x01 = x00 - t * (x00 - x10);\n    const x11 = x10 - t * (x10 - x20);\n    const x21 = x20 - t * (x20 - x30);\n    const x02 = x01 - t * (x01 - x11);\n    const x12 = x11 - t * (x11 - x21);\n    const x03 = x02 - t * (x02 - x12);\n    const y01 = y00 - t * (y00 - y10);\n    const y11 = y10 - t * (y10 - y20);\n    const y21 = y20 - t * (y20 - y30);\n    const y02 = y01 - t * (y01 - y11);\n    const y12 = y11 - t * (y11 - y21);\n    const y03 = y02 - t * (y02 - y12);\n    return [[x00, y00], [x01, y01], [x02, y02], [x03, y03]];\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth3(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const x3 = p3[0];\n    const y3 = p3[1];\n    // --------------------------------------------------------\n    const ttS = tS * tS;\n    const tttS = tS * ttS;\n    const ttE = tE * tE;\n    const tttE = tE * ttE;\n    const tStE = tS * tE;\n    const xA = x0 - x1;\n    const xB = x2 - x1;\n    const xC = x3 - x0;\n    const xD = xA + xB;\n    const tSxA = tS * xA;\n    const tExA = tE * xA;\n    const xC3xB = xC - 3 * xB;\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const yC = y3 - y0;\n    const yD = yA + yB;\n    const tSyA = tS * yA;\n    const tEyA = tE * yA;\n    const yC3yB = yC - 3 * yB;\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]];\n}\n\n//# sourceMappingURL=from-to-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitByCurvatureAndLength: () => (/* binding */ splitByCurvatureAndLength)\n/* harmony export */ });\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global-properties/curviness.js */ \"./node_modules/flo-bezier3/node/global-properties/curviness.js\");\n/* harmony import */ var _from_to_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n\n\n\n/**\n * Split the given bezier curve into pieces (given as an array of parameter\n * `t` values) such that each piece is flat within a given tolerance (where\n * curvature is measured by the `curviness` function).\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param maxCurviness optional; defaults to `0.4 radians`; maximum curviness\n * (must be > 0) as calculated using\n * the `curviness` function (that measures the total angle in radians formed\n * by the vectors formed by the ordered control points)\n * @param maxLength optional; defaults to `10`; maximum allowed length of any returned piece\n * @param minTSpan optional; defaults to `2**-16`; the minimum `t` span that can\n * be returned for a bezier piece; necessary for cubics otherwise a curve with a\n * cusp would cause an infinite loop\n *\n * @doc mdx\n */\nfunction splitByCurvatureAndLength(ps, maxCurviness = 0.4, maxLength = 10, minTSpan = 2 ** -16) {\n    const head = { r: [0, 1] };\n    let n = head;\n    while (n !== undefined) {\n        const ts_ = n.r;\n        const ps_ = (0,_from_to_js__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps, ts_[0], ts_[1]);\n        if (((0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__.controlPointLinesLength)(ps_) <= maxLength &&\n            (0,_global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_2__.curviness)(ps_) <= maxCurviness) || ts_[1] - ts_[0] <= minTSpan) {\n            n = n.next;\n            continue;\n        }\n        const t = (ts_[0] + ts_[1]) / 2;\n        const L = [ts_[0], t];\n        const R = [t, ts_[1]];\n        n.r = L;\n        n.next = { r: R, next: n.next };\n    }\n    n = head;\n    const ts = [];\n    while (n !== undefined) {\n        ts.push(n.r[0]);\n        if (n.next === undefined) {\n            ts.push(n.r[1]);\n        }\n        n = n.next;\n    }\n    return ts;\n}\n\n//# sourceMappingURL=split-by-curvature-and-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitByCurvature: () => (/* binding */ splitByCurvature)\n/* harmony export */ });\n/* harmony import */ var _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global-properties/curviness.js */ \"./node_modules/flo-bezier3/node/global-properties/curviness.js\");\n/* harmony import */ var _from_to_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n\n\n/**\n * Split the order 0,1,2 or 3 bezier curve into pieces (given as an array of\n * parameter `t` values) such that each piece is flat within a given tolerance\n * given by the `curviness` function.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param maxCurviness optional; defaults to `0.4 radians`; maximum curviness\n * (must be > 0) as calculated using\n * the `curviness` function (which measures the total angle in radians formed\n * by the vectors formed by the ordered control points)\n * @param minTSpan optional; defaults to `2**-16`; the minimum `t` span that\n * can be returned for a bezier piece; necessary for cubics otherwise a curve\n * with a cusp would cause an infinite loop\n *\n * @doc mdx\n */\nfunction splitByCurvature(ps, maxCurviness = 0.4, minTSpan = 2 ** -16) {\n    const head = { r: [0, 1] };\n    let n = head;\n    while (n !== undefined) {\n        const ts_ = n.r;\n        const ps_ = (0,_from_to_js__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps, ts_[0], ts_[1]);\n        const curviness_ = (0,_global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_1__.curviness)(ps_);\n        if (curviness_ <= maxCurviness || ts_[1] - ts_[0] <= minTSpan) {\n            n = n.next;\n            continue;\n        }\n        const t = (ts_[0] + ts_[1]) / 2;\n        const L = [ts_[0], t];\n        const R = [t, ts_[1]];\n        n.r = L;\n        n.next = { r: R, next: n.next };\n    }\n    n = head;\n    const ts = [];\n    while (n !== undefined) {\n        ts.push(n.r[0]);\n        if (n.next === undefined) {\n            ts.push(n.r[1]);\n        }\n        n = n.next;\n    }\n    return ts;\n}\n\n//# sourceMappingURL=split-by-curvature.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split/split-by-length.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split/split-by-length.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitByLength: () => (/* binding */ splitByLength)\n/* harmony export */ });\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _from_to_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to.js */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n\n\n/**\n * Split the given bezier curve into pieces (given as an array of parameter\n * `t` values) such that the longest curve length is guaranteed to be lower than\n * the given max length.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param maxLength\n *\n * @doc mdx\n */\nfunction splitByLength(ps, maxLength) {\n    const head = { r: [0, 1] };\n    let n = head;\n    while (n !== undefined) {\n        const ts_ = n.r;\n        const ps_ = (0,_from_to_js__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps, ts_[0], ts_[1]);\n        if ((0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__.controlPointLinesLength)(ps_) <= maxLength) {\n            n = n.next;\n            continue;\n        }\n        const t = (ts_[0] + ts_[1]) / 2;\n        const L = [ts_[0], t];\n        const R = [t, ts_[1]];\n        n.r = L;\n        n.next = { r: R, next: n.next };\n    }\n    n = head;\n    const ts = [];\n    while (n !== undefined) {\n        ts.push(n.r[0]);\n        if (n.next === undefined) {\n            ts.push(n.r[1]);\n        }\n        n = n.next;\n    }\n    return ts;\n}\n\n//# sourceMappingURL=split-by-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/split/split-by-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/to-string.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/to-string.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/**\n * Returns a 'human readable' string representation of the given bezier curve.\n *\n * @param ps a bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n *\n * @doc\n */\nfunction toString(ps) {\n    return `[${ps.map(p => `[${p.join(',')}]`).join(',')}]`;\n}\n\n//# sourceMappingURL=to-string.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-bezier3/node/transformation/to-string.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/are-boxes-intersecting.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/are-boxes-intersecting.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoxesIntersecting: () => (/* binding */ areBoxesIntersecting)\n/* harmony export */ });\n/**\n * Returns `true` if the 2 given axis-aligned rectangular boxes intersect.\n *\n * * **exact**: not susceptible to floating point round-off\n *\n * @param closed if `true`, interpret boxes as being closed (i.e. they contain\n * their border), otherwise open.\n * @param a an axis-aligned rectangular box (given by an array of two points,\n * e.g. `[[1,2], [3,4]]`)\n * @param b another axis-aligned rectangular box\n *\n * @doc mdx\n */\nfunction areBoxesIntersecting(closed, a, b) {\n    let [[ax0, ay0], [ax1, ay1]] = a;\n    let [[bx0, by0], [bx1, by1]] = b;\n    // Swap so smaller coordinate comes first\n    if (ay0 > ay1) {\n        [ay0, ay1] = [ay1, ay0];\n    }\n    if (by0 > by1) {\n        [by0, by1] = [by1, by0];\n    }\n    if (ax0 > ax1) {\n        [ax0, ax1] = [ax1, ax0];\n    }\n    if (bx0 > bx1) {\n        [bx0, bx1] = [bx1, bx0];\n    }\n    const closedX = closed || (ax0 === ax1 && bx0 === bx1);\n    const closedY = closed || (ay0 === ay1 && by0 === by1);\n    return ((closedX ? ax0 <= bx1 : ax0 < bx1) &&\n        (closedX ? ax1 >= bx0 : ax1 > bx0) &&\n        (closedY ? by0 <= ay1 : by0 < ay1) &&\n        (closedY ? by1 >= ay0 : by1 > ay0));\n    // return closed\n    //     ? ax0 <= bx1 &&\n    //       ax1 >= bx0 && \n    //       by0 <= ay1 &&\n    //       by1 >= ay0\n    //     : ax0 < bx1 &&\n    //       ax1 > bx0 && \n    //       by0 < ay1 &&\n    //       by1 > ay0\n}\n\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/are-boxes-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areContainersIntersecting: () => (/* binding */ areContainersIntersecting)\n/* harmony export */ });\n/* harmony import */ var _are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../are-boxes-intersecting.js */ \"./node_modules/flo-boolean/node/are-boxes-intersecting.js\");\n\nfunction areContainersIntersecting(container1, container2) {\n    return (0,_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__.areBoxesIntersecting)(true, container1.box, container2.box);\n}\n\n//# sourceMappingURL=are-containers-intersecting.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/filter-containers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/filter-containers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterContainers: () => (/* binding */ filterContainers)\n/* harmony export */ });\n/**\n * Returns the containers that is the given containers filtered so that those\n * having only interface intersections or only a single (given as a pair) even\n * multiple intersection are not included.\n * @param containers\n */\nfunction filterContainers(containers) {\n    const containers_ = containers.filter(container => {\n        const xs = container.xs;\n        if (container.xs.length === 2) {\n            const _x_ = xs[0];\n            if (_x_.x.kind === 1 && _x_.x.ri.multiplicity % 2 === 0) {\n                // multiple even intersection - exclude\n                return false;\n            }\n        }\n        for (const x of container.xs) {\n            if (x.x.kind !== 4) {\n                // include container if any __X__ is not an interface\n                return true;\n            }\n        }\n        return false; // exclude container\n    });\n    return containers_;\n}\n\n//# sourceMappingURL=filter-containers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/filter-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContainerInOuts: () => (/* binding */ getContainerInOuts)\n/* harmony export */ });\n/* harmony import */ var _get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-in-outs-via-sides/get-in-outs-via-sides.js */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js\");\n/* harmony import */ var _get_in_outs_via_crossing_get_in_outs_via_crossing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-in-outs-via-crossing/get-in-outs-via-crossing.js */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js\");\n\n\n/**\n * * **warning** ioIdx will be modified by this function\n *\n * @param container\n * @param ioIdx\n */\nfunction getContainerInOuts(container, ioIdx) {\n    // We check one __X__ for each curve with an intersection within this container\n    const xs = container.xs;\n    // console.log(xs);\n    // Check nature of Xs. If Xs is the very common case where two curves cross\n    // we can use a faster check. Also in the bit less common case where all\n    // curves are joining at an interface we can do a fast ccw (the ccw part\n    // has not been implemented yet).\n    if (xs.length === 2) {\n        if (xs[0].x.kind === 1 && xs[1].x.kind === 1 &&\n            xs[0].x.ri.multiplicity % 2 === 1 && xs[1].x.ri.multiplicity % 2 === 1) {\n            return (0,_get_in_outs_via_crossing_get_in_outs_via_crossing_js__WEBPACK_IMPORTED_MODULE_0__.getInOutsViaCrossing)(container, ioIdx);\n        }\n    }\n    return (0,_get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_1__.getInOutsViaSides)(container, ioIdx);\n}\n\n//# sourceMappingURL=get-container-in-outs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInOutsViaCrossing: () => (/* binding */ getInOutsViaCrossing)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/get-hodograph.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../get-in-outs-via-sides/get-in-outs-via-sides.js */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js\");\n\n\n\n/**\n * Returns the incoming / outgoing curves (as InOuts) for the given container.\n * @param container\n * @param ioIdx\n */\nfunction getInOutsViaCrossing(container, ioIdx) {\n    const xs = container.xs;\n    const inOuts = [];\n    const x1 = xs[0];\n    const x2 = xs[1];\n    const ps1 = x1.curve.ps;\n    const ps2 = x2.curve.ps;\n    const p = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps1, x1.x.ri.tS);\n    const t1S = x1.x.ri.tS;\n    const t1E = x1.x.ri.tE;\n    const t2S = x2.x.ri.tS;\n    const t2E = x2.x.ri.tE;\n    let v1s;\n    let v2s;\n    if (ps1.length === 4 || ps1.length === 3) {\n        // cubic => hodograph is a parabola\n        // quadratic => hodograph is a line (we still get the box, but in future maybe we can do better)\n        const h1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps1); // <= cubic: 50 bit-aligned => exact, quadratic: 52 bit-aligned => exact\n        v1s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(h1, [t1S, t1E]);\n    }\n    else /*if (ps1.length === 2)*/ {\n        // line => hodograph is a fixed point\n        v1s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps1); // <= 52 bit-aligned => exact\n    }\n    if (ps2.length === 4 || ps2.length === 3) {\n        // cubic => hodograph is a parabola\n        // quadratic => hodograph is a line (we still get the box, but in future maybe we can do better)\n        const h2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps2); // <= cubic: 50 bit-aligned => exact, quadratic: 52 bit-aligned => exact\n        v2s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(h2, [t2S, t2E]);\n    }\n    else /*if (ps2.length === 2)*/ {\n        // line => hodograph is a fixed point\n        v2s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps2); // <= 52 bit-aligned => exact\n    }\n    // possible configurations: (up to cyclic permutation)\n    // config1: i1 o2 o1 i2 ==== i2 i1 o2 o1 ==== etc.\n    // config2: i1 i2 o1 o2 ==== o2 i1 i2 o1 ==== etc.\n    let cSign = undefined;\n    // TODO - investigate faster method by finding and using the 2 extreme points only\n    for (let i = 0; i < v1s.length; i++) {\n        for (let j = 0; j < v2s.length; j++) {\n            // we use orient2d below since it is completely robust (cross is not)\n            //const c = Math.sign(cross(v1s[i],v2s[j]));\n            const c = Math.sign((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.orient2d)(v1s[i], v2s[j], [0, 0]));\n            if (c === 0) {\n                // too close to call \n                // use a more accurate but slower method\n                return (0,_get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_4__.getInOutsViaSides)(container, ioIdx);\n            }\n            if (cSign === undefined) {\n                cSign = c;\n                continue;\n            }\n            if (cSign !== c) {\n                // conflicting results\n                // use a more accurate but slower method\n                return (0,_get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_4__.getInOutsViaSides)(container, ioIdx);\n            }\n        }\n    }\n    const config1 = cSign > 0;\n    if (config1) {\n        // config1 (the 1st of the 2 possible configurations)\n        inOuts.push({ dir: -1, p, _x_: x1, container });\n        inOuts.push({ dir: +1, p, _x_: x2, container });\n        inOuts.push({ dir: +1, p, _x_: x1, container });\n        inOuts.push({ dir: -1, p, _x_: x2, container });\n        x1.in_ = inOuts[0];\n        x2.in_ = inOuts[3];\n    }\n    else {\n        // config2 (the 2nd of the 2 possible configurations)\n        inOuts.push({ dir: -1, p, _x_: x1, container });\n        inOuts.push({ dir: -1, p, _x_: x2, container });\n        inOuts.push({ dir: +1, p, _x_: x1, container });\n        inOuts.push({ dir: +1, p, _x_: x2, container });\n        x1.in_ = inOuts[0];\n        x2.in_ = inOuts[1];\n    }\n    return { inOuts, ioIdx };\n}\n\n//# sourceMappingURL=get-in-outs-via-crossing.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareOrderedInOut: () => (/* binding */ compareOrderedInOut)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/refine-k1.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n\n\nconst { abs } = Math;\n/**\n *\n * @param inOutA\n * @param inOutB\n */\nfunction compareOrderedInOut(inOutA, inOutB) {\n    // First compare side indexes - side indexes are the coursest ordering\n    const sideA = inOutA.side;\n    const sideB = inOutB.side;\n    let res = sideA - sideB;\n    if (res !== 0) {\n        return res;\n    }\n    // Could not resolve by side indexes (they are the same)\n    // Compare by side `t` values\n    const xA = inOutA.sideX;\n    const xB = inOutB.sideX;\n    res = xA.ri.tS - xB.ri.tS;\n    const errBound = 2 * 4 * Number.EPSILON; // is factor of 2 necessary?\n    if (abs(res) >= errBound) {\n        return res;\n    }\n    // At this point we zoom in once more (compensated once) to add an \n    // additional 49 bits accuracy\n    // TODO - first check if they are in the same k family - this will speed\n    // up the algorithm in those cases.\n    if (!xA.compensated) { // else the root is already compensated once\n        xA.compensated = 1; // compensate once - in future we can compensate more times if necessary\n        // there should be only 1 root in the 4u interval\n        // TODO - getPExact called too often - cache it!\n        xA.riExp = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.refineK1)(xA.ri, xA.getPExact())[0];\n    }\n    if (!xB.compensated) { // else the root is already compensated once\n        xB.compensated = 1; // compensate once - in future we can compensate more times if necessary\n        // there should be only 1 root in the 4u interval\n        // TODO - getPExact called too often - cache it!\n        xB.riExp = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.refineK1)(xB.ri, xB.getPExact())[0];\n    }\n    //console.log('compensated')\n    //console.log('xA', expEst(xA.riExp.tS), ' - ', expEst(xA.riExp.tE));\n    //console.log('xB', expEst(xB.riExp.tS), ' - ', expEst(xB.riExp.tE));\n    res = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eCompare)(xA.riExp.tS, xB.riExp.tS);\n    if (res !== 0) {\n        return res;\n    }\n    // At this stage it is either the same curve (mathematically, if endpoints\n    // and direction is ignored) or even the once compenensated roots cannot be\n    // resolved. In future we can cascade compensations to ensure resolution\n    // but we are already about a quadrillionth of a quadrillionth of a unit\n    // accurate at this stage.\n    res = inOutB.dir - inOutA.dir;\n    if (res !== 0) {\n        return res;\n    }\n    // At this stage they are both in or both out\n    // We reverse sort the ins in comparison to the outs\n    return inOutA.dir === 1\n        ? inOutA.idx - inOutB.idx\n        : inOutB.idx - inOutA.idx;\n}\n\n//# sourceMappingURL=compare-in-out.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInOutsViaSides: () => (/* binding */ getInOutsViaSides)\n/* harmony export */ });\n/* harmony import */ var _get_x_in_outs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-x-in-outs.js */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js\");\n\n/**\n * Returns the incoming / outgoing curves (as InOuts) for the given container\n * using an extremely small rectangle around the intersections.\n * * **warning** ioIdx will be modified by this function\n * @param container\n * @param ioIdx\n */\nfunction getInOutsViaSides(container, ioIdx) {\n    // We check one __X__ for each curve with an intersection within this container\n    const xs_ = container.xs;\n    //if (xs_.length === 4) {\n    //    console.log(xs_.map(x => x.x.kind))\n    //}\n    const inOuts = [];\n    // get a map from each Curve to each __X__ of this container\n    const xMap = new Map();\n    for (const x of xs_) {\n        const curve = x.curve;\n        const xs = xMap.get(curve);\n        if (!xs) {\n            xMap.set(curve, [x]);\n        }\n        else {\n            xs.push(x);\n        }\n    }\n    const getXInOuts_ = (0,_get_x_in_outs_js__WEBPACK_IMPORTED_MODULE_0__.getXInOuts)(container);\n    for (const entry of xMap) {\n        const [curve, xs] = entry;\n        let ins;\n        let outs;\n        ({ ins, outs, ioIdx } = getXInOuts_(curve, xs, ioIdx));\n        inOuts.push(...ins);\n        inOuts.push(...outs);\n    }\n    return { inOuts: inOuts, ioIdx };\n}\n\n//# sourceMappingURL=get-in-outs-via-sides.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getXInOuts: () => (/* binding */ getXInOuts)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/refine-k1.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js\");\n/* harmony import */ var _sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../sweep-line/are-boxes-intersecting.js */ \"./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js\");\n\n\n\n\nfunction midBox(_x_) {\n    return [\n        (_x_.x.box[0][0] + _x_.x.box[1][0]) / 2,\n        (_x_.x.box[0][1] + _x_.x.box[1][1]) / 2\n    ];\n}\n/**\n * * **warning** modifies container.xs[i].in_\n * @param container\n */\nfunction getXInOuts(container) {\n    const [[left, top], [right, bottom]] = container.box;\n    const sides = [\n        [[right, top], [left, top]],\n        [[left, top], [left, bottom]],\n        [[left, bottom], [right, bottom]],\n        [[right, bottom], [right, top]]\n    ];\n    return (curve, xs_, ioIdx) => {\n        // At this point all xs belong to the same curve and container.\n        // For each of the four sides get the t values closest to the \n        // intersection t.\n        const ps = curve.ps;\n        const xs = xs_.slice();\n        for (let i = 0; i < sides.length; i++) {\n            const xs_ = getTs(ps, sides[i]);\n            for (const { psX, sideX } of xs_) {\n                xs.push({\n                    x: psX,\n                    side: i,\n                    sideX,\n                    curve: undefined, // unused\n                });\n            }\n        }\n        //---- resolve in-outs\n        // the sort below should always resolve if the container dimension is\n        // 'large enough', where large enough is based on the maximum value that\n        // the tangent magnitude of a curve can attain (no need to resort to \n        // compensated intervals)\n        xs.sort((xA, xB) => xA.x.ri.tS - xB.x.ri.tS);\n        const ins = [];\n        const outs = [];\n        let prevX = undefined;\n        /** true if the prevX was a proper X, false if it was a SideX */\n        let prevWasX = undefined;\n        for (const x of xs) {\n            if (x.side !== undefined) {\n                // it is a sideX\n                if (prevWasX === true) {\n                    outs.push({\n                        dir: +1,\n                        p: midBox(x),\n                        _x_: prevX,\n                        container,\n                        idx: ++ioIdx,\n                        side: x.side,\n                        sideX: x.sideX\n                    });\n                }\n                prevWasX = false;\n            }\n            else {\n                // it is a proper X\n                if (prevWasX === false) {\n                    ins.push({\n                        dir: -1,\n                        p: midBox(prevX),\n                        _x_: x,\n                        container,\n                        idx: ++ioIdx,\n                        side: prevX.side,\n                        sideX: prevX.sideX\n                    });\n                    x.in_ = ins[ins.length - 1];\n                }\n                prevWasX = true;\n            }\n            prevX = x;\n        }\n        return { ins, outs, ioIdx };\n    };\n}\n/**\n * Get zero times compensated roots and exact coefficents\n */\nfunction getXs0(ps1, ps2) {\n    // const _coeffs = getIntersectionCoeffs(ps1, ps2);\n    const _coeffs = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getCoeffsBezBez)(ps1, ps2);\n    if (_coeffs === undefined) {\n        return undefined;\n    }\n    const { coeffs, errBound, getPExact } = _coeffs;\n    const ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)(coeffs, 0, 1, errBound, getPExact);\n    if (ris.length === 0) {\n        return undefined;\n    }\n    return { ris: ris.map(flo_poly__WEBPACK_IMPORTED_MODULE_2__.rootIntervalToExp), getPExact };\n}\nfunction rootIntervalToDouble(ri) {\n    return {\n        tS: (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eEstimate)(ri.tS),\n        tE: (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eEstimate)(ri.tE),\n        multiplicity: ri.multiplicity\n    };\n}\n/**\n * Robustly get matching intersections of ps (a bezier) that matches those of\n * side. ps and side can actually be any order 1, 2 or 3 bezier curve.\n * * **precondition** RootInterval[] contains no multiple roots\n * @param ps\n * @param side\n * @param risSide_\n */\nfunction getTs(ps, side) {\n    const xs0Side = getXs0(ps, side);\n    if (xs0Side === undefined) {\n        return [];\n    }\n    const { getPExact: getPExactSide } = xs0Side;\n    let { ris: risSide } = xs0Side;\n    //const exactSide = getPExactSide();\n    let exactSide = undefined; // lazy loaded\n    const getPExactSide_ = () => {\n        exactSide = exactSide || getPExactSide();\n        return exactSide;\n    };\n    const xs0Ps = getXs0(side, ps);\n    if (xs0Ps === undefined) {\n        return [];\n    }\n    let { ris: risPs } = xs0Ps;\n    const { getPExact: getPExactPs } = xs0Ps;\n    //const exactPs = getPExactPs();\n    let exactPs = undefined; // lazy loaded\n    const getPExactPs_ = () => {\n        exactPs = exactPs || getPExactPs();\n        return exactPs;\n    };\n    //---- Make sure no boxesPs overlap. \n    // If any two boxes do operlap we cannot match the t value of a ps box to \n    // that of a side box, else we can definitively match them.\n    // Note: multiplicity > 1 intersections will result in an infinite loop. \n    // It is assumed (as a precondition) the code is such that a multiple \n    // intersection is node possible here\n    let maxIter;\n    // currently we only go up to once compensated (double-double precision roots)\n    maxIter = 1;\n    /** number of compensations for ps */\n    let cPs = 0;\n    let boxesPs = undefined;\n    loop: while ( true && cPs < maxIter) {\n        // update boxes to new tighter versions\n        boxesPs = risPs.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.getIntervalBoxDd)(ps, [ri.tS, ri.tE]));\n        for (let i = 0; i < risPs.length; i++) {\n            const boxPsI = boxesPs[i];\n            for (let j = i + 1; j < risPs.length; j++) {\n                const boxPsJ = boxesPs[j];\n                if ((0,_sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_5__.areBoxesIntersectingDd)(true)(boxPsI, boxPsJ)) {\n                    const _risPs = [];\n                    for (const riPs of risPs) {\n                        // TODO - below we're converting riPs (using getXs0) to RootIntervalExp and below back to \n                        // RootInterval again - not necessary - fix\n                        _risPs.push(...(0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.refineK1)({ tS: riPs.tS[1], tE: riPs.tE[1], multiplicity: riPs.multiplicity }, getPExactPs_()));\n                    }\n                    risPs = _risPs;\n                    cPs++;\n                    continue loop;\n                }\n            }\n        }\n        break loop;\n    }\n    //---- Make sure no boxesSides overlap - this should be rare as we are \n    // already roughly once compensated on that (due to small length of the sides).\n    // currently we only go up to once compensated (quad precision roots)\n    maxIter = 1;\n    /** number of compensations for sides */\n    let cSide = 0;\n    let boxesSide = undefined;\n    loop: while ( true && cSide < maxIter) {\n        boxesSide = risSide.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.getIntervalBoxDd)(side, [ri.tS, ri.tE]));\n        for (let i = 0; i < risSide.length; i++) {\n            const boxSideI = boxesSide[i];\n            for (let j = i + 1; j < risSide.length; j++) {\n                const boxSideJ = boxesSide[j];\n                if ((0,_sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_5__.areBoxesIntersectingDd)(true)(boxSideI, boxSideJ)) {\n                    const _risSide = [];\n                    for (const riSide of risSide) {\n                        _risSide.push(...(0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.refineK1)({ tS: riSide.tS[1], tE: riSide.tE[1], multiplicity: riSide.multiplicity }, getPExactSide_()));\n                    }\n                    risSide = _risSide;\n                    cSide++;\n                    continue loop;\n                }\n            }\n        }\n        break loop;\n    }\n    const xPairs = [];\n    for (let i = 0; i < risPs.length; i++) {\n        const boxPs = boxesPs[i];\n        for (let j = 0; j < risSide.length; j++) {\n            const boxSide = boxesSide[j];\n            // TODO - investigate if below commented code would improve algorithm\n            //const box = intersectBoxes(boxPs,boxSide);\n            //if (box !== undefined) {\n            if ((0,_sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_5__.areBoxesIntersectingDd)(true)(boxPs, boxSide)) {\n                const psX = {\n                    compensated: cPs,\n                    ri: rootIntervalToDouble(risPs[i]),\n                    riExp: cPs ? risPs[i] : undefined,\n                    getPExact: cPs ? undefined : getPExactPs,\n                    kind: 1,\n                    box: boxExpToBox(boxPs)\n                };\n                const sideX = {\n                    compensated: cSide,\n                    ri: rootIntervalToDouble(risSide[j]),\n                    riExp: cSide ? risSide[j] : undefined,\n                    getPExact: cSide ? undefined : getPExactSide,\n                    kind: 1,\n                    box: boxExpToBox(boxSide)\n                };\n                xPairs.push({ psX, sideX });\n            }\n        }\n    }\n    return xPairs;\n}\n/**\n * Converts a box with expansion coordinates into one with double coordinates.\n */\nfunction boxExpToBox(boxExp) {\n    return boxExp.map(p => p.map(big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eEstimate));\n}\n\n//# sourceMappingURL=get-x-in-outs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-containers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-containers.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContainers: () => (/* binding */ getContainers)\n/* harmony export */ });\n/* harmony import */ var _are_containers_intersecting_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./are-containers-intersecting.js */ \"./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js\");\n/* harmony import */ var _graph_get_connected_components_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../graph/get-connected-components.js */ \"./node_modules/flo-boolean/node/graph/get-connected-components.js\");\n/* harmony import */ var _get_isolated_containers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-isolated-containers.js */ \"./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js\");\n/* harmony import */ var _merge_containers_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge-containers.js */ \"./node_modules/flo-boolean/node/calc-containers/merge-containers.js\");\n/* harmony import */ var _get_container_in_outs_get_container_in_outs_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./get-container-in-outs/get-container-in-outs.js */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js\");\n/* harmony import */ var _get_critical_points_get_intersections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../get-critical-points/get-intersections.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-intersections.js\");\n/* harmony import */ var _get_critical_points_set_intersection_next_values_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../get-critical-points/set-intersection-next-values.js */ \"./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js\");\n/* harmony import */ var _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../sweep-line/sweep-line.js */ \"./node_modules/flo-boolean/node/sweep-line/sweep-line.js\");\n/* harmony import */ var _get_critical_points_get_self_intersections_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../get-critical-points/get-self-intersections.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js\");\n/* harmony import */ var _get_critical_points_get_interface_intersections_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../get-critical-points/get-interface-intersections.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js\");\n/* harmony import */ var _get_critical_points_get_excessive_curvatures_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../get-critical-points/get-excessive-curvatures.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-excessive-curvatures.js\");\n/* harmony import */ var _get_critical_points_get_extremes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-critical-points/get-extremes.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-extremes.js\");\n/* harmony import */ var _send_containers_to_grid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./send-containers-to-grid.js */ \"./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js\");\n/* harmony import */ var _get_container_in_outs_get_in_outs_via_sides_compare_in_out_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./get-container-in-outs/get-in-outs-via-sides/compare-in-out.js */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js\");\n/* harmony import */ var _filter_containers_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./filter-containers.js */ \"./node_modules/flo-boolean/node/calc-containers/filter-containers.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n *\n * @param containerDim\n */\nfunction getContainers(loops, containerDim, expMax) {\n    const xs1 = (0,_get_critical_points_get_intersections_js__WEBPACK_IMPORTED_MODULE_0__.getIntersections)(loops, expMax);\n    const xs2 = (0,_get_critical_points_get_self_intersections_js__WEBPACK_IMPORTED_MODULE_1__.getSelfIntersections)(loops);\n    const xs3 = (0,_get_critical_points_get_interface_intersections_js__WEBPACK_IMPORTED_MODULE_2__.getInterfaceIntersections)(loops);\n    const { extremes, xs: xs4 } = (0,_get_critical_points_get_extremes_js__WEBPACK_IMPORTED_MODULE_3__.getExtremes)(loops);\n    const xs5 = (0,_get_critical_points_get_excessive_curvatures_js__WEBPACK_IMPORTED_MODULE_4__.getExcessiveCurvatures)(expMax, loops);\n    let xPairs = [...xs1, ...xs2, ...xs3, ...xs4, ...xs5];\n    // console.log('general  ', xs1);\n    // console.log('self     ', xs2);\n    // console.log('interface', xs3);\n    // console.log('topmost  ', xs4);\n    // console.log('excessive  ', xs5);\n    if (typeof _debug_ !== 'undefined') {\n        for (const xPair of xs1) {\n            _debug_.generated.elems.intersection.push(...xPair);\n        }\n        for (const xPair of xs2) {\n            _debug_.generated.elems.intersection.push(...xPair);\n        }\n        for (const xPair of xs3) {\n            _debug_.generated.elems.intersection.push(...xPair);\n        }\n        for (const xPair of xs4) {\n            _debug_.generated.elems.intersection.push(...xPair);\n        }\n        for (const xPair of xs5) {\n            _debug_.generated.elems.intersection.push(...xPair);\n        }\n    }\n    // initialize the containers with one of the one-sided intersections\n    // console.log(xPairs)\n    let containers = xPairs.map(xPair => ({\n        xs: xPair,\n        box: [\n            // TODO xs[0].box -> combine xs[0] and xs[1] boxes\n            [xPair[0].x.box[0][0] - containerDim, xPair[0].x.box[0][1] - containerDim],\n            [xPair[0].x.box[1][0] + containerDim, xPair[0].x.box[1][1] + containerDim]\n        ],\n        inOuts: undefined // to be set later\n    }));\n    // iterate, combining containers that overlap on each iteration \n    while (true) {\n        /** container intersections as an array of Container pairs */\n        const is = (0,_sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_5__.sweepLine)(containers, getLeftMost, getRightMost, _are_containers_intersecting_js__WEBPACK_IMPORTED_MODULE_6__.areContainersIntersecting);\n        // if there are no more intersections between containers we're done\n        if (!is.length) {\n            break;\n        }\n        const graph = new Map();\n        (0,_graph_get_connected_components_js__WEBPACK_IMPORTED_MODULE_7__.addEdges)(graph, is);\n        const connectedContainers = (0,_graph_get_connected_components_js__WEBPACK_IMPORTED_MODULE_7__.getConnectedComponents)(graph);\n        const isolatedContainers = (0,_get_isolated_containers_js__WEBPACK_IMPORTED_MODULE_8__.getIsolatedComponents)(containers, connectedContainers);\n        containers = [\n            ...(0,_merge_containers_js__WEBPACK_IMPORTED_MODULE_9__.mergeContainers)(connectedContainers),\n            ...isolatedContainers\n        ];\n    }\n    containers = (0,_filter_containers_js__WEBPACK_IMPORTED_MODULE_10__.filterContainers)(containers);\n    containers = (0,_send_containers_to_grid_js__WEBPACK_IMPORTED_MODULE_11__.sendContainersToGrid)(containers, expMax, containerDim);\n    // console.log(xPairs.map(xp => xp[0].x.kind).filter(k => k === 7).length);\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.container = containers;\n    }\n    // Add the other half of the intersections too - all intersections has \n    // exactly one opposite curve intersection (t values come in pairs)\n    // Also, set inOuts on each container, and `idx`\n    let ioIdx = 0;\n    for (const container of containers) {\n        for (const x of container.xs) {\n            x.container = container;\n        }\n        let inOuts;\n        ({ inOuts, ioIdx } = (0,_get_container_in_outs_get_container_in_outs_js__WEBPACK_IMPORTED_MODULE_12__.getContainerInOuts)(container, ioIdx));\n        container.inOuts = inOuts;\n    }\n    // remove xs not belonging to a container (caused by filterContainers)\n    xPairs = xPairs.filter(x => x[0].container !== undefined);\n    (0,_get_critical_points_set_intersection_next_values_js__WEBPACK_IMPORTED_MODULE_13__.setIntersectionNextValues)(xPairs);\n    // Connect container ins and outs\n    for (const container of containers) {\n        for (const out of container.inOuts) {\n            if (out.dir === -1) {\n                continue;\n            }\n            let _x_ = out._x_;\n            // move to next 'in' __X__\n            while (true) {\n                _x_ = _x_.next;\n                if (_x_.in_ !== undefined) {\n                    break;\n                }\n            }\n            out.next = _x_.in_;\n            out.idx = out.next.idx;\n        }\n    }\n    for (const container of containers) {\n        container.inOuts.sort(_get_container_in_outs_get_in_outs_via_sides_compare_in_out_js__WEBPACK_IMPORTED_MODULE_14__.compareOrderedInOut);\n    }\n    // set `next` and `prev` around container for each `inOut` for each `container`\n    for (const container of containers) {\n        const inOuts = container.inOuts;\n        let prevInOut = inOuts[inOuts.length - 1];\n        for (let i = 0; i < inOuts.length; i++) {\n            const inOut = inOuts[i];\n            inOut.prevAround = prevInOut;\n            prevInOut.nextAround = inOut;\n            prevInOut = inOut;\n        }\n    }\n    return { extremes, containers };\n}\nfunction getLeftMost(container) {\n    return container.box[0][0];\n}\nfunction getRightMost(container) {\n    return container.box[1][0];\n}\n\n//# sourceMappingURL=get-containers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIsolatedComponents: () => (/* binding */ getIsolatedComponents)\n/* harmony export */ });\n/**\n * @param containers all containers\n * @param connectedContainers\n */\nfunction getIsolatedComponents(containers, connectedContainers) {\n    const connectedContainers_ = new Set();\n    for (const cs of connectedContainers) {\n        for (const c of cs) {\n            connectedContainers_.add(c);\n        }\n    }\n    const res = [];\n    for (let i = 0; i < containers.length; i++) {\n        const container = containers[i];\n        if (!connectedContainers_.has(container)) {\n            res.push(container);\n        }\n    }\n    return res;\n}\n\n//# sourceMappingURL=get-isolated-containers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/merge-containers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/merge-containers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeContainers: () => (/* binding */ mergeContainers)\n/* harmony export */ });\nfunction mergeContainers(ccs) {\n    const containers = [];\n    for (const cc of ccs) {\n        let minLeft = Number.POSITIVE_INFINITY;\n        let minTop = Number.POSITIVE_INFINITY;\n        let maxRight = Number.NEGATIVE_INFINITY;\n        let maxBottom = Number.NEGATIVE_INFINITY;\n        const xs = [];\n        for (const c of cc) {\n            const [[left, top], [right, bottom]] = c.box;\n            if (left < minLeft) {\n                minLeft = left;\n            }\n            if (top < minTop) {\n                minTop = top;\n            }\n            if (right > maxRight) {\n                maxRight = right;\n            }\n            if (bottom > maxBottom) {\n                maxBottom = bottom;\n            }\n            xs.push(...c.xs);\n        }\n        // console.log(minLeft)\n        const container = {\n            box: [[minLeft, minTop], [maxRight, maxBottom]],\n            xs: xs,\n            inOuts: undefined\n        };\n        containers.push(container);\n    }\n    return containers;\n}\n\n//# sourceMappingURL=merge-containers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/merge-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sendContainersToGrid: () => (/* binding */ sendContainersToGrid)\n/* harmony export */ });\n/* harmony import */ var _loop_normalize_to_grid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loop/normalize/to-grid.js */ \"./node_modules/flo-boolean/node/loop/normalize/to-grid.js\");\n\n/**\n * Returns the containers from the given containers by sending their boxes to a\n * grid with a smaller bitlength.\n *\n * @param containers\n * @param expMax\n * @param containerDim\n */\nfunction sendContainersToGrid(containers, expMax, containerDim) {\n    /**\n     * The exponent difference between expMax and the distance of critical\n     * points from the sides of the containers. This value cannot be higher\n     * than ⌈sqrt(n)⌉ where n is the number of intersections in a container.\n     * Assume n < 100 - this is a (mild) limitation of the algorithm\n     */\n    const expContainer = Math.log2(containerDim);\n    const expContainerAdj = expContainer - 3; // 2**-3 === 1/8 of container\n    const containers_ = containers.map(container => {\n        const box = container.box.map(p => p.map(c => {\n            return (0,_loop_normalize_to_grid_js__WEBPACK_IMPORTED_MODULE_0__.toGrid)(c, expMax, expMax - expContainerAdj);\n        }));\n        return { ...container, box };\n    });\n    return containers_;\n}\n\n//# sourceMappingURL=send-containers-to-grid.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/complete-loop.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/complete-loop.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeLoop: () => (/* binding */ completeLoop)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var _get_next_exit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-next-exit.js */ \"./node_modules/flo-boolean/node/calc-paths/get-next-exit.js\");\n/* harmony import */ var _get_beziers_to_next_container_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-beziers-to-next-container.js */ \"./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js\");\n\n\n\n\n/**\n * Completes a loop for a specific intersection point entry curve.\n * @param expMax\n * @param takenOuts\n * @param out\n */\nfunction completeLoop(expMax, takenOuts, out) {\n    const additionalOutsToCheck = [];\n    const beziers = [];\n    // Move immediately to the outgoing start of the loop\n    let out_ = out;\n    let additionalBezier;\n    // console.log(out_);\n    do {\n        takenOuts.add(out_); // Mark this intersection as taken\n        const { beziers: additionalBeziers, in_, inBez } = (0,_get_beziers_to_next_container_js__WEBPACK_IMPORTED_MODULE_0__.getBeziersToNextContainer)(expMax, out_);\n        // TODO - it will probably better to remove additionalBeziers and just\n        // connect the endpoints of adjacent beziers - even if we had near\n        // exact coordinates (think quad or better precision) of intersections\n        // they are still not returned as algebraic numbers so we can never have\n        // a perfect algorithm anyway without returning algebraic numbers as \n        // intersection coordinates, hence we might as well remove \n        // additionalBeziers whose length is about a trillionth of the max\n        // coordinate of loops\n        beziers.push(...additionalBeziers);\n        ({ out_, additionalBezier } = (0,_get_next_exit_js__WEBPACK_IMPORTED_MODULE_1__.getNextExit)(expMax, in_, out, additionalOutsToCheck, takenOuts));\n        if (additionalBezier) {\n            const t = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezierCertified)(inBez, additionalBezier[0])[0].ri);\n            const inBez_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.fromTo)(inBez, 0, t);\n            beziers.push(inBez_);\n            beziers.push(additionalBezier);\n        }\n        else {\n            beziers.push(inBez);\n        }\n    } while (out_ !== out /* && ii++ < 100*/);\n    return { beziers, additionalOutsToCheck };\n}\n\n//# sourceMappingURL=complete-loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/complete-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/complete-path.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/complete-path.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completePath: () => (/* binding */ completePath)\n/* harmony export */ });\n/* harmony import */ var _complete_loop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complete-loop.js */ \"./node_modules/flo-boolean/node/calc-paths/complete-loop.js\");\n\n/**\n * Completes the path of a disjoint set of loops, i.e. this function is called\n * for each disjoint set of paths.\n * @param intersections\n * @param takenLoops\n * @param parent\n * @param loop\n */\nfunction completePath(expMax, initialOut, takenLoops, takenOuts) {\n    const outStack = [initialOut];\n    while (outStack.length) {\n        const out = outStack.pop();\n        takenLoops.add(out._x_.curve.loop);\n        if (takenOuts.has(out)) {\n            continue;\n        }\n        out.children = new Set();\n        const { beziers, additionalOutsToCheck } = (0,_complete_loop_js__WEBPACK_IMPORTED_MODULE_0__.completeLoop)(expMax, takenOuts, out);\n        out.beziers = beziers;\n        out.parent.children = out.parent.children || new Set();\n        out.parent.children.add(out);\n        outStack.push(...additionalOutsToCheck);\n    }\n}\n\n//# sourceMappingURL=complete-path.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/complete-path.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBeziersToNextContainer: () => (/* binding */ getBeziersToNextContainer)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n/* harmony import */ var _container_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container.js */ \"./node_modules/flo-boolean/node/container.js\");\n\n\n\nfunction getBeziersToNextContainer(expMax, out) {\n    const in_ = out.next;\n    const endCurve = in_._x_.curve;\n    const endT = in_._x_.x.ri.tS;\n    let curCurve = out._x_.curve;\n    let curT = out._x_.x.ri.tS;\n    if (!(0,_container_js__WEBPACK_IMPORTED_MODULE_0__.containerIsBasic)(expMax, out.container)) {\n        // we must clip the outgoing curve\n        curT = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.closestPointOnBezierCertified)(curCurve.ps, out.p)[0].ri);\n    }\n    const beziers = [];\n    let inBez;\n    while (true) {\n        if (curCurve === endCurve &&\n            (curT < endT || (curT === endT && beziers.length))) {\n            inBez = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.fromTo)(curCurve.ps, curT, endT);\n            return { beziers, in_, inBez };\n        }\n        else {\n            const ps = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.fromTo)(curCurve.ps, curT, 1);\n            beziers.push(ps);\n        }\n        curT = 0;\n        curCurve = curCurve.next;\n    }\n}\n\n//# sourceMappingURL=get-beziers-to-next-container.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLoopsFromTree: () => (/* binding */ getLoopsFromTree)\n/* harmony export */ });\n/**\n * Returns an array of LoopTrees from the given LoopTree where each returned\n * LoopTree is one of the nodes of the tree. Nodes with winding number absolute\n * value > 1 are not returned.\n * @param root\n */\nfunction getLoopsFromTree(root) {\n    const trees = [root];\n    const stack = Array.from(root.children);\n    while (stack.length) {\n        const tree = stack.pop();\n        if (tree.windingNum === 0) {\n            trees.push(tree);\n        }\n        for (const child of tree.children) {\n            stack.push(child);\n        }\n    }\n    return trees;\n}\n\n//# sourceMappingURL=get-loops-from-tree.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-next-exit.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-next-exit.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNextExit: () => (/* binding */ getNextExit)\n/* harmony export */ });\n/* harmony import */ var _container_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container.js */ \"./node_modules/flo-boolean/node/container.js\");\n\n/**\n *\n * @param in_ the in for which the next exit should be found\n * @param additionalOutsToCheck\n */\nfunction getNextExit(expMax, in_, originalOut, additionalOutsToCheck, takenOuts) {\n    const markOutForChecking_ = markOutForChecking(originalOut, takenOuts, additionalOutsToCheck);\n    let additionalBezier = undefined;\n    let fromCount = 0;\n    let toCount = 1;\n    let next = in_;\n    let outToUse = undefined;\n    do {\n        next = originalOut.orientation === +1\n            ? next.nextAround\n            : next.prevAround;\n        if (next === in_) {\n            break;\n        }\n        fromCount = toCount;\n        toCount = toCount - next.dir;\n        if (next.dir === -1) {\n            continue;\n        }\n        if (!outToUse) {\n            // we are still rotating on the inside of the loop\n            if (toCount === 0) {\n                outToUse = next;\n            }\n            else if (toCount === 1) {\n                // the outermost inner loop must have the same orientation\n                markOutForChecking_(next, +1, originalOut);\n            }\n        }\n        else {\n            // else we are rotating on the outside of the loop\n            if (fromCount === 1 && toCount === 0) {\n                markOutForChecking_(next, +1, originalOut.parent);\n            }\n            else if (fromCount === 0 && toCount === -1) {\n                markOutForChecking_(next, -1, originalOut.parent);\n            }\n        }\n    } while (true);\n    if (!(0,_container_js__WEBPACK_IMPORTED_MODULE_0__.containerIsBasic)(expMax, in_.container)) {\n        // if there is multiple intersection pairs then add an additional bezier\n        additionalBezier = [in_.p, outToUse.p];\n    }\n    return { out_: outToUse, additionalBezier };\n}\nfunction markOutForChecking(originalOut, takenOuts, additionalOutsToCheck) {\n    return (out, parity, parent) => {\n        if (!takenOuts.has(out) && !out.orientation) {\n            out.orientation = parity * originalOut.orientation;\n            out.parent = parent;\n            out.windingNum = parent.windingNum + out.orientation;\n            additionalOutsToCheck.push(out);\n        }\n    };\n}\n\n//# sourceMappingURL=get-next-exit.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/get-next-exit.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOutermostInAndOut: () => (/* binding */ getOutermostInAndOut)\n/* harmony export */ });\n/**\n * Get initial an intersection for the given loop. The loop must be such that\n * an extreme point on the loop forms part of an outermost loop that is outside\n * all other component loops that is formed by this loop and all other loops it\n * may intersect. This extreme point is guaranteed by the initial ordering of\n * the loops by their minimum y value.\n * @param loop\n * @param parent\n */\nfunction getOutermostInAndOut(container) {\n    const inOuts = container.inOuts;\n    const firstInOut = inOuts[0];\n    const lastInOut = inOuts[inOuts.length - 1];\n    // set 'loop' direction\n    if (firstInOut.dir === 1) {\n        firstInOut.orientation = -1; // anti-clockwise\n        return firstInOut;\n    }\n    else {\n        lastInOut.orientation = +1;\n        return lastInOut;\n    }\n}\n\n//# sourceMappingURL=get-outermost-in-and-out.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTightestContainingLoop: () => (/* binding */ getTightestContainingLoop)\n/* harmony export */ });\n/* harmony import */ var _is_loop_in_loop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-loop-in-loop.js */ \"./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js\");\n\n/**\n * @param root\n * @param loop\n */\nfunction getTightestContainingLoop(root, loop) {\n    let containingLoop = undefined;\n    const stack = [root];\n    while (stack.length) {\n        const inOut = stack.pop();\n        f(inOut);\n    }\n    return containingLoop;\n    function f(parent) {\n        if (parent === root || (0,_is_loop_in_loop_js__WEBPACK_IMPORTED_MODULE_0__.isLoopInLoop)(loop.beziers, parent.beziers)) {\n            containingLoop = parent;\n            for (const child of parent.children) {\n                stack.push(child);\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=get-tightest-containing-loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isLoopInLoop: () => (/* binding */ isLoopInLoop)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/predictive-random/double/random.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-bounding-box-.js */ \"./node_modules/flo-boolean/node/get-bounding-box-.js\");\n/* harmony import */ var _get_bounds_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../get-bounds-.js */ \"./node_modules/flo-boolean/node/get-bounds-.js\");\n\n\n\n\n\n// TODO - remove delta by basing isLoopInLoop on a solid numerical analytic \n// basis - isLoopInLoop is the only sub-algorithm left having a DELTA.\nconst DELTA = 1e-6;\n/**\n * Returns true if the first loop is wholly contained within the second loop's\n * boundary.\n *\n * Precondition: the loop is either wholly contained inside the loop or is wholly outside.\n * @param loop1\n * @param loop2\n */\nfunction isLoopInLoop(loop1, loop2) {\n    let i = 0;\n    let seed = 1231; // Just some value\n    do {\n        i++;\n        // This gets us a predictable random number between 0 and 1;\n        const rand1 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.flatCoefficients)(1, 0, 1, seed);\n        const t = rand1.p[0];\n        seed = rand1.seed; // Get next seed.\n        // This gets us a predictable random number roughly between 0 and the \n        // number of curves in the loop.\n        const curveCount = loop1.length;\n        const rand2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.flatCoefficients)(1, 0, curveCount, seed);\n        const idx = Math.floor(rand2.p[0]);\n        seed = rand2.seed; // Get next seed.\n        const ps = loop1[idx];\n        const p = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau)(ps, t);\n        const res = f(loop1, loop2, p);\n        if (res !== undefined) {\n            return res;\n        }\n    } while (i < 100);\n    return undefined; // There's no chance we'll get up to this point.\n    function f(loop1, loop2, p) {\n        if (isLoopNotInLoop(loop1, loop2)) {\n            return false;\n        }\n        const count = getAxisAlignedRayLoopIntersections(loop2, p, 'left');\n        if (count !== undefined) {\n            return count % 2 !== 0;\n        }\n    }\n}\n/**\n * Returns true if the first loop is not wholly within the second. The converse\n * is not necessarily true. It is assumed the loops don't intersect.\n * @param loops\n */\nfunction isLoopNotInLoop(loop1, loop2) {\n    const boundss = [loop1, loop2].map(getLoopBounds);\n    return (boundss[0].minX < boundss[1].minX ||\n        boundss[0].maxX > boundss[1].maxX ||\n        boundss[0].minY < boundss[1].minY ||\n        boundss[0].maxY > boundss[1].maxY);\n}\nfunction getLoopBounds(pss) {\n    const bounds = pss.map(ps => (0,_get_bounds_js__WEBPACK_IMPORTED_MODULE_2__.getBounds_)(ps));\n    return {\n        minX: Math.min(...bounds.map(bound => bound.box[0][0])),\n        maxX: Math.max(...bounds.map(bound => bound.box[1][0])),\n        minY: Math.min(...bounds.map(bound => bound.box[0][1])),\n        maxY: Math.max(...bounds.map(bound => bound.box[1][1])),\n    };\n}\n/**\n * @param p The point where the horizontal ray starts\n * @param toLeft The ray to the left of this point (else right)\n * @param loop A loop of curves\n *\n * @internal\n */\nfunction getAxisAlignedRayLoopIntersections(loop, p, dir) {\n    const [x, y] = p;\n    let count = 0;\n    for (let i = 0; i < loop.length; i++) {\n        const ps = loop[i];\n        //------------------------------------------------------/\n        //---- Check if ray intersects bezier bounding box -----/\n        //------------------------------------------------------/\n        const [[minX, minY], [maxX, maxY]] = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__.getBoundingBox_)(ps);\n        let notIntersecting = ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||\n            ((dir === 'up' || dir === 'down') && (minX > x || maxX < x));\n        notIntersecting = notIntersecting ||\n            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||\n            (dir === 'down' && minY > y) || (dir === 'up' && maxY < y);\n        if (notIntersecting) {\n            continue;\n        } // No intersection with bezier\n        //------------------------------------------------------/\n        //----------- Get intersection ts on bezier ------------/\n        //------------------------------------------------------/\n        // Get the bezier's x-coordinate power representation.\n        const ts = [];\n        let f;\n        let offset;\n        let axis;\n        const dirIsDecreasing = (dir === 'left' || dir === 'up');\n        if (dir === 'left' || dir === 'right') {\n            //f = getY;\n            f = (ps) => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis)(ps)[1];\n            offset = [0, -y];\n            axis = 0;\n        }\n        else {\n            //f = getX;\n            f = (ps) => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis)(ps)[0];\n            offset = [-x, 0];\n            axis = 1;\n        }\n        //let translatedPs = translate(offset, ps);\n        const translatedPs = ps.map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.translate)(offset));\n        const poly = f(translatedPs);\n        //let ev = evalDeCasteljau(translatedPs);\n        const ts_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.allRoots)(poly, 0 - DELTA, 1 + DELTA);\n        for (let i = 0; i < ts_.length; i++) {\n            const t = ts_[i];\n            if (Math.abs(t) < DELTA || Math.abs(t - 1) < DELTA) {\n                // We don't know the exact number of intersections due to\n                // floating point arithmetic. \n                return undefined;\n            }\n            //let p_ = ev(t);\n            const p_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau)(translatedPs, t);\n            if ((dirIsDecreasing && p[axis] >= p_[axis]) ||\n                (!dirIsDecreasing && p[axis] <= p_[axis])) {\n                ts.push(t);\n            }\n        }\n        //------------------------------------------------------/\n        //----- Check if line is tangent to intersections ------/\n        //------------------------------------------------------/\n        // We only care if there were 1 or 3 intersections.\n        if (ts.length === 1 || ts.length === 3) {\n            for (const t of ts) {\n                const tan = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_8__.tangent)(ps, t));\n                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||\n                    ((dir === 'down' || dir === 'up') && Math.abs(tan[0]) < DELTA)) {\n                    // We don't know the exact number of intersections due to\n                    // floating point arithmetic\n                    return undefined;\n                }\n            }\n        }\n        count += ts.length;\n    }\n    return count;\n}\n\n//# sourceMappingURL=is-loop-in-loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orderLoopAscendingByMinY: () => (/* binding */ orderLoopAscendingByMinY)\n/* harmony export */ });\n/* harmony import */ var _get_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../get-bounds-.js */ \"./node_modules/flo-boolean/node/get-bounds-.js\");\n\n/**\n * Returns < 0 if loopA's topmost point is higher (i.e. smaller) than that of\n * loopB. Using this function in a sort will sort from highest topmost (smallest\n * y) point loops to lowest in a left-handed coordinate system.\n * @param loopA\n * @param loopB\n */\nfunction orderLoopAscendingByMinY(loopA, loopB) {\n    return getMinY(loopA) - getMinY(loopB);\n}\nfunction getMinY(pss) {\n    let minY = Number.POSITIVE_INFINITY;\n    for (const ps of pss) {\n        const y = (0,_get_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getBounds_)(ps).box[0][1];\n        if (y < minY) {\n            minY = y;\n        }\n    }\n    return minY;\n}\n\n//# sourceMappingURL=order-loop-ascending-by-min-y.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/simplify-paths.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/simplify-paths.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simplifyPaths: () => (/* binding */ simplifyPaths)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js\");\n/* harmony import */ var _complete_path_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./complete-path.js */ \"./node_modules/flo-boolean/node/calc-paths/complete-path.js\");\n/* harmony import */ var _get_tightest_containing_loop_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-tightest-containing-loop.js */ \"./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js\");\n/* harmony import */ var _order_loop_ascending_by_min_y_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./order-loop-ascending-by-min-y.js */ \"./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js\");\n/* harmony import */ var _split_loop_trees_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./split-loop-trees.js */ \"./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js\");\n/* harmony import */ var _get_loops_from_tree_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-loops-from-tree.js */ \"./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js\");\n/* harmony import */ var _calc_containers_get_containers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../calc-containers/get-containers.js */ \"./node_modules/flo-boolean/node/calc-containers/get-containers.js\");\n/* harmony import */ var _get_outermost_in_and_out_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-outermost-in-and-out.js */ \"./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js\");\n/* harmony import */ var _loop_reverse_orientation_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../loop/reverse-orientation.js */ \"./node_modules/flo-boolean/node/loop/reverse-orientation.js\");\n/* harmony import */ var _loop_loop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../loop/loop.js */ \"./node_modules/flo-boolean/node/loop/loop.js\");\n/* harmony import */ var _loop_normalize_normalize_loop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loop/normalize/normalize-loop.js */ \"./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js\");\n/* harmony import */ var _loop_normalize_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loop/normalize/get-max-coordinate.js */ \"./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js\");\n/* harmony import */ var _loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../loop/get-loop-area.js */ \"./node_modules/flo-boolean/node/loop/get-loop-area.js\");\n/* harmony import */ var _svg_loops_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../svg/loops-to-svg-path-str.js */ \"./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../get-bounding-box-.js */ \"./node_modules/flo-boolean/node/get-bounding-box-.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Uses the algorithm of Lavanya Subramaniam: PARTITION OF A NON-SIMPLE POLYGON\n * INTO SIMPLE POLYGONS;\n *\n * see http://www.cis.southalabama.edu/~hain/general/Theses/Subramaniam_thesis.pdf\n * but modified to use bezier curves (as opposed to polygons) and to additionally\n * take care of paths with multiple subpaths, i.e. such as disjoint nested paths.\n *\n * Also takes care of all special cases.\n *\n * @param loops an array of possibly intersecting paths\n * @param maxCoordinate optional - if not provided, it will be calculated - a\n * wrong value could cause the algorithm to fail\n */\nfunction simplifyPaths(bezierLoops, maxCoordinate) {\n    let timingStart;\n    if (typeof _debug_ !== 'undefined') {\n        timingStart = performance.now();\n    }\n    // bezierLoops = bezierLoops.map(loopFromBeziers).map(reverseOrientation).map(loops => loops.beziers);\n    // console.log(loopsToSvgPathStr(bezierLoops));\n    /**\n     * All bezier coordinates will be truncated to this (bit-aligned) bitlength.\n     * Higher bitlengths would increase the running time of the algorithm\n     * considerably.\n     */\n    // const maxBitLength = 46;\n    const maxBitLength = 46;\n    maxCoordinate = maxCoordinate || (0,_loop_normalize_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_0__.getMaxCoordinate)(bezierLoops);\n    /** The exponent, e, such that 2**e >= all bezier coordinate points. */\n    const expMax = Math.ceil(Math.log2(maxCoordinate));\n    const gridSpacing = 2 ** expMax * 2 ** (-maxBitLength);\n    /**\n     * A size (based on the max value of the tangent) for the containers holding\n     * critical points.\n     */\n    const containerSizeMultiplier = 2 ** 6;\n    // const containerSizeMultiplier = 2**36;\n    const containerDim = gridSpacing * containerSizeMultiplier;\n    bezierLoops = (0,_loop_normalize_normalize_loop_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoops)(bezierLoops, maxBitLength, expMax, false, true);\n    // console.log(bezierLoops)\n    addDebugInfo1(bezierLoops);\n    bezierLoops.sort(_order_loop_ascending_by_min_y_js__WEBPACK_IMPORTED_MODULE_2__.orderLoopAscendingByMinY);\n    const loops = bezierLoops.map((loop, i) => (0,_loop_loop_js__WEBPACK_IMPORTED_MODULE_3__.loopFromBeziers)(loop, i));\n    const { extremes } = (0,_calc_containers_get_containers_js__WEBPACK_IMPORTED_MODULE_4__.getContainers)(loops, containerDim, expMax);\n    const root = createRootInOut();\n    const takenLoops = new Set();\n    const takenOuts = new Set(); // Taken intersections\n    for (const loop of loops) {\n        if (takenLoops.has(loop)) {\n            continue;\n        }\n        takenLoops.add(loop);\n        const parent = (0,_get_tightest_containing_loop_js__WEBPACK_IMPORTED_MODULE_5__.getTightestContainingLoop)(root, loop);\n        const container = extremes.get(loop)[0].container;\n        if (!container.inOuts.length) {\n            continue;\n        }\n        const initialOut = (0,_get_outermost_in_and_out_js__WEBPACK_IMPORTED_MODULE_6__.getOutermostInAndOut)(container);\n        // Each loop generated will give rise to one componentLoop. \n        initialOut.parent = parent;\n        initialOut.windingNum = parent.windingNum + initialOut.orientation;\n        initialOut.children = new Set();\n        (0,_complete_path_js__WEBPACK_IMPORTED_MODULE_7__.completePath)(expMax, (0,_get_outermost_in_and_out_js__WEBPACK_IMPORTED_MODULE_6__.getOutermostInAndOut)(container), takenLoops, takenOuts);\n    }\n    const loopTrees = (0,_split_loop_trees_js__WEBPACK_IMPORTED_MODULE_8__.splitLoopTrees)(root);\n    const outSets = loopTrees.map(_get_loops_from_tree_js__WEBPACK_IMPORTED_MODULE_9__.getLoopsFromTree);\n    const loopss = outSets.map(outSet => outSet.map((out, idx) => loopFromOut(out, outSet[0].orientation, idx)));\n    /**\n     * Arbitrarily choose min. loop area to be equal to one square pixel on a\n     * 4096 x 4096 grid.\n     */\n    const minLoopArea = (2 ** expMax * 2 ** (-12)) ** 2;\n    const loopss_ = [];\n    for (let i = 0; i < loopss.length; i++) {\n        const loops = loopss[i].filter((loop) => Math.abs((0,_loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_10__.getLoopArea)(loop)) > minLoopArea);\n        if (loops.length) {\n            loops.sort((loopA, loopB) => {\n                return (0,_order_loop_ascending_by_min_y_js__WEBPACK_IMPORTED_MODULE_2__.orderLoopAscendingByMinY)(loopA.beziers, loopB.beziers);\n            });\n            loopss_.push(loops);\n        }\n    }\n    addDebugInfo2(loopss_);\n    if (typeof _debug_ !== 'undefined') {\n        const timing = _debug_.generated.timing;\n        timing.simplifyPaths = performance.now() - timingStart;\n    }\n    // console.log(loopsToSvgPathStr(loopss_[0].map(loop => loop.beziers)));\n    return loopss_;\n}\n/**\n *\n * @param out\n * @param orientation\n * @param idx identifies the loop during debugging\n */\nfunction loopFromOut(out, orientation, idx) {\n    const loop = orientation < 0\n        ? (0,_loop_loop_js__WEBPACK_IMPORTED_MODULE_3__.loopFromBeziers)(out.beziers, idx)\n        : (0,_loop_reverse_orientation_js__WEBPACK_IMPORTED_MODULE_11__.reverseOrientation)((0,_loop_loop_js__WEBPACK_IMPORTED_MODULE_3__.loopFromBeziers)(out.beziers, idx));\n    return loop;\n}\nfunction addDebugInfo2(loopss) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    for (const loops of loopss) {\n        _debug_.generated.elems.loop.push(...loops);\n        _debug_.generated.elems.loops.push(loops);\n        //console.log(loopsToSvgPathStr(loops.map(loop => loop.beziers)));\n    }\n    // Don't delete below commented lines - it is for creating test cases.\n    // if (typeof document === 'undefined') { return; }\n    // let g = document.getElementsByTagName('g')[0];\n    // let invariants = loopss.map(loops => {\n    //    return loops.map(loop => {\n    //        let centroid = getLoopCentroid(loop);\n    //        let area     = getLoopArea(loop);\n    //        let bounds   = simplifyBounds(getLoopBounds(loop));\n    //        //drawFs.crossHair(g, centroid, 'thin10 red nofill', 1, 0);\n    //        return { centroid, area, bounds };\n    //    });\n    // });\n    // console.log(JSON.stringify(invariants, undefined, '    '));\n}\nfunction addDebugInfo1(loops) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    // Modifies the displayed SVG to reflect changes caused by `normalizeLoops`.\n    if (typeof document !== 'undefined') {\n        const pathStr = (0,_svg_loops_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_12__.loopsToSvgPathStr)(loops);\n        const $svg = document.getElementsByClassName('shape')[0];\n        $svg.setAttributeNS(null, 'd', pathStr);\n    }\n    for (const loop of loops) {\n        _debug_.generated.elems.loopPre.push(...loops);\n        _debug_.generated.elems.loopsPre.push(loops);\n        for (const ps of loop) {\n            const lbb = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_13__.getBoundingBox_)(ps);\n            const tbb = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_14__.getBoundingBoxTight)(ps);\n            const bhull = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_15__.getBoundingHull)(ps);\n            _debug_.generated.elems.bezier_.push(ps);\n            _debug_.generated.elems.looseBoundingBox_.push(lbb);\n            _debug_.generated.elems.tightBoundingBox_.push(tbb);\n            _debug_.generated.elems.boundingHull_.push(bhull);\n        }\n    }\n}\nfunction createRootInOut() {\n    return {\n        dir: undefined,\n        idx: 0,\n        parent: undefined,\n        children: new Set(),\n        windingNum: 0,\n        p: undefined,\n        _x_: undefined,\n        container: undefined\n    };\n}\n\n// TODO - Handle case where bezier tangentially touches container edge. \n// Simply move the container boundary 1/8th or 1/16th inward and try again. \n// This case is truly extremely rare and not hard to fix completely.\n//# sourceMappingURL=simplify-paths.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/simplify-paths.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitLoopTrees: () => (/* binding */ splitLoopTrees)\n/* harmony export */ });\n/**\n * Take the forest of trees, create a new root making it a tree and snip\n * branches such that each branch determines a new set of loops each\n * representing an individual independent shape (possibly with holes).\n * @param root\n */\nfunction splitLoopTrees(root) {\n    const iLoopTrees = [];\n    const stack = [root];\n    while (stack.length) {\n        const tree = stack.pop();\n        tree.children = tree.children || new Set();\n        for (const child of tree.children) {\n            if (tree.windingNum === 0) {\n                iLoopTrees.push(child);\n            }\n            stack.push(child);\n        }\n        if (tree.windingNum === 0) {\n            tree.children = new Set(); // Make it a leaf\n        }\n    }\n    return iLoopTrees;\n}\n\n//# sourceMappingURL=split-loop-trees.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/container.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-boolean/node/container.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   containerIsBasic: () => (/* binding */ containerIsBasic)\n/* harmony export */ });\n/**\n * Returns true if the container is basic, i.e. contains only 1 interface\n * intersection or contains only 1 general, extreme or loop intersection\n * (not cusp, or endpoint overlap), false otherwise.\n *\n * @param container\n */\nfunction containerIsBasic(expMax, container) {\n    const xs = container.xs;\n    if (xs.length <= 2 && xs[0].x.kind !== 7) {\n        return true;\n    }\n    return false;\n}\n\n//# sourceMappingURL=container.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/container.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doConvexPolygonsIntersect: () => (/* binding */ doConvexPolygonsIntersect)\n/* harmony export */ });\n/**\n * Adapted from https://stackoverflow.com/a/12414951/2010061.\n * Returns true if there is any intersection between the 2 polygons, false otherwise\n * Uses the Separating Axis Theorem.\n *\n * @param polygonA an array of connected points that form a closed polygon\n * @param polygonB an array of connected points that form a closed polygon\n * @param closed set to false to compare open polygons (not containing their\n * boundary) or true to compare closed polygons\n */\nfunction doConvexPolygonsIntersect(polygonA, polygonB, closed) {\n    // for each polygon, look at each edge of the polygon, and determine if \n    // it separates the two shapes\n    for (const polygon of [polygonA, polygonB]) {\n        const len = polygon.length;\n        for (let i = 1; i < len + 1; i++) {\n            // grab 2 consecutive vertices to create an edge\n            const p1 = polygon[i - 1];\n            const p2 = polygon[i % len];\n            // find the vector perpendicular to this edge\n            const normal = [p2[1] - p1[1], p1[0] - p2[0]];\n            let minA = Number.POSITIVE_INFINITY;\n            let maxA = Number.NEGATIVE_INFINITY;\n            // for each vertex in the first shape, project it onto the line \n            // perpendicular to the edge and keep track of the min and max of \n            // these values\n            for (let k = 0; k < polygonA.length; k++) {\n                const projected = normal[0] * polygonA[k][0] +\n                    normal[1] * polygonA[k][1];\n                if (projected < minA) {\n                    minA = projected;\n                }\n                if (projected > maxA) {\n                    maxA = projected;\n                }\n            }\n            // for each vertex in the second shape, project it onto the line \n            // perpendicular to the edge and keep track of the min and max of \n            // these values\n            let minB = Number.POSITIVE_INFINITY;\n            let maxB = Number.NEGATIVE_INFINITY;\n            for (let k = 0; k < polygonB.length; k++) {\n                const projected = normal[0] * polygonB[k][0] +\n                    normal[1] * polygonB[k][1];\n                if (projected < minB) {\n                    minB = projected;\n                }\n                if (projected > maxB) {\n                    maxB = projected;\n                }\n            }\n            // if there is no overlap between the projections, the edge we are \n            // looking at separates the two polygons, and we know there is no \n            // overlap\n            if (closed) {\n                if (maxA < minB || maxB < minA) {\n                    return false;\n                }\n            }\n            if (!closed) {\n                if (maxA <= minB || maxB <= minA) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=do-convex-polygons-intersect.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-bounding-box-.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-bounding-box-.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingBox_: () => (/* binding */ getBoundingBox_)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n\n\nconst getBoundingBox_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox);\n\n//# sourceMappingURL=get-bounding-box-.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-bounding-box-.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-bounds-.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-bounds-.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBounds_: () => (/* binding */ getBounds_)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js\");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n\n\nconst getBounds_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getBounds);\n\n//# sourceMappingURL=get-bounds-.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-bounds-.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvesIntersections: () => (/* binding */ getCurvesIntersections)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js\");\n/* harmony import */ var _get_other_t_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-other-t.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-other-t.js\");\n/* harmony import */ var _geometry_do_convex_polygons_intersect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry/do-convex-polygons-intersect.js */ \"./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js\");\n/* harmony import */ var _get_intersection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-intersection.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-intersection.js\");\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./make-simple-x.js */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../get-bounding-box-.js */ \"./node_modules/flo-boolean/node/get-bounding-box-.js\");\n/* harmony import */ var _are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../are-boxes-intersecting.js */ \"./node_modules/flo-boolean/node/are-boxes-intersecting.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Returns the pairs of intersection `t` values between the curves. Interface\n * intersections may not be returned - they should already be caught.\n *\n * @param curveA\n * @param curveB\n */\nfunction getCurvesIntersections(expMax) {\n    return (curveA, curveB) => {\n        const psA = curveA.ps;\n        const psB = curveB.ps;\n        if (psA.length === 2 && psB.length === 2) {\n            return getLineLineIntersections(curveA, curveB, expMax);\n        }\n        if (curveA.next === curveB || curveB.next === curveA) {\n            // curves are connected at endpoints\n            // closed bounding boxes are guaranteed to intersect - don't check\n            // check open bounding boxes\n            const aabbsIntersectOpen = (0,_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__.areBoxesIntersecting)(false, \n            // const aabbsIntersectOpen = areBoxesIntersecting(true,\n            (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(psA), (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(psB));\n            if (!aabbsIntersectOpen) {\n                return checkEndpoints(curveA, curveB);\n            }\n            // check open bounding hulls\n            const bbHullA = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getBoundingHull)(psA);\n            const bbHullB = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getBoundingHull)(psB);\n            const hullsIntersectOpen = (0,_geometry_do_convex_polygons_intersect_js__WEBPACK_IMPORTED_MODULE_3__.doConvexPolygonsIntersect)(bbHullA, bbHullB, false);\n            if (!hullsIntersectOpen) {\n                return checkEndpoints(curveA, curveB);\n            }\n            // neither aabbs nor hulls can split the curves\n            return curveB.next === curveA\n                ? (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_4__.getIntersection)(curveB, curveA, expMax, true) // B-->A\n                : (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_4__.getIntersection)(curveA, curveB, expMax, true); // A-->B\n        }\n        // curves are not connected at endpoints\n        // check closed bounding boxes\n        let possiblyIntersecting = (0,_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__.areBoxesIntersecting)(true, (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(psA), (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(psB));\n        if (!possiblyIntersecting) {\n            return undefined;\n        }\n        // check closed bounding hulls\n        const bbHullA = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getBoundingHull)(psA);\n        const bbHullB = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getBoundingHull)(psB);\n        possiblyIntersecting = (0,_geometry_do_convex_polygons_intersect_js__WEBPACK_IMPORTED_MODULE_3__.doConvexPolygonsIntersect)(bbHullA, bbHullB, true);\n        if (!possiblyIntersecting) {\n            return undefined;\n        }\n        return (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_4__.getIntersection)(curveA, curveB, expMax, false);\n    };\n}\n/**\n * Returns an un-ordered pair of intersections (excluding interface intersections,\n * in which case `undefined` is returned) between curveA and curveB.\n *\n * * **precondition:** curveA.next === curveB || curveB.next === curveA\n * * **precondition:** every intersection will be at an endpoint of at least\n * one of the curves\n *\n * @param curveA\n * @param curveB\n */\nfunction checkEndpoints(curveA, curveB) {\n    if (curveB.next === curveA) {\n        if (curveA.next === curveB) {\n            // if this is a very simple loop with only 2 beziers in it\n            return undefined;\n        }\n        // else swap the curves to make the algorithm simpler\n        [curveA, curveB] = [curveB, curveA];\n    }\n    // At this point A-->B (curveA's next === curveB)\n    // There is thus an intersection at curveA(t=1) and curveB(t=0)\n    const psA = curveA.ps;\n    const psB = curveB.ps;\n    // Is last point (i.e. at `t` === 1) of curveB on curveA?\n    // if (isPointOnBezierExtension(psA, psB[psB.length-1])) {\n    if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_5__.isPointOnBezierExtension)(psA, psB[psB.length - 1].map(c => [c]))) {\n        // Check if they are in same k family (this *is* necessary for two curves\n        // in same k-family joined end to end, e.g. ---A--->|---B---> in which\n        // case ...)\n        const xPairs = (0,_get_other_t_js__WEBPACK_IMPORTED_MODULE_6__.getOtherTs)(psA, psB, [(0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.createRootExact)(1)]);\n        if (xPairs === undefined || xPairs.length === 0) {\n            return undefined;\n        }\n        const xPair = xPairs[0];\n        return [[\n                { x: xPair[0], curve: curveA },\n                (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_8__.makeSimpleX)(1, curveB, 1)\n            ]];\n    }\n}\nfunction getLineLineIntersections(curveA, curveB, expMax) {\n    let psA = curveA.ps;\n    let psB = curveB.ps;\n    const bbA = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(psA);\n    const bbB = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(psB);\n    // if (equal(psA,[[4,8],[4,7]]) && equal(psB,[[4,6],[4,8]])) {\n    //     console.log('testing');\n    // }\n    if (curveA.next !== curveB && curveB.next !== curveA) {\n        // the two line curves are not consecutive in the loop\n        if ((0,_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__.areBoxesIntersecting)(true, bbA, bbB)) {\n            const xs = (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_4__.getIntersection)(curveA, curveB, expMax, false);\n            return xs.length ? xs : undefined;\n        }\n        return undefined;\n    }\n    // the two line curves are consecutive in the loop\n    const swap = curveB.next === curveA;\n    if (swap) {\n        [curveA, curveB] = [curveB, curveA];\n        [psA, psB] = [psB, psA];\n    }\n    const orientation = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_9__.orient2d)(psA[0], psA[1], psB[1]);\n    if (orientation !== 0) {\n        // they cannot intersect\n        return undefined;\n    }\n    // they are in the same k family - they can either go in the\n    // same direction or go back on top of each other\n    // if going in same direction\n    if (!(0,_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_0__.areBoxesIntersecting)(false, bbA, bbB)) {\n        // they cannot intersect\n        return undefined;\n    }\n    // it is a line going back on itself \n    // - return endpoint intersections\n    const lenCurveA = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_10__.squaredDistanceBetween)(psA[0], psA[1]);\n    const lenCurveB = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_10__.squaredDistanceBetween)(psB[0], psB[1]);\n    let tPair;\n    if (lenCurveA > lenCurveB) {\n        const t0 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_11__.closestPointOnBezierCertified)(psA, psB[1])[0].ri);\n        tPair = [t0, 1];\n    }\n    else {\n        const t1 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_11__.closestPointOnBezierCertified)(psB, psA[0])[0].ri);\n        tPair = [0, t1];\n    }\n    return [[\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_8__.makeSimpleX)(1, curveA, 5),\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_8__.makeSimpleX)(0, curveB, 5), // exact overlap endpoint\n        ], [\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_8__.makeSimpleX)(tPair[0], curveA, 5),\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_8__.makeSimpleX)(tPair[1], curveB, 5) // exact overlap endpoint\n        ]];\n}\n\n//# sourceMappingURL=get-curves-intersections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-excessive-curvatures.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-excessive-curvatures.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getExcessiveCurvatures: () => (/* binding */ getExcessiveCurvatures)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/curvature.js\");\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./make-simple-x.js */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\n\n\nconst { abs } = Math;\nfunction getExcessiveCurvatures(expMax, loops) {\n    /** all one-sided Xs from */\n    const xs = [];\n    // return xs;\n    // Get interface points\n    for (const loop of loops) {\n        for (const curve of loop.curves) {\n            const ps = curve.ps;\n            const extrema = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getCurvatureExtrema)(ps);\n            const { minima, maxima } = extrema;\n            const minmaxs = [0, 1, ...minima, ...maxima];\n            for (let t of minmaxs) {\n                //const k = eeCurvature(ps,[t]);\n                const k = abs((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.curvature)(ps, t));\n                if (k > 10000000 * 2 ** -expMax) {\n                    xs.push([\n                        (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleX)(t, curve, 7),\n                        (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_2__.makeSimpleX)(t, curve, 7), // excessive curvature\n                    ]);\n                }\n            }\n        }\n    }\n    return xs;\n}\n\n//# sourceMappingURL=get-excessive-curvatures.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-excessive-curvatures.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-extreme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-extreme.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getExtreme: () => (/* binding */ getExtreme)\n/* harmony export */ });\n/* harmony import */ var _loop_get_min_y_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loop/get-min-y.js */ \"./node_modules/flo-boolean/node/loop/get-min-y.js\");\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./make-simple-x.js */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\n\n\n/**\n * Get an extreme point (point with minimum y value) of the given loop.\n * @param loop\n */\nfunction getExtreme(loop) {\n    const { curve, y } = (0,_loop_get_min_y_js__WEBPACK_IMPORTED_MODULE_0__.getMinY)(loop);\n    const ts = y.ts;\n    if (ts[0] <= 0) {\n        return [\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(0, curve, 0),\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(1, curve.prev, 0) // extreme\n        ];\n    }\n    if (ts[1] >= 1) {\n        return [\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(1, curve, 0),\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(0, curve.next, 0) // extreme\n        ];\n    }\n    return [\n        // TODO - should multiplicity be undefined in these cases?\n        // TODO - do we need 2 intersections???\n        {\n            x: {\n                ri: { tS: ts[0], tE: ts[1], multiplicity: 1 },\n                kind: 0,\n                box: y.box\n            },\n            curve\n        },\n        {\n            x: {\n                ri: { tS: ts[0], tE: ts[1], multiplicity: 1 },\n                kind: 0,\n                box: y.box\n            },\n            curve\n        } // extreme\n    ];\n}\n\n//# sourceMappingURL=get-extreme.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-extreme.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-extremes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-extremes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getExtremes: () => (/* binding */ getExtremes)\n/* harmony export */ });\n/* harmony import */ var _get_extreme_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-extreme.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-extreme.js\");\n\n// TODO - include all interface points close to the extreme - they are the only\n// important interface points - or are they??\n/**\n *\n * @param loops\n */\nfunction getExtremes(loops) {\n    const extremes = new Map();\n    const xs = [];\n    for (const loop of loops) {\n        const xPair = (0,_get_extreme_js__WEBPACK_IMPORTED_MODULE_0__.getExtreme)(loop);\n        xs.push(xPair);\n        extremes.set(loop, xPair);\n    }\n    return { extremes, xs };\n}\n\n//# sourceMappingURL=get-extremes.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-extremes.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInterfaceIntersections: () => (/* binding */ getInterfaceIntersections)\n/* harmony export */ });\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./make-simple-x.js */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\n\nfunction getInterfaceIntersections(loops) {\n    /** all one-sided Xs from */\n    const xs = [];\n    // Get interface points\n    for (const loop of loops) {\n        for (const curve of loop.curves) {\n            xs.push([\n                (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_0__.makeSimpleX)(1, curve, 4),\n                (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_0__.makeSimpleX)(0, curve.next, 4), // interface\n            ]);\n        }\n    }\n    return xs;\n}\n\n//# sourceMappingURL=get-interface-intersections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-intersection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-intersection.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIntersection: () => (/* binding */ getIntersection)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _get_other_t_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-other-t.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-other-t.js\");\n\n\n/**\n *\n * @param curveA\n * @param curveB\n * @param expMax\n * @param isANextB is curveB the next curve after curveA, i.e. is A's next B\n */\nfunction getIntersection(curveA, curveB, expMax, isANextB) {\n    const ps1 = curveA.ps;\n    const ps2 = curveB.ps;\n    const xs = [];\n    let ris2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.bezierBezierIntersectionBoundless)(ps1, ps2);\n    if (ris2 === undefined) {\n        // the curves have an infinte number of intersections\n        // some reasonable error bound -> to be fine-tuned, but cannot\n        // break the algorithm (unless its too small), only make it run slower.\n        const errBound = 2 ** (expMax - 47);\n        const xPairs = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getEndpointIntersections)(ps1, ps2);\n        for (const xPair of xPairs) {\n            const p1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps1, xPair.ri1.tS);\n            const box = [\n                [p1[0] - errBound, p1[1] - errBound],\n                [p1[0] + errBound, p1[1] + errBound],\n            ];\n            const ri1 = { x: { ri: xPair.ri1, kind: 5, box }, curve: curveA }; // exact overlap endpoint\n            const ri2 = { x: { ri: xPair.ri2, kind: 5, box }, curve: curveB }; // exact overlap endpoint\n            xs.push([ri1, ri2]);\n        }\n        return xs;\n    }\n    if (isANextB) {\n        // we are not interested in zero t values (they are interface points)\n        ris2 = ris2.filter(t => t.tS > 0);\n    }\n    if (ris2.length === 0) {\n        return [];\n    }\n    const xPairs = (0,_get_other_t_js__WEBPACK_IMPORTED_MODULE_3__.getOtherTs)(ps1, ps2, ris2);\n    if (xPairs === undefined || xPairs.length === 0) {\n        return [];\n    }\n    for (const xPair of xPairs) {\n        const x1 = { x: xPair[0], curve: curveA };\n        const x2 = { x: xPair[1], curve: curveB };\n        xs.push([x1, x2]);\n    }\n    return xs;\n}\n\n//# sourceMappingURL=get-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-intersections.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-intersections.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIntersections: () => (/* binding */ getIntersections)\n/* harmony export */ });\n/* harmony import */ var _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sweep-line/sweep-line.js */ \"./node_modules/flo-boolean/node/sweep-line/sweep-line.js\");\n/* harmony import */ var _get_curves_intersections_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-curves-intersections.js */ \"./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../get-bounding-box-.js */ \"./node_modules/flo-boolean/node/get-bounding-box-.js\");\n\n\n\n/**\n * Find and return all one-sided intersections on all given loops as a map from\n * each curve to an array of intersections on the curve, ordered by t value.\n * @param loops\n */\nfunction getIntersections(loops, expMax) {\n    const curves = [];\n    for (const loop of loops) {\n        for (const curve of loop.curves) {\n            curves.push(curve);\n        }\n    }\n    // Filter curves so that we eliminate those that can definitely not intersect\n    const _xs = (0,_sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_0__.sweepLine)(curves, curve => (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(curve.ps)[0][0], curve => (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(curve.ps)[1][0], (0,_get_curves_intersections_js__WEBPACK_IMPORTED_MODULE_2__.getCurvesIntersections)(expMax));\n    const xs = [];\n    for (const _x of _xs) {\n        for (const x of _x.u) {\n            xs.push(x);\n        }\n    }\n    return xs;\n}\n\n//# sourceMappingURL=get-intersections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-other-t.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-other-t.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOtherTs: () => (/* binding */ getOtherTs)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/boxes/intersect-boxes.js\");\n\n// TODO - could this come from flo-bezier3\nfunction getOtherTs(ps1, ps2, ts2) {\n    if (ts2 === undefined) {\n        // infinite number of intersections\n        return undefined;\n    }\n    if (ts2.length === 0) {\n        return [];\n    }\n    const ts1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.bezierBezierIntersectionBoundless)(ps2, ps1);\n    if (ts1 === undefined) {\n        // infinite number of intersections\n        return undefined;\n    }\n    if (ts1.length === 0) {\n        return [];\n    }\n    const is1 = ts1.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getIntervalBox)(ps1, [ri.tS, ri.tE]));\n    const is2 = ts2.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getIntervalBox)(ps2, [ri.tS, ri.tE]));\n    const xPairs = [];\n    for (let i = 0; i < ts1.length; i++) {\n        const box1 = is1[i];\n        for (let j = 0; j < ts2.length; j++) {\n            const box2 = is2[j];\n            const box = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.intersectBoxes)(box1, box2);\n            if (box !== undefined) {\n                // TODO important - combine boxes to make sense, i.e. combine better\n                // e.g. two odd multiplicity boxes should combine to a single even, etc. etc.\n                const x1 = { ri: ts1[i], box, kind: 1 };\n                const x2 = { ri: ts2[j], box, kind: 1 };\n                xPairs.push([x1, x2]);\n            }\n        }\n    }\n    return xPairs;\n}\n\n//# sourceMappingURL=get-other-t.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-other-t.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSelfIntersections: () => (/* binding */ getSelfIntersections)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n\nconst eps = Number.EPSILON;\n/**\n * @param loops\n */\nfunction getSelfIntersections(loops) {\n    const xs = [];\n    for (const loop of loops) {\n        for (const curve of loop.curves) {\n            const ps = curve.ps;\n            const ts = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.bezierSelfIntersection)(ps);\n            // if (ts === undefined) { continue; }  // there is no self-intersection\n            if (ts.length === 0) {\n                continue;\n            }\n            // if a cusp (or extremely close to it)\n            const kind = ts[0] === ts[1]\n                ? 3 /*cusp*/\n                : 2 /*self-intersection*/;\n            // TODO - fix box - must combine 2 boxes and bezierSelfIntersection must return intervals\n            const t0S = ts[0] - eps;\n            const t0E = ts[0] + eps;\n            const t1S = ts[1] - eps;\n            const t1E = ts[1] + eps;\n            const box0 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getIntervalBox)(ps, [t0S, t0E]); // ts are within 1 upls accurate\n            const box1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getIntervalBox)(ps, [t1S, t1E]); // ts are within 1 upls accurate\n            xs.push([\n                // TODO - multiplicity relevant??\n                { x: { ri: { tS: t0S, tE: t0E, multiplicity: 1 }, box: box0, kind }, curve },\n                { x: { ri: { tS: t1S, tE: t1E, multiplicity: 1 }, box: box1, kind }, curve }\n            ]);\n        }\n    }\n    return xs;\n}\n\n//# sourceMappingURL=get-self-intersections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeSimpleX: () => (/* binding */ makeSimpleX)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js\");\n\n/**\n *\n * @param t\n * @param curve\n * @param kind\n */\nfunction makeSimpleX(t, curve, kind) {\n    const ps = curve.ps;\n    if (t === 0) {\n        // we have the exact point\n        const pS = ps[0];\n        const box = [ps[0], ps[0]];\n        return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\n    }\n    else if (t === 1) {\n        // we have the exact point\n        const pE = ps[ps.length - 1];\n        const box = [pE, pE];\n        return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\n    }\n    // there will be some error in calculating the point\n    const { p, pE } = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauWithErr)(ps, t);\n    const box = [\n        [p[0] - pE[0], p[1] - pE[1]],\n        [p[0] + pE[0], p[1] + pE[1]]\n    ];\n    return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\n}\n\n//# sourceMappingURL=make-simple-x.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setIntersectionNextValues: () => (/* binding */ setIntersectionNextValues)\n/* harmony export */ });\n/**\n * Set each intersection on the given original loop's `next` and `prev` value.\n *\n * @param xPairs\n */\nfunction setIntersectionNextValues(xPairs) {\n    const xsByLoop = new Map();\n    for (const xPair of xPairs) {\n        for (const x_ of xPair) {\n            const loop = x_.curve.loop;\n            const xs_ = xsByLoop.get(loop) || [];\n            if (!xs_.length) {\n                xsByLoop.set(loop, xs_);\n            }\n            xs_.push(x_);\n        }\n    }\n    for (const item of xsByLoop) {\n        const xs = item[1];\n        if (!xs || !xs.length) {\n            continue;\n        }\n        xs.sort((xA, xB) => {\n            let res = xA.curve.idx - xB.curve.idx;\n            if (res !== 0) {\n                return res;\n            }\n            res = xA.x.ri.tS - xB.x.ri.tS;\n            if (res !== 0) {\n                return res;\n            }\n            return xA.in_ !== undefined ? -1 : +1;\n        });\n        const len = xs.length;\n        for (let i = 0; i < len; i++) {\n            xs[i].next = xs[(i + 1) % len];\n        }\n    }\n}\n\n//# sourceMappingURL=set-intersection-next-values.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/graph/get-connected-components.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/graph/get-connected-components.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   addEdges: () => (/* binding */ addEdges),\n/* harmony export */   getConnectedComponents: () => (/* binding */ getConnectedComponents)\n/* harmony export */ });\nfunction addEdges(graph, edges) {\n    for (let i = 0; i < edges.length; i++) {\n        const edge = edges[i];\n        addEdge(graph, [edge.a, edge.b]);\n    }\n}\n/**\n * Adds an edge to an undirected graph.\n */\nfunction addEdge(graph, vertices) {\n    const [src, dest] = vertices;\n    let srcList = graph.get(src);\n    if (!srcList) {\n        srcList = [];\n        graph.set(src, srcList);\n    }\n    let destList = graph.get(dest);\n    if (!destList) {\n        destList = [];\n        graph.set(dest, destList);\n    }\n    srcList.push(dest);\n    destList.push(src);\n}\nfunction DFSUtil(graph, v, visited, component) {\n    // Mark the current node as visited and print it \n    visited.add(v);\n    component.push(v);\n    // Recur for all the vertices adjacent to this vertex \n    const list = graph.get(v);\n    for (let i = 0; i < list.length; i++) {\n        const x = list[i];\n        if (!visited.has(x)) {\n            DFSUtil(graph, x, visited, component);\n        }\n    }\n}\n/**\n * Returns connected components for the given undirected graph\n */\nfunction getConnectedComponents(graph) {\n    // Mark all the vertices as not visited \n    const components = [];\n    const visited = new Set();\n    for (const item of graph) {\n        const node = item[0];\n        if (!visited.has(node)) {\n            // print all reachable vertices from v \n            components.push([]);\n            DFSUtil(graph, node, visited, components[components.length - 1]);\n        }\n    }\n    return components;\n}\n\n//# sourceMappingURL=get-connected-components.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/graph/get-connected-components.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/get-loop-area.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/get-loop-area.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLoopArea: () => (/* binding */ getLoopArea)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/basic/double/multiply.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/basic/double/negate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/calculus/double/integrate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/basic/double/add.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\n\n/**\n * Returns the area of the given Loop.\n * * see e.g. https://mathinsight.org/greens_theorem_find_area\n */\nfunction getLoopArea(loop) {\n    let totalArea = 0;\n    for (const curve of loop.curves) {\n        const ps = curve.ps;\n        const [x, y] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis)(ps);\n        const [dx, dy] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\n        const xdy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.multiply)(x, dy);\n        const ydx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.negate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.multiply)(y, dx));\n        const poly = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.integrate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.add)(xdy, ydx), 0);\n        const area = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.Horner)(poly, 1);\n        totalArea += area;\n    }\n    return -totalArea / 2;\n}\n\n//# sourceMappingURL=get-loop-area.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/get-loop-area.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/get-min-y.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/get-min-y.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMinY: () => (/* binding */ getMinY)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js\");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n\n\n/**\n *\n */\nconst getMinY = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function getMinY(loop) {\n    const curves = loop.curves;\n    let bestY = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getYBoundsTight)(curves[0].ps).minY;\n    let bestCurve = curves[0];\n    for (let i = 1; i < curves.length; i++) {\n        const ps = loop.curves[i].ps;\n        const minY = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getYBoundsTight)(ps).minY;\n        const v = minY.box[0][1];\n        const x = bestY.box[0][1];\n        if (v < x || (v === x && minY.ts[0] > bestY.ts[0])) {\n            bestY = minY;\n            bestCurve = loop.curves[i];\n        }\n    }\n    return { curve: bestCurve, y: bestY };\n});\n\n//# sourceMappingURL=get-min-y.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/get-min-y.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/loop.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/loop.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loopFromBeziers: () => (/* binding */ loopFromBeziers)\n/* harmony export */ });\nfunction isPoint(ps) {\n    if (ps.length === 2) {\n        return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] // p[0] === p[1]\n        );\n    }\n    if (ps.length === 3) {\n        return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] && // p[0] === p[1]\n            ps[1][1] === ps[2][1] && ps[1][1] === ps[2][1] // p[1] === p[2]\n        );\n    }\n    return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] && // p[0] === p[1]\n        ps[1][1] === ps[2][1] && ps[1][1] === ps[2][1] && // p[1] === p[2]\n        ps[2][1] === ps[3][1] && ps[2][1] === ps[3][1] // p[2] === p[3]\n    );\n}\n/**\n * @param beziers a pre-ordered array of bezier curves to add initially.\n * @param idx an optional index to assign to the loop - it can be anything\n */\nfunction loopFromBeziers(beziers = [], idx) {\n    const curves = [];\n    const loop = { beziers, curves, idx };\n    if (!beziers.length) {\n        return loop;\n    }\n    let prev = undefined;\n    let j = 0;\n    for (let i = 0; i < beziers.length; i++) {\n        if (isPoint(beziers[i])) {\n            continue;\n        }\n        const curve = {\n            loop,\n            ps: beziers[i],\n            prev: prev,\n            next: undefined,\n            idx: j\n        };\n        if (prev) {\n            prev.next = curve;\n        }\n        prev = curve;\n        curves.push(curve);\n        j++;\n    }\n    // close loop\n    const lastCurve = curves[curves.length - 1];\n    curves[0].prev = lastCurve;\n    lastCurve.next = curves[0];\n    lastCurve.ps[lastCurve.ps.length - 1] = curves[0].ps[0];\n    return loop;\n}\n\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areAllPointsDifferent: () => (/* binding */ areAllPointsDifferent)\n/* harmony export */ });\n/**\n * Returns true if all points in the given array are different, false otherwise.\n * @param ps An array of points.\n */\nfunction areAllPointsDifferent(ps) {\n    for (let i = 0; i < ps.length - 1; i++) {\n        for (let j = i + 1; j < ps.length; j++) {\n            if (ps[i][0] === ps[j][0] && ps[i][1] === ps[j][1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=are-all-points-different.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixBezierByPointSpacing: () => (/* binding */ fixBezierByPointSpacing)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-length.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/equal.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _are_all_points_different_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./are-all-points-different.js */ \"./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js\");\n\n// import { lengthSquaredUpperBound, isLine, isCubicReallyQuad, toQuadraticFromCubic } from \"flo-bezier3\";\n\n\nconst { abs } = Math;\n/**\n * Returns the same bezier if its points are well-spaced, e.g. all points not\n * coincident, etc., else fix it, if possible, and return the fixed bezier,\n * else return undefined.\n * @param ps A bezier\n */\nfunction fixBezierByPointSpacing(ps, gridSpacing, sendToGrid) {\n    if (ps === undefined) {\n        return undefined;\n    }\n    // Early filter - if all points coincide, we're done - degenerate to point\n    if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.isReallyPoint)(ps)) {\n        return undefined; // Cannot fix\n    }\n    if (ps.length === 2) {\n        // obviously no need to fix a line (that is not degenerate to a point)\n        return ps;\n    }\n    if (ps.length === 3) {\n        // Early filter - if no points coincide, we're done - well spaced\n        if ((0,_are_all_points_different_js__WEBPACK_IMPORTED_MODULE_1__.areAllPointsDifferent)(ps)) {\n            // but if it s a line masquerading as a quadratic or cubic bezier\n            // then make it line\n            // return isLine(ps) ? [ps[0], ps[2]] : ps;\n            return (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.isCollinear)(ps) ? [ps[0], ps[2]] : ps;\n        }\n        // Is the quadratic bezier overlapping onto itself? \n        if (arePsEqual(ps[0], ps[2])) {\n            // a quadratic with equal endpoints (and not degenerate to a point)\n            return undefined; // better to just remove it\n            // return [ps[0], ps[1]];\n        }\n        // At this point not all points same and not all points different and \n        // not endpoints coincide, so either:\n        // * point 0 and 1 coincide\n        // * point 1 and 2 coincide\n        // but in that case we simply have a line\n        return [ps[0], ps[2]];\n    }\n    // ---- at this point we must have a cubic\n    // Early filter - if no points coincide, we're done - well spaced\n    if ((0,_are_all_points_different_js__WEBPACK_IMPORTED_MODULE_1__.areAllPointsDifferent)(ps)) {\n        const ps_ = checkCubicForLineOrQuad(ps);\n        if (ps_ === undefined) {\n            return undefined;\n        }\n        if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.equal)(ps_, ps)) {\n            return ps;\n        }\n        return fixBezierByPointSpacing(ps_, gridSpacing, sendToGrid);\n    }\n    if (arePsEqual(ps[0], ps[3])) {\n        // we should simply handle this case for cubics - lines and quadratics \n        // degenerate into a point and a self-overlapping curve respectively.\n        // if (isCollinear(ps)) { return [ps[0], ps[3]]; }\n        if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.isCollinear)(ps)) {\n            return undefined;\n        }\n        // if (arePsEqual(ps[1], ps[2])) {\n        //     // it is a cubic degenerated to a line\n        //     return [ps[0], ps[2]];\n        // }\n        // no need to fix anything - it is a loop - it cannot be a line or a\n        // quadratic (they don't make loops)\n        return ps;\n    }\n    if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.isCollinear)(ps)) {\n        return [ps[0], ps[3]];\n    }\n    // At this point, either:\n    // * point 0, 1 and 2 coincide\n    // * point 1, 2 and 3 coincide\n    // * points 0,1 AND points 2,3 coincide\n    // * only point 0 and point 1 coincide\n    // * only point 0 and point 2 coincide\n    // * only point 1 and point 2 coincide\n    // * only point 1 and point 3 coincide\n    // * only point 2 and point 3 coincide\n    // If point 0, 1 and 2 coincide OR point 1, 2 and 3 coincide OR\n    // points 0,1 AND points 2,3 coincide we have a line\n    if ((arePsEqual(ps[0], ps[1]) &&\n        arePsEqual(ps[1], ps[2])) ||\n        (arePsEqual(ps[1], ps[2]) &&\n            arePsEqual(ps[2], ps[3])) ||\n        (arePsEqual(ps[0], ps[1]) &&\n            arePsEqual(ps[2], ps[3]))) {\n        return fixBezierByPointSpacing([ps[0], ps[ps.length - 1]], gridSpacing, sendToGrid);\n        /*\n        // Check if first and last point are sufficiently far apart to split\n        // the bezier into a line so that all points differ.\n\n        // TODO2 - is below maybe not correct?\n        //if ((ps[0][0] - ps[3][0]) > (3+1)*gridSpacing ||\n        //    (ps[0][1] - ps[3][1]) > (3+1)*gridSpacing) {\n        if (abs(ps[0][0] - ps[3][0]) > (3+1)*gridSpacing ||\n            abs(ps[0][1] - ps[3][1]) > (3+1)*gridSpacing) {\n\n            return [ps[0], ps[ps.length-1]];\n        } else {\n            // Points are not sufficiently far apart to resolve onto grid -\n            // cannot fix it - it is basically a point.\n\n            return undefined;\n        }*/\n    }\n    // At this point, either:\n    // * only point 0 and point 1 coincides\n    // * only point 0 and point 2 coincides        \n    // * only point 1 and point 2 coincides\n    // * only point 1 and point 3 coincides\n    // * only point 2 and point 3 coincides\n    // If points 0,2 OR points 1,3 OR points 1,2 coincide we're done - they\n    // are not problematic\n    if (arePsEqual(ps[0], ps[2]) ||\n        arePsEqual(ps[1], ps[3]) ||\n        arePsEqual(ps[1], ps[2])) {\n        // these kinds of cubics cannot be quadratics and the case for a line\n        // has already been checked - we're done\n        return ps;\n    }\n    // At this point, either:\n    // * only point 0 and point 1 coincides\n    // * only point 2 and point 3 coincides\n    // it is a cubic with a cusp at an endpoint - these are fine for our\n    // algorithm but lets move them a little apart for later alogorithms \n    // operating on our returned result.\n    if (arePsEqual(ps[0], ps[1])) {\n        // Move point 1 towards point 2 without surpassing it and ensuring it\n        // will be on a new grid point\n        // If squared distance between the points < 4 * gridSpacing just \n        // move them onto each other - this shouldn't affect the overall \n        // accuracy of the algorithm and it ensures the move > gridSpacing.\n        if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.squaredDistanceBetween)(ps[1], ps[2]) < 4 * gridSpacing) {\n            return [ps[0], ps[2], ps[2], ps[3]]; // cannot be a line or quad\n        }\n        else {\n            const v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.toLength)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.fromTo)(ps[1], ps[2]), 2 * gridSpacing);\n            const p1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.translate)(ps[1], v);\n            return checkCubicForLineOrQuad([\n                ps[0],\n                sendToGrid(p1),\n                ps[2],\n                ps[3]\n            ]);\n        }\n    }\n    if (arePsEqual(ps[2], ps[3])) {\n        // Move point 2 towards point 1 without surpassing it and ensuring it\n        // will be on a new grid point\n        // If squared distance between the points < 4 * gridSpacing just \n        // move them onto each other - this shouldn't affect the overall \n        // accuracy of the algorithm and it ensures the move > gridSpacing.\n        if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.squaredDistanceBetween)(ps[2], ps[1]) < 4 * gridSpacing) {\n            return [\n                ps[0],\n                ps[1],\n                ps[1],\n                ps[3]\n            ]; // cannot be a line or quad\n        }\n        else {\n            const v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.toLength)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.fromTo)(ps[2], ps[1]), 2 * gridSpacing);\n            const p2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.translate)(ps[2], v);\n            return checkCubicForLineOrQuad([\n                ps[0],\n                ps[1],\n                sendToGrid(p2),\n                ps[3]\n            ]);\n        }\n    }\n}\nfunction checkCubicForLineOrQuad(ps) {\n    // return isLine(ps)\n    return (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.isCollinear)(ps)\n        ? [ps[0], ps[3]]\n        : (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_8__.isCubicReallyQuad)(ps)\n            ? (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_9__.cubicToQuadratic)(ps)\n            : ps;\n}\n/** Returns true if the points are the same */\nfunction arePsEqual(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\n\n//# sourceMappingURL=fix-bezier-by-point-spacing.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixBeziers: () => (/* binding */ fixBeziers)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js\");\n/* harmony import */ var _to_grid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./to-grid.js */ \"./node_modules/flo-boolean/node/loop/normalize/to-grid.js\");\n/* harmony import */ var _fix_bezier_by_point_spacing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fix-bezier-by-point-spacing.js */ \"./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js\");\n\n\n\nfunction sendToGrid(expMax, maxBitLength) {\n    return (p) => [\n        (0,_to_grid_js__WEBPACK_IMPORTED_MODULE_0__.toGrid)(p[0], expMax, maxBitLength),\n        (0,_to_grid_js__WEBPACK_IMPORTED_MODULE_0__.toGrid)(p[1], expMax, maxBitLength)\n    ];\n}\nfunction sendToGridNoop(p) { return p; }\n/**\n * Returns the grid-aligned loop derived from the given input loop.\n *\n * Also ensures that:\n * * All points are coerced onto a grid.\n * * All bezier points of a single curve are seperated.\n * @param expMax The exponent, e, such that 2^e > all bezier coordinate points.\n * @param maxBitLength\n */\nfunction fixBeziers(expMax, maxBitLength, doSendToGrid = true) {\n    /** The actual control point grid spacing */\n    const gridSpacing = 2 ** expMax * 2 ** (-maxBitLength);\n    const sendToGrid_ = doSendToGrid\n        ? sendToGrid(expMax, maxBitLength)\n        : sendToGridNoop;\n    return (loop) => {\n        const newPss = [];\n        for (let i = 0; i < loop.length; i++) {\n            let ps = loop[i].slice();\n            // Get endpoint of last good bezier or else the original start point\n            const len = newPss.length;\n            const prevGoodBezier = newPss[len - 1];\n            const prevGoodBezierEndpoint = prevGoodBezier\n                ? prevGoodBezier[prevGoodBezier.length - 1]\n                : sendToGrid_(loop[0][0]); // Bit-align original start point\n            // Set the start point to the previous good bezier's endpoint\n            ps[0] = prevGoodBezierEndpoint;\n            // Align to grid before doing any further checks\n            ps = ps.map(p => sendToGrid_(p));\n            // Check if ps degenerates into a self-overlapping line\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.isSelfOverlapping)(ps)) {\n                // Change into a line with endponts that of the original bezier\n                ps = [ps[0], ps[ps.length - 1]];\n            }\n            ps = (0,_fix_bezier_by_point_spacing_js__WEBPACK_IMPORTED_MODULE_2__.fixBezierByPointSpacing)(ps, gridSpacing, sendToGrid_);\n            if (ps !== undefined) {\n                newPss.push(ps);\n            }\n        }\n        const len = newPss.length;\n        if (!len) {\n            return [];\n        }\n        // Connect the last bezier end-point to the first bezier start-point.\n        const ps = newPss[len - 1];\n        ps[ps.length - 1] = newPss[0][0];\n        return newPss;\n    };\n}\n\n//# sourceMappingURL=fix-beziers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMaxCoordinate: () => (/* binding */ getMaxCoordinate)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n\n/**\n * Returns the maximum control point coordinate value (x or y) within any loop.\n * @param loops The array of loops\n */\nconst getMaxCoordinate = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)((loops) => {\n    let max = 0;\n    for (const loop of loops) {\n        for (const ps of loop) {\n            for (const p of ps) {\n                for (const c of p) {\n                    const c_ = Math.abs(c);\n                    if (c_ > max) {\n                        max = c_;\n                    }\n                }\n            }\n        }\n    }\n    return max;\n});\n\n//# sourceMappingURL=get-max-coordinate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeLoops: () => (/* binding */ normalizeLoops)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-representation/bit-length.js\");\n/* harmony import */ var _fix_beziers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fix-beziers.js */ \"./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js\");\n/* harmony import */ var _to_grid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./to-grid.js */ \"./node_modules/flo-boolean/node/loop/normalize/to-grid.js\");\n\n\n\n/**\n * Returns new loops from the given loops by aligning the 53-bit double\n * precision coordinates to 46-bit coordinates. This speeds up the algorithm\n * considerably.\n *\n * The following guarantees are put in place for the returned loops:\n * * All points are coerced onto a grid. In other words, such that the\n *   significand of all coordinates are reduced to a specified number of bits\n *   and the significant bits of all points 'overlap'.\n *\n * * No curves are disguised as higher order curves (this includes the case\n *   that no bezier is of zero length and the case where there are an infinite\n *   number of self-intersections). The curves are simply deflated exactly.\n *\n * * No cusps (this includes the case that all bezier end-points of each curve\n *   are seperated. (this prevents infinite curvature at the endpoints, etc).\n *   (this condition is not necessary for this algorithm but may help algorithms\n *    down the line that needs such guarantees)\n * @param bezierLoops\n * @param maxBitLength\n * @param expMax\n * @param doScramble\n * @param doSendToGrid\n */\nfunction normalizeLoops(bezierLoops, maxBitLength, expMax, doScramble = false, doSendToGrid = true) {\n    const fixBeziers_ = (0,_fix_beziers_js__WEBPACK_IMPORTED_MODULE_0__.fixBeziers)(expMax, maxBitLength, doSendToGrid);\n    let loops = bezierLoops.slice();\n    // just for testing purposes\n    loops = doScramble ? scrambleLoops(loops, maxBitLength, expMax, 1) : loops;\n    loops = loops.map(fixBeziers_);\n    loops = loops.filter(loop => loop.length > 0);\n    return loops;\n}\n/** Just for testing purposes - not used in the actual algorithm */\nfunction scrambleLoops(loops, maxBitLength, expMax, mult = 0.02) {\n    const loops_ = [];\n    for (const loop of loops) {\n        const loop_ = [];\n        for (const bez of loop) {\n            const bez_ = bez.map(v => v.map(c => {\n                let c_ = 0;\n                let ii = 0;\n                let mblc;\n                let mbl = 0;\n                while (true) {\n                    if (++ii > 10) {\n                        break;\n                    }\n                    c_ = (c + Math.random()) * (1 + ((Math.random() - 0.7) * mult));\n                    c_ = (0,_to_grid_js__WEBPACK_IMPORTED_MODULE_1__.toGrid)(c_, expMax, maxBitLength);\n                    const bl = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.bitLength)(c_);\n                    if (bl > mbl) {\n                        mbl = bl;\n                        mblc = c_;\n                    }\n                }\n                return mblc;\n            }));\n            loop_.push(bez_);\n        }\n        loops_.push(loop_);\n    }\n    return loops_;\n}\n\n//# sourceMappingURL=normalize-loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/to-grid.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/to-grid.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toGrid: () => (/* binding */ toGrid)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/reduce-significand.js\");\n\n/**\n * Sends a onto a fixed-spacing grid with 2**significantFigures divisions. Each\n * division is 2**maxExp / 2**significantFigures wide.\n * @param a\n * @param expMax log2(max extent of grid in positive and negative directions)\n *\n * @param significantFigures\n */\nfunction toGrid(a, expMax, significantFigures) {\n    const expA = Math.floor(Math.log2(Math.abs(a)));\n    const expDif = expMax - expA;\n    const newSig = significantFigures - expDif + 1;\n    if (newSig <= 0) {\n        return 0;\n    }\n    if (significantFigures >= 53) {\n        return a;\n    }\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.reduceSignificand)(a, newSig);\n}\n\n//# sourceMappingURL=to-grid.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/normalize/to-grid.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/reverse-orientation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/reverse-orientation.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reverseOrientation: () => (/* binding */ reverseOrientation)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reverse.js\");\n/* harmony import */ var _loop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loop.js */ \"./node_modules/flo-boolean/node/loop/loop.js\");\n\n\n/**\n * Returns a completely reversed loop of the given bezier loop.\n * @param loop\n */\nfunction reverseOrientation(loop) {\n    const beziers = [];\n    const curves = loop.curves;\n    for (let i = curves.length - 1; i >= 0; i--) {\n        const curve = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.reverse)(curves[i].ps);\n        beziers.push(curve);\n    }\n    return (0,_loop_js__WEBPACK_IMPORTED_MODULE_1__.loopFromBeziers)(beziers, undefined);\n}\n\n//# sourceMappingURL=reverse-orientation.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/loop/reverse-orientation.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arcToCubicCurves: () => (/* binding */ arcToCubicCurves)\n/* harmony export */ });\n// TODO - a work in progress - currently using a different (less accurate?) \n// function.\n/**\n * @hidden\n * Get an array of corresponding cubic bezier curve parameters for given arc\n * curve paramters.\n */\nfunction arcToCubicCurves(\n/** the start point */\npS, \n/** radius x */\nrx, \n/** radius y */\nry, \n/** x-axis rotation - in degrees */\nrotationAngle, largeArcFlag, sweepFlag, pE) {\n    return [[\n            pS,\n            pE\n        ]];\n}\n/**\n * @param x\n * @param y\n * @param angleRad\n */\nfunction rotate(x, y, angleRad) {\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return { x: X, y: Y };\n}\n/**\n * @param degrees\n */\nfunction degToRad(degrees) {\n    return (Math.PI * degrees) / 180;\n}\n\n//# sourceMappingURL=arc-to-cubic-curves.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beziersToSvgPathStr: () => (/* binding */ beziersToSvgPathStr)\n/* harmony export */ });\n/**\n * Returns an SVG path string representation of the given bezier loop.\n * @param beziers An array of bezier curves each given as an array of\n * control points.\n */\nfunction beziersToSvgPathStr(beziers) {\n    let str = '';\n    for (let i = 0; i < beziers.length; i++) {\n        const ps = beziers[i];\n        if (i === 0) {\n            str = 'M ' +\n                ps[0][0].toString() + ' ' +\n                ps[0][1].toString() + '\\n';\n        }\n        if (ps.length === 4) {\n            str += 'C ' +\n                ps[1][0].toString() + ' ' +\n                ps[1][1].toString() + ' ' +\n                ps[2][0].toString() + ' ' +\n                ps[2][1].toString() + ' ' +\n                ps[3][0].toString() + ' ' +\n                ps[3][1].toString() + ' ' + '\\n';\n        }\n        else if (ps.length === 3) {\n            str += 'Q ' +\n                ps[1][0].toString() + ' ' +\n                ps[1][1].toString() + ' ' +\n                ps[2][0].toString() + ' ' +\n                ps[2][1].toString() + ' ' + '\\n';\n        }\n        else if (ps.length === 2) {\n            str += 'L ' +\n                ps[1][0].toString() + ' ' +\n                ps[1][1].toString() + ' ' + '\\n';\n        }\n    }\n    return str + ' z' + '\\n';\n}\n\n//# sourceMappingURL=beziers-to-svg-path-str.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBeziersFromRawPaths: () => (/* binding */ getBeziersFromRawPaths)\n/* harmony export */ });\n/* harmony import */ var _path_state_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./path-state.js */ \"./node_modules/flo-boolean/node/svg/path-state.js\");\n/* harmony import */ var _path_segment_z_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path-segment/z.js */ \"./node_modules/flo-boolean/node/svg/path-segment/z.js\");\n/* harmony import */ var _path_segment_c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path-segment/c.js */ \"./node_modules/flo-boolean/node/svg/path-segment/c.js\");\n/* harmony import */ var _path_segment_s_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path-segment/s.js */ \"./node_modules/flo-boolean/node/svg/path-segment/s.js\");\n/* harmony import */ var _path_segment_l_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path-segment/l.js */ \"./node_modules/flo-boolean/node/svg/path-segment/l.js\");\n/* harmony import */ var _path_segment_h_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-segment/h.js */ \"./node_modules/flo-boolean/node/svg/path-segment/h.js\");\n/* harmony import */ var _path_segment_v_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./path-segment/v.js */ \"./node_modules/flo-boolean/node/svg/path-segment/v.js\");\n/* harmony import */ var _path_segment_q_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path-segment/q.js */ \"./node_modules/flo-boolean/node/svg/path-segment/q.js\");\n/* harmony import */ var _path_segment_t_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path-segment/t.js */ \"./node_modules/flo-boolean/node/svg/path-segment/t.js\");\n/* harmony import */ var _path_segment_a_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./path-segment/a.js */ \"./node_modules/flo-boolean/node/svg/path-segment/a.js\");\n\n\n\n\n\n\n\n\n\n\nconst pathFs = {\n    //a, // elliptical arc\n    c: _path_segment_c_js__WEBPACK_IMPORTED_MODULE_0__.c,\n    h: _path_segment_h_js__WEBPACK_IMPORTED_MODULE_1__.h,\n    l: _path_segment_l_js__WEBPACK_IMPORTED_MODULE_2__.l,\n    q: _path_segment_q_js__WEBPACK_IMPORTED_MODULE_3__.q,\n    s: _path_segment_s_js__WEBPACK_IMPORTED_MODULE_4__.s,\n    t: _path_segment_t_js__WEBPACK_IMPORTED_MODULE_5__.t,\n    v: _path_segment_v_js__WEBPACK_IMPORTED_MODULE_6__.v,\n    z: _path_segment_z_js__WEBPACK_IMPORTED_MODULE_7__.z // close path\n};\n/**\n * Returns order 1, 2 and 3 beziers from the given SVG DOM element. If a path\n * data tag is not \"C, Q or L, etc\", i.e. if it is not an absolute bezier\n * coordinate then it is converted into one.\n * @param paths An SVG element\n */\nfunction getBeziersFromRawPaths(paths) {\n    if (paths.length === 0) {\n        return []; // A shape is not described   \n    }\n    if (paths[0].type.toLowerCase() !== 'm') {\n        throw new Error('Invalid SVG - every new path must start with an M or m.');\n    }\n    const s = new _path_state_js__WEBPACK_IMPORTED_MODULE_8__.PathState();\n    const beziersArrays = [];\n    let beziers = [];\n    let prevType = undefined;\n    for (let i = 0; i < paths.length; i++) {\n        const pathSeg = paths[i];\n        const type = pathSeg.type.toLowerCase();\n        s.vals = pathSeg.values;\n        // If pathSeg was lowercase, it is relative - make absolute\n        if (pathSeg.type === type) {\n            if (type === 'v') {\n                s.vals[0] += s.p[1];\n            }\n            else if (type === 'a') {\n                s.vals[5] += s.p[0];\n                s.vals[6] += s.p[1];\n            }\n            else {\n                for (let i = 0; i < s.vals.length; i++) {\n                    s.vals[i] += s.p[i % 2];\n                }\n            }\n        }\n        if (type === 'm') {\n            if (beziers.length) {\n                // This is a subpath, close as if the previous command was a \n                // Z or z.\n                if (prevType !== 'z') {\n                    beziers.push((0,_path_segment_z_js__WEBPACK_IMPORTED_MODULE_7__.z)(s));\n                }\n                // Start new path\n                beziersArrays.push(beziers);\n                beziers = [];\n            }\n            s.initialPoint = s.p = s.vals;\n            prevType = type;\n            continue;\n        }\n        if (type === 'a') {\n            beziers.push(...(0,_path_segment_a_js__WEBPACK_IMPORTED_MODULE_9__.a)(s));\n        }\n        else {\n            const f = pathFs[type];\n            if (!f) {\n                throw new Error('Invalid SVG - command not recognized.');\n            }\n            const ps = f(s);\n            s.p = ps[ps.length - 1]; // Update current point\n            beziers.push(ps);\n        }\n        prevType = type;\n    }\n    if (beziers.length > 0) {\n        // This is a subpath, close as if the previous command was a Z or z.\n        if (prevType !== 'z') {\n            beziers.push((0,_path_segment_z_js__WEBPACK_IMPORTED_MODULE_7__.z)(s));\n        }\n        // Start new path\n        beziersArrays.push(beziers);\n    }\n    return beziersArrays;\n}\n\n//# sourceMappingURL=get-beziers-from-raw-paths.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/get-paths-from-str.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/get-paths-from-str.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPathsFromStr: () => (/* binding */ getPathsFromStr)\n/* harmony export */ });\n/* harmony import */ var _get_beziers_from_raw_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-beziers-from-raw-paths.js */ \"./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js\");\n/* harmony import */ var _path_data_polyfill_parse_path_data_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-data-polyfill/parse-path-data-string.js */ \"./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js\");\n\n\n/**\n * Returns an array of loops with each loop consisting of an array of beziers\n * and each bezier in turn consisting of an array of control points from the\n * given SVG path string. An array of loops are returned (as opposed to a single\n * loop) since an SVG path may have sub-paths.\n * @param str The SVG path string, e.g. 'M1 1 C 5 1 5 2 4 2 C 3 3 1 3 1 1 z'\n */\nfunction getPathsFromStr(str) {\n    return (0,_get_beziers_from_raw_paths_js__WEBPACK_IMPORTED_MODULE_0__.getBeziersFromRawPaths)((0,_path_data_polyfill_parse_path_data_string_js__WEBPACK_IMPORTED_MODULE_1__.parsePathDataString)(str));\n}\n\n//# sourceMappingURL=get-paths-from-str.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/get-paths-from-str.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loopsToSvgPathStr: () => (/* binding */ loopsToSvgPathStr)\n/* harmony export */ });\n/* harmony import */ var _beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./beziers-to-svg-path-str.js */ \"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js\");\n\n/**\n * Returns an SVG path string representation of the given bezier loops.\n * @param loops An array of loops having an array of bezier curves each given as\n * an array of control points.\n */\nfunction loopsToSvgPathStr(loops) {\n    let str = '';\n    for (const loop of loops) {\n        str = str + (0,_beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_0__.beziersToSvgPathStr)(loop) + '\\n';\n    }\n    return str;\n}\n\n//# sourceMappingURL=loops-to-svg-path-str.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseNumber: () => (/* binding */ parseNumber)\n/* harmony export */ });\n/**\n * @hidden\n * Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n * Source/core/svg/SVGParserUtilities.cpp.\n * Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n * @param source\n */\nfunction parseNumber(source) {\n    let exponent = 0;\n    let integer = 0;\n    let frac = 1;\n    let decimal = 0;\n    let sign = 1;\n    let expsign = 1;\n    const startIndex = source._currentIndex;\n    source._skipOptionalSpaces();\n    // Read the sign.\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"+\") {\n        source._currentIndex += 1;\n    }\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"-\") {\n        source._currentIndex += 1;\n        sign = -1;\n    }\n    if (source._currentIndex === source._endIndex ||\n        ((source._string[source._currentIndex] < \"0\" || source._string[source._currentIndex] > \"9\") &&\n            source._string[source._currentIndex] !== \".\")) {\n        throw new Error('The first character of a number must be one of [0-9+-.].');\n    }\n    // Read the integer part, build right-to-left.\n    const startIntPartIndex = source._currentIndex;\n    while (source._currentIndex < source._endIndex &&\n        source._string[source._currentIndex] >= \"0\" &&\n        source._string[source._currentIndex] <= \"9\") {\n        source._currentIndex += 1; // Advance to first non-digit.\n    }\n    if (source._currentIndex !== startIntPartIndex) {\n        let scanIntPartIndex = source._currentIndex - 1;\n        let multiplier = 1;\n        while (scanIntPartIndex >= startIntPartIndex) {\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\n            scanIntPartIndex -= 1;\n            multiplier *= 10;\n        }\n    }\n    // Read the decimals.\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \".\") {\n        source._currentIndex += 1;\n        if (source._currentIndex >= source._endIndex ||\n            source._string[source._currentIndex] < \"0\" ||\n            source._string[source._currentIndex] > \"9\") {\n            throw new Error('There must be a least one digit following the .');\n        }\n        while (source._currentIndex < source._endIndex &&\n            source._string[source._currentIndex] >= \"0\" &&\n            source._string[source._currentIndex] <= \"9\") {\n            frac *= 10;\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\n            source._currentIndex += 1;\n        }\n    }\n    // Read the exponent part.\n    if (source._currentIndex !== startIndex &&\n        source._currentIndex + 1 < source._endIndex &&\n        (source._string[source._currentIndex] === \"e\" || source._string[source._currentIndex] === \"E\") &&\n        (source._string[source._currentIndex + 1] !== \"x\" && source._string[source._currentIndex + 1] !== \"m\")) {\n        source._currentIndex += 1;\n        // Read the sign of the exponent.\n        if (source._string[source._currentIndex] === \"+\") {\n            source._currentIndex += 1;\n        }\n        else if (source._string[source._currentIndex] === \"-\") {\n            source._currentIndex += 1;\n            expsign = -1;\n        }\n        if (source._currentIndex >= source._endIndex ||\n            source._string[source._currentIndex] < \"0\" ||\n            source._string[source._currentIndex] > \"9\") {\n            throw new Error('There must be an exponent.');\n        }\n        while (source._currentIndex < source._endIndex &&\n            source._string[source._currentIndex] >= \"0\" &&\n            source._string[source._currentIndex] <= \"9\") {\n            exponent *= 10;\n            exponent += (Number(source._string[source._currentIndex]));\n            source._currentIndex += 1;\n        }\n    }\n    let number = integer + decimal;\n    number *= sign;\n    if (exponent) {\n        number *= Math.pow(10, expsign * exponent);\n    }\n    if (startIndex === source._currentIndex) {\n        throw new Error('Internal error: startIndex === source._currentIndex');\n    }\n    source._skipOptionalSpacesOrDelimiter();\n    return number;\n}\n\n//# sourceMappingURL=parse-number.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePathDataString: () => (/* binding */ parsePathDataString)\n/* harmony export */ });\n/* harmony import */ var _source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./source.js */ \"./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js\");\n\n/**\n * @hidden\n * @param string\n */\nfunction parsePathDataString(string) {\n    if (!string.length) {\n        return [];\n    }\n    const source = new _source_js__WEBPACK_IMPORTED_MODULE_0__.Source(string);\n    const pathData = [];\n    if (!source.initialCommandIsMoveTo()) {\n        throw new Error('Path must start with m or M');\n    }\n    while (source.hasMoreData()) {\n        pathData.push(source.parseSegment());\n    }\n    return pathData;\n}\n\n//# sourceMappingURL=parse-path-data-string.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Source: () => (/* binding */ Source)\n/* harmony export */ });\n/* harmony import */ var _parse_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-number.js */ \"./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js\");\n\n/** @hidden */\nconst COMMAND_MAP = {\n    Z: \"Z\", M: \"M\", L: \"L\", C: \"C\", Q: \"Q\", A: \"A\", H: \"H\", V: \"V\", S: \"S\", T: \"T\",\n    z: \"Z\", m: \"m\", l: \"l\", c: \"c\", q: \"q\", a: \"a\", h: \"h\", v: \"v\", s: \"s\", t: \"t\"\n};\n/** @hidden */\nclass Source {\n    constructor(string) {\n        this._string = string;\n        this._currentIndex = 0;\n        this._endIndex = this._string.length;\n        this._prevCommand = undefined;\n        this._skipOptionalSpaces();\n    }\n    parseSegment() {\n        const char = this._string[this._currentIndex];\n        let command = COMMAND_MAP[char];\n        if (command === undefined) {\n            if (this._prevCommand === undefined) {\n                throw new Error('Implicit command not allowed for first commands.');\n            }\n            // Check for remaining coordinates in the current command.\n            if ((char === \"+\" || char === \"-\" || char === \".\" || (char >= \"0\" && char <= \"9\")) &&\n                this._prevCommand !== \"Z\") {\n                if (this._prevCommand === \"M\") {\n                    command = \"L\";\n                }\n                else if (this._prevCommand === \"m\") {\n                    command = \"l\";\n                }\n                else {\n                    command = this._prevCommand;\n                }\n            }\n            else {\n                throw new Error('Remaining coordinates not found for implicit command');\n            }\n        }\n        else {\n            this._currentIndex += 1;\n        }\n        this._prevCommand = command;\n        let values = undefined;\n        const cmd = command.toUpperCase();\n        if (cmd === \"H\" || cmd === \"V\") {\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\n        }\n        else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\n        }\n        else if (cmd === \"S\" || cmd === \"Q\") {\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\n        }\n        else if (cmd === \"C\") {\n            values = [\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)\n            ];\n        }\n        else if (cmd === \"A\") {\n            values = [\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                this._parseArcFlag(),\n                this._parseArcFlag(),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)\n            ];\n        }\n        else if (cmd === \"Z\") {\n            this._skipOptionalSpaces();\n            values = [];\n        }\n        if (values === undefined) {\n            throw new Error('Unknown command');\n        }\n        else {\n            return { type: command, values };\n        }\n    }\n    hasMoreData() {\n        return this._currentIndex < this._endIndex;\n    }\n    initialCommandIsMoveTo() {\n        // If the path is empty it is still valid, so return true.\n        if (!this.hasMoreData()) {\n            return true;\n        }\n        const command = COMMAND_MAP[this._string[this._currentIndex]];\n        return command === \"M\" || command === \"m\";\n    }\n    _isCurrentSpace() {\n        const char = this._string[this._currentIndex];\n        return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\n    }\n    _skipOptionalSpaces() {\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n            this._currentIndex += 1;\n        }\n        return this._currentIndex < this._endIndex;\n    }\n    _skipOptionalSpacesOrDelimiter() {\n        if (this._currentIndex < this._endIndex &&\n            !this._isCurrentSpace() &&\n            this._string[this._currentIndex] !== \",\") {\n            return false;\n        }\n        if (this._skipOptionalSpaces()) {\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\n                this._currentIndex += 1;\n                this._skipOptionalSpaces();\n            }\n        }\n        return this._currentIndex < this._endIndex;\n    }\n    _parseArcFlag() {\n        if (this._currentIndex >= this._endIndex) {\n            throw new Error('Unable to parse arc flag');\n        }\n        let flag = undefined;\n        const flagChar = this._string[this._currentIndex];\n        this._currentIndex += 1;\n        if (flagChar === \"0\") {\n            flag = 0;\n        }\n        else if (flagChar === \"1\") {\n            flag = 1;\n        }\n        else {\n            throw new Error('Unable to parse arc flag - arc flag must be 0 or 1');\n        }\n        this._skipOptionalSpacesOrDelimiter();\n        return flag;\n    }\n}\n\n//# sourceMappingURL=source.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/a.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/a.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ a)\n/* harmony export */ });\n/* harmony import */ var _arc_to_cubic_curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../arc-to-cubic-curves.js */ \"./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js\");\n\n/**\n * @hidden\n * A and a: (from www.w3.org)\n *\n * params: rx ry x-axis-rotation large-arc-flag sweep-flag x y\n *\n * Draws an elliptical arc from the current point to (x, y). The size and\n * orientation of the ellipse are defined by two radii (rx, ry) and an\n * x-axis-rotation, which indicates how the ellipse as a whole is rotated\n * relative to the current coordinate system. The center (cx, cy) of the ellipse\n * is calculated automatically to satisfy the constraints imposed by the other\n * parameters. large-arc-flag and sweep-flag contribute to the automatic\n * calculations and help determine how the arc is drawn.\n */\nfunction a(s) {\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    const curves = (0,_arc_to_cubic_curves_js__WEBPACK_IMPORTED_MODULE_0__.arcToCubicCurves)(s.p, s.vals[0], s.vals[1], s.vals[2], s.vals[3], s.vals[4], [s.vals[5], s.vals[6]]);\n    const lastPs = curves[curves.length - 1];\n    s.p = lastPs[lastPs.length - 1]; // Update current point\n    return curves;\n}\n\n//# sourceMappingURL=a.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/a.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/c.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ c)\n/* harmony export */ });\n/**\n * @hidden\n * C and c: (from www.w3.org)\n *\n * params: x1 y1 x2 y2 x y\n *\n * Draws a cubic Bézier curve from the current point to (x,y)\n * using (x1,y1) as the control point at the beginning of the\n * curve and (x2,y2) as the control point at the end of the\n * curve. C (uppercase) indicates that absolute coordinates\n * will follow; c (lowercase) indicates that relative\n * coordinates will follow. Multiple sets of coordinates may\n * be specified to draw a polybézier. At the end of the\n * command, the new current point becomes the final (x,y)\n * coordinate pair used in the polybézier.\n */\nfunction c(s) {\n    const ps = [\n        s.p,\n        [s.vals[0], s.vals[1]],\n        [s.vals[2], s.vals[3]],\n        [s.vals[4], s.vals[5]]\n    ];\n    s.prev2ndCubicControlPoint = ps[2];\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n//# sourceMappingURL=c.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/c.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/h.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/h.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ h)\n/* harmony export */ });\n/**\n * @hidden\n * H and h: (from www.w3.org)\n *\n * params: x\n *\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\n * indicates that relative coordinates will follow. Multiple x values can be\n * provided (although usually this doesn't make sense). At the end of the\n * command, the new current point becomes (x, cpy) for the final value of x.\n */\nfunction h(s) {\n    const ps = [\n        s.p,\n        [s.vals[0], s.p[1]]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/h.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/l.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/l.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ l)\n/* harmony export */ });\n/**\n * @hidden\n * L and l: (from www.w3.org)\n *\n * params: x y\n *\n * Draw a line from the current point to the given (x,y) coordinate which\n * becomes the new current point. L (uppercase) indicates that absolute\n * coordinates will follow; l (lowercase) indicates that relative coordinates\n * will follow. A number of coordinates pairs may be specified to draw a\n * polyline. At the end of the command, the new current point is set to the\n * final set of coordinates provided.\n */\nfunction l(s) {\n    const ps = [\n        s.p,\n        s.vals\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n//# sourceMappingURL=l.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/l.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/q.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/q.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   q: () => (/* binding */ q)\n/* harmony export */ });\n/**\n * @hidden\n * Q and q: (from www.w3.org)\n *\n * params: x1 y1 x y\n *\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\n * as the control point. Q (uppercase) indicates that absolute coordinates will\n * follow; q (lowercase) indicates that relative coordinates will follow.\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\n * end of the command, the new current point becomes the final (x,y) coordinate\n * pair used in the polybézier.\n */\nfunction q(s) {\n    const QP1 = [s.vals[0], s.vals[1]];\n    const QP2 = [s.vals[2], s.vals[3]];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = QP1;\n    const ps = [s.p, QP1, QP2];\n    return ps;\n}\n\n//# sourceMappingURL=q.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/q.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/s.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/s.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   s: () => (/* binding */ s)\n/* harmony export */ });\n/**\n * @hidden\n * S and s: (from www.w3.org)\n *\n * params: x2 y2 x y\n *\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\n * point is assumed to be the reflection of the second control point on the\n * previous command relative to the current point. (If there is no previous\n * command or if the previous command was not an C, c, S or s, assume the first\n * control point is coincident with the current point.) (x2,y2) is the second\n * control point (i.e., the control point at the end of the curve). S\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\n * indicates that relative coordinates will follow. Multiple sets of coordinates\n * may be specified to draw a polybézier. At the end of the command, the new\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\n */\nfunction s(s) {\n    const p = s.prev2ndCubicControlPoint\n        ? [(s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0],\n            (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1]]\n        : s.p;\n    const ps = [\n        s.p,\n        p,\n        [s.vals[0], s.vals[1]],\n        [s.vals[2], s.vals[3]]\n    ];\n    s.prev2ndCubicControlPoint = ps[2];\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n//# sourceMappingURL=s.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/s.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/t.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/t.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   t: () => (/* binding */ t)\n/* harmony export */ });\n/**\n * @hidden\n * T and t: (from www.w3.org)\n *\n * params: x y\n *\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\n * point is assumed to be the reflection of the control point on the previous\n * command relative to the current point. (If there is no previous command or if\n * the previous command was not a Q, q, T or t, assume the control point is\n * coincident with the current point.) T (uppercase) indicates that absolute\n * coordinates will follow; t (lowercase) indicates that relative coordinates\n * will follow. At the end of the command, the new current point becomes the\n * final (x,y) coordinate pair used in the polybézier.\n */\nfunction t(s) {\n    const p = s.prev2ndQuadraticControlPoint\n        ? [(s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0],\n            (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1]]\n        : s.p;\n    const QP1 = p;\n    const QP2 = [s.vals[0], s.vals[1]];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = QP1;\n    return [s.p, QP1, QP2];\n}\n\n//# sourceMappingURL=t.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/t.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/v.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/v.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ v)\n/* harmony export */ });\n/**\n * @hidden\n * V and v: (from www.w3.org)\n *\n * params: y\n *\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\n * indicates that relative coordinates will follow. Multiple y values can be\n * provided (although usually this doesn't make sense). At the end of the\n * command, the new current point becomes (cpx, y) for the final value of y.\n */\nfunction v(s) {\n    const ps = [\n        s.p,\n        [s.p[0], s.vals[0]]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n//# sourceMappingURL=v.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/v.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/z.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/z.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\n/**\n * @hidden\n * Z and z: (from www.w3.org)\n *\n * params: (none)\n *\n * Close the current subpath by drawing a straight line from the current point\n * to current subpath's initial point. Since the Z and z commands take no\n * parameters, they have an identical effect.\n */\nfunction z(s) {\n    const ps = [\n        s.p,\n        s.initialPoint\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n//# sourceMappingURL=z.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-segment/z.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-state.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-state.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PathState: () => (/* binding */ PathState)\n/* harmony export */ });\n/** @hidden */\nclass PathState {\n    constructor() {\n        this.initialPoint = undefined;\n        this.vals = undefined;\n        // Used in conjunction with \"S\", \"s\"\n        this.prev2ndCubicControlPoint = undefined;\n        // Used in conjunction with \"T\", \"t\"\n        this.prev2ndQuadraticControlPoint = undefined;\n        this.p = [0, 0];\n    }\n}\n\n//# sourceMappingURL=path-state.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/svg/path-state.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areBoxesIntersectingDd: () => (/* binding */ areBoxesIntersectingDd)\n/* harmony export */ });\n/**\n * Returns true if the 2 given axis-aligned rectangular boxes intersect.\n * @param a An axis-aligned rectangular box\n * @param b Another axis-aligned rectangular box\n * @param closed (defaults to false) Interpret boxes as being closed (i.e. they\n * contain their border) or open. If open then if both boxes have zero area\n * then they are both considered close.\n */\nfunction areBoxesIntersectingDd(closed) {\n    return (a, b) => {\n        let [[ax0, ay0], [ax1, ay1]] = a;\n        let [[bx0, by0], [bx1, by1]] = b;\n        // If open then if both boxes have zero area then they are both \n        // considered closed.\n        /*if ((ax0 === ax1 || ay0 === ay1) && (bx0 === bx1 || by0 === by1)) {\n            closed = true;\n        }*/\n        // Swap so smaller coordinate comes first\n        if (ay0[1] > ay1[1] || ay0[1] === ay1[1] && ay0[0] > ay1[0]) {\n            [ay0, ay1] = [ay1, ay0];\n        }\n        if (by0[1] > by1[1] || by0[1] === by1[1] && by0[0] > by1[0]) {\n            [by0, by1] = [by1, by0];\n        }\n        if (ax0[1] > ax1[1] || ax0[1] === ax1[1] && ax0[0] > ax1[0]) {\n            [ax0, ax1] = [ax1, ax0];\n        }\n        if (bx0[1] > bx1[1] || bx0[1] === bx1[1] && bx0[0] > bx1[0]) {\n            [bx0, bx1] = [bx1, bx0];\n        }\n        return closed\n            ? (\n            //ax0 <= bx1 && ax1 >= bx0 && \n            //by0 <= ay1 && by1 >= ay0\n            (ax0[1] < bx1[1] || (ax0[1] === bx1[1] && ax0[0] <= bx1[0])) &&\n                (ax1[1] > bx0[1] || (ax1[1] === bx0[1] && ax1[0] >= bx0[0])) &&\n                (by0[1] < ay1[1] || (by0[1] === ay1[1] && by0[0] <= ay1[0])) &&\n                (by1[1] > ay0[1] || (by1[1] === ay0[1] && by1[0] >= ay0[0])))\n            : (\n            //ax0 < bx1 && ax1 > bx0 && \n            //by0 < ay1 && by1 > ay0\n            (ax0[1] < bx1[1] || (ax0[1] === bx1[1] && ax0[0] < bx1[0])) &&\n                (ax1[1] > bx0[1] || (ax1[1] === bx0[1] && ax1[0] > bx0[0])) &&\n                (by0[1] < ay1[1] || (by0[1] === ay1[1] && by0[0] < ay1[0])) &&\n                (by1[1] > ay0[1] || (by1[1] === ay0[1] && by1[0] > ay0[0])));\n    };\n}\n\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/sweep-line/sweep-line.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/sweep-line/sweep-line.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sweepLine: () => (/* binding */ sweepLine)\n/* harmony export */ });\nconst EVENT_LEFT = -1;\nconst EVENT_RIGHT = +1;\n/**\n * Generalized sweepline algorithm.\n *\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\n *\n * @param items An array of items that are to be compared. Items should\n * typically be geometric objects in 2d space with well-defined left and right\n * endpoints.\n * @param getLeftmostPoint A function that returns the leftmost point of the\n * geometric object of interest.\n * @param getRightmostPoint A function that returns the rightmost point of the\n * geometric object of interest.\n * @param predicate A predicate that takes two geometric objects and returns\n * truthy (of some specific type) if they are of interest or falsey otherwise.\n */\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\n    // Initialize event queue to contain all endpoints.\n    const events = [];\n    for (const item of items) {\n        events.push({\n            type: EVENT_LEFT,\n            item,\n            x: getLeftmost(item)\n        });\n        events.push({\n            type: EVENT_RIGHT,\n            item,\n            x: getRightmost(item)\n        });\n    }\n    events.sort(compare);\n    const activeItems = new Set();\n    /** A list of pairs of items that passed the predicate */\n    const pairedItems = [];\n    for (const event of events) {\n        const item = event.item;\n        if (event.type === EVENT_LEFT) {\n            for (const activeItem of activeItems.values()) {\n                //(window as any).ii++;\n                const result = predicate(item, activeItem);\n                if (result) {\n                    //(window as any).jj++;\n                    //console.log(result)\n                    pairedItems.push({\n                        a: item,\n                        b: activeItem,\n                        u: result\n                    });\n                }\n            }\n            activeItems.add(item);\n        }\n        else if (event.type === EVENT_RIGHT) {\n            activeItems.delete(event.item);\n        }\n    }\n    return pairedItems;\n}\n/**\n * Compare two Events by their x-axis and then by their type.\n * @param a An event\n * @param b Another event\n */\nfunction compare(a, b) {\n    const res = a.x - b.x;\n    if (res !== 0) {\n        return res;\n    }\n    // Alwys put left events before right ones.\n    return a.type;\n}\n\n//# sourceMappingURL=sweep-line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node/sweep-line/sweep-line.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/add-1-ulp.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/add-1-ulp.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add1Ulp: () => (/* binding */ add1Ulp)\n/* harmony export */ });\nconst { EPSILON: eps } = Number;\r\nconst u = eps / 2;\r\nconst es = (eps ** 2) / 2;\r\nconst ups = u + es;\r\n/**\r\n * Add one unit in the last place (ulp) to the given number\r\n *\r\n * * subnormal numbers (and 0) are returned unaltered\r\n * @internal\r\n */\r\nfunction add1Ulp(n) {\r\n    return n > 0 ? n + n * ups : n - n * ups;\r\n}\r\n\r\n//# sourceMappingURL=add-1-ulp.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/add-1-ulp.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/boxes/intersect-boxes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/boxes/intersect-boxes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectBoxes: () => (/* binding */ intersectBoxes)\n/* harmony export */ });\nconst min = Math.min;\r\nconst max = Math.max;\r\n/**\r\n * Returns the intersection of 2 given axis-aligned rectangular boxes (or\r\n * `undefined` if they don't intersect).\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n * * **closed**: interpret boxes as being closed (i.e. they contain their border).\r\n *\r\n * @param a an axis-aligned rectangular box (given by an array of two points,\r\n * e.g. `[[1,2], [3,4]]`)\r\n * @param b another box\r\n *\r\n * @doc mdx\r\n */\r\nfunction intersectBoxes(a, b) {\r\n    let [[ax0, ay0], [ax1, ay1]] = a;\r\n    let [[bx0, by0], [bx1, by1]] = b;\r\n    // Swap so smaller coordinate comes first\r\n    if (ax0 > ax1) {\r\n        [ax0, ax1] = [ax1, ax0];\r\n    }\r\n    if (bx0 > bx1) {\r\n        [bx0, bx1] = [bx1, bx0];\r\n    }\r\n    if (ay0 > ay1) {\r\n        [ay0, ay1] = [ay1, ay0];\r\n    }\r\n    if (by0 > by1) {\r\n        [by0, by1] = [by1, by0];\r\n    }\r\n    if (!(ax0 <= bx1 && ax1 >= bx0 &&\r\n        by0 <= ay1 && by1 >= ay0)) {\r\n        // they don't intersect\r\n        return undefined;\r\n    }\r\n    return [\r\n        [max(ax0, bx0), max(ay0, by0)],\r\n        [min(ax1, bx1), min(ay1, by1)]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=intersect-boxes.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/boxes/intersect-boxes.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"γ\": () => (/* binding */ γ),\n/* harmony export */   \"γγ\": () => (/* binding */ γγ)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\r\nconst uu = u * u;\r\n/** @internal */\r\nfunction γ(n) {\r\n    const nu = n * u;\r\n    return nu / (1 - nu);\r\n}\r\n/** @internal */\r\nfunction γγ(n) {\r\n    const nuu = n * uu;\r\n    return nuu / (1 - nuu);\r\n}\r\n\r\nγ(1); //=> 1.1102230246251568e-16\r\nγγ(3); //=> 3.697785493223493e-32\r\n//# sourceMappingURL=error-analysis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAbsCurvatureExtremaPolys: () => (/* binding */ getAbsCurvatureExtremaPolys)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js\");\n\r\n\r\n\r\n/**\r\n * Returns the polynomials whose zeros are the `t` values of the local\r\n * minima / maxima of the absolute curvature for the given bezier curve.\r\n *\r\n * The polynomials are in the form `p1*p2` where the zeros\r\n * of `p1` are the inflection points and the zeros of `p2` are the other minima /\r\n * maxima.\r\n *\r\n * * **precondition:** must be a `true` cubic bezier (not degenerate to line or\r\n * quadratic)\r\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)\r\n * * **non-exact:** due to floating point roundof during calculation\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction getAbsCurvatureExtremaPolys(ps) {\r\n    // It is a real cubic - use the excellent answer from the description:\r\n    // dd(kappa^2)/dt === (x′′y′ − x′y′′)*((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\r\n    // Inflection points at: (x′′y′ − x′y′′) === 0\r\n    // Max abs curvature at: ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′)) === 0\r\n    const [[dx2, dx1, dx0], [dy2, dy1, dy0]] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps); // max bitlength increase === 5\r\n    const [[ddx1, ddx0], [ddy1, ddy0]] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_2ndDerivative)(ps); // max bitlength increase === 6\r\n    const [dddx, dddy] = (0,_to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_3rdDerivative)(ps); // max bitlength increase === 6\r\n    // ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\r\n    // or \r\n    // x′′′x′x′y′ + x′′′y′y′y′ - y′′′x′x′x′ - y′′′x′y′y′ + \r\n    // 3(x′′y′′x′x′ - x′′x′′x′y′ - x′′y′′y′y′ + y′′y′′x′y′)\r\n    // The above line becomes\r\n    // ((dddx*dy(t) − dx(t)*dddy)(dx(t)dx(t) + dy(t)dy(t)) − 3(dx(t)ddx(t) + dy(t)ddy(t))(ddx(t)dy(t) − dx(t)ddy(t)))\r\n    // or \r\n    // dddx*dxt**2*dyt + dddx*dyt**3 - dddy*dxt**3 - dddy*dxt*dyt**2 - \r\n    // 3*ddxt**2*dxt*dyt + 3*ddxt*ddyt*dxt**2 - 3*ddxt*ddyt*dyt**2 + 3*ddyt**2*dxt*dyt\r\n    // which becomes: (after substituting e.g. dy(t) = dy2*t^2 + dy1*t + dy0, etc. using Python and\r\n    // then expanding and collecting terms)\r\n    const dddx_dy1 = dddx * dy1;\r\n    const dddy_dx1 = dddy * dx1;\r\n    const ddx0_dy0 = ddx0 * dy0;\r\n    const ddx0_dy1 = ddx0 * dy1;\r\n    const ddy1_ddy1 = ddy1 * ddy1;\r\n    const ddx1_dy0 = ddx1 * dy0;\r\n    const ddy0_dx0 = ddy0 * dx0;\r\n    const ddy0_dx1 = ddy0 * dx1;\r\n    const ddy1_dx0 = ddy1 * dx0;\r\n    const dx0_dx1 = dx0 * dx1;\r\n    const dx0_dx2 = dx0 * dx2;\r\n    const dx0_dy2 = dx0 * dy2;\r\n    const dx1_dx1 = dx1 * dx1;\r\n    const dx1_dx2 = dx1 * dx2;\r\n    const dx1_dy1 = dx1 * dy1;\r\n    const dx2_dy0 = dx2 * dy0;\r\n    const dx2_dy2 = dx2 * dy2;\r\n    const dx2_dx2 = dx2 * dx2;\r\n    const dy0_dy1 = dy0 * dy1;\r\n    const dy0_dy2 = dy0 * dy2;\r\n    const dy1_dy1 = dy1 * dy1;\r\n    const dy1_dy2 = dy1 * dy2;\r\n    const dy2_dy2 = dy2 * dy2;\r\n    const ss = dddx * dy0 - dddy * dx0;\r\n    const uu = dddx_dy1 - dddy_dx1;\r\n    const vv = ddx0 * dx0 + ddy0 * dy0;\r\n    const ww = ddx0 * dx1 + ddx1 * dx0 + ddy0 * dy1 + ddy1 * dy0;\r\n    const xx = ddx0_dy0 - ddy0_dx0;\r\n    const yy = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;\r\n    const qq = dx0 * dx0 + dy0 * dy0;\r\n    const rr = dx0_dx1 + dy0_dy1;\r\n    // t6 cancels! see https://math.stackexchange.com/a/1956264/130809\r\n    const z1 = dx1_dy1 + dx2_dy0;\r\n    const z2 = dy0_dy2 + dy1_dy1;\r\n    const z3 = dx0_dx2 + dx1_dx1;\r\n    const z4 = dx1 * dy2 + dx2 * dy1;\r\n    const z5 = dx2_dx2 - dy2_dy2;\r\n    const z6 = dx1_dx2 - dy1_dy2;\r\n    const z7 = dx0_dy2 + dx1_dy1;\r\n    const z8 = dx0_dx1 - dy0_dy1;\r\n    const z9 = dx0 * dy1 + dx1 * dy0;\r\n    const x1 = dy0_dy2 + z2;\r\n    const x2 = dx0_dx2 + z3;\r\n    const x3 = dx0_dy2 + z1;\r\n    const x4 = dx1_dy1 + z1;\r\n    const x5 = x2 - x1;\r\n    const x6 = z1 + dx2_dy0;\r\n    const x7 = z7 + dx2_dy0;\r\n    const x8 = 2 * ddy0_dx1 + ddy1_dx0;\r\n    const t5 = dx2_dx2 * (dddx_dy1 - 3 * dddy_dx1) +\r\n        dy2_dy2 * (3 * dddx_dy1 - dddy_dx1) +\r\n        2 * ((dx2_dy2) * ((dddx * dx1 - dddy * dy1) + 3 * (ddy0 * ddy1 - ddx0 * ddx1)) + 3 * ddx1 * ddy1 * z6) +\r\n        3 * (z4 * (ddy1_ddy1 - ddx1 * ddx1) + z5 * (ddx0 * ddy1 + ddy0 * ddx1));\r\n    const t4 = dddx * (dy2 * (x2 + 3 * z2) + dx2 * x4) -\r\n        dddy * (dx0 * (3 * dx2_dx2 + dy2_dy2) + dx1 * (3 * dx1_dx2 + 2 * dy1_dy2) + dx2 * x1) +\r\n        3 * (ddx0 * ((ddy0 * z5 - ddx0 * dx2_dy2) + 2 * (ddy1 * z6 - ddx1 * z4)) +\r\n            ddx1 * (2 * ddy0 * z6 + ddy1 * (2 * (dx0_dx2 - dy0_dy2) + (dx1_dx1 - dy1_dy1)) - ddx1 * x7) +\r\n            ddy0 * (ddy0 * dx2_dy2 + 2 * ddy1 * z4) +\r\n            ddy1_ddy1 * x3);\r\n    const t3 = dddx * (2 * dx0 * z4 + dx1 * x6 + dy1 * (4 * dy0_dy2 + x1)) -\r\n        dddy * (2 * dx0 * (3 * dx1_dx2 + dy1_dy2) + dx1 * (dx1_dx1 + 2 * dy0_dy2) + dy1 * x6) +\r\n        3 * (ddx0 * (2 * (ddy0 * z6 - ddx1 * x7) + ddy1 * x5 - ddx0 * z4) +\r\n            ddx1 * (2 * ddy1 * z8 - ddx1 * z9) +\r\n            ddy0 * (ddy0 * z4 + 2 * ddy1 * x3 + ddx1 * x5) +\r\n            ddy1_ddy1 * z9);\r\n    const t2 = dddx * (dx0 * (dx0_dy2 + 2 * z1) + dy0 * (dx1_dx1 + 3 * z2)) -\r\n        dddy * (dx0 * (3 * z3 + x1) + dy0 * x4) +\r\n        3 * (ddx0 * (ddy0 * x5 - ddx0 * x3 + 2 * (ddy1 * z8 - ddx1 * z9)) +\r\n            ddx1 * (dx0 * (x8 - ddx1 * dy0) - dy0 * (2 * ddy0 * dy1 + ddy1 * dy0)) +\r\n            ddy0 * (ddy0 * z1 + dx0 * (2 * ddy1 * dy1 + ddy0 * dy2)) +\r\n            ddy1 * dy0 * x8);\r\n    const t1 = (qq * uu + 2 * rr * ss) - 3 * (vv * yy + ww * xx);\r\n    const t0 = ss * qq - 3 * vv * xx;\r\n    const r3 = ddx1 * dy2 - ddy1 * dx2;\r\n    const r2 = ddx0 * dy2 + ddx1 * dy1 - ddy0 * dx2 - ddy1 * dx1;\r\n    const r1 = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;\r\n    const r0 = ddx0_dy0 - ddy0_dx0;\r\n    return {\r\n        inflectionPoly: [r3, r2, r1, r0],\r\n        otherExtremaPoly: [t5, t4, t3, t2, t1, t0]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-abs-curvature-extrema-polys.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurvatureExtrema: () => (/* binding */ getCurvatureExtrema)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/calculus/double/differentiate.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _get_abs_curvature_extrema_polys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-abs-curvature-extrema-polys.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js\");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-collinear.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Returns the parameter `t` values (in `[0,1]`) of local minimum / maximum\r\n * absolute curvature for the given bezier curve.\r\n *\r\n * If there are an infinite number of such `t` values (such as is the case for a\r\n * line), an empty array is returned.\r\n *\r\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)'s excellent\r\n * answer on math.stackexchange\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getCurvatureExtrema(ps) {\r\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\r\n        return { minima: [], maxima: [], inflections: [] };\r\n    }\r\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_1__.isCubicReallyQuad)(ps)) {\r\n        ps = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        const poly = getCurvatureExtremaQuadraticPoly(ps);\r\n        const maxima = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.allRoots)(poly, 0, 1);\r\n        return {\r\n            minima: [],\r\n            maxima,\r\n            inflections: []\r\n        };\r\n    }\r\n    const polys = (0,_get_abs_curvature_extrema_polys_js__WEBPACK_IMPORTED_MODULE_4__.getAbsCurvatureExtremaPolys)(ps);\r\n    const p1 = polys.inflectionPoly;\r\n    const p2 = polys.otherExtremaPoly;\r\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.allRoots)(p2, 0, 1);\r\n    // get second derivative (using product rule) to see if it is a local \r\n    // minimum or maximum, i.e. diff(p1*p2) = p1'*p2 + p1*p2' = dp1*p2 + p1*dp2\r\n    // = p1*dp2 (since dp1*p2 === 0)\r\n    const dp2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_5__.differentiate)(p2);\r\n    const minima = [];\r\n    const maxima = [];\r\n    for (let i = 0; i < ts.length; i++) {\r\n        const t = ts[i];\r\n        const dp2_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.Horner)(dp2, t);\r\n        const p1_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_6__.Horner)(p1, t);\r\n        const secondDerivative = p1_ * dp2_;\r\n        if (secondDerivative >= 0) {\r\n            minima.push(t);\r\n        }\r\n        else {\r\n            maxima.push(t);\r\n        }\r\n    }\r\n    const inflections = (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.allRoots)(p1, 0, 1);\r\n    return { minima, maxima, inflections };\r\n}\r\n/**\r\n * Returns the polynomial whose zero is the t value of maximum absolute\r\n * curvature for the given *quadratic* bezier curve.\r\n *\r\n * * **precondition:** the given parabola is not degenerate to a line\r\n * * **non-exact:** there is floating point roundof during calculation\r\n * * see e.g. [math.stackexchange](https://math.stackexchange.com/a/2971112)'s\r\n * answer by [KeithWM](https://math.stackexchange.com/a/2971112/130809)\r\n *\r\n * @param ps an order 2 bezier curve given as an array of control points,\r\n * e.g. `[[0,0],[1,1],[2,1]]`\r\n *\r\n * @internal\r\n */\r\nfunction getCurvatureExtremaQuadraticPoly(ps) {\r\n    // Find the point of max curvature (of the parabola)\r\n    // calculate t*\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const x10 = x1 - x0;\r\n    const x21 = x2 - x1;\r\n    const wx = x21 - x10;\r\n    const y10 = y1 - y0;\r\n    const y21 = y2 - y1;\r\n    const wy = y21 - y10;\r\n    const n = x0 * (wx - x1) - x1 * (x21 - x1) +\r\n        y0 * (wy - y1) - y1 * (y21 - y1);\r\n    const d = wx * wx + wy * wy;\r\n    return [d, -n];\r\n}\r\n\r\n//# sourceMappingURL=get-curvature-extrema.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingBoxTight: () => (/* binding */ getBoundingBoxTight)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-bounding-box.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\n/* harmony import */ var _length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../length/control-point-lines-length.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Returns a **non-certified**, **rotated**, **tight** bounding box of the given\r\n * bezier curve as four ordered points of a rotated rectangle (with each given\r\n * as `[x,y]`)\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getBoundingBoxTight(ps) {\r\n    const [xS, yS] = ps[0];\r\n    const [xE, yE] = ps[ps.length - 1];\r\n    let sinθ;\r\n    let cosθ;\r\n    // take care of the case the endpoints are close together\r\n    const len = (0,_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(ps);\r\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(ps[0], ps[ps.length - 1]) * 2 ** 8 < len * len) {\r\n        const [xE_, yE_] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, 0.5);\r\n        const hypotenuse = Math.sqrt((xE_ - xS) * (xE_ - xS) + (yE_ - yS) * (yE_ - yS));\r\n        sinθ = (yE_ - yS) / hypotenuse;\r\n        cosθ = (xE_ - xS) / hypotenuse;\r\n    }\r\n    else {\r\n        const hypotenuse = Math.sqrt((xE - xS) * (xE - xS) + (yE - yS) * (yE - yS));\r\n        sinθ = (yE - yS) / hypotenuse;\r\n        cosθ = (xE - xS) / hypotenuse;\r\n    }\r\n    const box = getNormalizedBoundingBox(ps, sinθ, cosθ);\r\n    const [[p0x, p0y], [p1x, p1y]] = box;\r\n    const axisAlignedBox = [\r\n        box[0], [p1x, p0y],\r\n        box[1], [p0x, p1y]\r\n    ];\r\n    const rotate_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.rotate)(sinθ, cosθ);\r\n    return axisAlignedBox.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.translate)(ps[0], rotate_(p)));\r\n}\r\n/**\r\n * Helper function. Returns the bounding box of the normalized (i.e. first point\r\n * moved to origin and rotated so that last point lies on x-axis) given cubic\r\n * bezier.\r\n *\r\n * * returns the bounding box in the form [[minX, minY], [maxX,maxY]\r\n *\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param sinθ - Sine of angle made by line from first bezier point to\r\n * last with x-axis.\r\n * @param cosθ - Cosine of angle made by line from first bezier point\r\n * to last with x-axis.\r\n *\r\n * @internal\r\n */\r\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\r\n    const vectorToOrigin = ps[0].map(x => -x);\r\n    const f = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.translate)(vectorToOrigin);\r\n    const boundingPs = ps.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.rotate)(-sinθ, cosθ, f(p)));\r\n    return (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__.getBoundingBox)(boundingPs);\r\n}\r\n\r\n//# sourceMappingURL=get-bounding-box-tight.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingBox: () => (/* binding */ getBoundingBox)\n/* harmony export */ });\n/* harmony import */ var _get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-x-bounds-tight.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js\");\n/* harmony import */ var _get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-y-bounds-tight.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js\");\n\r\n\r\n/**\r\n * Returns a tight axis-aligned bounding box of the given bezier curve.\r\n *\r\n * * **certified**: the box is guaranteed to engulf the given bezier curve.\r\n *\r\n * * returns the box in the form `[[minX, minY], [maxX, maxY]`\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getBoundingBox(ps) {\r\n    const xBounds = (0,_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_0__.getXBoundsTight)(ps);\r\n    const yBounds = (0,_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_1__.getYBoundsTight)(ps);\r\n    return [\r\n        [xBounds.minX.box[0][0], yBounds.minY.box[0][1]],\r\n        [xBounds.maxX.box[1][0], yBounds.maxY.box[1][1]]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-bounding-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingHull: () => (/* binding */ getBoundingHull)\n/* harmony export */ });\n/* harmony import */ var flo_graham_scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-graham-scan */ \"./node_modules/flo-graham-scan/node/index.js\");\n\r\n/**\r\n * Finds the convex hull of the given set of 2d points using the\r\n * Graham Scan algorithm and returns the hull as an array of points.\r\n *\r\n * * see https://en.wikipedia.org/wiki/Graham_scan\r\n *\r\n * **exact**: this algorithm is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n *\r\n * @param ps a set of points, e.g. a bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param includeAllBoundaryPoints set this to `true` to if all boundary points\r\n * should be returned, even redundant ones; defaults to `false`\r\n *\r\n * @dox mdx\r\n */\r\nconst getBoundingHull = flo_graham_scan__WEBPACK_IMPORTED_MODULE_0__.grahamScan;\r\n\r\n//# sourceMappingURL=get-bounding-hull.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBounds: () => (/* binding */ getBounds)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/all-roots.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n\r\n\r\n\r\n/**\r\n * Returns an axis-aligned bounding box together with the `t` values where the\r\n * bounds on the bezier are reached.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getBounds(ps) {\r\n    // Roots of derivative\r\n    const dxy = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    const rootsX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRoots)(dxy[0], 0, 1);\r\n    const rootsY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRoots)(dxy[1], 0, 1);\r\n    // Endpoints\r\n    rootsX.push(0, 1);\r\n    rootsY.push(0, 1);\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    let tMinX;\r\n    let tMaxX;\r\n    let tMinY;\r\n    let tMaxY;\r\n    // Test points\r\n    for (let i = 0; i < rootsX.length; i++) {\r\n        const t = rootsX[i];\r\n        const [x,] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\r\n        if (x < minX) {\r\n            minX = x;\r\n            tMinX = t;\r\n        }\r\n        if (x > maxX) {\r\n            maxX = x;\r\n            tMaxX = t;\r\n        }\r\n    }\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        const t = rootsY[i];\r\n        const [, y] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\r\n        if (y < minY) {\r\n            minY = y;\r\n            tMinY = t;\r\n        }\r\n        if (y > maxY) {\r\n            maxY = y;\r\n            tMaxY = t;\r\n        }\r\n    }\r\n    // `tMinX`, ... is guaranteed defined below - TS was (understandably) \r\n    // unable to follow the logic.\r\n    const ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\r\n    const box = [[minX, minY], [maxX, maxY]];\r\n    return { ts, box };\r\n}\r\n\r\n//# sourceMappingURL=get-bounds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIntervalBoxDd: () => (/* binding */ getIntervalBoxDd)\n/* harmony export */ });\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/eval-de-casteljau-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n\r\n\r\n\r\nconst ddDiffDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst ddDivDdWithError = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivDdWithError;\r\nconst ddAddDouble = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\r\nconst ddMultDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst ddAddDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst ddMultBy2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst ddMin = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMin;\r\nconst ddMax = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMax;\r\nconst u = Number.EPSILON / 2;\r\nconst uu = u * u;\r\nconst abs = Math.abs;\r\nconst qdq = ddDiffDd;\r\nconst qOne = [0, 1];\r\nconst qad = ddAddDouble;\r\nconst qaq = ddAddDd;\r\nconst qmq = ddMultDd;\r\nconst qmd = ddMultDouble2;\r\nconst qm2 = ddMultBy2;\r\nconst qDivQuadWithError = ddDivDdWithError;\r\nconst qMin = ddMin;\r\nconst qMax = ddMax;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire\r\n * given bezier curve from `t1` to `t2`. The returned box is given as an array\r\n * of points in double-double precision, e.g. `[[[0,1],[0,1]], [[0,2],[0,2]]]`.\r\n *\r\n * * **precondition**: (to satisfy guarantee) t1 < t2\r\n * * **precondition**: (to satisfy guarantee) t1,t2 >= 0 && t1,t2 <= 1\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ts [first, second] parameter values, given in double-double\r\n * precision, e.g. [[0,0.11], [0,0.12]]. (Use [[getIntervalBox]] instead for\r\n * double precision)\r\n *\r\n * @doc mdx\r\n */\r\nfunction getIntervalBoxDd(ps, ts) {\r\n    if (ts[0][0] !== ts[1][0] || ts[0][1] !== ts[1][1]) {\r\n        if (ps.length === 4) {\r\n            return getIntervalBox3Dd(ps, ts);\r\n        }\r\n        if (ps.length === 3) {\r\n            return getIntervalBox2Dd(ps, ts);\r\n        }\r\n        return getIntervalBox1Dd(ps, ts);\r\n    }\r\n    else { // ts[0] === ts[1]\r\n        return getIntervalBoxAtTDd(ps, ts[0]);\r\n    }\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox3Dd([[x0, y0], [x1, y1], [x2, y2], [x3, y3]], [t1, t2]) {\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const tDel = qdq(t2, t1);\r\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\r\n    const oMt1 = qdq(qOne, t1);\r\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    const s1 = qdq(qOne, t1); // <1>s1\r\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\r\n    const tt1 = qmq(t1, t1); // <2>tt1  \r\n    const ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\r\n    const ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\r\n    const ttt1 = qmq(tt1, t1); // <4>(<2>tt1<0>t1)\r\n    const tts1 = qmq(tt1, s1); // <5>(<2>tt1<1>s1)\r\n    const tss1 = qmq(ss1, t1); // <6>(<4>ss1<0>t1)\r\n    const sss1 = qmq(ss1, s1); // <7>(<4>ss1<1>s1)\r\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    const tt2 = qmq(t2, t2); // <2>tt2\r\n    const ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\r\n    const ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\r\n    const ttt2 = qmq(tt2, t2); // <4>(<1>tt2<0>t2)\r\n    const tts2 = qmq(tt2, s2); // <5>(<1>tt2<1>s2)\r\n    const tss2 = qmq(ss2, t2); // <6>(<3>ss2<0>t2)\r\n    const sss2 = qmq(ss2, s2); // <7>(<3>ss2<1>s2)\r\n    const _t1 = abs(t1[1]);\r\n    const _s1 = abs(s1[1]);\r\n    const _tt1 = abs(tt1[1]);\r\n    const _ts1 = abs(ts1[1]);\r\n    const _ss1 = abs(ss1[1]);\r\n    const _ttt1 = abs(ttt1[1]);\r\n    const _tts1 = abs(tts1[1]);\r\n    const _tss1 = abs(tss1[1]);\r\n    const _sss1 = abs(sss1[1]);\r\n    const _t2 = abs(t2[1]);\r\n    const _s2 = abs(s2[1]);\r\n    const _tt2 = abs(tt2[1]);\r\n    const _ts2 = abs(ts2[1]);\r\n    const _ss2 = abs(ss2[1]);\r\n    const _ttt2 = abs(ttt2[1]);\r\n    const _tts2 = abs(tts2[1]);\r\n    const _tss2 = abs(tss2[1]);\r\n    const _sss2 = abs(sss2[1]);\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    let _x3 = abs(x3);\r\n    let _y3 = abs(y3);\r\n    //---- x - calculation\r\n    const q8 = qaq(qmd(x3, t1), qmd(x2, s1));\r\n    const q7 = qaq(qaq(qmd(x3, tt1), qmd(2 * x2, ts1)), qmd(x1, ss1));\r\n    const qx0 = qaq(qaq(qmd(x3, ttt1), qmd(x0, sss1)), qmd(3, (qaq(qmd(x2, tts1), qmd(x1, tss1)))));\r\n    const qx1 = qaq(qmq(q7, t2), qmq(qx0, s2));\r\n    const qx2 = qaq(qaq(qmq(q8, tt2), qmq(qx0, ss2)), qmq(qm2(q7), ts2));\r\n    const qx3 = qaq(qaq(qmd(x3, ttt2), qmq(qx0, sss2)), qmd(3, qaq(qmq(q8, tts2), qmq(q7, tss2))));\r\n    const _qx0 = abs(qx0[1]);\r\n    //---- error / abs value calculation\r\n    const _q8 = _x3 * _t1 + _x2 * _s1; // <= <3>\r\n    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))\r\n    const _q7 = _x3 * _tt1 + 2 * _x2 * _ts1 + _x1 * _ss1; // <= <6> \r\n    // q7: <6>(<5>(<3>(x3*<2>tt1) + <4>(2*x2*<3>ts1)) + <5>(x1*<4>ss1));\r\n    _x0 = (_x3 * _ttt1 + _x0 * _sss1) + 3 * (_x2 * _tts1 + _x1 * _tss1); // <= <11>\r\n    // x0: <11>(<9>(x3*<4>ttt1 + x0*<7>sss1) + <10>(3*<9>(<8>(<6>(x2*<5>tts1) + <7>(x1*<6>tss1)))));\r\n    _x1 = _q7 * _t2 + _qx0 * _s2; // <= <15>\r\n    // x1: <15>(<7>(<6>q7*t2) + <14>(<11>x0*<1>s2));\r\n    _x2 = _q8 * _tt2 + _qx0 * _ss2 + 2 * _q7 * _ts2; // <= <20>\r\n    // x2: <20>(<19>(<18>(<3>q8*<2>tt2) + <17>(<11>x0*<4>ss2)) + <11>(2*<6>q7*<3>ts2));\r\n    _x3 = _x3 * _ttt2 + _qx0 * _sss2 + 3 * (_q8 * _tts2 + _q7 * _tss2); // <= <22>\r\n    // x3: <22>(<21>(<5>(x3*<4>ttt2) + <20>(<11>x0*<7>sss2)) + <16>(3*<15>(<10>(<3>q8*<5>tts2) + <14>(<6>q7*<6>tss2)))));\r\n    // max errors: \r\n    _x0 = 11 * uu * _x0;\r\n    _x1 = 15 * uu * _x1;\r\n    _x2 = 20 * uu * _x2;\r\n    _x3 = 22 * uu * _x3;\r\n    //---- y - calculation\r\n    const r8 = qaq(qmd(y3, t1), qmd(y2, s1));\r\n    const r7 = qaq(qaq(qmd(y3, tt1), qmd(2 * y2, ts1)), qmd(y1, ss1));\r\n    const qy0 = qaq(qaq(qmd(y3, ttt1), qmd(y0, sss1)), qmd(3, (qaq(qmd(y2, tts1), qmd(y1, tss1)))));\r\n    const qy1 = qaq(qmq(r7, t2), qmq(qy0, s2));\r\n    const qy2 = qaq(qaq(qmq(r8, tt2), qmq(qy0, ss2)), qmq(qm2(r7), ts2));\r\n    const qy3 = qaq(qaq(qmd(y3, ttt2), qmq(qy0, sss2)), qmd(3, qaq(qmq(r8, tts2), qmq(r7, tss2))));\r\n    const _qy0 = abs(qy0[1]);\r\n    //---- error / abs value calculation\r\n    const _r8 = _y3 * _t1 + _y2 * _s1; // <= <3>\r\n    const _r7 = _y3 * _tt1 + 2 * _y2 * _ts1 + _y1 * _ss1; // <= <6> \r\n    _y0 = (_y3 * _ttt1 + _y0 * _sss1) + 3 * (_y2 * _tts1 + _y1 * _tss1); // <= <11>\r\n    _y1 = _r7 * _t2 + _qy0 * _s2; // <= <15>\r\n    _y2 = _r8 * _tt2 + _qy0 * _ss2 + 2 * _r7 * _ts2; // <= <20>\r\n    _y3 = _y3 * _ttt2 + _qy0 * _sss2 + 3 * (_r8 * _tts2 + _r7 * _tss2); // <= <22>\r\n    // max errors: \r\n    _y0 = 11 * uu * _y0;\r\n    _y1 = 15 * uu * _y1;\r\n    _y2 = 20 * uu * _y2;\r\n    _y3 = 22 * uu * _y3;\r\n    const minX = qMin(qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qMin(qad(qx2, -_x2), qad(qx3, -_x3)));\r\n    const maxX = qMax(qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qMax(qad(qx2, +_x2), qad(qx3, +_x3)));\r\n    const minY = qMin(qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qMin(qad(qy2, -_y2), qad(qy3, -_y3)));\r\n    const maxY = qMax(qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qMax(qad(qy2, +_y2), qad(qy3, +_y3)));\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox2Dd([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const tDel = qdq(t2, t1);\r\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\r\n    const oMt1 = qdq(qOne, t1);\r\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    //const s1 = (1 - t1);  // <= exact by precondition - not anymore\r\n    const s1 = qdq(qOne, t1); // <1>s1\r\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\r\n    const tt1 = qmq(t1, t1); // <2>tt1  \r\n    const ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\r\n    const ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\r\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    const tt2 = qmq(t2, t2); // <2>tt2\r\n    const ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\r\n    const ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\r\n    const _t1 = abs(t1[1]);\r\n    const _s1 = abs(s1[1]);\r\n    const _tt1 = abs(tt1[1]);\r\n    const _ts1 = abs(ts1[1]);\r\n    const _ss1 = abs(ss1[1]);\r\n    const _t2 = abs(t2[1]);\r\n    const _s2 = abs(s2[1]);\r\n    const _tt2 = abs(tt2[1]);\r\n    const _ts2 = abs(ts2[1]);\r\n    const _ss2 = abs(ss2[1]);\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    //---- x - calculation\r\n    const q1 = qaq(qaq(qmd(x2, tt1), qmd(2 * x1, ts1)), qmd(x0, ss1));\r\n    const q2 = qaq(qmd(x2, t1), qmd(x1, s1));\r\n    const qx0 = q1;\r\n    const qx1 = qaq(qmq(t2, q2), qmq(s2, q1));\r\n    const qx2 = qaq(qaq(qmd(x2, tt2), qmq(qm2(ts2), q2)), qmq(ss2, q1));\r\n    const _q1 = _x2 * _tt1 + 2 * _x1 * _ts1 + _x0 * _ss1; // <= <7>\r\n    // q1: <7>(<6>(<5>(x2*<2>tt1) + <4>(2*x1*<3>ts1)) + <5>(x0*<4>ss1));\r\n    const _q2 = _x2 * _t1 + _x1 * _s1; // <= <3>\r\n    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));\r\n    _x0 = _q1; // <= <7>\r\n    // x0: <7>q1;\r\n    _x1 = _t2 * _q2 + _s2 * _q1; // <= <11>\r\n    // x1: <11>(<5>(t2*<3>q2) + <10>(<1>s2*<7>q1));\r\n    _x2 = (_tt2 * x2 + 2 * _ts2 * _q2) + _ss2 * _q1; // <= <14>\r\n    // x2: <14>(<9>(<3>(<2>tt2*x2) + <8>(2*<3>ts2*<3>q2)) + <13>(<4>ss2*<7>q1));\r\n    // max errors: \r\n    _x0 = 7 * uu * _x0;\r\n    _x1 = 11 * uu * _x1;\r\n    _x2 = 14 * uu * _x2;\r\n    //---- y - calculation\r\n    const r1 = qaq(qaq(qmd(y2, tt1), qmd(2 * y1, ts1)), qmd(y0, ss1));\r\n    const r2 = qaq(qmd(y2, t1), qmd(y1, s1));\r\n    const qy0 = r1;\r\n    const qy1 = qaq(qmq(t2, r2), qmq(s2, r1));\r\n    const qy2 = qaq(qaq(qmd(y2, tt2), qmq(qm2(ts2), r2)), qmq(ss2, r1));\r\n    const _r1 = _y2 * _tt1 + 2 * _y1 * _ts1 + _y0 * _ss1; // <= <7>\r\n    // r1: <7>(<6>(<5>(y2*<2>tt1) + <4>(2*y1*<3>ts1)) + <5>(y0*<4>ss1));\r\n    const _r2 = _y2 * _t1 + _y1 * _s1; // <= <3>\r\n    // r2: <3>(<1>(y2*t1) + <2>(y1*<1>s1));\r\n    _y0 = _r1; // <= <7>\r\n    // y0: <7>r1;\r\n    _y1 = _t2 * _r2 + _s2 * _r1; // <= <11>\r\n    // y1: <11>(<5>(t2*<3>r2) + <10>(<1>s2*<7>r1));\r\n    _y2 = (_tt2 * y2 + 2 * _ts2 * _r2) + _ss2 * _r1; // <= <14>\r\n    // y2: <14>(<9>(<3>(<2>tt2*y2) + <8>(2*<3>ts2*<3>r2)) + <13>(<4>ss2*<7>r1));\r\n    // max errors: \r\n    _y0 = 7 * uu * _y0;\r\n    _y1 = 11 * uu * _y1;\r\n    _y2 = 14 * uu * _y2;\r\n    const minX = qMin(qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qad(qx2, -_x2));\r\n    const maxX = qMax(qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qad(qx2, +_x2));\r\n    const minY = qMin(qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qad(qy2, -_y2));\r\n    const maxY = qMax(qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qad(qy2, +_y2));\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox1Dd([[x0, y0], [x1, y1]], [t1, t2]) {\r\n    // Implementation for lines kept for symmetry - there are obviously much\r\n    // simpler ways to calculate the required box in the case of a line.\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const tDel = qdq(t2, t1);\r\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\r\n    const oMt1 = qdq(qOne, t1);\r\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    const s1 = qdq(qOne, t1); // <1>s1\r\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    const _t1 = abs(t1[1]);\r\n    const _s1 = abs(s1[1]);\r\n    const _t2 = abs(t2[1]);\r\n    const _s2 = abs(s2[1]);\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    //---- x - calculation\r\n    const qx0 = qaq(qmd(x1, t1), qmd(x0, s1));\r\n    const qx1 = qaq(qmd(x1, t2), qmq(qx0, s2));\r\n    _x0 = _x1 * _t1 + _x0 * _s1; // <= <3>\r\n    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));\r\n    _x1 = _x1 * _t2 + _x0 * _s2; // <= <7>\r\n    // x1: <7>(<1>(x1*t2) + <6>(<3>x0*<1>s2));\r\n    // max errors: \r\n    _x0 = 3 * u * _x0;\r\n    _x1 = 7 * u * _x1;\r\n    //---- y - calculation\r\n    const qy0 = qaq(qmd(y1, t1), qmd(y0, s1));\r\n    const qy1 = qaq(qmd(y1, t2), qmq(qy0, s2));\r\n    _y0 = _y1 * _t1 + _y0 * _s1; // <= <3>\r\n    _y1 = _y1 * _t2 + _y0 * _s2; // <= <7>\r\n    // max errors: \r\n    _y0 = 3 * u * _y0;\r\n    _y1 = 7 * u * _y1;\r\n    const minX = qMin(qad(qx0, -_x0), qad(qx1, -_x1));\r\n    const maxX = qMax(qad(qx0, +_x0), qad(qx1, +_x1));\r\n    const minY = qMin(qad(qy0, -_y0), qad(qy1, -_y1));\r\n    const maxY = qMax(qad(qy0, +_y0), qad(qy1, +_y1));\r\n    //return [[x0,y0],[x1,y1]];\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param ps\r\n * @param t\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBoxAtTDd(ps, t) {\r\n    const _pS = ps[0];\r\n    const _pE = ps[ps.length - 1];\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        const pSx = [0, _pS[0]];\r\n        const pSy = [0, _pS[1]];\r\n        return [\r\n            [pSx, pSy],\r\n            [pSx, pSy]\r\n        ];\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        const pEx = [0, _pE[0]];\r\n        const pEy = [0, _pE[1]];\r\n        return [\r\n            [pEx, pEy],\r\n            [pEx, pEy]\r\n        ];\r\n    }\r\n    const p = (0,_local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljauDd)(ps, t);\r\n    let pE;\r\n    if (ps.length === 4) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljauError)(ps, t).map(c_ => 8 * 2 * γγ3 * c_);\r\n    }\r\n    else if (ps.length === 3) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljauError)(ps, t).map(c_ => 5 * 2 * γγ3 * c_);\r\n    }\r\n    else if (ps.length === 2) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljauError)(ps, t).map(c_ => 2 * 2 * γγ3 * c_);\r\n    }\r\n    else if (ps.length === 1) {\r\n        return [p, p];\r\n    }\r\n    return [\r\n        [qad(p[0], -pE[0]), qad(p[1], -pE[1])],\r\n        [qad(p[0], +pE[0]), qad(p[1], +pE[1])]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-interval-box-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIntervalBox: () => (/* binding */ getIntervalBox)\n/* harmony export */ });\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/eval-de-casteljau-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-3-incl-error-bound.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-2-incl-error-bound.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js\");\n/* harmony import */ var _transformation_split_from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-1-incl-error-bound.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γ\"])(1);\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire\r\n * given bezier curve from t1 to t2. The returned box is given as a pair\r\n * of points (the box corners) in double precision, e.g. `[[1,1], [2,2]]`.\r\n *\r\n * * **precondition:** (to satisfy guarantee) t1 < t2\r\n * * **precondition:** (to satisfy guarantee) t1,t2 >= 0 && t1,t2 <= 1\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ts [first, second] parameter values, e.g. [0.11, 0.12]\r\n *\r\n * @doc mdx\r\n */\r\nfunction getIntervalBox(ps, ts) {\r\n    if (ts[0] !== ts[1]) {\r\n        if (ps.length === 4) {\r\n            return getIntervalBox3(ps, ts);\r\n        }\r\n        if (ps.length === 3) {\r\n            return getIntervalBox2(ps, ts);\r\n        }\r\n        return getIntervalBox1(ps, ts);\r\n    }\r\n    // ts[0] === ts[1]\r\n    return getIntervalBoxAtT(ps, ts[0]);\r\n}\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\r\n * bezier curve from t1 to t2.\r\n *\r\n * This is achieved by calculating the error bounds of a new curve calculated\r\n * form t1 to t2 using a splitting algorithm and then taking its extreme\r\n * control points and finally finding a box that engulfs the control points.\r\n * @internal\r\n *\r\n * @param ps\r\n * @param ts\r\n */\r\nfunction getIntervalBox3(ps, ts) {\r\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__.fromTo3InclErrorBound)(ps, ts[0], ts[1]);\r\n    const x0 = psI[0][0];\r\n    const x1 = psI[1][0];\r\n    const x2 = psI[2][0];\r\n    const x3 = psI[3][0];\r\n    const _x0 = 9 * u * _psI[0][0];\r\n    const _x1 = 9 * u * _psI[1][0];\r\n    const _x2 = 9 * u * _psI[2][0];\r\n    const _x3 = 9 * u * _psI[3][0];\r\n    const y0 = psI[0][1];\r\n    const y1 = psI[1][1];\r\n    const y2 = psI[2][1];\r\n    const y3 = psI[3][1];\r\n    const _y0 = 9 * u * _psI[0][1];\r\n    const _y1 = 9 * u * _psI[1][1];\r\n    const _y2 = 9 * u * _psI[2][1];\r\n    const _y3 = 9 * u * _psI[3][1];\r\n    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2, x3 - _x3);\r\n    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2, x3 + _x3);\r\n    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2, y3 - _y3);\r\n    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2, y3 + _y3);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\r\n * bezier curve from t1 to t2.\r\n *\r\n * This is achievied by calculating the error bounds of a new curve calculated\r\n * form t1 to t2 using a splitting algorithm and then taking its extreme\r\n * control points and finally finding a box that engulfs the control points\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox2(ps, ts) {\r\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo2InclErrorBound)(ps, ts[0], ts[1]);\r\n    const x0 = psI[0][0];\r\n    const x1 = psI[1][0];\r\n    const x2 = psI[2][0];\r\n    const _x0 = 5 * u * _psI[0][0];\r\n    const _x1 = 5 * u * _psI[1][0];\r\n    const _x2 = 5 * u * _psI[2][0];\r\n    const y0 = psI[0][1];\r\n    const y1 = psI[1][1];\r\n    const y2 = psI[2][1];\r\n    const _y0 = 5 * u * _psI[0][1];\r\n    const _y1 = 5 * u * _psI[1][1];\r\n    const _y2 = 5 * u * _psI[2][1];\r\n    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2);\r\n    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2);\r\n    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2);\r\n    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\r\n * bezier curve from t1 to t2.\r\n *\r\n * This is achievied by calculating the error bounds of a new curve calculated\r\n * form t1 to t2 using a splitting algorithm and then taking its extreme\r\n * control points and finally finding a box that engulfs the control points\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox1(ps, ts) {\r\n    // Implementation for lines kept for symmetry - there are obviously much\r\n    // simpler ways to calculate the required box in the case of a line.\r\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__.fromTo1InclErrorBound)(ps, ts[0], ts[1]);\r\n    const x0 = psI[0][0];\r\n    const x1 = psI[1][0];\r\n    const _x0 = 3 * u * _psI[0][0];\r\n    const _x1 = 3 * u * _psI[1][0];\r\n    const y0 = psI[0][1];\r\n    const y1 = psI[1][1];\r\n    const _y0 = 3 * u * _psI[0][1];\r\n    const _y1 = 3 * u * _psI[1][1];\r\n    const minX = Math.min(x0 - _x0, x1 - _x1);\r\n    const maxX = Math.max(x0 + _x0, x1 + _x1);\r\n    const minY = Math.min(y0 - _y0, y1 - _y1);\r\n    const maxY = Math.max(y0 + _y0, y1 + _y1);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * @param ps\r\n * @param t\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBoxAtT(ps, t) {\r\n    const _pS = ps[0];\r\n    const _pE = ps[ps.length - 1];\r\n    if (t === 0) {\r\n        return [_pS, _pS];\r\n    }\r\n    else if (t === 1) {\r\n        return [_pE, _pE];\r\n    }\r\n    const p = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_4__.evalDeCasteljau)(ps, t);\r\n    let pE;\r\n    if (ps.length === 4) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 8 * γ1 * c_);\r\n    }\r\n    else if (ps.length === 3) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 5 * γ1 * c_);\r\n    }\r\n    else if (ps.length === 2) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 2 * γ1 * c_);\r\n    }\r\n    else if (ps.length === 1) {\r\n        return [p, p];\r\n    }\r\n    return [\r\n        [p[0] - pE[0], p[1] - pE[1]],\r\n        [p[0] + pE[0], p[1] + pE[1]]\r\n    ];\r\n}\r\n\r\n// 416\r\n//# sourceMappingURL=get-interval-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getXBoundsTight: () => (/* binding */ getXBoundsTight)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interval-box/get-interval-box.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n\r\n\r\n\r\n/**\r\n * Returns tight x-coordinate bounds of the given bezier curve.\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve given as an array of control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getXBoundsTight(ps) {\r\n    const pS = ps[0];\r\n    const pE = ps[ps.length - 1];\r\n    let minX;\r\n    let maxX;\r\n    if (pS[0] < pE[0]) {\r\n        minX = { ts: [0, 0], box: [pS, pS] };\r\n        maxX = { ts: [1, 1], box: [pE, pE] };\r\n    }\r\n    else {\r\n        minX = { ts: [1, 1], box: [pE, pE] };\r\n        maxX = { ts: [0, 0], box: [pS, pS] };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { minX, maxX };\r\n    }\r\n    const [dx,] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    const rootsX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertifiedSimplified)(dx, 0, 1);\r\n    // Test points\r\n    for (let i = 0; i < rootsX.length; i++) {\r\n        const r = rootsX[i];\r\n        const ts = [r.tS, r.tE];\r\n        const box = (0,_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, ts);\r\n        if (box[0][0] < minX.box[0][0]) {\r\n            minX = { ts, box };\r\n        }\r\n        if (box[1][0] > maxX.box[0][0]) {\r\n            maxX = { ts, box };\r\n        }\r\n    }\r\n    return { minX, maxX };\r\n}\r\n\r\n//# sourceMappingURL=get-x-bounds-tight.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getYBoundsTight: () => (/* binding */ getYBoundsTight)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interval-box/get-interval-box.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n\r\n\r\n\r\n/**\r\n * Returns tight y-coordinate bounds of the given bezier curve.\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve given as an array of control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getYBoundsTight(ps) {\r\n    const pS = ps[0];\r\n    const pE = ps[ps.length - 1];\r\n    let minY;\r\n    let maxY;\r\n    if (pS[1] < pE[1]) {\r\n        minY = { ts: [0, 0], box: [pS, pS] };\r\n        maxY = { ts: [1, 1], box: [pE, pE] };\r\n    }\r\n    else {\r\n        minY = { ts: [1, 1], box: [pE, pE] };\r\n        maxY = { ts: [0, 0], box: [pS, pS] };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { minY, maxY };\r\n    }\r\n    const [, dy] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    const rootsY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertifiedSimplified)(dy, 0, 1);\r\n    // Test points\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        const r = rootsY[i];\r\n        const ts = [r.tS, r.tE];\r\n        const box = (0,_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, ts);\r\n        if (box[0][1] < minY.box[0][1]) {\r\n            minY = { ts, box };\r\n        }\r\n        if (box[1][1] > maxY.box[0][1]) {\r\n            maxY = { ts, box };\r\n        }\r\n    }\r\n    return { minY, maxY };\r\n}\r\n\r\n//# sourceMappingURL=get-y-bounds-tight.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCollinear: () => (/* binding */ isCollinear),\n/* harmony export */   isHorizontal: () => (/* binding */ isHorizontal),\n/* harmony export */   isVertical: () => (/* binding */ isVertical)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst { orient2d } = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.operators;\r\n/**\r\n * Returns `true` if the given bezier curve has all control points collinear,\r\n * `false` otherwise.\r\n *\r\n * * if you need to know whether a given bezier curve can be converted to an\r\n * order 1 bezier curve (a line) such that the same `(x,y)` point is returned\r\n * for the same `t` value then use e.g. [[isQuadReallyLine]] instead.\r\n *\r\n * * **exact** not susceptible to floating point round-off\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isCollinear(ps) {\r\n    if (ps.length === 4) {\r\n        // Cubic bezier\r\n        return (orient2d(ps[0], ps[1], ps[2]) === 0 &&\r\n            orient2d(ps[1], ps[2], ps[3]) === 0 &&\r\n            // The below check is necessary for if ps[1] === ps[2]\r\n            orient2d(ps[0], ps[2], ps[3]) === 0);\r\n    }\r\n    if (ps.length === 3) {\r\n        // Quadratic bezier\r\n        return orient2d(ps[0], ps[1], ps[2]) === 0;\r\n    }\r\n    if (ps.length <= 2) {\r\n        // Line (or point)\r\n        return true;\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n/**\r\n * Returns `true` if the given bezier curve has all control points the\r\n * same `y` value (possibly self-overlapping), `false` otherwise.\r\n *\r\n * @param ps An order 0, 1, 2 or 3 bezier curve.\r\n *\r\n * @doc\r\n */\r\nfunction isHorizontal(ps) {\r\n    const y = ps[0][1];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][1] !== y) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns `true` if the given bezier curve has all control points the\r\n * same `x` value (possibly self-overlapping), `false` otherwise.\r\n *\r\n * @param ps An order 0, 1, 2 or 3 bezier curve.\r\n *\r\n * @doc\r\n */\r\nfunction isVertical(ps) {\r\n    const x = ps[0][0];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][0] !== x) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-collinear.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCubicReallyQuad: () => (/* binding */ isCubicReallyQuad)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eDiff;\r\nconst u = Number.EPSILON / 2;\r\nconst abs = Math.abs;\r\n/**\r\n * Returns `true` if the given cubic bezier curve is really a quadratic (or\r\n * lower order) curve in disguise, i.e. it can be represent by a quadratic\r\n * bezier curve, `false` otherwise.\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isCubicReallyQuad(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // The line below is unrolled (uses a toHybridQuadratic condition (points same?))\r\n    //if ((x3 + 3*x1) - (x0 + 3*x2) === 0 && \r\n    //    (y3 + 3*y1) - (y0 + 3*y2) === 0) {\r\n    // Calculate an approximation of the above with error bounds and use it as\r\n    // a fast filter.\r\n    const u1 = 3 * x1;\r\n    const u1_ = abs(3 * x1); // the absolute error in u1\r\n    const u2 = x3 + u1;\r\n    const u2_ = u1_ + abs(u2); // the absolute error in u2\r\n    const v1 = 3 * x2;\r\n    const v1_ = abs(3 * x2); // the absolute error in v1\r\n    const v2 = x0 + v1;\r\n    const v2_ = v1_ + abs(v2); // the absolute error in v2\r\n    const w = u2 - v2;\r\n    const w_ = u2_ + v2_ + abs(w); // the absolute error in w\r\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\r\n    if (abs(w) - u * w_ > 0) {\r\n        // fast filter 1 passed\r\n        return false;\r\n    }\r\n    const q1 = 3 * y1;\r\n    const q1_ = abs(3 * y1); // the absolute error in q1\r\n    const q2 = y3 + q1;\r\n    const q2_ = q1_ + abs(q2); // the absolute error in q2\r\n    const r1 = 3 * y2;\r\n    const r1_ = abs(3 * y2); // the absolute error in r1\r\n    const r2 = y0 + r1;\r\n    const r2_ = r1_ + abs(r2); // the absolute error in r2\r\n    const s = q2 - r2;\r\n    const s_ = q2_ + r2_ + abs(s); // the absolute error in s\r\n    if (abs(s) - u * s_ > 0) {\r\n        // fast filter 2 passed\r\n        return false;\r\n    }\r\n    // unable to filter - go slow and exact\r\n    return (esign(ediff(fes([x3], tp(3, x1)), fes([x0], tp(3, x2)))) === 0 &&\r\n        esign(ediff(fes([y3], tp(3, y1)), fes([y0], tp(3, y2)))) === 0);\r\n}\r\n\r\n//# sourceMappingURL=is-cubic-really-quad.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isQuadReallyLine: () => (/* binding */ isQuadReallyLine)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoSum;\r\nconst { abs } = Math;\r\n/**\r\n * Returns `true` if the given quadratic bezier curve is really a linear curve\r\n * (or a point), i.e. if all control points collinear *and* it can be converted\r\n * to an order 1 bezier curve (a line) such that the\r\n * same `(x,y)` point is returned for the same `t` value, `false` otherwise.\r\n *\r\n * * the required condition is met if: `x0 + x2 = 2*x1` and `y0 + y2 = 2*y1`\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isQuadReallyLine(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    //if (x0 + x2 === 2*x1) && (y0 + y2 === 2*y1)\r\n    // Calculate an approximation of the above with error bounds and use it as\r\n    // a fast filter.\r\n    const q = x0 + x2;\r\n    const _q_ = abs(q); // the absolute error bound in q (after multipliciation by `u`)\r\n    const w = q - 2 * x1;\r\n    const w_ = _q_ + abs(w); // the absolute error bound in w\r\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\r\n    if (abs(w) - w_ > 0) {\r\n        // fast filter passed\r\n        return false;\r\n    }\r\n    const r = y0 + y2;\r\n    const _r_ = abs(r); // the absolute error bound in r (after multipliciation by `u`)\r\n    const z = r - 2 * y1;\r\n    const z_ = _r_ + abs(z); // the absolute error bound in w\r\n    // if the error is smaller than the value\r\n    if (abs(z) - z_ > 0) {\r\n        // fast filter passed\r\n        return false;\r\n    }\r\n    // unable to filter - go slow and exact\r\n    return (esign(ediff(ts(x0, x2), [2 * x1])) === 0 &&\r\n        esign(ediff(ts(y0, y2), [2 * y1])) === 0);\r\n}\r\n\r\n//# sourceMappingURL=is-quad-really-line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isReallyPoint: () => (/* binding */ isReallyPoint)\n/* harmony export */ });\n/**\r\n * Returns `true` if the given bezier curve has all control points coincident,\r\n * `false` otherwise.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction isReallyPoint(ps) {\r\n    const x = ps[0][0];\r\n    const y = ps[0][1];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (x !== ps[i][0] || y !== ps[i][1]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-really-point.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSelfOverlapping: () => (/* binding */ isSelfOverlapping)\n/* harmony export */ });\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-collinear.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n\r\n/**\r\n * Returns `true` if the given bezier has all control points collinear and\r\n * it is self-overlapping, i.e. if it intersects itself at an infinite number\r\n * of points.\r\n *\r\n * * a bezier curve can only intersect itself at an infinite number of\r\n * points if its locus is a 'self-overlapping line'.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isSelfOverlapping(ps) {\r\n    if (!(0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\r\n        return false;\r\n    }\r\n    // Check if control points are non-strict monotone\r\n    const xs = ps.map(p => p[0]);\r\n    const ys = ps.map(p => p[1]);\r\n    return !(isMonotone(xs) && isMonotone(ys));\r\n}\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone increasing.\r\n * @param xs an array of numbers\r\n *\r\n * @internal\r\n */\r\nfunction isMonotoneIncreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] > xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone decreasing.\r\n * @param xs an array of numbers\r\n *\r\n * @internal\r\n */\r\nfunction isMonotoneDecreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] < xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @param xs\r\n *\r\n * @internal\r\n */\r\nfunction isMonotone(xs) {\r\n    return isMonotoneIncreasing(xs) || isMonotoneDecreasing(xs);\r\n}\r\n\r\n//# sourceMappingURL=is-self-overlapping.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   controlPointLinesLength: () => (/* binding */ controlPointLinesLength)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n\r\n/**\r\n * Returns an upper bound for the length of the given bezier curve - this bound\r\n * is not very strict as it uses the sum of the straight-line distances between\r\n * control points as a measure.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction controlPointLinesLength(ps) {\r\n    let totalLength = 0;\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        totalLength += (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(ps[i], ps[i + 1]);\r\n    }\r\n    return totalLength;\r\n}\r\n\r\n//# sourceMappingURL=control-point-lines-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1DdWithRunningError: () => (/* binding */ getImplicitForm1DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a double-double precision implicit form of the given line segment\r\n * and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\r\n * where `u === Number.EPSILON / 2` before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a line segment given as an array of its control points,\r\n * e.g. `[[1,2],[3,4]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm1DdWithRunningError(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis1DdWithRunningError)(ps);\r\n    const vₓ = eno(b1); // exact\r\n    const vᵧ = a1; // exact\r\n    //const v = a1*b0 - a0*b1;\r\n    const a1b0 = qmd(b0, a1);\r\n    const _a1b0_ = abs(a1b0[1]);\r\n    const a0b1 = qmd(a0, b1);\r\n    const _a0b1_ = abs(a0b1[1]);\r\n    const v = qdq(a0b1, a1b0);\r\n    const v_ = _a1b0_ + _a0b1_ + abs(v[1]);\r\n    return {\r\n        coeffs: { vₓ, vᵧ, v },\r\n        errorBound: { v_ } // vₓ_, vᵧ_ === 0\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2DdWithRunningError: () => (/* binding */ getImplicitForm2DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a double-double precision implicit form of the given quadratic\r\n * bezier curve and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\r\n * where `u === Number.EPSILON / 2` before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2DdWithRunningError(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const { coeffs: [[a2, a1, [, a0]], [b2, b1, [, b0]]], errorBound: [[a2_], [b2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2DdWithRunningError)(ps);\r\n    const $a2 = a2[1];\r\n    const $a1 = a1[1];\r\n    const $b2 = b2[1];\r\n    const $b1 = b1[1];\r\n    const _a0 = abs(a0);\r\n    const _a1 = abs($a1);\r\n    const _a2 = abs($a2);\r\n    const _b0 = abs(b0);\r\n    const _b1 = abs($b1);\r\n    const _b2 = abs($b2);\r\n    const a2b1 = qmq(a2, b1);\r\n    const a2b1_ = a2_ * _b1 + 2 * abs($a2 * $b1);\r\n    const a1b2 = qmq(a1, b2);\r\n    const a1b2_ = _a1 * b2_ + 2 * abs($a1 * $b2);\r\n    const a2b0 = qmd(b0, a2);\r\n    const a2b0_ = _b0 * a2_ + abs(b0 * $a2);\r\n    const a0b2 = qmd(a0, b2);\r\n    const a0b2_ = _a0 * b2_ + abs(a0 * $b2);\r\n    const a1b0 = qmd(b0, a1);\r\n    const a1b0_ = abs(b0 * $a1);\r\n    const a0b1 = qmd(a0, b1);\r\n    const a0b1_ = abs(a0 * $b1);\r\n    const a2a2 = qmq(a2, a2);\r\n    const a2a2_ = 2 * (a2_ * _a2 + abs($a2 * $a2));\r\n    const a2b2 = qmq(a2, b2);\r\n    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * abs($a2 * $b2);\r\n    const b2b2 = qmq(b2, b2);\r\n    const b2b2_ = 2 * (b2_ * _b2 + abs($b2 * $b2));\r\n    const $a2b1 = $a2 * $b1;\r\n    const $a1b2 = $a1 * $b2;\r\n    const $a2b0 = $a2 * b0;\r\n    const $a0b2 = a0 * $b2;\r\n    const $a1b0 = $a1 * b0;\r\n    const $a0b1 = a0 * $b1;\r\n    const $q1 = $a2b1 - $a1b2;\r\n    const $q2 = $a2b0 - $a0b2;\r\n    const $q3 = $a1b0 - $a0b1;\r\n    const q1 = qdq(a2b1, a1b2);\r\n    const _q1 = abs($q1);\r\n    const q1_ = a2b1_ + a1b2_ + abs($q1);\r\n    const q2 = qdq(a2b0, a0b2);\r\n    const _q2 = abs($q2);\r\n    const q2_ = a2b0_ + a0b2_ + abs($q2);\r\n    const q3 = qdq(a1b0, a0b1);\r\n    const _q3 = abs($q3);\r\n    const q3_ = a1b0_ + a0b1_ + abs($q3);\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // -------------\r\n    // b2**2 *x**2\r\n    // -b2**2 *x**2\r\n    // -------------\r\n    const vₓₓ = qno(b2b2);\r\n    const vₓₓ_ = b2b2_;\r\n    // -------------\r\n    // -2*a2*b2 *x*y\r\n    // 2*a2*b2 *x*y\r\n    // -------------\r\n    const vₓᵧ = qm2(a2b2);\r\n    const vₓᵧ_ = a2b2_;\r\n    // -------------\r\n    // a2**2 *y**2 \r\n    // -a2**2 *y**2 \r\n    // -------------\r\n    const vᵧᵧ = qno(a2a2);\r\n    const vᵧᵧ_ = a2a2_;\r\n    // -----------------------------------------------\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //const vₓ = b1*q1 - 2*b2*q2;\r\n    // -----------------------------------------------\r\n    const $w1 = $b1 * $q1;\r\n    const w1 = qmq(b1, q1);\r\n    const w1_ = _b1 * q1_ + 2 * abs($w1);\r\n    const $w2 = 2 * $q2 * $b2;\r\n    const w2 = qm2(qmq(b2, q2));\r\n    const w2_ = 2 * (b2_ * _q2 + _b2 * q2_ + 2 * abs($w2));\r\n    const $vₓ = $w1 - $w2;\r\n    const vₓ = qdq(w1, w2);\r\n    const vₓ_ = w1_ + w2_ + abs($vₓ);\r\n    // -----------------------------------------------\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    // -----------------------------------------------\r\n    const $w3 = 2 * $a2 * $q2;\r\n    const w3 = qm2(qmq(a2, q2));\r\n    const w3_ = 2 * (a2_ * _q2 + _a2 * q2_ + 2 * abs($w3));\r\n    const $w4 = $a1 * $q1;\r\n    const w4 = qmq(a1, q1);\r\n    const w4_ = _a1 * q1_ + 2 * abs($w4);\r\n    const $vᵧ = $w3 - $w4;\r\n    const vᵧ = qdq(w3, w4);\r\n    const vᵧ_ = w3_ + w4_ + abs($vᵧ);\r\n    // --------------------------------------------------------------------------------------------------\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    // --------------------------------------------------------------------------------------------------\r\n    const $w5 = $q1 * $q3;\r\n    const w5 = qmq(q1, q3);\r\n    const w5_ = q1_ * _q3 + _q1 * q3_ + 2 * abs($w5);\r\n    const $w6 = $q2 * $q2;\r\n    const w6 = qmq(q2, q2);\r\n    const w6_ = 2 * (q2_ * _q2 + abs($w6));\r\n    const $v = $w5 - $w6;\r\n    const v = qdq(w5, w6);\r\n    const v_ = w5_ + w6_ + abs($v);\r\n    return {\r\n        coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3DdWithRunningError: () => (/* binding */ getImplicitForm3DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\nconst abs = Math.abs;\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \r\nconst qd2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 5*γ² (worst found), 7*γ² (theoretical), we use 6*γ²\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd; // error -> 3*γ²\r\n/**\r\n * Returns a double-double precision implicit form of the given cubic\r\n * bezier curve curve and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\r\n * where `u === Number.EPSILON / 2` before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3DdWithRunningError(ps) {\r\n    // Takes about 15 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    //--------------------------------------------------------------------------\r\n    // `var` -> a variable\r\n    // `$var` -> the double precision approximation to `var`\r\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\r\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\r\n    // `_var_` -> means both absolute value and absolute error bound\r\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\r\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\r\n    // * the returned errors need to be multiplied by 3γ² to get the true error\r\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\r\n    //   due to multiplication by 3*γ² and not 3*u²\r\n    //--------------------------------------------------------------------------\r\n    // examples:\r\n    // ----------------\r\n    // let qmd === ddMultDouble2, etc.\r\n    //\r\n    // ---------------\r\n    // 1. double-double X by double\r\n    // ---------------\r\n    // qmd(a,b);  // both `a` and `b` is error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + |a*b|\r\n    //                           === |a*b|\r\n    //\r\n    // ---------------\r\n    // 2a. double-double +/- double-double\r\n    // ---------------\r\n    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === _a_ + _b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 2b. double-double +/- double-double\r\n    // ---------------\r\n    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 2*_a + 2*_b + |a+b|\r\n    //                           === 2*(_a + _b) + |a+b| OR\r\n    //                           === a_ + b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 3a. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + 2|a*b|\r\n    //                           === 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` not error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` not error-free and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //                           === a_|b| + 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 4a. double-double +/- double\r\n    // ---------------\r\n    // qad(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 0 + 0 + |a+b|\r\n    //                           === |a+b| \r\n    //--------------------------------------------------------------------------\r\n    const { coeffs: [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]], errorBound: [[a3_, a2_, a1_], [b3_, b2_, b1_]] // a0, b0 - error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3DdWithRunningError)(ps);\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const $a1 = a1[1];\r\n    const $a2 = a2[1];\r\n    const $a3 = a3[1];\r\n    const $b1 = b1[1];\r\n    const $b2 = b2[1];\r\n    const $b3 = b3[1];\r\n    const _a0 = abs(a0);\r\n    const _a1 = abs($a1);\r\n    const _a2 = abs($a2);\r\n    const _a3 = abs($a3);\r\n    const _b0 = abs(b0);\r\n    const _b1 = abs($b1);\r\n    const _b2 = abs($b2);\r\n    const _b3 = abs($b3);\r\n    const a3b1 = qmq(a3, b1);\r\n    const $a3b1 = $a3 * $b1;\r\n    const a3b1_ = a3_ * _b1 + _a3 * b1_ + 2 * abs($a3b1);\r\n    const a1b3 = qmq(a1, b3);\r\n    const $a1b3 = $a1 * $b3;\r\n    const a1b3_ = a1_ * _b3 + _a1 * b3_ + 2 * abs($a1b3);\r\n    const a3b2 = qmq(a3, b2);\r\n    const $a3b2 = $a3 * $b2;\r\n    const a3b2_ = a3_ * _b2 + _a3 * b2_ + 2 * abs($a3b2);\r\n    const a2b2 = qmq(a2, b2);\r\n    const $a2b2 = $a2 * $b2;\r\n    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * abs($a2b2);\r\n    const a2b3 = qmq(a2, b3);\r\n    const $a2b3 = $a2 * $b3;\r\n    const a2b3_ = a2_ * _b3 + _a2 * b3_ + 2 * abs($a2b3);\r\n    const a3a3 = qmq(a3, a3);\r\n    const $a3a3 = $a3 * $a3;\r\n    const _a3a3 = abs($a3a3);\r\n    const a3a3_ = a3_ * _a3 + _a3 * a3_ + 2 * abs($a3a3);\r\n    const b2b2 = qmq(b2, b2);\r\n    const $b2b2 = $b2 * $b2;\r\n    const b2b2_ = b2_ * _b2 + _b2 * b2_ + 2 * abs($b2b2);\r\n    const b3b3 = qmq(b3, b3);\r\n    const $b3b3 = $b3 * $b3;\r\n    const _b3b3 = abs($b3b3);\r\n    const b3b3_ = b3_ * _b3 + _b3 * b3_ + 2 * abs($b3b3);\r\n    const a1a3 = qmq(a1, a3);\r\n    const $a1a3 = $a1 * $a3;\r\n    const a1a3_ = a1_ * _a3 + _a1 * a3_ + 2 * abs($a1a3);\r\n    const a2a2 = qmq(a2, a2);\r\n    const $a2a2 = $a2 * $a2;\r\n    const a2a2_ = a2_ * _a2 + _a2 * a2_ + 2 * abs($a2a2);\r\n    const b1b3 = qmq(b1, b3);\r\n    const $b1b3 = $b1 * $b3;\r\n    const b1b3_ = b1_ * _b3 + _b1 * b3_ + 2 * abs($b1b3);\r\n    const b2b3 = qmq(b2, b3);\r\n    const _b2b3 = abs($b2 * $b3); // or equivalently `_b2b3 = _b2*_b3`;\r\n    const b2b3_ = b2_ * _b3 + _b2 * b3_ + 2 * _b2b3;\r\n    const a2a3 = qmq(a2, a3);\r\n    const _a2a3 = abs($a2 * $a3);\r\n    const a2a3_ = a2_ * _a3 + _a2 * a3_ + 2 * _a2a3;\r\n    const a3b3 = qmq(a3, b3);\r\n    const _a3b3 = abs($a3 * $b3);\r\n    const a3b3_ = a3_ * _b3 + _a3 * b3_ + 2 * _a3b3;\r\n    const a3b0 = qmd(b0, a3);\r\n    const $a3b0 = $a3 * b0;\r\n    const a3b0_ = a3_ * _b0 + abs($a3b0);\r\n    const a0b3 = qmd(a0, b3);\r\n    const $a0b3 = a0 * $b3;\r\n    const a0b3_ = _a0 * b3_ + abs($a0b3);\r\n    const a2b0 = qmd(b0, a2);\r\n    const $a2b0 = $a2 * b0;\r\n    const a2b0_ = a2_ * _b0 + abs($a2b0);\r\n    const a0b2 = qmd(a0, b2);\r\n    const $a0b2 = a0 * $b2;\r\n    const a0b2_ = _a0 * b2_ + abs($a0b2);\r\n    const a2b1 = qmq(a2, b1);\r\n    const $a2b1 = $a2 * $b1;\r\n    const a2b1_ = a2_ * _b1 + _a2 * b1_ + 2 * abs($a2b1);\r\n    const a1b2 = qmq(a1, b2);\r\n    const $a1b2 = $a1 * $b2;\r\n    const a1b2_ = a1_ * _b2 + _a1 * b2_ + 2 * abs($a1b2);\r\n    const a1b0 = qmd(b0, a1);\r\n    const $a1b0 = $a1 * b0;\r\n    const a1b0_ = a1_ * _b0 + abs($a1b0);\r\n    const a0b1 = qmd(a0, b1);\r\n    const $a0b1 = a0 * $b1;\r\n    const a0b1_ = _a0 * b1_ + abs($a0b1);\r\n    const q1 = qdq(a3b0, a0b3);\r\n    const q1_ = a3b0_ + a0b3_ + abs($a3b0 - $a0b3);\r\n    const q2 = qdq(a3b1, a1b3);\r\n    const q2_ = a3b1_ + a1b3_ + abs($a3b1 - $a1b3);\r\n    const q3 = qdq(a3b2, a2b3);\r\n    const q3_ = a3b2_ + a2b3_ + abs($a3b2 - $a2b3);\r\n    const q4 = qdq(a2b0, a0b2);\r\n    const q4_ = a2b0_ + a0b2_ + abs($a2b0 - $a0b2);\r\n    const q5 = qdq(a2b1, a1b2);\r\n    const q5_ = a2b1_ + a1b2_ + abs($a2b1 - $a1b2);\r\n    const q6 = qdq(a1b0, a0b1);\r\n    const q6_ = a1b0_ + a0b1_ + abs($a1b0 - $a0b1);\r\n    const _t1 = abs($b1b3 - $b2b2);\r\n    const t1 = qdq(b1b3, b2b2);\r\n    const t1_ = b1b3_ + b2b2_ + _t1;\r\n    const _t2 = abs($a1a3 - $a2a2);\r\n    const t2 = qdq(a1a3, a2a2);\r\n    const t2_ = a1a3_ + a2a2_ + abs($a1a3 - $a2a2);\r\n    const _p1 = abs($a2b3 + $a3b2);\r\n    const p1 = qaq(a2b3, a3b2);\r\n    const p1_ = a2b3_ + a3b2_ + abs($a2b3 + $a3b2);\r\n    const $p2 = $a1b3 + $a3b1;\r\n    const _p2 = abs($p2);\r\n    const p2 = qaq(a1b3, a3b1);\r\n    const p2_ = a1b3_ + a3b1_ + _p2;\r\n    const tq2 = qm2(q2);\r\n    const tq2_ = 2 * q2_;\r\n    const $q1 = $a3b0 - $a0b3;\r\n    const $q2 = $a3b1 - $a1b3;\r\n    const $q3 = $a3b2 - $a2b3;\r\n    const $q4 = $a2b0 - $a0b2;\r\n    const $q5 = $a2b1 - $a1b2;\r\n    const $q6 = $a1b0 - $a0b1;\r\n    const _q1 = abs($q1);\r\n    const _q2 = abs($q2);\r\n    const _q3 = abs($q3);\r\n    const _q4 = abs($q4);\r\n    const _q5 = abs($q5);\r\n    const _q6 = abs($q6);\r\n    const _tq2 = 2 * _q2;\r\n    const q1q1 = qmq(q1, q1);\r\n    const q1q2 = qmq(q1, q2);\r\n    const q1q3 = qmq(q1, q3);\r\n    const q1q5 = qmq(q1, q5);\r\n    const q2q2 = qmq(q2, q2);\r\n    const tq2q4 = qmq(tq2, q4);\r\n    const q3q4 = qmq(q3, q4);\r\n    const q3q5 = qmq(q3, q5);\r\n    const q3q6 = qmq(q3, q6);\r\n    const q1q1_ = q1_ * _q1 + _q1 * q1_ + 2 * abs(q1q1[1]);\r\n    const q1q2_ = q1_ * _q2 + _q1 * q2_ + 2 * abs(q1q2[1]);\r\n    const q1q3_ = q1_ * _q3 + _q1 * q3_ + 2 * abs(q1q3[1]);\r\n    const q1q5_ = q1_ * _q5 + _q1 * q5_ + 2 * abs(q1q5[1]);\r\n    const q2q2_ = q2_ * _q2 + _q2 * q2_ + 2 * abs(q2q2[1]);\r\n    const tq2q4_ = tq2_ * _q4 + _tq2 * q4_ + 2 * abs(tq2q4[1]);\r\n    const q3q4_ = q3_ * _q4 + _q3 * q4_ + 2 * abs(q3q4[1]);\r\n    const q3q5_ = q3_ * _q5 + _q3 * q5_ + 2 * abs(q3q5[1]);\r\n    const q3q6_ = q3_ * _q6 + _q3 * q6_ + 2 * abs(q3q4[1]);\r\n    const vₓₓₓ = qmq(qno(b3), b3b3);\r\n    const vₓₓₓ_ = b3_ * _b3b3 + _b3 * b3b3_ + 2 * abs(vₓₓₓ[1]);\r\n    const _z1 = 3 * _a3;\r\n    const z1 = qmd(3, a3);\r\n    const z1_ = 3 * a3_ + _z1;\r\n    const vₓₓᵧ = qmq(z1, b3b3);\r\n    const vₓₓᵧ_ = z1_ * _b3b3 + _z1 * b3b3_ + 2 * abs(vₓₓᵧ[1]);\r\n    const _z2 = 3 * _b3;\r\n    const z2 = qmd(-3, b3);\r\n    const z2_ = 3 * b3_ + _z2;\r\n    const vₓᵧᵧ = qmq(z2, a3a3);\r\n    const vₓᵧᵧ_ = z2_ * _a3a3 + _z2 * a3a3_ + 2 * abs(vₓᵧᵧ[1]);\r\n    const vᵧᵧᵧ = qmq(a3, a3a3);\r\n    const vᵧᵧᵧ_ = a3_ * _a3a3 + _a3 * a3a3_ + 2 * abs(vᵧᵧᵧ[1]);\r\n    const $z3 = -3 * $q1;\r\n    const _z3 = 3 * _q1;\r\n    const z3 = qmd(-3, q1);\r\n    const z3_ = 3 * q1_ + _z3;\r\n    const u1 = qdq(z3, q5);\r\n    const _u1 = abs($z3 - $q5);\r\n    const u1_ = z3_ + q5_ + _u1;\r\n    //const t1_ = _b1b3 + _b2b2 + _t1;\r\n    //const _t2 = abs(t2);\r\n    //const t2_ = _a1a3 + _a2a2 + abs(t2);\r\n    const w1 = qmq(u1, b3b3);\r\n    const w1_ = u1_ * _b3b3 + _u1 * b3b3_ + 2 * abs(w1[1]);\r\n    const w2 = qmq(q3, t1);\r\n    const w2_ = q3_ * _t1 + _q3 * t1_ + 2 * abs(w2[1]);\r\n    const w3 = qaq(w1, w2);\r\n    const w3_ = w1_ + w2_ + abs(w3[1]);\r\n    const w4 = qmq(tq2, b2b3);\r\n    const w4_ = tq2_ * _b2b3 + _tq2 * b2b3_ + 2 * abs(w4[1]);\r\n    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    const vₓₓ = qaq(w3, w4);\r\n    const vₓₓ_ = w3_ + w4_ + abs(vₓₓ[1]);\r\n    const w5 = qmq(u1, a3a3);\r\n    const w5_ = u1_ * _a3a3 + _u1 * a3a3_ + 2 * abs(w5[1]);\r\n    const w6 = qmq(q3, t2);\r\n    const w6_ = q3_ * _t2 + _q3 * t2_ + 2 * abs(w6[1]);\r\n    const w7 = qaq(w5, w6);\r\n    const w7_ = w5_ + w6_ + abs(w7[1]);\r\n    const w8 = qmq(tq2, a2a3);\r\n    const w8_ = tq2_ * _a2a3 + _tq2 * a2a3_ + 2 * abs(w8[1]);\r\n    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    const vᵧᵧ = qaq(w7, w8);\r\n    const vᵧᵧ_ = w7_ + w8_ + abs(vᵧᵧ[1]);\r\n    const _wa = abs($a2b2 - $p2 / 2);\r\n    const wa = qdq(a2b2, qd2(p2));\r\n    const wa_ = a2b2_ + p2_ / 2 + abs(wa[1]);\r\n    const wb = qmq(u1, a3b3);\r\n    const wb_ = u1_ * _a3b3 + _u1 * a3b3_ + 2 * abs(wb[1]);\r\n    const wc = qmq(q2, p1);\r\n    const wc_ = q2_ * _p1 + _q2 * p1_ + 2 * abs(wc[1]);\r\n    const wd = qaq(wb, wc);\r\n    const wd_ = wb_ + wc_ + abs(wd[1]);\r\n    const wq = qmq(q3, wa);\r\n    const wq_ = q3_ * _wa + _q3 * wa_ + 2 * abs(wq[1]);\r\n    //-------------------------------------------------------\r\n    // const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    //-------------------------------------------------------\r\n    const vₓᵧ = qm2(qdq(wq, wd));\r\n    const vₓᵧ_ = 2 * (wq_ + wd_) + abs(vₓᵧ[1]);\r\n    const wr = qmd(-3, q1q1);\r\n    const wr_ = 3 * q1q1_ + abs(wr[1]);\r\n    const we = qdq(wr, qm2(q1q5));\r\n    const we_ = wr_ + 2 * q1q5_ + abs(we[1]);\r\n    const wf = qaq(tq2q4, q3q6);\r\n    const wf_ = tq2q4_ + q3q6_ + abs(wf[1]);\r\n    //------------------------------------------------\r\n    // const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    //------------------------------------------------\r\n    const s1 = qaq(we, wf);\r\n    const _s1 = abs(s1[1]);\r\n    const s1_ = we_ + wf_ + _s1;\r\n    //-----------------------------\r\n    // const s2 = 2*(q1q2 - q3q4);\r\n    //-----------------------------\r\n    const s2 = qm2(qdq(q1q2, q3q4));\r\n    const _s2 = abs(s2[1]);\r\n    const s2_ = 2 * (q1q2_ + q3q4_) + _s2;\r\n    const wl = qdq(q1q3, q2q2);\r\n    const wl_ = q1q3_ + q2q2_ + abs(wl[1]);\r\n    //-------------------------------\r\n    // const s3 = q1q3 - q2q2 + q3q5;\r\n    //-------------------------------\r\n    const s3 = qaq(wl, q3q5);\r\n    const _s3 = abs(s3[1]);\r\n    const s3_ = wl_ + q3q5_ + _s3;\r\n    const wm = qmq(b3, s1);\r\n    const wm_ = b3_ * _s1 + _b3 * s1_ + 2 * abs(wm[1]);\r\n    const ws = qmq(b2, s2);\r\n    const ws_ = b2_ * _s2 + _b2 * s2_ + 2 * abs(ws[1]);\r\n    const wt = qmq(b1, s3);\r\n    const wt_ = b1_ * _s3 + _b1 * s3_ + 2 * abs(wt[1]);\r\n    const wn = qaq(ws, wt);\r\n    const wn_ = ws_ + wt_ + abs(wn[1]);\r\n    //-------------------------------\r\n    // const vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    //-------------------------------\r\n    const vₓ = qaq(wm, wn);\r\n    const vₓ_ = wm_ + wn_ + abs(vₓ[1]);\r\n    const wo = qmq(a3, s1);\r\n    const wo_ = a3_ * _s1 + _a3 * s1_ + 2 * abs(wo[1]);\r\n    const wu = qmq(a2, s2);\r\n    const wu_ = a2_ * _s2 + _a2 * s2_ + 2 * abs(wu[1]);\r\n    const wv = qmq(a1, s3);\r\n    const wv_ = a1_ * _s3 + _a1 * s3_ + 2 * abs(wv[1]);\r\n    const wp = qaq(wu, wv);\r\n    const wp_ = wu_ + wv_ + abs(wp[1]);\r\n    //-------------------------------------\r\n    // const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    //-------------------------------------\r\n    const vᵧ = qno(qaq(wo, wp));\r\n    const vᵧ_ = wo_ + wp_ + abs(vᵧ[1]);\r\n    // the commented part above is re\r\n    const v3 = qdq(tq2q4, q1q1);\r\n    const v1 = qdq(v3, q1q5);\r\n    const _v1 = abs(v1[1]);\r\n    const v4 = qmq(s3, q6);\r\n    const v5 = qmq(q3q4, q4);\r\n    const v2 = qdq(v4, v5);\r\n    const v2_ = s3_ * abs(q6[1]) + 2 * abs(v4[1]) + q3q4_ * abs(q4[1]) + 2 * abs(v5[1]) + abs(v2[1]);\r\n    const v6 = qmq(q1, v1);\r\n    const v6_ = q1_ * _v1 + _q1 * tq2q4_ + q1q1_ + abs(v3[1]) + q1q5_ + _v1 + 2 * abs(v6[1]);\r\n    // -------------------------------------------------------------------------\r\n    //-------------------------------------------------------\r\n    // const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    //-------------------------------------------------------\r\n    const v = qaq(v6, v2);\r\n    const v_ = v6_ + v2_ + abs(v[1]);\r\n    return {\r\n        coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2: () => (/* binding */ getImplicitForm2)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n\r\n/**\r\n * Returns the implicit form of the given quadratic bezier curve.\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in **double** precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const [[a2, a1, a0], [b2, b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2)(ps);\r\n    const q1 = a2 * b1 - a1 * b2;\r\n    const q2 = a2 * b0 - a0 * b2;\r\n    const vₓₓ = -b2 * b2;\r\n    const vₓᵧ = 2 * a2 * b2;\r\n    const vᵧᵧ = -a2 * a2;\r\n    const vₓ = b1 * q1 - 2 * b2 * q2;\r\n    const vᵧ = 2 * a2 * q2 - a1 * q1;\r\n    const v = q1 * (a1 * b0 - a0 * b1) - q2 * q2;\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3: () => (/* binding */ getImplicitForm3)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js\");\n\r\n/**\r\n * Returns the implicit form of the given cubic bezier curve.\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n * * takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79\r\n *\r\n * @param ps a cubic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3)(ps);\r\n    const a3b1 = a3 * b1;\r\n    const a1b3 = a1 * b3;\r\n    const a3b2 = a3 * b2;\r\n    const a2b3 = a2 * b3;\r\n    const a3a3 = a3 * a3;\r\n    const b3b3 = b3 * b3;\r\n    const q1 = a3 * b0 - a0 * b3;\r\n    const q2 = a3b1 - a1b3;\r\n    const q3 = a3b2 - a2b3;\r\n    const q4 = a2 * b0 - a0 * b2;\r\n    const q5 = a2 * b1 - a1 * b2;\r\n    const q6 = a1 * b0 - a0 * b1;\r\n    const tq2 = 2 * q2;\r\n    const q1q1 = q1 * q1;\r\n    const q1q5 = q1 * q5;\r\n    const tq2q4 = tq2 * q4;\r\n    const q3q4 = q3 * q4;\r\n    const u1 = -3 * q1 - q5;\r\n    const vₓₓₓ = -b3 * b3b3;\r\n    const vₓₓᵧ = 3 * a3 * b3b3;\r\n    const vₓᵧᵧ = -3 * b3 * a3a3;\r\n    const vᵧᵧᵧ = a3 * a3a3;\r\n    const vₓₓ = (u1 * b3b3 + q3 * (b1 * b3 - b2 * b2)) + tq2 * b2 * b3;\r\n    const vᵧᵧ = (u1 * a3a3 + q3 * (a1 * a3 - a2 * a2)) + tq2 * a2 * a3;\r\n    const vₓᵧ = 2 * (q3 * (a2 * b2 - (a1b3 + a3b1) / 2) - (u1 * a3 * b3 + q2 * (a2b3 + a3b2)));\r\n    const s1 = (-3 * q1q1 - 2 * q1q5) + (tq2q4 + q3 * q6);\r\n    const s2 = 2 * (q1 * q2 - q3q4);\r\n    const s3 = q1 * q3 - q2 * q2 + q3 * q5;\r\n    const vₓ = b3 * s1 + (b2 * s2 + b1 * s3);\r\n    const vᵧ = -a3 * s1 - (a2 * s2 + a1 * s3);\r\n    const v = (q1 * ((tq2q4 - q1q1) - q1q5)) + (s3 * q6 - q3q4 * q4);\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm1Exact: () => (/* binding */ getImplicitForm1Exact),\n/* harmony export */   getImplicitForm1ExactPb: () => (/* binding */ getImplicitForm1ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eNegativeOf;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns the *exact* implicit form of the given linear bezier curve (a line\r\n * segment) or `undefined` if the line degenerates to a point.\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm1Exact(ps) {\r\n    return getImplicitForm1ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps));\r\n}\r\n/**\r\n * The power basis version of [[getImplicitForm1Exact]].\r\n *\r\n * @param pspb the power basis representation of a linear bezier curve that\r\n * can be found via [[toPowerBasis1Exact]]\r\n *\r\n * @internal\r\n */\r\nfunction getImplicitForm1ExactPb(pspb) {\r\n    const [[a1, [a0]], [b1, [b0]]] = pspb;\r\n    if (eSign(a1) === 0 && eSign(b1) === 0) {\r\n        // the input bezier curve is in fact not linear but has order < 1\r\n        // it is a point and no implicit form is possible\r\n        return undefined;\r\n    }\r\n    const vₓ = eno(b1);\r\n    const vᵧ = a1;\r\n    //const v = a1*b0 - a0*b1;\r\n    const v = edif(sce(a0, b1), sce(b0, a1));\r\n    return { vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2Exact: () => (/* binding */ getImplicitForm2Exact),\n/* harmony export */   getImplicitForm2ExactPb: () => (/* binding */ getImplicitForm2ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-implicit-form1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMultBy2;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.expansionProduct;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eNegativeOf;\r\n/**\r\n * Returns the exact implicit form of the given quadratic bezier curve\r\n * or `undefined` if the curve degenerates to a point.\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2Exact(ps) {\r\n    return getImplicitForm2ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_5__.toPowerBasis2Exact)(ps));\r\n}\r\n/**\r\n * The power basis version of [[getImplicitForm2Exact]].\r\n *\r\n * @param pspb the power basis representation of a quadratic bezier curve that\r\n * can be found via [[toPowerBasis2Exact]]\r\n *\r\n * @internal\r\n */\r\nfunction getImplicitForm2ExactPb(pspb) {\r\n    const [[a2, a1, [a0]], [b2, b1, [b0]]] = pspb;\r\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eSign)(a2) === 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eSign)(b2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm1ExactPb)([[a1, [a0]], [b1, [b0]]]);\r\n    }\r\n    const a2b1 = epr(a2, b1);\r\n    const a1b2 = epr(a1, b2);\r\n    const a2b0 = sce(b0, a2);\r\n    const a0b2 = sce(a0, b2);\r\n    const a1b0 = sce(b0, a1);\r\n    const a0b1 = sce(a0, b1);\r\n    const a2a2 = epr(a2, a2);\r\n    const a2b2 = epr(a2, b2);\r\n    const b2b2 = epr(b2, b2);\r\n    const q1 = edif(a2b1, a1b2);\r\n    const q2 = edif(a2b0, a0b2);\r\n    const q3 = edif(a1b0, a0b1);\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // b2**2*x**2\r\n    // -b2**2 *x**2\r\n    const vₓₓ = eno(b2b2);\r\n    // -2*a2*b2*x*y\r\n    // 2*a2*b2 *x*y\r\n    const vₓᵧ = em2(a2b2);\r\n    // a2**2*y**2\r\n    // -a2**2 *y**2 \r\n    const vᵧᵧ = eno(a2a2);\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //const vₓ = b1*q1 - 2*b2*q2;\r\n    const w1 = epr(b1, q1);\r\n    const w2 = em2(epr(b2, q2));\r\n    const vₓ = edif(w1, w2);\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    const w3 = em2(epr(a2, q2));\r\n    const w4 = epr(a1, q1);\r\n    const vᵧ = edif(w3, w4);\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    const w5 = epr(q1, q3);\r\n    const w6 = epr(q2, q2);\r\n    const v = edif(w5, w6);\r\n    //console.log({ vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v })\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3Exact: () => (/* binding */ getImplicitForm3Exact),\n/* harmony export */   getImplicitForm3ExactPb: () => (/* binding */ getImplicitForm3ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-implicit-form2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eDiff;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eNegativeOf;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMultBy2;\r\nconst ed2 = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eDivBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_7__.eSign;\r\n/**\r\n * Returns the exact implicit form of the given cubic bezier curve\r\n * or `undefined` if the curve degenerates to a point.\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3Exact(ps) {\r\n    // Takes about 155 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    return getImplicitForm3ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_8__.toPowerBasis3Exact)(ps));\r\n}\r\n/**\r\n * The power basis version of [[getImplicitForm3Exact]].\r\n *\r\n * @param pspb the power basis representation of a cubic bezier curve that can\r\n * be found via [[toPowerBasis3Exact]]\r\n *\r\n * @internal\r\n */\r\nfunction getImplicitForm3ExactPb(pspb) {\r\n    const [[a3, a2, a1, [a0]], [b3, b2, b1, [b0]]] = pspb;\r\n    if (eSign(a3) === 0 && eSign(b3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm2ExactPb)([[a2, a1, [a0]], [b2, b1, [b0]]]);\r\n    }\r\n    const a3b1 = epr(a3, b1);\r\n    const a1b3 = epr(a1, b3);\r\n    const a3b2 = epr(a3, b2);\r\n    const a2b2 = epr(a2, b2);\r\n    const a2b3 = epr(a2, b3);\r\n    const a3a3 = epr(a3, a3);\r\n    const b2b2 = epr(b2, b2);\r\n    const b3b3 = epr(b3, b3);\r\n    const a1a3 = epr(a1, a3);\r\n    const a2a2 = epr(a2, a2);\r\n    const b1b3 = epr(b1, b3);\r\n    const b2b3 = epr(b2, b3);\r\n    const a2a3 = epr(a2, a3);\r\n    const a3b3 = epr(a3, b3);\r\n    const a3b0 = sce(b0, a3);\r\n    const a0b3 = sce(a0, b3);\r\n    const a2b0 = sce(b0, a2);\r\n    const a0b2 = sce(a0, b2);\r\n    const a2b1 = epr(a2, b1);\r\n    const a1b2 = epr(a1, b2);\r\n    const a1b0 = sce(b0, a1);\r\n    const a0b1 = sce(a0, b1);\r\n    const q1 = edif(a3b0, a0b3);\r\n    const q2 = edif(a3b1, a1b3);\r\n    const q3 = edif(a3b2, a2b3);\r\n    const q4 = edif(a2b0, a0b2);\r\n    const q5 = edif(a2b1, a1b2);\r\n    const q6 = edif(a1b0, a0b1);\r\n    const t1 = edif(b1b3, b2b2);\r\n    const t2 = edif(a1a3, a2a2);\r\n    const p1 = fes(a2b3, a3b2);\r\n    const p2 = fes(a1b3, a3b1);\r\n    const tq2 = em2(q2); // error free\r\n    const q1q1 = epr(q1, q1);\r\n    const q1q2 = epr(q1, q2);\r\n    const q1q3 = epr(q1, q3);\r\n    const q1q5 = epr(q1, q5);\r\n    const q2q2 = epr(q2, q2);\r\n    const tq2q4 = epr(tq2, q4);\r\n    const q3q4 = epr(q3, q4);\r\n    const q3q5 = epr(q3, q5);\r\n    const q3q6 = epr(q3, q6);\r\n    const vₓₓₓ = epr(eno(b3), b3b3);\r\n    const vₓₓᵧ = epr(sce(3, a3), b3b3);\r\n    const vₓᵧᵧ = epr(sce(-3, b3), a3a3);\r\n    const vᵧᵧᵧ = epr(a3, a3a3);\r\n    const u1 = edif(sce(-3, q1), q5);\r\n    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    const w1 = epr(u1, b3b3);\r\n    const w2 = epr(q3, t1);\r\n    const w3 = fes(w1, w2);\r\n    const w4 = epr(tq2, b2b3);\r\n    const vₓₓ = fes(w3, w4);\r\n    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    const w5 = epr(u1, a3a3);\r\n    const w6 = epr(q3, t2);\r\n    const w7 = fes(w5, w6);\r\n    const w8 = epr(tq2, a2a3);\r\n    const vᵧᵧ = fes(w7, w8);\r\n    //const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    const wa = edif(a2b2, ed2(p2));\r\n    const wb = epr(u1, a3b3);\r\n    const wc = epr(q2, p1);\r\n    const wd = fes(wb, wc);\r\n    const wq = epr(q3, wa);\r\n    const vₓᵧ = em2(edif(wq, wd));\r\n    //const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    const wr = sce(-3, q1q1);\r\n    const we = edif(wr, em2(q1q5));\r\n    const wf = fes(tq2q4, q3q6);\r\n    const s1 = fes(we, wf);\r\n    //const s2 = 2*(q1q2 - q3q4);\r\n    const s2 = em2(edif(q1q2, q3q4));\r\n    //const s3 = q1q3 - q2q2 + q3q5;\r\n    const wl = edif(q1q3, q2q2);\r\n    const s3 = fes(wl, q3q5);\r\n    //const vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    const wm = epr(b3, s1);\r\n    const ws = epr(b2, s2);\r\n    const wt = epr(b1, s3);\r\n    const wn = fes(ws, wt);\r\n    const vₓ = fes(wm, wn);\r\n    //const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    const wo = epr(a3, s1);\r\n    const wu = epr(a2, s2);\r\n    const wv = epr(a1, s3);\r\n    const wp = fes(wu, wv);\r\n    const vᵧ = eno(fes(wo, wp));\r\n    const v3 = edif(tq2q4, q1q1);\r\n    const v1 = edif(v3, q1q5);\r\n    const v4 = epr(s3, q6);\r\n    const v5 = epr(q3q4, q4);\r\n    const v2 = edif(v4, v5);\r\n    const v6 = epr(q1, v1);\r\n    //const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    const v = fes(v6, v2);\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm2ErrorCounters: () => (/* binding */ getImplicitForm2ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the implicit form of the given bezier\r\n * curve (using [[getImplicitForm2]] or [[getImplicitForm2Dd]]).\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`\r\n * * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\r\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * return {\r\n *      vₓₓ_,  // <5>\r\n *      vₓᵧ_,  // <5>\r\n *      vᵧᵧ_,  // <5>\r\n *      vₓ_,   // <8>\r\n *      vᵧ_,   // <8>\r\n *      v_     // <10>\r\n * }\r\n * ```\r\n *\r\n * @param ps\r\n *\r\n * @doc\r\n */\r\nfunction getImplicitForm2ErrorCounters(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    //const [[,,a0],[,,b0]] = toPowerBasis2ErrorCounters(ps);\r\n    const [a0, b0] = ps[0];\r\n    const [[a2_, a1_], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b2_, b1_] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2ErrorCounters)(ps);\r\n    //-------------------\r\n    // Error calculation\r\n    //-------------------\r\n    const a0_ = abs(a0);\r\n    const b0_ = abs(b0);\r\n    // <5>q1 <-- <5>(<4>(<2>a2*<1>b1) - <4>(a1*b2))\r\n    const q1_ = a2_ * b1_ + a1_ * b2_;\r\n    // <4>q2 <-- <4>(<3>(a2*b0) - <3>(a0*b2))\r\n    const q2_ = a2_ * b0_ + a0_ * b2_;\r\n    // <5>vₓₓ <-- <5>(-<2>b2*<2>b2)\r\n    const vₓₓ_ = b2_ * b2_;\r\n    // <5>vₓᵧ <-- 2*a2*b2\r\n    const vₓᵧ_ = 2 * a2_ * b2_;\r\n    // <5>vᵧᵧ <-- -a2*a2\r\n    const vᵧᵧ_ = a2_ * a2_;\r\n    // <8>vₓ <-- <8>(<7>(<1>b1*<5>q1) - <7>(2*<2>b2*<4>q2))\r\n    const vₓ_ = b1_ * q1_ + 2 * b2_ * q2_;\r\n    // <8>vᵧ <-- <8>(<7>(2*<2>a2<4>q2) - <7>(<1>a1<5>q1))\r\n    const vᵧ_ = 2 * a2_ * q2_ + a1_ * q1_;\r\n    // <10>v <-- <10>(<9>(<5>q1*<3>(<2>(a1*b0) - <2>(a0*b1))) - <9>(<4>q2*<4>q2))\r\n    const v_ = q1_ * (a1_ * b0_ + a0_ * b1_) + q2_ * q2_;\r\n    return {\r\n        vₓₓ_,\r\n        vₓᵧ_,\r\n        vᵧᵧ_,\r\n        vₓ_,\r\n        vᵧ_,\r\n        v_ // <10>\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImplicitForm3ErrorCounters: () => (/* binding */ getImplicitForm3ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js\");\n\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the implicit form of the given bezier\r\n * curve (using [[getImplicitForm1]] or [[getImplicitForm1Dd]]).\r\n *\r\n * * returned coefficients are subscripted to match their monomial's variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`\r\n * * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\r\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * errorBound: {\r\n *      vₓₓₓ_,  // <11>\r\n *      vₓₓᵧ_,  // <12>\r\n *      vₓᵧᵧ_,  // <12>\r\n *      vᵧᵧᵧ_,  // <11>\r\n *      vₓₓ_,   // <19>\r\n *      vₓᵧ_,   // <18>\r\n *      vᵧᵧ_,   // <19>\r\n *      vₓ_,    // <22>\r\n *      vᵧ_,    // <22>\r\n *      v_      // <24>\r\n * }\r\n * ```\r\n * @param ps\r\n *\r\n * @doc\r\n */\r\nfunction getImplicitForm3ErrorCounters(ps) {\r\n    // Takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    //const [[,,,a0],[,,,b0]] = toPowerBasis3ErrorCounters(ps);\r\n    const [a0, b0] = ps[0];\r\n    const [[a3_, a2_, a1_], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b3_, b2_, b1_] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3ErrorCounters)(ps);\r\n    //-------------------\r\n    // Error calculation\r\n    //-------------------\r\n    const a0_ = abs(a0);\r\n    const b0_ = abs(b0);\r\n    // <6>a3b1 <-- <6>(<3>a3*<2>b1);\r\n    const a3b1_ = a3_ * b1_;\r\n    // <6>a1b3 <-- a1*b3;\r\n    const a1b3_ = a1_ * b3_;\r\n    // <7>a3b2 <-- <7>(<3>a3*<3>b2);\r\n    const a3b2_ = a3_ * b2_;\r\n    // <7>a2b3 <-- a2*b3;\r\n    const a2b3_ = a2_ * b3_;\r\n    // <7>a3a3 <-- a3*a3;\r\n    const a3a3_ = a3_ * a3_;\r\n    // <7>b3b3 <-- b3*b3;\r\n    const b3b3_ = b3_ * b3_;\r\n    // <5>q1 <-- <5>(<4>(a3*b0) - <4>(a0*b3));\r\n    const q1_ = a3_ * b0_ + a0_ * b3_;\r\n    // <7>q2 <-- <7>(<6>a3b1 - <6>a1b3);\r\n    const q2_ = a3b1_ + a1b3_;\r\n    // <8>q3 <-- <8>(<7>a3b2 - <7>a2b3);\r\n    const q3_ = a3b2_ + a2b3_;\r\n    // <5>q4 <-- a2*b0 - a0*b2;\r\n    const q4_ = a2_ * b0_ + a0_ * b2_;\r\n    // <7>q5 <-- a2*b1 - a1*b2;\r\n    const q5_ = a2_ * b1_ + a1_ * b2_;\r\n    // <4>q6 <-- <4>(<3>(<2>a1*<0>b0) - <3>(<0>a0*<2>b1));\r\n    const q6_ = a1_ * b0_ + a0_ * b1_;\r\n    // <7>tq2 <-- 2*q2;\r\n    const tq2_ = 2 * q2_;\r\n    // <11>q1q1 <-- <11>(<5>q1*<5>q1)\r\n    const q1q1_ = q1_ * q1_;\r\n    // <13>q1q5 <-- <13>(<5>q1*<7>q5)\r\n    const q1q5_ = q1_ * q5_;\r\n    // <13>tq2q4 <-- <13>(<7>tq2*<5>q4)\r\n    const tq2q4_ = tq2_ * q4_;\r\n    // <14>q3q4 <-- <14>(<8>q3*<5>q4)\r\n    const q3q4_ = q3_ * q4_;\r\n    // <8>u1 <-- <8>(<6>(-3*<5>q1) - <7>q5)\r\n    const u1_ = 3 * q1_ + q5_;\r\n    // <11>vₓₓₓ <-- <11>(-<3>b3*<7>b3b3)\r\n    const vₓₓₓ_ = b3_ * b3b3_;\r\n    // <12>vₓₓᵧ <--  <12>(3*<11>(<3>a3*<7>b3b3))\r\n    const vₓₓᵧ_ = 3 * a3_ * b3b3_;\r\n    // <12>vₓᵧᵧ <-- -3*b3*a3a3\r\n    const vₓᵧᵧ_ = 3 * b3_ * a3a3_;\r\n    // <11>vᵧᵧᵧ <--  a3*a3a3\r\n    const vᵧᵧᵧ_ = a3_ * a3a3_;\r\n    // <19>vₓₓ <-- <19>(<18>(<16>(<8>u1*<7>b3b3) + <17>(<8>q3*(<8>(<6>(b1*b3) - <7>(b2*b2))))) + <15>(<7>tq2*<7>(b2*b3)))\r\n    const vₓₓ_ = (u1_ * b3b3_ + q3_ * (b1_ * b3_ + b2_ * b2_)) + tq2_ * b2_ * b3_;\r\n    // <19>vᵧᵧ <-- <19>((<18>(<16>(<8>u1*<7>a3a3) + <17>(<8>q3*<8>(<6>(a1*a3) - <7>(a2*a2))))) + <15>(<7>tq2*<7>(a2*a3)))\r\n    const vᵧᵧ_ = (u1_ * a3a3_ + q3_ * (a1_ * a3_ + a2_ * a2_)) + tq2_ * a2_ * a3_;\r\n    // <18>vₓᵧ <-- <18>(2*(<17>(<8>q3*<8>(<7>(a2*b2) - <7>(<6>a1b3 + <6>a3b1)/2)) - <17>(<16>(<8>u1*<7>(a3*b3)) + <16>(<7>q2*(<8>(a2b3 + a3b2))))))\r\n    const vₓᵧ_ = 2 * (q3_ * (a2_ * b2_ + (a1b3_ + a3b1_) / 2) + (u1_ * a3_ * b3_ + q2_ * (a2b3_ + a3b2_)));\r\n    // <15>s1 <-- <15>(<14>(<12>(-3*q1q1) - <13>2*q1q5) + <14>(<13>tq2q4 + <13>(<8>q3*<4>q6)))\r\n    const s1_ = (3 * q1q1_ + 2 * q1q5_) + (tq2q4_ + q3_ * q6_);\r\n    // <15>s2 <-- <15>(2*(<13>(<5>q1*<7>q2) - <14>q3q4))\r\n    const s2_ = 2 * (q1_ * q2_ + q3q4_);\r\n    // <17>s3 <-- <17>(<16>(<14>(<5>q1*<8>q3) - <15>(<7>q2*<7>q2)) + <16>(<8>q3*<7>q5))\r\n    const s3_ = q1_ * q3_ + q2_ * q2_ + q3_ * q5_;\r\n    // <22>vₓ <-- <22>(<19>(<3>b3*<15>s1) + <21>(<19>(<3>b2*<15>s2) + <20>(<2>b1*<17>s3)))\r\n    const vₓ_ = b3_ * s1_ + (b2_ * s2_ + b1_ * s3_);\r\n    // <22>vᵧ <-- <22>(<19>(<3>-a3*<15>s1) - <21>(<19>(<3>a2*<15>s2) + <20>(<2>a1*<17>s3)))\r\n    const vᵧ_ = a3_ * s1_ + (a2_ * s2_ + a1_ * s3_);\r\n    // <24>v <-- <24>(<21>(<5>q1*<15>(<14>(<13>tq2q4 - <11>q1q1) - <13>q1q5)) + <23>(<22>(<17>s3*<4>q6) - <20>(<14>q3q4*<5>q4)))\r\n    const v_ = (q1_ * ((tq2q4_ + q1q1_) + q1q5_)) + (s3_ * q6_ + q3q4_ * q4_);\r\n    return {\r\n        vₓₓₓ_,\r\n        vₓₓᵧ_,\r\n        vₓᵧᵧ_,\r\n        vᵧᵧᵧ_,\r\n        vₓₓ_,\r\n        vₓᵧ_,\r\n        vᵧᵧ_,\r\n        vₓ_,\r\n        vᵧ_,\r\n        v_ // <24>\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierBezierIntersectionBoundless: () => (/* binding */ bezierBezierIntersectionBoundless)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var _get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coefficients/get-coeffs-bez-bez.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js\");\n\r\n\r\n/**\r\n * Returns the intersection between any of two linear, quadratic or cubic bezier\r\n * curves without limiting the `t` parameter value of the first given curve\r\n * in [0,1], i.e. `t ∈ [-∞,+∞]`.\r\n *\r\n * * if the two curves have an infinite number of intersections `undefined` is returned\r\n * * the second bezier curve's parameter `t` values are returned *ordered* by `t` value\r\n *\r\n * * **precondition:** the bezier curves must be of lowest possible\r\n * representable order, i.e. cubics are really cubics, etc. (else\r\n * use [[reduceOrderIfPossible]] first)\r\n *\r\n * @param ps1 an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n * @param ps2 an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @internal but still exported for backwards compatibility\r\n */\r\nfunction bezierBezierIntersectionBoundless(ps1, ps2) {\r\n    const { coeffs, errBound, getPExact } = (0,_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsBezBez)(ps1, ps2);\r\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)(coeffs, 0, 1, errBound, getPExact, true);\r\n}\r\n\r\n//# sourceMappingURL=bezier-bezier-intersection-boundless.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez1Dd: () => (/* binding */ getCoeffsBez1Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of two\r\n * order 1 bezier curves (i.e. 2 lines).\r\n *\r\n * The returned polynomial degree will be 1\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez1Dd(ps1, ps2) {\r\n    const { coeffs: { vₓ, vᵧ, v }, // all these are double-doubles\r\n    errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\r\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\r\n    const $c1 = c1[1];\r\n    const $d1 = d1[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    //----------------------------------\r\n    // const v1 = c1*vₓ + d1*vᵧ;\r\n    //----------------------------------\r\n    const $p1 = $c1 * $vₓ;\r\n    const _p1 = abs($p1);\r\n    const p1_ = 2 * _p1;\r\n    const p1 = qmq(c1, vₓ);\r\n    const $p2 = $d1 * $vᵧ;\r\n    const _p2 = abs($p2);\r\n    const p2_ = 2 * _p2;\r\n    const p2 = qmq(d1, vᵧ);\r\n    const $v1 = $p1 + $p2;\r\n    //const _$v1 = abs($v1);\r\n    const v1 = qaq(p1, p2);\r\n    const v1_ = p1_ + p2_ + abs($v1);\r\n    //----------------------------------\r\n    // const v0 = c0*vₓ + d0*vᵧ + v_0;\r\n    //----------------------------------\r\n    const $p3 = c0 * $vₓ;\r\n    const p3 = qmd(c0, vₓ);\r\n    const _p3_ = abs($p3);\r\n    const $p4 = d0 * $vᵧ;\r\n    const p4 = qmd(d0, vᵧ);\r\n    const _p4_ = abs($p4);\r\n    const $p5 = $p3 + $p4;\r\n    //const _p5 = abs($p5);\r\n    const p5 = qaq(p3, p4);\r\n    const p5_ = _p3_ + _p4_ + abs($p5);\r\n    const v0 = qaq(p5, v);\r\n    const v0_ = p5_ + v_ + abs($p5 + $v);\r\n    return {\r\n        coeffs: [v1, v0],\r\n        errBound: [γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez2Dd: () => (/* binding */ getCoeffsBez1Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez2Dd(ps1, ps2) {\r\n    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\r\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const _v = abs($v);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    // --------------------------\r\n    // a2*v_x + b2*v_y\r\n    // const v2 = c2*vₓ + d2*vᵧ;\r\n    // --------------------------\r\n    const $p1 = $c2 * $vₓ;\r\n    const p1 = qmq(c2, vₓ);\r\n    const p1_ = c2_ * _vₓ + 2 * abs($p1);\r\n    const $p2 = $d2 * $vᵧ;\r\n    const p2 = qmq(d2, vᵧ);\r\n    const p2_ = d2_ * _vᵧ + 2 * abs($p2);\r\n    const $v2 = $p1 + $p2;\r\n    const v2 = qaq(p1, p2);\r\n    const v2_ = p1_ + p2_ + abs($v2);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const $p3 = $c1 * $vₓ;\r\n    const p3 = qmq(c1, vₓ);\r\n    const p3_ = 2 * abs($p3);\r\n    const $p4 = $d1 * $vᵧ;\r\n    const p4 = qmq(d1, vᵧ);\r\n    const p4_ = 2 * abs($p4);\r\n    const $v1 = $p3 + $p4;\r\n    const v1 = qaq(p3, p4);\r\n    const v1_ = p3_ + p4_ + abs($v1);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p5 = qmd(c0, vₓ);\r\n    const $p5 = c0 * $vₓ;\r\n    const p5_ = abs($p5);\r\n    const p6 = qmd(d0, vᵧ);\r\n    const $p6 = d0 * $vᵧ;\r\n    const p6_ = abs($p6);\r\n    const $p7 = $p5 + $p6;\r\n    const p7 = qaq(p5, p6);\r\n    const p7_ = p5_ + p6_ + abs($p7);\r\n    const $v0 = $p7 + $v;\r\n    const v0 = qaq(p7, v);\r\n    const v0_ = p7_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez3Dd: () => (/* binding */ getCoeffsBez1Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez3Dd(ps1, ps2) {\r\n    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\r\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\r\n    const _vₓ = abs(vₓ[1]);\r\n    const _vᵧ = abs(vᵧ[1]);\r\n    // a3*v_x + b3*v_y\r\n    //const v3 = c3*vₓ + d3*vᵧ;\r\n    const p1 = qmq(c3, vₓ); // vₓ is error free\r\n    const p1_ = c3_ * _vₓ + 2 * abs(p1[1]);\r\n    const p2 = qmq(d3, vᵧ); // vᵧ is error free\r\n    const p2_ = d3_ * _vᵧ + 2 * abs(p2[1]);\r\n    const v3 = qaq(p1, p2);\r\n    const v3_ = p1_ + p2_ + abs(v3[1]);\r\n    // a2*v_x + b2*v_y\r\n    //const v2 = c2*vₓ + d2*vᵧ;\r\n    const p3 = qmq(c2, vₓ); // vₓ is error free\r\n    const p3_ = c2_ * _vₓ + 2 * abs(p3[1]);\r\n    const p4 = qmq(d2, vᵧ); // vᵧ is error free\r\n    const p4_ = d2_ * _vᵧ + 2 * abs(p4[1]);\r\n    const v2 = qaq(p3, p4);\r\n    const v2_ = p3_ + p4_ + abs(v2[1]);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p5 = qmq(c1, vₓ); // vₓ is error free\r\n    const p5_ = c1_ * _vₓ + 2 * abs(p5[1]);\r\n    const p6 = qmq(d1, vᵧ); // vᵧ is error free\r\n    const p6_ = d1_ * _vᵧ + 2 * abs(p6[1]);\r\n    const v1 = qaq(p5, p6);\r\n    const v1_ = p5_ + p6_ + abs(v1[1]);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p7 = qmd(c0, vₓ); // vₓ is error free\r\n    const p7_ = abs(p7[1]);\r\n    const p8 = qmd(d0, vᵧ); // vᵧ is error free\r\n    const p8_ = abs(p8[1]);\r\n    const p9 = qaq(p7, p8);\r\n    const p9_ = p7_ + p8_ + abs(p9[1]);\r\n    const v0 = qaq(p9, v);\r\n    const v0_ = p9_ + v_ + abs(v0[1]);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez1Dd: () => (/* binding */ getCoeffsBez2Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez1Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\r\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const $c1 = c1[1];\r\n    const $d1 = d1[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d1d1 = $d1 * $d1;\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = qmd(c0, c1);\r\n    const _c0c1_ = abs($c0c1);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = abs($c0d1);\r\n    const _c1c1 = abs($c1c1);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * _c1c1;\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = abs($c1d0);\r\n    const _c1d1 = abs($c1d1);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * _c1d1;\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = qmd(d0, d1);\r\n    const _d0d1_ = abs($d0d1);\r\n    const _d1d1 = abs($d1d1);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * _d1d1;\r\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\r\n    const $p1 = $c1c1 * $vₓₓ;\r\n    const p1 = qmq(c1c1, vₓₓ);\r\n    const p1_ = c1c1_ * _vₓₓ * _c1c1 * vₓₓ_ + 2 * abs($p1);\r\n    const $p2 = $d1d1 * $vᵧᵧ;\r\n    const p2 = qmq(d1d1, vᵧᵧ);\r\n    const p2_ = d1d1_ * _vᵧᵧ * _d1d1 * vᵧᵧ_ + 2 * abs($p2);\r\n    const $p3 = $c1d1 * $vₓᵧ;\r\n    const p3 = qmq(c1d1, vₓᵧ);\r\n    const p3_ = c1d1_ * _vₓᵧ * _c1d1 * vₓᵧ_ + 2 * abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $v2 = $p4 + $p3;\r\n    const v2 = qaq(p4, p3);\r\n    const v2_ = p4_ + p3_ + abs($v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\r\n    const $p5 = $c0c1 * $vₓₓ;\r\n    const p5 = qmq(c0c1, vₓₓ);\r\n    const p5_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * abs($p5);\r\n    const $p6 = $d0d1 * $vᵧᵧ;\r\n    const p6 = qmq(d0d1, vᵧᵧ);\r\n    const p6_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * abs($p6);\r\n    const $p7 = $c0d1 + $c1d0;\r\n    const p7 = qaq(c0d1, c1d0);\r\n    const p7_ = c0d1_ + c1d0_ + abs($p7);\r\n    const $pn = $p7 * $vₓᵧ;\r\n    const pn = qmq(p7, vₓᵧ);\r\n    const pn_ = p7_ * _vₓᵧ + abs($p7) * vₓᵧ_ + 2 * abs($pn);\r\n    const $p8 = 2 * ($p5 + $p6);\r\n    const p8 = qm2(qaq(p5, p6));\r\n    const p8_ = 2 * (p5_ + p6_) + abs($p8);\r\n    const $p9 = $p8 + $pn;\r\n    const p9 = qaq(p8, pn);\r\n    const p9_ = p8_ + pn_ + abs($p9);\r\n    const $pa = $c1 * $vₓ;\r\n    const pa = qmq(c1, vₓ);\r\n    const pa_ = _c1 * vₓ_ + 2 * abs($pa);\r\n    const $pb = $d1 * $vᵧ;\r\n    const pb = qmq(d1, vᵧ);\r\n    const pb_ = _d1 * vᵧ_ + 2 * abs($pb);\r\n    const $pc = $pa + $pb;\r\n    const pc = qaq(pa, pb);\r\n    const pc_ = pa_ + pb_ + abs($pc);\r\n    const $v1 = $p9 + $pc;\r\n    const v1 = qaq(p9, pc);\r\n    const v1_ = p9_ + pc_ + abs($v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\r\n    const $pe = $c0c0 * $vₓₓ;\r\n    const pe = qmq(c0c0, vₓₓ);\r\n    const pe_ = 2 * abs($pe);\r\n    const $pf = $c0d0 * $vₓᵧ;\r\n    const pf = qmq(c0d0, vₓᵧ);\r\n    const pf_ = 2 * abs($pf);\r\n    const $pg = $d0d0 * $vᵧᵧ;\r\n    const pg = qmq(d0d0, vᵧᵧ);\r\n    const pg_ = 2 * abs($pg);\r\n    const $ph = $pe + $pf;\r\n    const ph = qaq(pe, pf);\r\n    const ph_ = pe_ + pf_ + abs($ph);\r\n    const $pi = $ph + $pg;\r\n    const pi = qaq(ph, pg);\r\n    const pi_ = ph_ + pg_ + abs($pi);\r\n    const $pj = c0 * $vₓ;\r\n    const pj = qmd(c0, vₓ);\r\n    const pj_ = _c0 * vₓ_ + abs($pj);\r\n    const $pk = d0 * $vᵧ;\r\n    const pk = qmd(d0, vᵧ);\r\n    const pk_ = _d0 * vᵧ_ + abs($pk);\r\n    const $pl = $pj + $pk;\r\n    const pl = qaq(pj, pk);\r\n    const pl_ = pj_ + pk_ + abs($pl);\r\n    const $pm = $pi + $pl;\r\n    const pm = qaq(pi, pl);\r\n    const pm_ = pi_ + pl_ + abs($pm);\r\n    const $v0 = $pm + $v;\r\n    const v0 = qaq(pm, v);\r\n    const v0_ = pm_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez2Dd: () => (/* binding */ getCoeffsBez2Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 2 bezier curves (i.e. 2 quadratic bezier curves).\r\n *\r\n * The returned polynomial degree will be 4\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez2Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\r\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d2d2 = $d2 * $d2;\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0d0 = abs($c0d0);\r\n    const _d0d0 = abs($d0d0);\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const _c0c1_ = abs($c0c1);\r\n    const c0c2 = qmd(c0, c2);\r\n    const _c0c2_ = abs($c0c2);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const _c0d1_ = abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const _c0d2_ = abs($c0d2);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * abs($c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const _c1c2 = abs($c1c2);\r\n    const c1c2_ = _c1 * c2_ + 2 * _c1c2;\r\n    const c1d0 = qmd(d0, c1);\r\n    const _c1d0_ = abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = _c1 * d2_ + 2 * abs($c1d2);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const _c2c2 = abs($c2c2);\r\n    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);\r\n    const c2d0 = qmd(d0, c2);\r\n    const _c2d0_ = abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const _c2d2 = abs($c2d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * _c2d2;\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const _d0d1_ = abs($d0d1);\r\n    const d0d2 = qmd(d0, d2);\r\n    const _d0d2_ = abs($d0d2);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * abs($d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const _d1d2 = abs($d1d2);\r\n    const d1d2_ = _d1 * d2_ + 2 * _d1d2;\r\n    const d2d2 = qmq(d2, d2);\r\n    const _d2d2 = abs($d2d2);\r\n    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //const v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    const $p1 = $c2c2 * $vₓₓ;\r\n    const p1 = qmq(c2c2, vₓₓ);\r\n    const p1_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * abs($p1);\r\n    const $p2 = $c2d2 * $vₓᵧ;\r\n    const p2 = qmq(c2d2, vₓᵧ);\r\n    const p2_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * abs($p2);\r\n    const $p3 = $d2d2 * $vᵧᵧ;\r\n    const p3 = qmq(d2d2, vᵧᵧ);\r\n    const p3_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $v4 = $p4 + $p3;\r\n    const v4 = qaq(p4, p3);\r\n    const v4_ = p4_ + p3_ + abs($v4);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    const $p5 = $c1c2 * $vₓₓ;\r\n    const p5 = qmq(c1c2, vₓₓ);\r\n    const p5_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * abs($p5);\r\n    const $p6 = $d1d2 * $vᵧᵧ;\r\n    const p6 = qmq(d1d2, vᵧᵧ);\r\n    const p6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * abs($p6);\r\n    const $p7 = $c1d2 + $c2d1;\r\n    const p7 = qaq(c1d2, c2d1);\r\n    const _p7 = abs($p7);\r\n    const p7_ = c1d2_ + c2d1_ + _p7;\r\n    const $p8 = $p7 * $vₓᵧ;\r\n    const p8 = qmq(p7, vₓᵧ);\r\n    const p8_ = p7_ * _vₓᵧ + _p7 * vₓᵧ_ + 2 * abs($p8);\r\n    const $p9 = 2 * ($p5 + $p6);\r\n    const p9 = qm2(qaq(p5, p6));\r\n    const p9_ = 2 * (p5_ + p6_) + abs($p9);\r\n    const $v3 = $p9 + $p8;\r\n    const v3 = qaq(p9, p8);\r\n    const v3_ = p9_ + p8_ + abs($v3);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    const $pa = 2 * $c0c2 + $c1c1;\r\n    const _pa = abs($pa);\r\n    const pa = qaq(qm2(c0c2), c1c1);\r\n    const pa_ = 2 * _c0c2_ + c1c1_ + abs($pa);\r\n    const $pb = 2 * $d0d2 + $d1d1;\r\n    const _pb = abs($pb);\r\n    const pb = qaq(qm2(d0d2), d1d1);\r\n    const pb_ = 2 * _d0d2_ + d1d1_ + abs($pb);\r\n    const $pc = $c0d2 + $c1d1;\r\n    const _pc = abs($pc);\r\n    const pc = qaq(c0d2, c1d1);\r\n    const pc_ = _c0d2_ + c1d1_ + abs($pc);\r\n    const $pd = $pc + $c2d0;\r\n    const pd = qaq(pc, c2d0);\r\n    const _pd = abs($pd);\r\n    const pd_ = pc_ + _c2d0_ + _pd;\r\n    const $pe = $pa * $vₓₓ;\r\n    const pe = qmq(pa, vₓₓ);\r\n    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * abs($pe);\r\n    const $pf = $pb * $vᵧᵧ;\r\n    const pf = qmq(pb, vᵧᵧ);\r\n    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * abs($pf);\r\n    const $pg = $pd * $vₓᵧ;\r\n    const pg = qmq(pd, vₓᵧ);\r\n    const pg_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * abs($pg);\r\n    const $ph = $c2 * $vₓ;\r\n    const ph = qmq(c2, vₓ);\r\n    const ph_ = c2_ * _vₓ + _c2 * vₓ_ + abs($ph);\r\n    const $pi = $d2 * $vᵧ;\r\n    const pi = qmq(d2, vᵧ);\r\n    const pi_ = d2_ * _vᵧ + _d2 * vᵧ_ + abs($pi);\r\n    const $pj = $pe + $pf;\r\n    const pj = qaq(pe, pf);\r\n    const pj_ = pe_ + pf_ + abs($pj);\r\n    const $pk = $pj + $pg;\r\n    const pk = qaq(pj, pg);\r\n    const pk_ = pj_ + pg_ + abs($pk);\r\n    const $pl = $ph + $pi;\r\n    const pl = qaq(ph, pi);\r\n    const pl_ = ph_ + pi_ + abs($pl);\r\n    const $v2 = $pk + $pl;\r\n    const v2 = qaq(pk, pl);\r\n    const v2_ = pk_ + pl_ + abs($v2);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    const $pm = $c0c1 * $vₓₓ;\r\n    const pm = qmq(c0c1, vₓₓ);\r\n    const pm_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * abs($pm);\r\n    const $pn = $d0d1 * $vᵧᵧ;\r\n    const pn = qmq(d0d1, vᵧᵧ);\r\n    const pn_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * abs($pn);\r\n    const $po = $c0d1 + $c1d0;\r\n    const po = qaq(c0d1, c1d0);\r\n    const _po = abs($po);\r\n    const po_ = _c0d1_ + _c1d0_ + _po;\r\n    const $pp = $po * $vₓᵧ;\r\n    const pp = qmq(po, vₓᵧ);\r\n    const pp_ = po_ * _vₓᵧ + _po * vₓᵧ_ + 2 * abs($pp);\r\n    const $pq = 2 * ($pm + $pn);\r\n    const pq = qm2(qaq(pm, pn));\r\n    const pq_ = 2 * (pm_ + pn_) + abs($pq);\r\n    const $pr = $c1 * $vₓ;\r\n    const pr = qmq(c1, vₓ);\r\n    const pr_ = _c1 * vₓ_ + 2 * abs($pr);\r\n    const $ps = $d1 * $vᵧ;\r\n    const ps = qmq(d1, vᵧ);\r\n    const ps_ = _d1 * vᵧ_ + 2 * abs($ps);\r\n    const $pt = $pq + $pp;\r\n    const pt = qaq(pq, pp);\r\n    const pt_ = pq_ + pp_ + abs($pt);\r\n    const $pu = $pr + $ps;\r\n    const pu = qaq(pr, ps);\r\n    const pu_ = pr_ + ps_ + abs($pu);\r\n    const $v1 = $pt + $pu;\r\n    const v1 = qaq(pt, pu);\r\n    const v1_ = pt_ + pu_ + abs($v1);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    const $pv = $c0c0 * $vₓₓ;\r\n    const pv = qmq(c0c0, vₓₓ);\r\n    const pv_ = _c0c0 * vₓₓ_ + 2 * abs($pv);\r\n    const $pw = $c0d0 * $vₓᵧ;\r\n    const pw = qmq(c0d0, vₓᵧ);\r\n    const pw_ = _c0d0 * vₓᵧ_ + 2 * abs($pw);\r\n    const $px = $d0d0 * $vᵧᵧ;\r\n    const px = qmq(d0d0, vᵧᵧ);\r\n    const px_ = _d0d0 * vᵧᵧ_ + 2 * abs($px);\r\n    const $py = c0 * $vₓ;\r\n    const py = qmd(c0, vₓ);\r\n    const py_ = _c0 * vₓ_ + abs($py);\r\n    const $pz = d0 * $vᵧ;\r\n    const pz = qmd(d0, vᵧ);\r\n    const pz_ = _d0 * vᵧ_ + abs($pz);\r\n    const $q1 = $pv + $pw;\r\n    const q1 = qaq(pv, pw);\r\n    const q1_ = pv_ + pw_ + abs($q1);\r\n    const $q2 = $q1 + $px;\r\n    const q2 = qaq(q1, px);\r\n    const q2_ = q1_ + px_ + abs($q2);\r\n    const $q3 = $py + $pz;\r\n    const q3 = qaq(py, pz);\r\n    const q3_ = py_ + pz_ + abs($q3);\r\n    const $q4 = $q2 + $q3;\r\n    const q4 = qaq(q2, q3);\r\n    const q4_ = q2_ + q3_ + abs($q4);\r\n    const $v0 = $q4 + $v;\r\n    const v0 = qaq(q4, v);\r\n    const v0_ = q4_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez3Dd: () => (/* binding */ getCoeffsBez2Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n  * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez3Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\r\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $c3 = c3[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const $d3 = d3[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _c3 = abs($c3);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const _d3 = abs($d3);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0c3 = c0 * $c3;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c0d3 = c0 * $d3;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1c3 = $c1 * $c3;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c1d3 = $c1 * $d3;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2c3 = $c2 * $c3;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $c2d3 = $c2 * $d3;\r\n    const $c3c3 = $c3 * $c3;\r\n    const $c3d0 = $c3 * d0;\r\n    const $c3d1 = $c3 * $d1;\r\n    const $c3d2 = $c3 * $d2;\r\n    const $c3d3 = $c3 * $d3;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d0d3 = d0 * $d3;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d3d3 = $d3 * $d3;\r\n    const $d2d2 = $d2 * $d2;\r\n    const $d2d3 = $d2 * $d3;\r\n    const $d1d3 = $d1 * $d3;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const _c0c0 = abs($c0c0);\r\n    const c0c1 = qmd(c0, c1);\r\n    const _c0c1 = abs($c0c1);\r\n    const c0c1_ = _c0 * c1_ + _c0c1;\r\n    const c0c2 = qmd(c0, c2);\r\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\r\n    const c0c3 = qmd(c0, c3);\r\n    const c0c3_ = _c0 * c3_ + abs($c0c3);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const _c0d0 = abs($c0d0);\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = _c0 * d1_ + abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\r\n    const c0d3 = qmd(c0, d3);\r\n    const c0d3_ = _c0 * d3_ + abs($c0d3);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = c1_ * _c1 + _c1 * c1_ + 2 * abs($c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * abs($c1c2);\r\n    const c1c3 = qmq(c1, c3);\r\n    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * abs($c1c3);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = _d0 * c1_ + abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * abs($c1d2);\r\n    const c1d3 = qmq(c1, d3);\r\n    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * abs($c1d3);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const c2c2_ = c2_ * _c2 + _c2 * c2_ + 2 * abs($c2c2);\r\n    const c2c3 = qmq(c2, c3);\r\n    const _c2c3 = abs($c2c3);\r\n    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * _c2c3;\r\n    const c2d0 = qmd(d0, c2);\r\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\r\n    const c2d3 = qmq(c2, d3);\r\n    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * abs($c2d3);\r\n    const c3c3 = qmq(c3, c3);\r\n    const _c3c3 = abs($c3c3);\r\n    const c3c3_ = c3_ * _c3 + _c3 * c3_ + 2 * _c3c3;\r\n    const c3d0 = qmd(d0, c3);\r\n    const c3d0_ = _d0 * c3_ + abs($c3d0);\r\n    const c3d1 = qmq(c3, d1);\r\n    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * abs($c3d1);\r\n    const c3d2 = qmq(c3, d2);\r\n    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * abs($c3d2);\r\n    const c3d3 = qmq(c3, d3);\r\n    const _c3d3 = abs($c3d3);\r\n    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * _c3d3;\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const _d0d0 = abs($d0d0);\r\n    const d0d1 = qmd(d0, d1);\r\n    const _d0d1 = abs($d0d1);\r\n    const d0d1_ = _d0 * d1_ + _d0d1;\r\n    const d0d2 = qmd(d0, d2);\r\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\r\n    const d0d3 = qmd(d0, d3);\r\n    const d0d3_ = _d0 * d3_ + abs($d0d3);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = d1_ * _d1 + _d1 * d1_ + 2 * abs($d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * abs($d1d2);\r\n    const d3d3 = qmq(d3, d3);\r\n    const _d3d3 = abs($d3d3);\r\n    const d3d3_ = d3_ * _d3 + _d3 * d3_ + 2 * _d3d3;\r\n    const d2d2 = qmq(d2, d2);\r\n    const d2d2_ = d2_ * _d2 + _d2 * d2_ + 2 * abs($d2d2);\r\n    const d2d3 = qmq(d2, d3);\r\n    const _d2d3 = abs($d2d3);\r\n    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * _d2d3;\r\n    const d1d3 = qmq(d1, d3);\r\n    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * abs($d1d3);\r\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\r\n    //const v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    const $p1 = $c3c3 * $vₓₓ;\r\n    const p1 = qmq(c3c3, vₓₓ);\r\n    const p1_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * abs($p1);\r\n    const $p2 = $c3d3 * $vₓᵧ;\r\n    const p2 = qmq(c3d3, vₓᵧ);\r\n    const p2_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * abs($p2);\r\n    const $p3 = $d3d3 * $vᵧᵧ;\r\n    const p3 = qmq(d3d3, vᵧᵧ);\r\n    const p3_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $v6 = $p4 + $p3;\r\n    const v6 = qaq(p4, p3);\r\n    const v6_ = p4_ + p3_ + abs($v6);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //const v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    vₓᵧ*(c2d3 + c3d2);\r\n    const $p5 = $c2c3 * $vₓₓ;\r\n    const p5 = qmq(c2c3, vₓₓ);\r\n    const p5_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * abs($p5);\r\n    const $p6 = $d2d3 * $vᵧᵧ;\r\n    const p6 = qmq(d2d3, vᵧᵧ);\r\n    const p6_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * abs($p6);\r\n    const $p7 = $p5 + $p6;\r\n    const p7 = qaq(p5, p6);\r\n    const p7_ = p5_ + p6_ + abs($p7);\r\n    const $p8 = $c2d3 + $c3d2;\r\n    const p8 = qaq(c2d3, c3d2);\r\n    const _p8 = abs($p8);\r\n    const p8_ = c2d3_ + c3d2_ + _p8;\r\n    const $p9 = $p8 * $vₓᵧ;\r\n    const p9 = qmq(p8, vₓᵧ);\r\n    const p9_ = p8_ * _vₓᵧ + _p8 * vₓᵧ_ + 2 * abs($p9);\r\n    const $v5 = 2 * $p7 + $p9;\r\n    const v5 = qaq(qm2(p7), p9);\r\n    const v5_ = 2 * p7_ + p9_ + abs($v5);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //const v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    const $pa = 2 * $c1c3 + $c2c2;\r\n    const pa = qaq(qm2(c1c3), c2c2);\r\n    const _pa = abs($pa);\r\n    const pa_ = 2 * c1c3_ + c2c2_ + abs($pa);\r\n    const $pb = 2 * $d1d3 + $d2d2;\r\n    const pb = qaq(qm2(d1d3), d2d2);\r\n    const _pb = abs($pb);\r\n    const pb_ = 2 * d1d3_ + d2d2_ + abs($pb);\r\n    const $pc = $c1d3 + $c2d2;\r\n    const pc = qaq(c1d3, c2d2);\r\n    const pc_ = c1d3_ + c2d2_ + abs($pc);\r\n    const $pd = $pc + $c3d1;\r\n    const pd = qaq(pc, c3d1);\r\n    const _pd = abs($pd);\r\n    const pd_ = pc_ + c3d1_ + _pd;\r\n    const $pe = $pa * $vₓₓ;\r\n    const pe = qmq(pa, vₓₓ);\r\n    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * abs($pe);\r\n    const $pf = $pb * $vᵧᵧ;\r\n    const pf = qmq(pb, vᵧᵧ);\r\n    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * abs($pf);\r\n    const $pg = $pe + $pf;\r\n    const pg = qaq(pe, pf);\r\n    const pg_ = pe_ + pf_ + abs($pg);\r\n    const $rp = $pd * $vₓᵧ;\r\n    const rp = qmq(pd, vₓᵧ);\r\n    const rp_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * abs($rp);\r\n    const $v4 = $pg + $rp;\r\n    const v4 = qaq(pg, rp);\r\n    const v4_ = pg_ + rp_ + abs($v4);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //const v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    const $ph = $c0c3 + $c1c2;\r\n    const ph = qaq(c0c3, c1c2);\r\n    const _ph = abs($ph);\r\n    const ph_ = c0c3_ + c1c2_ + _ph;\r\n    const $pi = $d0d3 + $d1d2;\r\n    const pi = qaq(d0d3, d1d2);\r\n    const _pi = abs($pi);\r\n    const pi_ = d0d3_ + d1d2_ + _pi;\r\n    const $pj = $c0d3 + $c1d2;\r\n    const pj = qaq(c0d3, c1d2);\r\n    const pj_ = c0d3_ + c1d2_ + abs($pj);\r\n    const $pk = $c2d1 + $c3d0;\r\n    const pk = qaq(c2d1, c3d0);\r\n    const pk_ = c2d1_ + c3d0_ + abs($pk);\r\n    const $pl = $pj + $pk;\r\n    const pl = qaq(pj, pk);\r\n    const _pl = abs($pl);\r\n    const pl_ = pj_ + pk_ + _pl;\r\n    const $pm = $ph * $vₓₓ;\r\n    const pm = qmq(ph, vₓₓ);\r\n    const pm_ = ph_ * _vₓₓ + _ph * vₓₓ_ + 2 * abs($pm);\r\n    const $pn = $pi * $vᵧᵧ;\r\n    const pn = qmq(pi, vᵧᵧ);\r\n    const pn_ = pi_ * _vᵧᵧ + _pi * vᵧᵧ_ + 2 * abs($pn);\r\n    const $po = 2 * ($pm + $pn);\r\n    const po = qm2(qaq(pm, pn));\r\n    const po_ = 2 * (pm_ + pn_) + abs($po);\r\n    const $pp = $pl * $vₓᵧ;\r\n    const pp = qmq(pl, vₓᵧ);\r\n    const pp_ = pl_ * _vₓᵧ + _pl * vₓᵧ_ + 2 * abs($pp);\r\n    const $rn = $c3 * $vₓ;\r\n    const rn = qmq(c3, vₓ);\r\n    const rn_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * abs($rn);\r\n    const $ro = $d3 * $vᵧ;\r\n    const ro = qmq(d3, vᵧ);\r\n    const ro_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * abs($ro);\r\n    const $pq = $rn + $ro;\r\n    const pq = qaq(rn, ro);\r\n    const pq_ = rn_ + ro_ + abs($pq);\r\n    const $pr = $po + $pp;\r\n    const pr = qaq(po, pp);\r\n    const pr_ = po_ + pp_ + abs($pr);\r\n    const $v3 = $pr + $pq;\r\n    const v3 = qaq(pr, pq);\r\n    const v3_ = pr_ + pq_ + abs($v3);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //const v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    const $ps = 2 * $c0c2 + $c1c1;\r\n    const ps = qaq(qm2(c0c2), c1c1);\r\n    const _ps = abs($ps);\r\n    const ps_ = 2 * c0c2_ + c1c1_ + _ps;\r\n    const $pt = 2 * $d0d2 + $d1d1;\r\n    const pt = qaq(qm2(d0d2), d1d1);\r\n    const _pt = abs($pt);\r\n    const pt_ = 2 * d0d2_ + d1d1_ + _pt;\r\n    const $pu = $c0d2 + $c1d1;\r\n    const pu = qaq(c0d2, c1d1);\r\n    const pu_ = c0d2_ + c1d1_ + abs($pu);\r\n    const $pv = $pu + $c2d0;\r\n    const pv = qaq(pu, c2d0);\r\n    const _pv = abs($pv);\r\n    const pv_ = pu_ + c2d0_ + _pv;\r\n    const $pw = $ps * $vₓₓ;\r\n    const pw = qmq(ps, vₓₓ);\r\n    const pw_ = ps_ * _vₓₓ + _ps * vₓₓ_ + 2 * abs($pw);\r\n    const $px = $pt * $vᵧᵧ;\r\n    const px = qmq(pt, vᵧᵧ);\r\n    const px_ = pt_ * _vᵧᵧ + _pt * vᵧᵧ_ + 2 * abs($px);\r\n    const $py = $pv * $vₓᵧ;\r\n    const py = qmq(pv, vₓᵧ);\r\n    const py_ = pv_ * _vₓᵧ + _pv * vₓᵧ_ + 2 * abs($py);\r\n    const $pz = $pw + $px;\r\n    const pz = qaq(pw, px);\r\n    const pz_ = pw_ + px_ + abs($pz);\r\n    const $r1 = $pz + $py;\r\n    const r1 = qaq(pz, py);\r\n    const r1_ = pz_ + py_ + abs($r1);\r\n    const $r2 = $c2 * $vₓ;\r\n    const r2 = qmq(c2, vₓ);\r\n    const r2_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * abs($r2);\r\n    const $r3 = $d2 * $vᵧ;\r\n    const r3 = qmq(d2, vᵧ);\r\n    const r3_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * abs($r3);\r\n    const $r4 = $r2 + $r3;\r\n    const r4 = qaq(r2, r3);\r\n    const r4_ = r2_ + r3_ + abs($r4);\r\n    const $v2 = $r1 + $r4;\r\n    const v2 = qaq(r1, r4);\r\n    const v2_ = r1_ + r4_ + abs($v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //const v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    const $r5 = $c0c1 * $vₓₓ;\r\n    const r5 = qmq(c0c1, vₓₓ);\r\n    const r5_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($r5);\r\n    const $r6 = $d0d1 * $vᵧᵧ;\r\n    const r6 = qmq(d0d1, vᵧᵧ);\r\n    const r6_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($r6);\r\n    const $r7 = $c0d1 + $c1d0;\r\n    const r7 = qaq(c0d1, c1d0);\r\n    const _r7 = abs($r7);\r\n    const r7_ = c0d1_ + c1d0_ + _r7;\r\n    const $r8 = $r7 * $vₓᵧ;\r\n    const r8 = qmq(r7, vₓᵧ);\r\n    const r8_ = r7_ * _vₓᵧ + _r7 * vₓᵧ_ + 2 * abs($r8);\r\n    const $r9 = 2 * ($r5 + $r6);\r\n    const r9 = qm2(qaq(r5, r6));\r\n    const r9_ = 2 * (r5_ + r6_) + abs($r9);\r\n    const $ra = $r9 + $r8;\r\n    const ra = qaq(r9, r8);\r\n    const ra_ = r9_ + r8_ + abs($ra);\r\n    const $rb = $c1 * $vₓ;\r\n    const rb = qmq(c1, vₓ);\r\n    const rb_ = c1_ * _vₓ + _c1 * vₓ_ + 2 * abs($rb);\r\n    const $rc = $d1 * $vᵧ;\r\n    const rc = qmq(d1, vᵧ);\r\n    const rc_ = d1_ * _vᵧ + _d1 * vᵧ_ + 2 * abs($rc);\r\n    const $rd = $rb + $rc;\r\n    const rd = qaq(rb, rc);\r\n    const rd_ = rb_ + rc_ + abs($rd);\r\n    const $v1 = $ra + $rd;\r\n    const v1 = qaq(ra, rd);\r\n    const v1_ = ra_ + rd_ + abs($v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const $re = $c0c0 * $vₓₓ;\r\n    const re = qmq(c0c0, vₓₓ);\r\n    const re_ = _c0c0 * vₓₓ_ + 2 * abs($re);\r\n    const $rf = $c0d0 * $vₓᵧ;\r\n    const rf = qmq(c0d0, vₓᵧ);\r\n    const rf_ = _c0d0 * vₓᵧ_ + 2 * abs($rf);\r\n    const $rg = $d0d0 * $vᵧᵧ;\r\n    const rg = qmq(d0d0, vᵧᵧ);\r\n    const rg_ = _d0d0 * vᵧᵧ_ + 2 * abs($rg);\r\n    const $rh = c0 * $vₓ;\r\n    const rh = qmd(c0, vₓ);\r\n    const rh_ = _c0 * vₓ_ + abs($rh);\r\n    const $ri = d0 * $vᵧ;\r\n    const ri = qmd(d0, vᵧ);\r\n    const ri_ = _d0 * vᵧ_ + abs($ri);\r\n    const $rj = $re + $rf;\r\n    const rj = qaq(re, rf);\r\n    const rj_ = re_ + rf_ + abs($rj);\r\n    const $rk = $rj + $rg;\r\n    const rk = qaq(rj, rg);\r\n    const rk_ = rj_ + rg_ + abs($rk);\r\n    const $rl = $rh + $ri;\r\n    const rl = qaq(rh, ri);\r\n    const rl_ = rh_ + ri_ + abs($rl);\r\n    const $rm = $rk + $rl;\r\n    const rm = qaq(rk, rl);\r\n    const rm_ = rk_ + rl_ + abs($rm);\r\n    const $v0 = $rm + $v;\r\n    const v0 = qaq(rm, v);\r\n    const v0_ = rm_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez1Dd: () => (/* binding */ getCoeffsBez3Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez1Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\r\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\r\n    const $vₓₓₓ = vₓₓₓ[1];\r\n    const $vₓₓᵧ = vₓₓᵧ[1];\r\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const $c1 = c1[1];\r\n    const $d1 = d1[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d1d1 = $d1 * $d1;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const c0c1_ = abs($c0c1);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = abs($c0d1);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * abs($c1c1);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * abs($c1d1);\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const d0d1_ = abs($d0d1);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * abs($d1d1);\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0c1 = abs($c0c1);\r\n    const _c0d0 = abs($c0d0);\r\n    const _c0d1 = abs($c0d1);\r\n    const _c1c1 = abs($c1c1);\r\n    const _c1d0 = abs($c1d0);\r\n    const _c1d1 = abs($c1d1);\r\n    const _d0d0 = abs($d0d0);\r\n    const _d0d1 = abs($d0d1);\r\n    const _d1d1 = abs($d1d1);\r\n    const $z1 = c0 * $vₓₓₓ;\r\n    const z1 = qmd(c0, vₓₓₓ);\r\n    const z1_ = _c0 * vₓₓₓ_ + abs($z1);\r\n    const $za = 3 * c0;\r\n    const za = tp(3, c0);\r\n    const _za = abs($za);\r\n    const $z7 = $za * $vₓₓₓ;\r\n    const z7 = qmq(za, vₓₓₓ);\r\n    const z7_ = _za * vₓₓₓ_ + 2 * abs($z7);\r\n    const $z2 = c0 * $vₓₓᵧ;\r\n    const z2 = qmd(c0, vₓₓᵧ);\r\n    const z2_ = _c0 * vₓₓᵧ_ + abs($z2);\r\n    const $z3 = d0 * $vₓₓᵧ;\r\n    const z3 = qmd(d0, vₓₓᵧ);\r\n    const z3_ = _d0 * vₓₓᵧ_ + abs($z3);\r\n    const $z4 = c0 * $vₓᵧᵧ;\r\n    const z4 = qmd(c0, vₓᵧᵧ);\r\n    const z4_ = _c0 * vₓᵧᵧ_ + abs($z4);\r\n    const $z5 = d0 * $vₓᵧᵧ;\r\n    const z5 = qmd(d0, vₓᵧᵧ);\r\n    const z5_ = _d0 * vₓᵧᵧ_ + abs($z5);\r\n    const $z6 = d0 * $vᵧᵧᵧ;\r\n    const z6 = qmd(d0, vᵧᵧᵧ);\r\n    const z6_ = _d0 * vᵧᵧᵧ_ + abs($z6);\r\n    const $zb = 3 * d0;\r\n    const zb = tp(3, d0);\r\n    const _zb = abs($zb);\r\n    const $z8 = $zb * $vᵧᵧᵧ;\r\n    const z8 = qmq(zb, vᵧᵧᵧ);\r\n    const z8_ = _zb * vᵧᵧᵧ_ + 2 * abs($z8);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //const v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    const $u1 = $c1 * $vₓₓₓ;\r\n    const u1 = qmq(c1, vₓₓₓ);\r\n    const u1_ = _c1 * vₓₓₓ_ + 2 * abs($u1);\r\n    const $u2 = $c1 * $vₓᵧᵧ;\r\n    const u2 = qmq(c1, vₓᵧᵧ);\r\n    const u2_ = _c1 * vₓᵧᵧ_ + 2 * abs($u2);\r\n    const $u3 = $d1 * $vₓₓᵧ;\r\n    const u3 = qmq(d1, vₓₓᵧ);\r\n    const u3_ = _d1 * vₓₓᵧ_ + 2 * abs($u3);\r\n    const $u4 = $d1 * $vᵧᵧᵧ;\r\n    const u4 = qmq(d1, vᵧᵧᵧ);\r\n    const u4_ = _d1 * vᵧᵧᵧ_ + 2 * abs($u4);\r\n    const $u5 = $u1 + $u3;\r\n    const u5 = qaq(u1, u3);\r\n    const _u5 = abs($u5);\r\n    const u5_ = u1_ + u3_ + _u5;\r\n    const $u6 = $u2 + $u4;\r\n    const u6 = qaq(u2, u4);\r\n    const _u6 = abs($u6);\r\n    const u6_ = u2_ + u4_ + _u6;\r\n    const $u7 = $c1c1 * $u5;\r\n    const u7 = qmq(c1c1, u5);\r\n    const u7_ = c1c1_ * _u5 + _c1c1 * u5_ + 2 * abs($u7);\r\n    const $u8 = $d1d1 * $u6;\r\n    const u8 = qmq(d1d1, u6);\r\n    const u8_ = d1d1_ * _u6 + _d1d1 * u6_ + 2 * abs($u8);\r\n    const $v3 = $u7 + $u8;\r\n    const v3 = qaq(u7, u8);\r\n    const v3_ = u7_ + u8_ + abs($v3);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //const v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //const v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    const $u9 = $z7 + $z3;\r\n    const u9 = qaq(z7, z3);\r\n    const u9_ = z7_ + z3_ + abs($u9);\r\n    const $ua = 2 * ($z2 + $z5);\r\n    const ua = qm2(qaq(z2, z5));\r\n    const ua_ = 2 * (z2_ + z5_) + abs($ua);\r\n    const $ub = $z4 + $z8;\r\n    const ub = qaq(z4, z8);\r\n    const ub_ = z4_ + z8_ + abs($ub);\r\n    const $uc = $u9 + $vₓₓ;\r\n    const uc = qaq(u9, vₓₓ);\r\n    const _uc = abs($uc);\r\n    const uc_ = u9_ + vₓₓ_ + _uc;\r\n    const $ud = $ua + $vₓᵧ;\r\n    const ud = qaq(ua, vₓᵧ);\r\n    const _ud = abs($ud);\r\n    const ud_ = ua_ + vₓᵧ_ + _ud;\r\n    const $ue = $ub + $vᵧᵧ;\r\n    const ue = qaq(ub, vᵧᵧ);\r\n    const _ue = abs($ue);\r\n    const ue_ = ub_ + vᵧᵧ_ + _ue;\r\n    const $uf = $c1c1 * $uc;\r\n    const uf = qmq(c1c1, uc);\r\n    const uf_ = c1c1_ * _uc + _c1c1 * uc_ + 2 * abs($uf);\r\n    const $ug = $c1d1 * $ud;\r\n    const ug = qmq(c1d1, ud);\r\n    const ug_ = c1d1_ * _ud + _c1d1 * ud_ + 2 * abs($ug);\r\n    const $uh = $d1d1 * $ue;\r\n    const uh = qmq(d1d1, ue);\r\n    const uh_ = d1d1_ * _ue + _d1d1 * ue_ + 2 * abs($uh);\r\n    const $ui = $uf + $ug;\r\n    const ui = qaq(uf, ug);\r\n    const ui_ = uf_ + ug_ + abs($ui);\r\n    const $v2 = $ui + $uh;\r\n    const v2 = qaq(ui, uh);\r\n    const v2_ = ui_ + uh_ + abs($v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    const $uj = 2 * ($z3 + $vₓₓ);\r\n    const uj = qm2(qaq(z3, vₓₓ));\r\n    const uj_ = 2 * (z3_ + vₓₓ_) + abs($uj);\r\n    const $uk = 2 * ($z4 + $vᵧᵧ);\r\n    const uk = qm2(qaq(z4, vᵧᵧ));\r\n    const uk_ = 2 * (z4_ + vᵧᵧ_) + abs($uk);\r\n    const $un = $z7 + $uj;\r\n    const un = qaq(z7, uj);\r\n    const _un = abs($un);\r\n    const un_ = z7_ + uj_ + _un;\r\n    const $uo = $z8 + $uk;\r\n    const uo = qaq(z8, uk);\r\n    const _uo = abs($uo);\r\n    const uo_ = z8_ + uk_ + _uo;\r\n    const $up = $z2 + $vₓᵧ;\r\n    const up = qaq(z2, vₓᵧ);\r\n    const _up = abs($up);\r\n    const up_ = z2_ + vₓᵧ_ + _up;\r\n    const $uq = $z5 + $vₓᵧ;\r\n    const uq = qaq(z5, vₓᵧ);\r\n    const _uq = abs($uq);\r\n    const uq_ = z5_ + vₓᵧ_ + _uq;\r\n    const $ur = $c0c1 * $un;\r\n    const ur = qmq(c0c1, un);\r\n    const ur_ = c0c1_ * _un + _c0c1 * un_ + 2 * abs($ur);\r\n    const $us = $d0d1 * $uo;\r\n    const us = qmq(d0d1, uo);\r\n    const us_ = d0d1_ * _uo + _d0d1 * uo_ + 2 * abs($us);\r\n    const $ut = $c0d1 * $up;\r\n    const ut = qmq(c0d1, up);\r\n    const ut_ = c0d1_ * _up + _c0d1 * up_ + 2 * abs($ut);\r\n    const $uu = $c1d0 * $uq;\r\n    const uu = qmq(c1d0, uq);\r\n    const uu_ = c1d0_ * _uq + _c1d0 * uq_ + 2 * abs($uu);\r\n    const $uv = $c1 * $vₓ;\r\n    const uv = qmq(c1, vₓ);\r\n    const uv_ = _c1 * vₓ_ + 2 * abs($uv);\r\n    const $uw = $d1 * $vᵧ;\r\n    const uw = qmq(d1, vᵧ);\r\n    const uw_ = _d1 * vᵧ_ + 2 * abs($uw);\r\n    const $ux = $ur + $us;\r\n    const ux = qaq(ur, us);\r\n    const ux_ = ur_ + us_ + abs($ux);\r\n    const $uy = $ut + $uu;\r\n    const uy = qaq(ut, uu);\r\n    const uy_ = ut_ + uu_ + abs($uy);\r\n    const $uz = $ux + $uy;\r\n    const uz = qaq(ux, uy);\r\n    const uz_ = ux_ + uy_ + abs($uz);\r\n    const $u0 = $uv + $uw;\r\n    const u0 = qaq(uv, uw);\r\n    const u0_ = uv_ + uw_ + abs($u0);\r\n    const $v1 = $uz + $u0;\r\n    const v1 = qaq(uz, u0);\r\n    const v1_ = uz_ + u0_ + abs($v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //const v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    const $f1 = $z1 + $z3;\r\n    const f1 = qaq(z1, z3);\r\n    const f1_ = z1_ + z3_ + abs($f1);\r\n    const $f2 = $z6 + $z4;\r\n    const f2 = qaq(z6, z4);\r\n    const f2_ = z6_ + z4_ + abs($f2);\r\n    const $f3 = $f1 + $vₓₓ;\r\n    const f3 = qaq(f1, vₓₓ);\r\n    const _f3 = abs($f3);\r\n    const f3_ = f1_ + vₓₓ_ + _f3;\r\n    const $f4 = $f2 + $vᵧᵧ;\r\n    const f4 = qaq(f2, vᵧᵧ);\r\n    const _f4 = abs($f4);\r\n    const f4_ = f2_ + vᵧᵧ_ + _f4;\r\n    const $f5 = $c0c0 * $f3;\r\n    const f5 = qmq(c0c0, f3);\r\n    const f5_ = _c0c0 * f3_ + 2 * abs($f5);\r\n    const $f6 = $d0d0 * $f4;\r\n    const f6 = qmq(d0d0, f4);\r\n    const f6_ = _d0d0 * f4_ + 2 * abs($f6);\r\n    const $f7 = $c0d0 * $vₓᵧ;\r\n    const f7 = qmq(c0d0, vₓᵧ);\r\n    const f7_ = _c0d0 * vₓᵧ_ + 2 * abs($f7);\r\n    const $f8 = $f5 + $f6;\r\n    const f8 = qaq(f5, f6);\r\n    const f8_ = f5_ + f6_ + abs($f8);\r\n    const $f9 = $f8 + $f7;\r\n    const f9 = qaq(f8, f7);\r\n    const f9_ = f8_ + f7_ + abs($f9);\r\n    const $fa = c0 * $vₓ;\r\n    const fa = qmd(c0, vₓ);\r\n    const fa_ = _c0 * vₓ_ + abs($fa);\r\n    const $fb = d0 * $vᵧ;\r\n    const fb = qmd(d0, vᵧ);\r\n    const fb_ = _d0 * vᵧ_ + abs($fb);\r\n    const $fc = $fa + $fb;\r\n    const fc = qaq(fa, fb);\r\n    const fc_ = fa_ + fb_ + abs($fc);\r\n    const $fd = $f9 + $fc;\r\n    const fd = qaq(f9, fc);\r\n    const fd_ = f9_ + fc_ + abs($fd);\r\n    const $v0 = $fd + $v;\r\n    const v0 = qaq(fd, v);\r\n    const v0_ = fd_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez2Dd: () => (/* binding */ getCoeffsBez3Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez2Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\r\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\r\n    const $vₓₓₓ = vₓₓₓ[1];\r\n    const $vₓₓᵧ = vₓₓᵧ[1];\r\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓₓ = abs($vₓₓₓ);\r\n    const _vₓₓᵧ = abs($vₓₓᵧ);\r\n    const _vₓᵧᵧ = abs($vₓᵧᵧ);\r\n    const _vᵧᵧᵧ = abs($vᵧᵧᵧ);\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d2d2 = $d2 * $d2;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const c0c1_ = abs($c0c1);\r\n    const c0c2 = qmd(c0, c2);\r\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * abs($c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const c1c2_ = _c1 * c2_ + 2 * abs($c1c2);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = _c1 * d2_ + 2 * abs($c1d2);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const c2c2_ = 2 * (c2_ * _c2 + abs($c2c2));\r\n    const c2d0 = qmd(d0, c2);\r\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const d0d1_ = abs($d0d1);\r\n    const d0d2 = qmd(d0, d2);\r\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * abs($d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const d1d2_ = _d1 * d2_ + 2 * abs($d1d2);\r\n    const d2d2 = qmq(d2, d2);\r\n    const d2d2_ = 2 * (d2_ * _d2 + abs($d2d2));\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0c1 = abs($c0c1);\r\n    const _c0d0 = abs($c0d0);\r\n    const _c0d1 = abs($c0d1);\r\n    const _c1c2 = abs($c1c2);\r\n    const _c2c2 = abs($c2c2);\r\n    const _c2d2 = abs($c2d2);\r\n    const _c1d0 = abs($c1d0);\r\n    const _d0d0 = abs($d0d0);\r\n    const _d0d1 = abs($d0d1);\r\n    const _d1d2 = abs($d1d2);\r\n    const _d2d2 = abs($d2d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //const v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    const e1 = qmq(c2, vₓₓₓ);\r\n    const $e1 = $c2 * $vₓₓₓ;\r\n    const e1_ = c2_ * _vₓₓₓ + _c2 * vₓₓₓ_ + 2 * abs($e1);\r\n    const e2 = qmq(c2, vₓᵧᵧ);\r\n    const $e2 = $c2 * $vₓᵧᵧ;\r\n    const e2_ = c2_ * _vₓᵧᵧ + _c2 * vₓᵧᵧ_ + 2 * abs($e2);\r\n    const e3 = qmq(d2, vₓₓᵧ);\r\n    const $e3 = $d2 * $vₓₓᵧ;\r\n    const e3_ = d2_ * _vₓₓᵧ + _d2 * vₓₓᵧ_ + 2 * abs($e3);\r\n    const e4 = qmq(d2, vᵧᵧᵧ);\r\n    const $e4 = $d2 * $vᵧᵧᵧ;\r\n    const e4_ = d2_ * _vᵧᵧᵧ + _d2 * vᵧᵧᵧ_ + 2 * abs($e4);\r\n    const $e5 = $e1 + $e3;\r\n    const e5 = qaq(e1, e3);\r\n    const _e5 = abs($e5);\r\n    const e5_ = e1_ + e3_ + _e5;\r\n    const $e6 = $e2 + $e4;\r\n    const e6 = qaq(e2, e4);\r\n    const _e6 = abs($e6);\r\n    const e6_ = e2_ + e4_ + _e6;\r\n    const $e7 = $c2c2 * $e5;\r\n    const e7 = qmq(c2c2, e5);\r\n    const e7_ = c2c2_ * _e5 + _c2c2 * e5_ + 2 * abs($e7);\r\n    const $e8 = $d2d2 * $e6;\r\n    const e8 = qmq(d2d2, e6);\r\n    const e8_ = d2d2_ * _e6 + _d2d2 * e6_ + 2 * abs($e8);\r\n    const $v6 = $e7 + $e8;\r\n    const v6 = qaq(e7, e8);\r\n    const v6_ = e7_ + e8_ + abs($v6);\r\n    ///\r\n    const $z1 = $c0c2 + $c1c1;\r\n    const z1 = qaq(c0c2, c1c1);\r\n    const _z1 = abs($z1);\r\n    const z1_ = c0c2_ + c1c1_ + _z1;\r\n    const $z2 = $d0d2 + $d1d1;\r\n    const z2 = qaq(d0d2, d1d1);\r\n    const _z2 = abs($z2);\r\n    const z2_ = d0d2_ + d1d1_ + _z2;\r\n    const $z3 = 2 * $c0c2 + $c1c1;\r\n    const _z3 = abs($z3);\r\n    const z3 = qaq(qm2(c0c2), c1c1);\r\n    const z3_ = 2 * c0c2_ + c1c1_ + _z3;\r\n    const $z4 = 2 * $d0d2 + $d1d1;\r\n    const z4 = qaq(qm2(d0d2), d1d1);\r\n    const _z4 = abs($z4);\r\n    const z4_ = 2 * d0d2_ + d1d1_ + _z4;\r\n    const $z5 = 2 * $c1d1 + $c2d0;\r\n    const z5 = qaq(qm2(c1d1), c2d0);\r\n    const _z5 = abs($z5);\r\n    const z5_ = 2 * c1d1_ + c2d0_ + _z5;\r\n    const $z6 = 2 * $c1d1 + $c0d2;\r\n    const z6 = qaq(qm2(c1d1), c0d2);\r\n    const _z6 = abs($z6);\r\n    const z6_ = 2 * c1d1_ + c0d2_ + _z6;\r\n    const $z7 = 2 * $c2d0 + $c1d1;\r\n    const z7 = qaq(qm2(c2d0), c1d1);\r\n    const z7_ = 2 * c2d0_ + c1d1_ + abs($z7);\r\n    const $z8 = 6 * $c0c2 + $c1c1;\r\n    const $q1 = 6 * $c0c2;\r\n    const q1 = qmd(6, c0c2);\r\n    const q1_ = 6 * c0c2_ + abs($q1);\r\n    const z8 = qaq(q1, c1c1);\r\n    const z8_ = q1_ + c1c1_ + abs($q1 + $c1c1);\r\n    const $z9 = 6 * $d0d2 + $d1d1;\r\n    const $q2 = 6 * $d0d2;\r\n    const q2 = qmd(6, d0d2);\r\n    const q2_ = 6 * d0d2_ + abs($q2);\r\n    const z9 = qaq(q2, d1d1);\r\n    const z9_ = q2_ + d1d1_ + abs($q2 + $d1d1);\r\n    const $za = $c1d2 + $c2d1;\r\n    const za = qaq(c1d2, c2d1);\r\n    const _za = abs($za);\r\n    const za_ = c1d2_ + c2d1_ + _za;\r\n    const $zb = $c0d2 + $c2d0;\r\n    const zb = qaq(c0d2, c2d0);\r\n    const zb_ = c0d2_ + c2d0_ + abs($zb);\r\n    const $zc = 2 * $c1d0 + $c0d1;\r\n    const zc = qaq(qm2(c1d0), c0d1);\r\n    const zc_ = 2 * c1d0_ + c0d1_ + abs($zc);\r\n    const $zd = 2 * $c0d1 + $c1d0;\r\n    const zd = qaq(qm2(c0d1), c1d0);\r\n    const zd_ = 2 * c0d1_ + c1d0_ + abs($zd);\r\n    const $zf = $c0d2 + $c1d1;\r\n    const zf = qaq(c0d2, c1d1);\r\n    const zf_ = c0d2_ + c1d1_ + abs($zf);\r\n    const $ze = $zf + $c2d0;\r\n    const ze = qaq(zf, c2d0);\r\n    const _ze = abs($ze);\r\n    const ze_ = zf_ + c2d0_ + _ze;\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //const v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    const $s0 = 3 * $c2c2;\r\n    const s0 = qmd(3, c2c2);\r\n    const s0_ = 3 * c2c2_ + abs($s0);\r\n    const _s0 = abs($s0);\r\n    const $t1 = 3 * $d2d2;\r\n    const t1 = qmd(3, d2d2);\r\n    const t1_ = 3 * d2d2_ + abs($t1);\r\n    const _t1 = abs($t1);\r\n    const $s1 = $s0 * $vₓₓₓ;\r\n    const s1 = qmq(s0, vₓₓₓ);\r\n    const s1_ = s0_ * _vₓₓₓ + _s0 * vₓₓₓ_ + 2 * abs($s1);\r\n    const $s2 = $c2c2 * $vₓₓᵧ;\r\n    const s2 = qmq(c2c2, vₓₓᵧ);\r\n    const s2_ = c2c2_ * _vₓₓᵧ + _c2c2 * vₓₓᵧ_ + 2 * abs($s2);\r\n    const $s3 = 2 * $c2d2 * $vₓₓᵧ;\r\n    const s3 = qm2(qmq(c2d2, vₓₓᵧ));\r\n    const s3_ = 2 * (c2d2_ * _vₓₓᵧ + _c2d2 * vₓₓᵧ_ + abs($s3));\r\n    const $s4 = 2 * $c2d2 * $vₓᵧᵧ;\r\n    const s4 = qm2(qmq(c2d2, vₓᵧᵧ));\r\n    const s4_ = 2 * (c2d2_ * _vₓᵧᵧ + _c2d2 * vₓᵧᵧ_ + abs($s4));\r\n    const $s5 = $d2d2 * $vₓᵧᵧ;\r\n    const s5 = qmq(d2d2, vₓᵧᵧ);\r\n    const s5_ = d2d2_ * _vₓᵧᵧ + _d2d2 * vₓᵧᵧ_ + 2 * abs($s5);\r\n    const $s6 = $t1 * $vᵧᵧᵧ;\r\n    const s6 = qmq(t1, vᵧᵧᵧ);\r\n    const s6_ = t1_ * _vᵧᵧᵧ + _t1 * vᵧᵧᵧ_ + 2 * abs($s6);\r\n    const $s7 = $s1 + $s3;\r\n    const s7 = qaq(s1, s3);\r\n    const s7_ = s1_ + s3_ + abs($s7);\r\n    const $s8 = $s2 + $s4;\r\n    const s8 = qaq(s2, s4);\r\n    const s8_ = s2_ + s4_ + abs($s8);\r\n    const $s9 = $s7 + $s5;\r\n    const s9 = qaq(s7, s5);\r\n    const s9_ = s7_ + s5_ + abs($s9);\r\n    const $sa = $s8 + $s6;\r\n    const sa = qaq(s8, s6);\r\n    const sa_ = s8_ + s6_ + abs($sa);\r\n    const $sb = $c1 * $s9;\r\n    const sb = qmq(c1, s9);\r\n    const sb_ = _c1 * s9_ + abs($sb);\r\n    const $sc = $d1 * $sa;\r\n    const sc = qmq(d1, sa);\r\n    const sc_ = _d1 * sa_ + abs($sc);\r\n    const $v5 = $sb + $sc;\r\n    const v5 = qaq(sb, sc);\r\n    const v5_ = sb_ + sc_ + abs($v5);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //const v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //const v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    const $sd = $d2 * $z3;\r\n    const sd = qmq(d2, z3);\r\n    const sd_ = d2_ * _z3 + _d2 * z3_ + 2 * abs($sd);\r\n    const $se = $d2 * $z6;\r\n    const se = qmq(d2, z6);\r\n    const se_ = d2_ * _z6 + _d2 * z6_ + 2 * abs($se);\r\n    const $sf = $c2 * $z5;\r\n    const sf = qmq(c2, z5);\r\n    const sf_ = c2_ * _z5 + _c2 * z5_ + 2 * abs($sf);\r\n    const $sg = $c2 * $z4;\r\n    const sg = qmq(c2, z4);\r\n    const sg_ = c2_ * _z4 + _c2 * z4_ + 2 * abs($sg);\r\n    const $q3 = 3 * $c2;\r\n    const q3 = qmd(3, c2);\r\n    const _q3 = abs($q3);\r\n    const q3_ = 3 * c2_ + _q3;\r\n    const $sh = $q3 * $z1;\r\n    const sh = qmq(q3, z1);\r\n    const _sh = abs($sh);\r\n    const sh_ = q3_ * _z1 + _q3 * z1_ + _sh;\r\n    const $q4 = 3 * $d2;\r\n    const q4 = qmd(3, d2);\r\n    const _q4 = abs($q4);\r\n    const q4_ = 3 * d2_ + _q4;\r\n    const $si = $q4 * $z2;\r\n    const si = qmq(q4, z2);\r\n    const _si = abs($si);\r\n    const si_ = q4_ * _z2 + _q4 * z2_ + _si;\r\n    const $sj = $sd + $sf;\r\n    const sj = qaq(sd, sf);\r\n    const _sj = abs($sj);\r\n    const sj_ = sd_ + sf_ + _sj;\r\n    const $sk = $se + $sg;\r\n    const sk = qaq(se, sg);\r\n    const _sk = abs($sk);\r\n    const sk_ = se_ + sg_ + _sk;\r\n    const $sl = $sh * $vₓₓₓ;\r\n    const sl = qmq(sh, vₓₓₓ);\r\n    const sl_ = sh_ * _vₓₓₓ + _sh * vₓₓₓ_ + 2 * abs($sl);\r\n    const $sm = $si * $vᵧᵧᵧ;\r\n    const sm = qmq(si, vᵧᵧᵧ);\r\n    const sm_ = si_ * _vᵧᵧᵧ + _si * vᵧᵧᵧ_ + 2 * abs($sm);\r\n    const $sn = $sj * $vₓₓᵧ;\r\n    const sn = qmq(sj, vₓₓᵧ);\r\n    const sn_ = sj_ * _vₓₓᵧ + _sj * vₓₓᵧ_ + 2 * abs($sn);\r\n    const $so = $sk * $vₓᵧᵧ;\r\n    const so = qmq(sk, vₓᵧᵧ);\r\n    const so_ = sk_ * _vₓᵧᵧ + _sk * vₓᵧᵧ_ + 2 * abs($so);\r\n    const $sp = $sl + $sm;\r\n    const sp = qaq(sl, sm);\r\n    const sp_ = sl_ + sm_ + abs($sp);\r\n    const $sq = $sn + $so;\r\n    const sq = qaq(sn, so);\r\n    const sq_ = sn_ + so_ + abs($sq);\r\n    const $sr = $c2c2 * $vₓₓ;\r\n    const sr = qmq(c2c2, vₓₓ);\r\n    const sr_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * abs($sr);\r\n    const $ss = $d2d2 * $vᵧᵧ;\r\n    const ss = qmq(d2d2, vᵧᵧ);\r\n    const ss_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * abs($ss);\r\n    const $st = $c2d2 * $vₓᵧ;\r\n    const st = qmq(c2d2, vₓᵧ);\r\n    const st_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * abs($st);\r\n    const $su = $sr + $ss;\r\n    const su = qaq(sr, ss);\r\n    const su_ = sr_ + ss_ + abs($su);\r\n    const $sv = $sp + $sq;\r\n    const sv = qaq(sp, sq);\r\n    const sv_ = sp_ + sq_ + abs($sv);\r\n    const $sw = $su + $st;\r\n    const sw = qaq(su, st);\r\n    const sw_ = su_ + st_ + abs($sw);\r\n    const $v4 = $sv + $sw;\r\n    const v4 = qaq(sv, sw);\r\n    const v4_ = sv_ + sw_ + abs($v4);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //const v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    const $sx = $c1 * $z8;\r\n    const sx = qmq(c1, z8);\r\n    const _sx = _c1 * z8_ + 2 * abs($sx);\r\n    const sx_ = 2 * _sx;\r\n    const $sy = $d1 * $z9;\r\n    const sy = qmq(d1, z9);\r\n    const _sy = _d1 * z9_ + 2 * abs($sy);\r\n    const sy_ = 2 * _sy;\r\n    const $sz = 2 * c0 * $za;\r\n    const sz = qmd(2 * c0, za);\r\n    const sz_ = 2 * _c0 * za_ + abs($sz);\r\n    const $o1 = 2 * $d1 * $zb;\r\n    const o1 = qmq(qm2(d1), zb);\r\n    const o1_ = 2 * _d1 * zb_ + 2 * abs($o1);\r\n    const $o2 = $c1 * $z7;\r\n    const o2 = qmq(c1, z7);\r\n    const o2_ = _c1 * z7_ + 2 * abs($o2);\r\n    const $o3 = $c1 * $z4;\r\n    const o3 = qmq(c1, z4);\r\n    const o3_ = _c1 * z4_ + 2 * abs($o3);\r\n    const $o4 = $sz + $o2;\r\n    const o4 = qaq(sz, o2);\r\n    const _o4 = sz_ + o2_ + abs($o4);\r\n    const o4_ = sz_ + o2_ + _o4;\r\n    const $o5 = $o1 + $o3;\r\n    const o5 = qaq(o1, o3);\r\n    const _o5 = o1_ + o3_ + abs($o5);\r\n    const o5_ = o1_ + o3_ + _o5;\r\n    const $o6 = $d1d2 * $vᵧᵧ;\r\n    const o6 = qmq(d1d2, vᵧᵧ);\r\n    const o6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * abs($o6);\r\n    const $o7 = $c1c2 * $vₓₓ;\r\n    const o7 = qmq(c1c2, vₓₓ);\r\n    const o7_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * abs($o7);\r\n    const $o8 = $za * $vₓᵧ;\r\n    const o8 = qmq(za, vₓᵧ);\r\n    const o8_ = za_ * _vₓᵧ + _za * vₓᵧ_ + 2 * abs($o8);\r\n    const $o9 = $o6 + $o7;\r\n    const o9 = qaq(o6, o7);\r\n    const o9_ = o6_ + o7_ + abs($o9);\r\n    const $oa = $sx * $vₓₓₓ;\r\n    const oa = qmq(sx, vₓₓₓ);\r\n    const oa_ = sx_ * _vₓₓₓ + _sx * vₓₓₓ_ + 2 * abs($oa);\r\n    const $ob = $o4 * $vₓₓᵧ;\r\n    const ob = qmq(o4, vₓₓᵧ);\r\n    const ob_ = o4_ * _vₓₓᵧ + _o4 * vₓₓᵧ_ + 2 * abs($ob);\r\n    const $oc = $sy * $vᵧᵧᵧ;\r\n    const oc = qmq(sy, vᵧᵧᵧ);\r\n    const oc_ = sy_ * _vᵧᵧᵧ + _sy * vᵧᵧᵧ_ + 2 * abs($oc);\r\n    const $od = $o5 * $vₓᵧᵧ;\r\n    const od = qmq(o5, vₓᵧᵧ);\r\n    const od_ = o5_ * _vₓᵧᵧ + _o5 * vₓᵧᵧ_ + 2 * abs($od);\r\n    const $oe = $oa + $oc;\r\n    const oe = qaq(oa, oc);\r\n    const oe_ = oa_ + oc_ + abs($oe);\r\n    const $og = $ob + $od;\r\n    const og = qaq(ob, od);\r\n    const og_ = ob_ + od_ + abs($og);\r\n    const $oh = $oe + $og;\r\n    const oh = qaq(oe, og);\r\n    const oh_ = oe_ + og_ + abs($oh);\r\n    const $oi = 2 * $o9 + $o8;\r\n    const oi = qaq(qm2(o9), o8);\r\n    const oi_ = 2 * o9_ + o8_ + abs($oi);\r\n    const $v3 = $oh + $oi;\r\n    const v3 = qaq(oh, oi);\r\n    const v3_ = oh_ + oi_ + abs($v3);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    //const v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    const $q5 = 3 * c0;\r\n    const _q5 = abs($q5);\r\n    const q5 = tp(3, c0); // error free\r\n    const $oj = $q5 * $z1;\r\n    const oj = qmq(q5, z1);\r\n    const _oj = abs($oj);\r\n    const oj_ = _q5 * z1_ + 2 * abs($oj);\r\n    const $q6 = 3 * d0;\r\n    const _q6 = abs($q6);\r\n    const q6 = tp(3, d0); // error free\r\n    const $ok = $q6 * $z2;\r\n    const ok = qmq(q6, z2);\r\n    const _ok = abs($ok);\r\n    const ok_ = _q6 * z2_ + 2 * abs($ok);\r\n    const $ol = c0 * $z6;\r\n    const ol = qmd(c0, z6);\r\n    const ol_ = _c0 * z6_ + abs($ol);\r\n    const $om = c0 * $z4;\r\n    const om = qmd(c0, z4);\r\n    const om_ = _c0 * z4_ + abs($om);\r\n    const $on = d0 * $z3;\r\n    const on = qmd(d0, z3);\r\n    const on_ = _d0 * z3_ + abs($on);\r\n    const $oo = d0 * $z5;\r\n    const oo = qmd(d0, z5);\r\n    const oo_ = _d0 * z5_ + abs($oo);\r\n    const $op = $ol + $on;\r\n    const op = qaq(ol, on);\r\n    const _op = abs($op);\r\n    const op_ = ol_ + on_ + _op;\r\n    const $oq = $om + $oo;\r\n    const oq = qaq(om, oo);\r\n    const _oq = abs($oq);\r\n    const oq_ = om_ + oo_ + _oq;\r\n    const $or = $oj * $vₓₓₓ;\r\n    const or = qmq(oj, vₓₓₓ);\r\n    const or_ = oj_ * _vₓₓₓ + _oj * vₓₓₓ_ + 2 * abs($or);\r\n    const $os = $ok * $vᵧᵧᵧ;\r\n    const os = qmq(ok, vᵧᵧᵧ);\r\n    const os_ = ok_ * _vᵧᵧᵧ + _ok * vᵧᵧᵧ_ + 2 * abs($os);\r\n    const $ot = $op * $vₓₓᵧ;\r\n    const ot = qmq(op, vₓₓᵧ);\r\n    const ot_ = op_ * _vₓₓᵧ + _op * vₓₓᵧ_ + 2 * abs($ot);\r\n    const $ou = $oq * $vₓᵧᵧ;\r\n    const ou = qmq(oq, vₓᵧᵧ);\r\n    const ou_ = oq_ * _vₓᵧᵧ + _oq * vₓᵧᵧ_ + 2 * abs($ou);\r\n    const $ov = $z3 * $vₓₓ;\r\n    const ov = qmq(z3, vₓₓ);\r\n    const ov_ = z3_ * _vₓₓ + _z3 * vₓₓ_ + 2 * abs($ov);\r\n    const $ow = $z4 * $vᵧᵧ;\r\n    const ow = qmq(z4, vᵧᵧ);\r\n    const ow_ = z4_ * _vᵧᵧ + _z4 * vᵧᵧ_ + 2 * abs($ow);\r\n    const $ox = $ze * $vₓᵧ;\r\n    const ox = qmq(ze, vₓᵧ);\r\n    const ox_ = ze_ * _vₓᵧ + _ze * vₓᵧ_ + 2 * abs($ox);\r\n    const $oy = $c2 * $vₓ;\r\n    const oy = qmq(c2, vₓ);\r\n    const oy_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * abs($oy);\r\n    const $oz = $d2 * $vᵧ;\r\n    const oz = qmq(d2, vᵧ);\r\n    const oz_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * abs($oz);\r\n    const $p1 = $or + $os;\r\n    const p1 = qaq(or, os);\r\n    const p1_ = or_ + os_ + abs($p1);\r\n    const $p2 = $ot + $ou;\r\n    const p2 = qaq(ot, ou);\r\n    const p2_ = ot_ + ou_ + abs($p2);\r\n    const $p3 = $ov + $ow;\r\n    const p3 = qaq(ov, ow);\r\n    const p3_ = ov_ + ow_ + abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $p5 = $p3 + $ox;\r\n    const p5 = qaq(p3, ox);\r\n    const p5_ = p3_ + ox_ + abs($p5);\r\n    const $p6 = $oy + $oz;\r\n    const p6 = qaq(oy, oz);\r\n    const p6_ = oy_ + oz_ + abs($p6);\r\n    const $p7 = $p4 + $p5;\r\n    const p7 = qaq(p4, p5);\r\n    const p7_ = p4_ + p5_ + abs($p7);\r\n    const $v2 = $p7 + $p6;\r\n    const v2 = qaq(p7, p6);\r\n    const v2_ = p7_ + p6_ + abs($v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    const $p8 = $q5 * $c0c1;\r\n    const p8 = qmq(q5, c0c1);\r\n    const _p8 = abs($p8);\r\n    const p8_ = _q5 * c0c1_ + 2 * _p8;\r\n    const $p9 = $q6 * $d0d1;\r\n    const p9 = qmq(q6, d0d1);\r\n    const _p9 = abs($p9);\r\n    const p9_ = _q6 * d0d1_ + 2 * _p9;\r\n    const $pa = c0 * $zc;\r\n    const pa = qmd(c0, zc);\r\n    const _pa = abs($pa);\r\n    const pa_ = _c0 * zc_ + abs($pa);\r\n    const $pb = d0 * $zd;\r\n    const pb = qmd(d0, zd);\r\n    const _pb = abs($pb);\r\n    const pb_ = _d0 * zd_ + abs($pb);\r\n    const $pc = $c0c1 * $vₓₓ;\r\n    const pc = qmq(c0c1, vₓₓ);\r\n    const pc_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($pc);\r\n    const $pd = $d0d1 * $vᵧᵧ;\r\n    const pd = qmq(d0d1, vᵧᵧ);\r\n    const pd_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($pd);\r\n    const $pe = $c0d1 * $vₓᵧ;\r\n    const pe = qmq(c0d1, vₓᵧ);\r\n    const pe_ = c0d1_ * _vₓᵧ + _c0d1 * vₓᵧ_ + 2 * abs($pe);\r\n    const $pf = $c1d0 * $vₓᵧ;\r\n    const pf = qmq(c1d0, vₓᵧ);\r\n    const pf_ = c1d0_ * _vₓᵧ + _c1d0 * vₓᵧ_ + 2 * abs($pf);\r\n    const $pg = 2 * ($pc + $pd);\r\n    const pg = qm2(qaq(pc, pd));\r\n    const pg_ = 2 * (pc_ + pd_) + abs($pg);\r\n    const $ph = $pe + $pf;\r\n    const ph = qaq(pe, pf);\r\n    const ph_ = pe_ + pf_ + abs($ph);\r\n    const $pi = $c1 * $vₓ;\r\n    const pi = qmq(c1, vₓ);\r\n    const pi_ = _c1 * vₓ_ + 2 * abs($pi);\r\n    const $pj = $d1 * $vᵧ;\r\n    const pj = qmq(d1, vᵧ);\r\n    const pj_ = _d1 * vᵧ_ + 2 * abs($pj);\r\n    const $pk = $p8 * $vₓₓₓ;\r\n    const pk = qmq(p8, vₓₓₓ);\r\n    const pk_ = p8_ * _vₓₓₓ + _p8 * vₓₓₓ_ + 2 * abs($pk);\r\n    const $pl = $p9 * $vᵧᵧᵧ;\r\n    const pl = qmq(p9, vᵧᵧᵧ);\r\n    const pl_ = p9_ * _vᵧᵧᵧ + _p9 * vᵧᵧᵧ_ + 2 * abs($pl);\r\n    const $pm = $pa * $vₓₓᵧ;\r\n    const pm = qmq(pa, vₓₓᵧ);\r\n    const pm_ = pa_ * _vₓₓᵧ + _pa * vₓₓᵧ_ + 2 * abs($pm);\r\n    const $pn = $pb * $vₓᵧᵧ;\r\n    const pn = qmq(pb, vₓᵧᵧ);\r\n    const pn_ = pb_ * _vₓᵧᵧ + _pb * vₓᵧᵧ_ + 2 * abs($pn);\r\n    const $po = $pk + $pl;\r\n    const po = qaq(pk, pl);\r\n    const po_ = pk_ + pl_ + abs($po);\r\n    const $pp = $pm + $pn;\r\n    const pp = qaq(pm, pn);\r\n    const pp_ = pm_ + pn_ + abs($pp);\r\n    const $pq = $po + $pp;\r\n    const pq = qaq(po, pp);\r\n    const pq_ = po_ + pp_ + abs($pq);\r\n    const $pr = $pg + $ph;\r\n    const pr = qaq(pg, ph);\r\n    const pr_ = pg_ + ph_ + abs($pr);\r\n    const $ps = $pi + $pj;\r\n    const ps = qaq(pi, pj);\r\n    const ps_ = pi_ + pj_ + abs($ps);\r\n    const $pt = $pq + $pr;\r\n    const pt = qaq(pq, pr);\r\n    const pt_ = pq_ + pr_ + abs($pt);\r\n    const $v1 = $pt + $ps;\r\n    const v1 = qaq(pt, ps);\r\n    const v1_ = pt_ + ps_ + abs($v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const $pu = c0 * $vₓₓₓ;\r\n    const pu = qmd(c0, vₓₓₓ);\r\n    const pu_ = _c0 * vₓₓₓ_ + abs($pu);\r\n    const $pv = c0 * $vₓᵧᵧ;\r\n    const pv = qmd(c0, vₓᵧᵧ);\r\n    const pv_ = _c0 * vₓᵧᵧ_ + abs($pv);\r\n    const $pw = d0 * $vₓₓᵧ;\r\n    const pw = qmd(d0, vₓₓᵧ);\r\n    const pw_ = _d0 * vₓₓᵧ_ + abs($pw);\r\n    const $px = d0 * $vᵧᵧᵧ;\r\n    const px = qmd(d0, vᵧᵧᵧ);\r\n    const px_ = _d0 * vᵧᵧᵧ_ + abs($px);\r\n    const $py = $pu + $pw;\r\n    const py = qaq(pu, pw);\r\n    const py_ = pu_ + pw_ + abs($py);\r\n    const $pz = $pv + $px;\r\n    const pz = qaq(pv, px);\r\n    const pz_ = pv_ + px_ + abs($pz);\r\n    const $u1 = $py + $vₓₓ;\r\n    const u1 = qaq(py, vₓₓ);\r\n    const _u1 = abs($u1);\r\n    const u1_ = py_ + vₓₓ_ + _u1;\r\n    const $u2 = $pz + $vᵧᵧ;\r\n    const u2 = qaq(pz, vᵧᵧ);\r\n    const _u2 = abs($u2);\r\n    const u2_ = pz_ + vᵧᵧ_ + _u2;\r\n    const $u3 = $c0c0 * $u1;\r\n    const u3 = qmq(c0c0, u1);\r\n    const u3_ = _c0c0 * u1_ + 2 * abs($u3);\r\n    const $u4 = $d0d0 * $u2;\r\n    const u4 = qmq(d0d0, u2);\r\n    const u4_ = _d0d0 * u2_ + 2 * abs($u4);\r\n    const $u5 = $c0d0 * $vₓᵧ;\r\n    const u5 = qmq(c0d0, vₓᵧ);\r\n    const u5_ = _c0d0 * vₓᵧ_ + 2 * abs($u5);\r\n    const $u6 = c0 * $vₓ;\r\n    const u6 = qmd(c0, vₓ);\r\n    const u6_ = _c0 * vₓ_ + abs($u6);\r\n    const $u7 = d0 * $vᵧ;\r\n    const u7 = qmd(d0, vᵧ);\r\n    const u7_ = _d0 * vᵧ_ + abs($u7);\r\n    const $u8 = $u3 + $u4;\r\n    const u8 = qaq(u3, u4);\r\n    const u8_ = u3_ + u4_ + abs($u8);\r\n    const $u9 = $u8 + $u5;\r\n    const u9 = qaq(u8, u5);\r\n    const u9_ = u8_ + u5_ + abs($u9);\r\n    const $ua = $u6 + $u7;\r\n    const ua = qaq(u6, u7);\r\n    const ua_ = u6_ + u7_ + abs($ua);\r\n    const $ub = $u9 + $ua;\r\n    const ub = qaq(u9, ua);\r\n    const ub_ = u9_ + ua_ + abs($ub);\r\n    const $v0 = $ub + $v;\r\n    const v0 = qaq(ub, v);\r\n    const v0_ = ub_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez3Dd: () => (/* binding */ getCoeffsBez3Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 3 bezier curves (i.e. 2 cubic bezier curves).\r\n *\r\n * The returned polynomial degree will be 9\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez3Dd(ps1, ps2) {\r\n    //--------------------------------------------------------------------------\r\n    // `var` -> a variable\r\n    // `$var` -> the double precision approximation to `var`\r\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\r\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\r\n    // `_var_` -> means both absolute value and absolute error bound\r\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\r\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\r\n    // * the returned errors need to be multiplied by 3γ² to get the true error\r\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\r\n    //   due to multiplication by 3*γ² and not 3*u²\r\n    //--------------------------------------------------------------------------\r\n    // examples: (all?)\r\n    // ----------------\r\n    // let qmd === ddMultDouble2, etc.\r\n    //\r\n    // ---------------\r\n    // 1. double-double X by double\r\n    // ---------------\r\n    // qmd(a,b);  // both `a` and `b` is error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + |a*b|\r\n    //                           === |a*b|\r\n    //\r\n    // ---------------\r\n    // 2a. double-double +/- double-double\r\n    // ---------------\r\n    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === _a_ + _b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 2b. double-double +/- double-double\r\n    // ---------------\r\n    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 2*_a + 2*_b + |a+b|\r\n    //                           === 2*(_a + _b) + |a+b| OR\r\n    //                           === a_ + b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 3a. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + 2|a*b|\r\n    //                           === 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` not error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` not error-free and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //                           === a_|b| + 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 4a. double-double +/- double\r\n    // ---------------\r\n    // qad(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 0 + 0 + |a+b|\r\n    //                           === |a+b| \r\n    //--------------------------------------------------------------------------\r\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\r\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\r\n    const $vₓₓₓ = vₓₓₓ[1];\r\n    const $vₓₓᵧ = vₓₓᵧ[1];\r\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓₓ = abs($vₓₓₓ);\r\n    const _vₓₓᵧ = abs($vₓₓᵧ);\r\n    const _vₓᵧᵧ = abs($vₓᵧᵧ);\r\n    const _vᵧᵧᵧ = abs($vᵧᵧᵧ);\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const _v = abs($v);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $c3 = c3[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const $d3 = d3[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _c3 = abs($c3);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const _d3 = abs($d3);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0c3 = c0 * $c3;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c0d3 = c0 * $d3;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1c3 = $c1 * $c3;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c1d3 = $c1 * $d3;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2c3 = $c2 * $c3;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $c2d3 = $c2 * $d3;\r\n    const $c3c3 = $c3 * $c3;\r\n    const $c3d0 = $c3 * d0;\r\n    const $c3d1 = $c3 * $d1;\r\n    const $c3d2 = $c3 * $d2;\r\n    const $c3d3 = $c3 * $d3;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d0d3 = d0 * $d3;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d3d3 = $d3 * $d3;\r\n    const $d2d2 = $d2 * $d2;\r\n    const $d2d3 = $d2 * $d3;\r\n    const $d1d3 = $d1 * $d3;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const c0c1_ = _c0 * c1_ + abs($c0c1);\r\n    const c0c2 = qmd(c0, c2);\r\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\r\n    const c0c3 = qmd(c0, c3);\r\n    const c0c3_ = _c0 * c3_ + abs($c0c3);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = _c0 * d1_ + abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\r\n    const c0d3 = qmd(c0, d3);\r\n    const c0d3_ = _c0 * d3_ + abs($c0d3);\r\n    const c1c1 = qmq(c1, c1);\r\n    const _c1c1 = abs($c1c1);\r\n    const c1c1_ = 2 * (c1_ * _c1 + _c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * abs($c1c2);\r\n    const c1c3 = qmq(c1, c3);\r\n    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * abs($c1c3);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = _d0 * c1_ + abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * abs($c1d2);\r\n    const c1d3 = qmq(c1, d3);\r\n    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * abs($c1d3);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const _c2c2 = abs($c2c2);\r\n    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);\r\n    const c2c3 = qmq(c2, c3);\r\n    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * abs($c2c3);\r\n    const c2d0 = qmd(d0, c2);\r\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\r\n    const c2d3 = qmq(c2, d3);\r\n    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * abs($c2d3);\r\n    const c3c3 = qmq(c3, c3);\r\n    const c3c3_ = 2 * (c3_ * _c3 + abs($c3c3));\r\n    const c3d0 = qmd(d0, c3);\r\n    const c3d0_ = _d0 * c3_ + abs($c3d0);\r\n    const c3d1 = qmq(c3, d1);\r\n    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * abs($c3d1);\r\n    const c3d2 = qmq(c3, d2);\r\n    const _c3d2 = abs($c3d2);\r\n    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * _c3d2;\r\n    const c3d3 = qmq(c3, d3);\r\n    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * abs($c3d3);\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const d0d1_ = _d0 * d1_ + abs($d0d1);\r\n    const d0d2 = qmd(d0, d2);\r\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\r\n    const d0d3 = qmd(d0, d3);\r\n    const d0d3_ = _d0 * d3_ + abs($d0d3);\r\n    const d1d1 = qmq(d1, d1);\r\n    const _d1d1 = abs($d1d1);\r\n    const d1d1_ = 2 * (d1_ * _d1 + _d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * abs($d1d2);\r\n    const d3d3 = qmq(d3, d3);\r\n    const d3d3_ = 2 * (d3_ * _d3 + abs($d3d3));\r\n    const d2d2 = qmq(d2, d2);\r\n    const _d2d2 = abs($d2d2);\r\n    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);\r\n    const d2d3 = qmq(d2, d3);\r\n    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * abs($d2d3);\r\n    const d1d3 = qmq(d1, d3);\r\n    const _d1d3 = abs($d1d3);\r\n    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * _d1d3;\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0c1 = abs($c0c1);\r\n    const _c2c3 = abs($c2c3);\r\n    const _c3c3 = abs($c3c3);\r\n    const _c3d3 = abs($c3d3);\r\n    const _c0d0 = abs($c0d0);\r\n    const _d0d0 = abs($d0d0);\r\n    const _d0d1 = abs($d0d1);\r\n    const _d2d3 = abs($d2d3);\r\n    const _d3d3 = abs($d3d3);\r\n    //-----------------------\r\n    //const v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;\r\n    //-----------------------\r\n    const $g1 = $c3 * $c3c3;\r\n    const g1 = qmq(c3, c3c3);\r\n    const _g1 = _c3 * _c3c3;\r\n    const g1_ = c3_ * _c3c3 + _c3 * c3c3_ + 2 * _g1;\r\n    const $g2 = $c3 * $d3d3;\r\n    const g2 = qmq(c3, d3d3);\r\n    const _g2 = _c3 * _d3d3;\r\n    const g2_ = c3_ * _d3d3 + _c3 * d3d3_ + 2 * _g2;\r\n    const $g3 = $d3 * $c3c3;\r\n    const g3 = qmq(d3, c3c3);\r\n    const _g3 = _d3 * _c3c3;\r\n    const g3_ = d3_ * _c3c3 + _d3 * c3c3_ + 2 * _g3;\r\n    const $g4 = $d3 * $d3d3;\r\n    const g4 = qmq(d3, d3d3);\r\n    const _g4 = _d3 * _d3d3;\r\n    const g4_ = d3_ * _d3d3 + _d3 * d3d3_ + 2 * _g4;\r\n    const $g5 = $g1 * $vₓₓₓ;\r\n    const g5 = qmq(g1, vₓₓₓ);\r\n    const g5_ = g1_ * _vₓₓₓ + _g1 * vₓₓₓ_ + 2 * abs($g5);\r\n    const $g6 = $g2 * $vₓᵧᵧ;\r\n    const g6 = qmq(g2, vₓᵧᵧ);\r\n    const g6_ = g2_ * _vₓᵧᵧ + _g2 * vₓᵧᵧ_ + 2 * abs($g6);\r\n    const $g7 = $g3 * $vₓₓᵧ;\r\n    const g7 = qmq(g3, vₓₓᵧ);\r\n    const g7_ = g3_ * _vₓₓᵧ + _g3 * vₓₓᵧ_ + 2 * abs($g7);\r\n    const $g8 = $g4 * $vᵧᵧᵧ;\r\n    const g8 = qmq(g4, vᵧᵧᵧ);\r\n    const g8_ = g4_ * _vᵧᵧᵧ + _g4 * vᵧᵧᵧ_ + 2 * abs($g8);\r\n    const $g9 = $g5 + $g6;\r\n    const g9 = qaq(g5, g6);\r\n    const g9_ = g5_ + g6_ + abs($g9);\r\n    const $ga = $g7 + $g8;\r\n    const ga = qaq(g7, g8);\r\n    const ga_ = g7_ + g8_ + abs($ga);\r\n    const $v9 = $g9 + $ga;\r\n    const v9 = qaq(g9, ga);\r\n    const v9_ = g9_ + ga_ + abs($v9);\r\n    //-----------------------\r\n    //const v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    //-----------------------\r\n    const $w1 = 2 * $c2d3 + $c3d2;\r\n    const _w1 = abs($w1);\r\n    const w1 = qaq(qm2(c2d3), c3d2);\r\n    const w1_ = 2 * c2d3_ + c3d2_ + _w1;\r\n    const $w2 = 2 * $c3d2 + $c2d3;\r\n    const _w2 = abs($w2);\r\n    const w2 = qaq(qm2(c3d2), c2d3);\r\n    const w2_ = 2 * c3d2_ + c2d3_ + abs($w2);\r\n    const $w3 = $c3 * $w1;\r\n    const _w3 = abs($w3);\r\n    const w3 = qmq(c3, w1);\r\n    const w3_ = c3_ * _w1 + _c3 * w1_ + 2 * _w3;\r\n    const $w4 = $d3 * $w2;\r\n    const _w4 = abs($w4);\r\n    const w4 = qmq(d3, w2);\r\n    const w4_ = d3_ * _w2 + _d3 * w2_ + 2 * _w4;\r\n    const $w5 = $c2 * $c3c3;\r\n    const _w5 = abs($w5);\r\n    const w5 = qmq(c2, c3c3);\r\n    const w5_ = c2_ * _c3c3 + _c2 * c3c3_ + 2 * _w5;\r\n    const $w6 = $d2 * $d3d3;\r\n    const _w6 = abs($w6);\r\n    const w6 = qmq(d2, d3d3);\r\n    const w6_ = d2_ * _d3d3 + _d2 * d3d3_ + 2 * _w6;\r\n    const $w7 = $vₓₓₓ * $w5;\r\n    const w7 = qmq(vₓₓₓ, w5);\r\n    const w7_ = w5_ * _vₓₓₓ + _vₓₓₓ * w5_ + 2 * abs($w7);\r\n    const $u1 = $vᵧᵧᵧ * $w6;\r\n    const u1 = qmq(vᵧᵧᵧ, w6);\r\n    const u1_ = w6_ * _vᵧᵧᵧ + _vᵧᵧᵧ * w6_ + 2 * abs($u1);\r\n    const $u2 = $vₓₓᵧ * $w3;\r\n    const u2 = qmq(vₓₓᵧ, w3);\r\n    const u2_ = w3_ * _vₓₓᵧ + _vₓₓᵧ * w3_ + 2 * abs($u2);\r\n    const $u3 = $vₓᵧᵧ * $w4;\r\n    const u3 = qmq(vₓᵧᵧ, w4);\r\n    const u3_ = w4_ * _vₓᵧᵧ + _vₓᵧᵧ * w4_ + 2 * abs($u3);\r\n    const $u4 = $u2 + $u3;\r\n    const u4 = qaq(u2, u3);\r\n    const u4_ = u2_ + u3_ + abs($u4);\r\n    const $u5 = 3 * ($w7 + $u1);\r\n    const u5 = qmd(3, qaq(w7, u1));\r\n    const u5_ = 3 * (w7_ + u1_) + 2 * abs($u5);\r\n    const $v8 = $u4 + $u5;\r\n    const v8 = qaq(u4, u5);\r\n    const v8_ = u4_ + u5_ + abs($v8);\r\n    //-----------------------\r\n    //const v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    //-----------------------\r\n    const $o1 = $c1 * $c3d3;\r\n    const o1 = qmq(c1, c3d3);\r\n    const o1_ = c1_ * _c3d3 + _c1 * c3d3_ + 2 * abs($o1);\r\n    const $o2 = $d1 * $c3c3;\r\n    const o2 = qmq(d1, c3c3);\r\n    const o2_ = d1_ * _c3c3 + _d1 * c3c3_ + 2 * abs($o2);\r\n    const $o3 = $c2 * $d2d3;\r\n    const o3 = qmq(c2, d2d3);\r\n    const o3_ = c2_ * _d2d3 + _c2 * d2d3_ + 2 * abs($o3);\r\n    const $o4 = $c1 * $d3d3;\r\n    const o4 = qmq(c1, d3d3);\r\n    const o4_ = c1_ * _d3d3 + _c1 * d3d3_ + 2 * abs($o4);\r\n    const $o5 = $c2 * $c3d2;\r\n    const o5 = qmq(c2, c3d2);\r\n    const o5_ = c2_ * _c3d2 + _c2 * c3d2_ + 2 * abs($o5);\r\n    const $o6 = $d3 * $c2c2;\r\n    const o6 = qmq(d3, c2c2);\r\n    const o6_ = d3_ * _c2c2 + _d3 * c2c2_ + 2 * abs($o6);\r\n    const $o7 = $c3 * $d1d3;\r\n    const o7 = qmq(c3, d1d3);\r\n    const o7_ = c3_ * _d1d3 + _c3 * d1d3_ + 2 * abs($o7);\r\n    const $o8 = $d2 * $c3d2;\r\n    const o8 = qmq(d2, c3d2);\r\n    const o8_ = d2_ * _c3d2 + _d2 * c3d2_ + 2 * abs($o8);\r\n    const $w8 = $o1 + $o5;\r\n    const w8 = qaq(o1, o5);\r\n    const w8_ = o1_ + o5_ + abs($w8);\r\n    const $w9 = $o2 + $o6;\r\n    const w9 = qaq(o2, o6);\r\n    const w9_ = o2_ + o6_ + abs($w9);\r\n    const $wa = $o3 + $o7;\r\n    const wa = qaq(o3, o7);\r\n    const wa_ = o3_ + o7_ + abs($wa);\r\n    const $wb = $o4 + $o8;\r\n    const wb = qaq(o4, o8);\r\n    const wb_ = o4_ + o8_ + abs($wb);\r\n    const $wc = $c1c3 + $c2c2;\r\n    const wc = qaq(c1c3, c2c2);\r\n    const _wc = abs($wc);\r\n    const wc_ = c1c3_ + c2c2_ + _wc;\r\n    const $wd = $d1d3 + $d2d2;\r\n    const _wd = abs($wd);\r\n    const wd = qaq(d1d3, d2d2);\r\n    const wd_ = d1d3_ + d2d2_ + _wd;\r\n    const $we = 2 * $w8 + $w9;\r\n    const we = qaq(qm2(w8), w9);\r\n    const _we = abs($we);\r\n    const we_ = 2 * w8_ + w9_ + _we;\r\n    const $wf = 2 * $wa + $wb;\r\n    const wf = qaq(qm2(wa), wb);\r\n    const _wf = abs($wf);\r\n    const wf_ = 2 * wa_ + wb_ + _wf;\r\n    const $wg = $vₓₓᵧ * $we;\r\n    const wg = qmq(vₓₓᵧ, we);\r\n    const wg_ = vₓₓᵧ_ * _we + _vₓₓᵧ * we_ + 2 * abs($wg);\r\n    const $wh = $vₓᵧᵧ * $wf;\r\n    const wh = qmq(vₓᵧᵧ, wf);\r\n    const wh_ = vₓᵧᵧ_ * _wf + _vₓᵧᵧ * wf_ + 2 * abs($wh);\r\n    const $wi = $c3 * $wc;\r\n    const wi = qmq(c3, wc);\r\n    const _wi = abs($wi);\r\n    const wi_ = c3_ * _wc + _c3 * wc_ + 2 * _wi;\r\n    const $wj = $d3 * $wd;\r\n    const wj = qmq(d3, wd);\r\n    const _wj = abs($wj);\r\n    const wj_ = d3_ * _wd + _d3 * wd_ + 2 * _wj;\r\n    const $wk = $vₓₓₓ * $wi;\r\n    const wk = qmq(vₓₓₓ, wi);\r\n    const wk_ = vₓₓₓ_ * _wi + _vₓₓₓ * wi_ + 2 * abs($wk);\r\n    const $wl = $vᵧᵧᵧ * $wj;\r\n    const wl = qmq(vᵧᵧᵧ, wj);\r\n    const wl_ = vᵧᵧᵧ_ * _wj + _vᵧᵧᵧ * wj_ + 2 * abs($wl);\r\n    const $wm = $wg + $wh;\r\n    const wm = qaq(wg, wh);\r\n    const wm_ = wg_ + wh_ + abs($wm);\r\n    const $wn = 3 * ($wk + $wl);\r\n    const wn = qmd(3, qaq(wk, wl));\r\n    const wn_ = 3 * (wk_ + wl_) + 2 * abs($wn);\r\n    const $v7 = $wm + $wn;\r\n    const v7 = qaq(wm, wn);\r\n    const v7_ = wm_ + wn_ + abs($v7);\r\n    //const v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    const $wo = $c2d3 + $c3d2;\r\n    const wo = qaq(c2d3, c3d2);\r\n    const _wo = abs($wo);\r\n    const wo_ = c2d3_ + c3d2_ + _wo;\r\n    const $zc = $d2 * $c2c2;\r\n    const zc = qmq(d2, c2c2);\r\n    const zc_ = d2_ * _c2c2 + _d2 * c2c2_ + 2 * abs($zc);\r\n    const $zd = 2 * $c1 * $wo;\r\n    const zd = qm2(qmq(c1, wo));\r\n    const zd_ = 2 * (c1_ * _wo + _c1 * wo_ + 2 * abs($zd));\r\n    const $wp = $zc + $zd;\r\n    const wp = qaq(zc, zd);\r\n    const wp_ = zc_ + zd_ + abs($wp);\r\n    const $wq = 2 * ($c0d3 + $c2d1);\r\n    const wq = qm2(qaq(c0d3, c2d1));\r\n    const wq_ = 2 * (c0d3_ + c2d1_) + abs($wq);\r\n    const $wr = $wq + $c3d0;\r\n    const _wr = abs($wr);\r\n    const wr = qaq(wq, c3d0);\r\n    const wr_ = wq_ + c3d0_ + _wr;\r\n    const $ze = $c3 * $wr;\r\n    const ze = qmq(c3, wr);\r\n    const ze_ = c3_ * _wr + _c3 * wr_ + 2 * abs($ze);\r\n    const $ws = $wp + $ze;\r\n    const ws = qaq(wp, ze);\r\n    const _ws = abs($ws);\r\n    const ws_ = wp_ + ze_ + _ws;\r\n    const $zf = $c2 * $d2d2;\r\n    const zf = qmq(c2, d2d2);\r\n    const zf_ = c2_ * _d2d2 + _c2 * d2d2_ + 2 * abs($zf);\r\n    const $zg = 2 * $d1 * $wo;\r\n    const zg = qm2(qmq(d1, wo));\r\n    const zg_ = 2 * (d1_ * _wo + _d1 * wo_ + abs($zg));\r\n    const $wt = $zf + $zg;\r\n    const wt = qaq(zf, zg);\r\n    const wt_ = zf_ + zg_ + abs($wt);\r\n    const $wu = 2 * ($c1d2 + $c3d0);\r\n    const wu = qm2(qaq(c1d2, c3d0));\r\n    const wu_ = 2 * (c1d2_ + c3d0_) + abs($wu);\r\n    const $wv = $wu + $c0d3;\r\n    const wv = qaq(wu, c0d3);\r\n    const _wv = abs($wv);\r\n    const wv_ = wu_ + c0d3_ + _wv;\r\n    const $zh = $d3 * $wv;\r\n    const zh = qmq(d3, wv);\r\n    const zh_ = d3_ * _wv + _d3 * wv_ + 2 * abs($zh);\r\n    const $ww = $wt + $zh;\r\n    const ww = qaq(wt, zh);\r\n    const _ww = abs($ww);\r\n    const ww_ = wt_ + zh_ + _ww;\r\n    const $wx = $c2 * $c2c2;\r\n    const wx = qmq(c2, c2c2);\r\n    const wx_ = c2_ * _c2c2 + _c2 * c2c2_ + 2 * abs($wx);\r\n    const $wy = 2 * $c1c2 + $c0c3;\r\n    const wy = qaq(qm2(c1c2), c0c3);\r\n    const _wy = abs($wy);\r\n    const wy_ = 2 * c1c2_ + c0c3_ + _wy;\r\n    const $q1 = 3 * $c3;\r\n    const q1 = qmd(3, c3);\r\n    const _q1 = abs($q1);\r\n    const q1_ = 3 * c3_ + _q1;\r\n    const $wz = $q1 * $wy;\r\n    const wz = qmq(q1, wy);\r\n    const wz_ = q1_ * _wy + _q1 * wy_ + 2 * abs($wz);\r\n    const $z1 = $wx + $wz;\r\n    const z1 = qaq(wx, wz);\r\n    const _z1 = abs($z1);\r\n    const z1_ = wx_ + wz_ + _z1;\r\n    const $z2 = $d2 * $d2d2;\r\n    const z2 = qmq(d2, d2d2);\r\n    const z2_ = d2_ * _d2d2 + _d2 * d2d2_ + 2 * abs($z2);\r\n    const $z3 = 2 * $d1d2 + $d0d3;\r\n    const z3 = qaq(qm2(d1d2), d0d3);\r\n    const _z3 = abs($z3);\r\n    const z3_ = 2 * d1d2_ + d0d3_ + _z3;\r\n    const $q2 = 3 * $d3;\r\n    const q2 = qmd(3, d3);\r\n    const _q2 = abs($q2);\r\n    const q2_ = 3 * d3_ + _q2;\r\n    const $z4 = $q2 * $z3;\r\n    const z4 = qmq(q2, z3);\r\n    const z4_ = q2_ * _z3 + _q2 * z3_ + 2 * abs($z4);\r\n    const $z5 = $z2 + $z4;\r\n    const z5 = qaq(z2, z4);\r\n    const _z5 = abs($z5);\r\n    const z5_ = z2_ + z4_ + _z5;\r\n    const $zi = $vₓₓᵧ * $ws;\r\n    const zi = qmq(vₓₓᵧ, ws);\r\n    const zi_ = vₓₓᵧ_ * _ws + _vₓₓᵧ * ws_ + 2 * abs($zi);\r\n    const $zj = $vₓᵧᵧ * $ww;\r\n    const zj = qmq(vₓᵧᵧ, ww);\r\n    const zj_ = vₓᵧᵧ_ * _ww + _vₓᵧᵧ * ww_ + 2 * abs($zj);\r\n    const $z6 = $zi + $zj;\r\n    const z6 = qaq(zi, zj);\r\n    const z6_ = zi_ + zj_ + abs($z6);\r\n    const $zk = $vₓₓₓ * $z1;\r\n    const zk = qmq(vₓₓₓ, z1);\r\n    const zk_ = vₓₓₓ_ * _z1 + _vₓₓₓ * z1_ + 2 * abs($zk);\r\n    const $zl = $vᵧᵧᵧ * $z5;\r\n    const zl = qmq(vᵧᵧᵧ, z5);\r\n    const zl_ = vᵧᵧᵧ_ * _z5 + _vᵧᵧᵧ * z5_ + 2 * abs($zl);\r\n    const $z7 = $zk + $zl;\r\n    const z7 = qaq(zk, zl);\r\n    const z7_ = zk_ + zl_ + abs($z7);\r\n    const $zm = $vₓₓ * $c3c3;\r\n    const zm = qmq(c3c3, vₓₓ);\r\n    const zm_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * abs($zm);\r\n    const $zn = $vᵧᵧ * $d3d3;\r\n    const zn = qmq(d3d3, vᵧᵧ);\r\n    const zn_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * abs($zn);\r\n    const $z8 = $zm + $zn;\r\n    const z8 = qaq(zm, zn);\r\n    const z8_ = zm_ + zn_ + abs($z8);\r\n    const $z9 = $vₓᵧ * $c3d3;\r\n    const z9 = qmq(c3d3, vₓᵧ);\r\n    const z9_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * abs($z9);\r\n    const $za = $z6 + $z7;\r\n    const za = qaq(z6, z7);\r\n    const za_ = z6_ + z7_ + abs($za);\r\n    const $zb = $z8 + $z9;\r\n    const zb = qaq(z8, z9);\r\n    const zb_ = z8_ + z9_ + abs($zb);\r\n    const $v6 = $za + $zb;\r\n    const v6 = qaq(za, zb);\r\n    const v6_ = za_ + zb_ + abs($v6);\r\n    //const r4 = c2d2 + c3d1;\r\n    //const r5 = c1d3 + c2d2;\r\n    //const v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    const $r4 = $c2d2 + $c3d1;\r\n    const r4 = qaq(c2d2, c3d1);\r\n    const _r4 = abs($r4);\r\n    const r4_ = c2d2_ + c3d1_ + _r4;\r\n    const $r5 = $c1d3 + $c2d2;\r\n    const r5 = qaq(c1d3, c2d2);\r\n    const _r5 = abs($r5);\r\n    const r5_ = c1d3_ + c2d2_ + _r5;\r\n    const $k1 = c0 * $wo;\r\n    const k1 = qmd(c0, wo);\r\n    const k1_ = _c0 * wo_ + abs($k1);\r\n    const $k2 = d0 * $wo;\r\n    const k2 = qmd(d0, wo);\r\n    const k2_ = _d0 * wo_ + abs($k2);\r\n    const $k3 = $c1 * $r4;\r\n    const k3 = qmq(c1, r4);\r\n    const k3_ = c1_ * _r4 + _c1 * r4_ + 2 * abs($k3);\r\n    const $k4 = $d1 * $r5;\r\n    const k4 = qmq(d1, r5);\r\n    const k4_ = d1_ * _r5 + _d1 * r5_ + 2 * abs($k4);\r\n    const $k5 = 2 * $c3d0 + $c2d1;\r\n    const k5 = qaq(qm2(c3d0), c2d1);\r\n    const _k5 = abs($k5);\r\n    const k5_ = 2 * c3d0_ + c2d1_ + _k5;\r\n    const $k6 = 2 * $c0d3 + $c1d2;\r\n    const k6 = qaq(qm2(c0d3), c1d2);\r\n    const _k6 = abs($k6);\r\n    const k6_ = 2 * c0d3_ + c1d2_ + _k6;\r\n    const $k7 = $d3 * $c1c1;\r\n    const k7 = qmq(d3, c1c1);\r\n    const k7_ = d3_ * _c1c1 + _d3 * c1c1_ + 2 * abs($k7);\r\n    const $k8 = $c3 * $d1d1;\r\n    const k8 = qmq(c3, d1d1);\r\n    const k8_ = c3_ * _d1d1 + _c3 * d1d1_ + 2 * abs($k8);\r\n    const $k9 = $c2 * $k5;\r\n    const k9 = qmq(c2, k5);\r\n    const k9_ = c2_ * _k5 + _c2 * k5_ + 2 * abs($k9);\r\n    const $ka = $d2 * $k6;\r\n    const ka = qmq(d2, k6);\r\n    const ka_ = d2_ * _k6 + _d2 * k6_ + 2 * abs($ka);\r\n    const $kb = 2 * ($k1 + $k3);\r\n    const kb = qm2(qaq(k1, k3));\r\n    const kb_ = 2 * (k1_ + k3_) + abs($kb);\r\n    const $kc = 2 * ($k2 + $k4);\r\n    const kc = qm2(qaq(k2, k4));\r\n    const kc_ = 2 * (k2_ + k4_) + abs($kc);\r\n    const $kd = 2 * c0 * $c2c3;\r\n    const kd = qm2(qmd(c0, c2c3));\r\n    const kd_ = 2 * _c0 * c2c3_ + abs($kd);\r\n    const $ke = 2 * d0 * $d2d3;\r\n    const ke = qm2(qmd(d0, d2d3));\r\n    const ke_ = 2 * _d0 * d2d3_ + abs($ke);\r\n    const $kf = $c1 * $wc;\r\n    const kf = qmq(c1, wc);\r\n    const kf_ = c1_ * _wc + _c1 * wc_ + 2 * abs($kf);\r\n    const $kg = $d1 * $wd;\r\n    const kg = qmq(d1, wd);\r\n    const kg_ = d1_ * _wd + _d1 * wd_ + 2 * abs($kg);\r\n    const $kh = $vₓₓ * $c2c3;\r\n    const kh = qmq(c2c3, vₓₓ);\r\n    const kh_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * abs($kh);\r\n    const $ki = $vᵧᵧ * $d2d3;\r\n    const ki = qmq(d2d3, vᵧᵧ);\r\n    const ki_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * abs($ki);\r\n    const $kj = $kb + $k7;\r\n    const kj = qaq(kb, k7);\r\n    const _kj = abs($kj);\r\n    const kj_ = kb_ + k7_ + _kj;\r\n    const $kk = $kc + $k8;\r\n    const kk = qaq(kc, k8);\r\n    const _kk = abs($kk);\r\n    const kk_ = kc_ + k8_ + _kk;\r\n    const $kl = $kj + $k9;\r\n    const kl = qaq(kj, k9);\r\n    const _kl = abs($kl);\r\n    const kl_ = kj_ + k9_ + _kl;\r\n    const $km = $kk + $ka;\r\n    const km = qaq(kk, ka);\r\n    const _km = abs($km);\r\n    const km_ = kk_ + ka_ + _km;\r\n    const $kn = $kd + $kf;\r\n    const kn = qaq(kd, kf);\r\n    const _kn = abs($kn);\r\n    const kn_ = kd_ + kf_ + _kn;\r\n    const $ko = $ke + $kg;\r\n    const ko = qaq(ke, kg);\r\n    const _ko = abs($ko);\r\n    const ko_ = ke_ + kg_ + _ko;\r\n    const $kp = 2 * ($kh + $ki);\r\n    const kp = qm2(qaq(kh, ki));\r\n    const kp_ = 2 * (kh_ + ki_) + abs($kp);\r\n    const $kq = $vₓₓᵧ * $kl;\r\n    const kq = qmq(vₓₓᵧ, kl);\r\n    const kq_ = vₓₓᵧ_ * _kl + _vₓₓᵧ * kl_ + 2 * abs($kq);\r\n    const $kr = $vₓᵧᵧ * $km;\r\n    const kr = qmq(vₓᵧᵧ, km);\r\n    const kr_ = vₓᵧᵧ_ * _km + _vₓᵧᵧ * km_ + 2 * abs($kr);\r\n    const $ks = $vₓₓₓ * $kn;\r\n    const ks = qmq(vₓₓₓ, kn);\r\n    const ks_ = vₓₓₓ_ * _kn + _vₓₓₓ * kn_ + 2 * abs($ks);\r\n    const $kt = $vᵧᵧᵧ * $ko;\r\n    const kt = qmq(vᵧᵧᵧ, ko);\r\n    const kt_ = vᵧᵧᵧ_ * _ko + _vᵧᵧᵧ * ko_ + 2 * abs($kt);\r\n    const $ku = $kq + $kr;\r\n    const ku = qaq(kq, kr);\r\n    const ku_ = kq_ + kr_ + abs($ku);\r\n    const $kv = 3 * ($ks + $kt);\r\n    const kv = qmd(3, qaq(ks, kt));\r\n    const kv_ = 3 * (ks_ + kt_) + 2 * abs($kv);\r\n    const $kw = $vₓᵧ * $wo;\r\n    const kw = qmq(vₓᵧ, wo);\r\n    const kw_ = vₓᵧ_ * _wo + _vₓᵧ * wo_ + 2 * abs($kw);\r\n    const $kx = $ku + $kv;\r\n    const kx = qaq(ku, kv);\r\n    const kx_ = ku_ + kv_ + abs($kx);\r\n    const $ky = $kw + $kp;\r\n    const ky = qaq(kw, kp);\r\n    const ky_ = kw_ + kp_ + abs($ky);\r\n    const $v5 = $kx + $ky;\r\n    const v5 = qaq(kx, ky);\r\n    const v5_ = kx_ + ky_ + abs($v5);\r\n    //const r1 = c1d3 + r4;\r\n    //const r2 = 2*c1c3 + c2c2;\r\n    //const r3 = 2*d1d3 + d2d2;\r\n    //const v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    const $r1 = $c1d3 + $r4;\r\n    const r1 = qaq(c1d3, r4);\r\n    const _r1 = abs($r1);\r\n    const r1_ = c1d3_ + r4_ + _r1;\r\n    const $r2 = 2 * $c1c3 + $c2c2;\r\n    const r2 = qaq(qm2(c1c3), c2c2);\r\n    const _r2 = abs($r2);\r\n    const r2_ = 2 * c1c3_ + c2c2_ + _r2;\r\n    const $r3 = 2 * $d1d3 + $d2d2;\r\n    const r3 = qaq(qm2(d1d3), d2d2);\r\n    const _r3 = abs($r3);\r\n    const r3_ = 2 * d1d3_ + d2d2_ + _r3;\r\n    const $s1 = 2 * c0 * $r1;\r\n    const s1 = qmd(2 * c0, r1);\r\n    const s1_ = 2 * _c0 * r1_ + abs($s1);\r\n    const $s2 = 2 * d0 * $r1;\r\n    const s2 = qmd(2 * d0, r1);\r\n    const s2_ = 2 * _d0 * r1_ + abs($s2);\r\n    const $s5 = $c1d2 + 2 * $c2d1;\r\n    const s5 = qaq(c1d2, qm2(c2d1));\r\n    const _s5 = abs($s5);\r\n    const s5_ = c1d2_ + 2 * c2d1_ + _s5;\r\n    const $s6 = $c2d1 + 2 * $c1d2;\r\n    const s6 = qaq(c2d1, qm2(c1d2));\r\n    const _s6 = abs($s6);\r\n    const s6_ = c2d1_ + 2 * c1d2_ + _s6;\r\n    const $s3 = d0 * $r2;\r\n    const s3 = qmd(d0, r2);\r\n    const s3_ = _d0 * r2_ + abs($s3);\r\n    const $s4 = c0 * $r3;\r\n    const s4 = qmd(c0, r3);\r\n    const s4_ = _c0 * r3_ + abs($s4);\r\n    const $s7 = $c1 * $s5;\r\n    const s7 = qmq(c1, s5);\r\n    const s7_ = c1_ * _s5 + _c1 * s5_ + 2 * abs($s7);\r\n    const $s8 = $d1 * $s6;\r\n    const s8 = qmq(d1, s6);\r\n    const s8_ = d1_ * _s6 + _d1 * s6_ + 2 * abs($s8);\r\n    const $s9 = c0 * $r2;\r\n    const s9 = qmd(c0, r2);\r\n    const s9_ = _c0 * r2_ + abs($s9);\r\n    const $sa = d0 * $r3;\r\n    const sa = qmd(d0, r3);\r\n    const sa_ = _d0 * r3_ + abs($sa);\r\n    const $sb = $c2 * $c1c1;\r\n    const sb = qmq(c2, c1c1);\r\n    const sb_ = c2_ * _c1c1 + _c2 * c1c1_ + 2 * abs($sb);\r\n    const $sc = $d2 * $d1d1;\r\n    const sc = qmq(d2, d1d1);\r\n    const sc_ = d2_ * _d1d1 + _d2 * d1d1_ + 2 * abs($sc);\r\n    const $sd = $s1 + $s3;\r\n    const sd = qaq(s1, s3);\r\n    const sd_ = s1_ + s3_ + abs($sd);\r\n    const $se = $s2 + $s4;\r\n    const se = qaq(s2, s4);\r\n    const se_ = s2_ + s4_ + abs($se);\r\n    const $sf = $sd + $s7;\r\n    const sf = qaq(sd, s7);\r\n    const _sf = abs($sf);\r\n    const sf_ = sd_ + s7_ + _sf;\r\n    const $sg = $se + $s8;\r\n    const sg = qaq(se, s8);\r\n    const _sg = abs($sg);\r\n    const sg_ = se_ + s8_ + _sg;\r\n    const $sh = $s9 + $sb;\r\n    const sh = qaq(s9, sb);\r\n    const _sh = abs($sh);\r\n    const sh_ = s9_ + sb_ + _sh;\r\n    const $si = $sa + $sc;\r\n    const si = qaq(sa, sc);\r\n    const _si = abs($si);\r\n    const si_ = sa_ + sc_ + _si;\r\n    const $sj = $vₓₓᵧ * $sf;\r\n    const sj = qmq(vₓₓᵧ, sf);\r\n    const sj_ = vₓₓᵧ_ * _sf + _vₓₓᵧ * sf_ + 2 * abs($sj);\r\n    const $sk = $vₓᵧᵧ * $sg;\r\n    const sk = qmq(vₓᵧᵧ, sg);\r\n    const sk_ = vₓᵧᵧ_ * _sg + _vₓᵧᵧ * sg_ + 2 * abs($sk);\r\n    const $sl = $vₓₓₓ * $sh;\r\n    const sl = qmq(vₓₓₓ, sh);\r\n    const sl_ = vₓₓₓ_ * _sh + _vₓₓₓ * sh_ + 2 * abs($sl);\r\n    const $sm = $vᵧᵧᵧ * $si;\r\n    const sm = qmq(vᵧᵧᵧ, si);\r\n    const sm_ = vᵧᵧᵧ_ * _si + _vᵧᵧᵧ * si_ + 2 * abs($sm);\r\n    const $sn = $sl + $sm;\r\n    const _sn = abs($sn);\r\n    const sn = qaq(sl, sm);\r\n    const sn_ = sl_ + sm_ + _sn;\r\n    const $so = $sj + $sk;\r\n    const so = qaq(sj, sk);\r\n    const so_ = sj_ + sk_ + abs($so);\r\n    const $sp = $so + 3 * $sn;\r\n    const sp = qaq(so, qmd(3, sn));\r\n    const sp_ = so_ + 3 * (sn_ + _sn) + abs($sp);\r\n    const $ss = $vₓᵧ * $r1;\r\n    const ss = qmq(vₓᵧ, r1);\r\n    const ss_ = vₓᵧ_ * _r1 + _vₓᵧ * r1_ + 2 * abs($ss);\r\n    const $st = $vₓₓ * $r2;\r\n    const st = qmq(vₓₓ, r2);\r\n    const st_ = vₓₓ_ * _r2 + _vₓₓ * r2_ + 2 * abs($st);\r\n    const $sq = $ss + $st;\r\n    const sq = qaq(ss, st);\r\n    const sq_ = ss_ + st_ + abs($sq);\r\n    const $su = $vᵧᵧ * $r3;\r\n    const su = qmq(vᵧᵧ, r3);\r\n    const su_ = vᵧᵧ_ * _r3 + _vᵧᵧ * r3_ + 2 * abs($su);\r\n    const $sr = $sq + $su;\r\n    const sr = qaq(sq, su);\r\n    const sr_ = sq_ + su_ + abs($sr);\r\n    const $v4 = $sp + $sr;\r\n    const v4 = qaq(sp, sr);\r\n    const v4_ = sp_ + sr_ + abs($v4);\r\n    //const r6 = c1d2 + c2d1;\r\n    //const r7 = c3d0 + c0d3;\r\n    //const r8 = c1c2 + c0c3;\r\n    //const r9 = d1d2 + d0d3;\r\n    //const v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    const $r6 = $c1d2 + $c2d1;\r\n    const r6 = qaq(c1d2, c2d1);\r\n    const r6_ = c1d2_ + c2d1_ + abs($r6);\r\n    const $r7 = $c3d0 + $c0d3;\r\n    const r7 = qaq(c3d0, c0d3);\r\n    const r7_ = c3d0_ + c0d3_ + abs($r7);\r\n    const $r8 = $c1c2 + $c0c3;\r\n    const r8 = qaq(c1c2, c0c3);\r\n    const r8_ = c1c2_ + c0c3_ + abs($r8);\r\n    const _r8 = abs($r8);\r\n    const $r9 = $d1d2 + $d0d3;\r\n    const r9 = qaq(d1d2, d0d3);\r\n    const r9_ = d1d2_ + d0d3_ + abs($r9);\r\n    const _r9 = abs($r9);\r\n    const $m1 = 2 * $r6 + $c3d0;\r\n    const m1 = qaq(qm2(r6), c3d0);\r\n    const m1_ = 2 * r6_ + c3d0_ + abs($m1);\r\n    const $m2 = 2 * $r6 + $c0d3;\r\n    const m2 = qaq(qm2(r6), c0d3);\r\n    const m2_ = 2 * r6_ + c0d3_ + abs($m2);\r\n    const $m3 = 2 * $c2d0 + $c1d1;\r\n    const m3 = qaq(qm2(c2d0), c1d1);\r\n    const _m3 = abs($m3);\r\n    const m3_ = 2 * c2d0_ + c1d1_ + _m3;\r\n    const $m4 = 2 * $c0d2 + $c1d1;\r\n    const m4 = qaq(qm2(c0d2), c1d1);\r\n    const _m4 = abs($m4);\r\n    const m4_ = 2 * c0d2_ + c1d1_ + _m4;\r\n    const $m5 = $r8 + $c1c2;\r\n    const m5 = qaq(r8, c1c2);\r\n    const m5_ = r8_ + c1c2_ + abs($m5);\r\n    const $m6 = $r9 + $d1d2;\r\n    const m6 = qaq(r9, d1d2);\r\n    const m6_ = r9_ + d1d2_ + abs($m6);\r\n    const $q3 = 3 * c0;\r\n    const q3 = tp(3, c0); // error free\r\n    const $m7 = $q3 * $m5;\r\n    const m7 = qmq(q3, m5);\r\n    const m7_ = abs($q3) * m5_ + 2 * abs($m7);\r\n    const $q4 = 3 * d0;\r\n    const q4 = tp(3, d0); // error free\r\n    const $m8 = $q4 * $m6;\r\n    const m8 = qmq(q4, m6);\r\n    const m8_ = abs($q4) * m6_ + 2 * abs($m8);\r\n    const $m9 = $c1 * $c1c1;\r\n    const m9 = qmq(c1, c1c1);\r\n    const m9_ = c1_ * _c1c1 + _c1 * c1c1_ + 2 * abs($m9);\r\n    const $ma = $d1 * $d1d1;\r\n    const ma = qmq(d1, d1d1);\r\n    const ma_ = d1_ * _d1d1 + _d1 * d1d1_ + 2 * abs($ma);\r\n    const $mb = $vₓₓ * $r8;\r\n    const mb = qmq(vₓₓ, r8);\r\n    const mb_ = vₓₓ_ * _r8 + _vₓₓ * r8_ + abs($mb);\r\n    const $mc = $vᵧᵧ * $r9;\r\n    const mc = qmq(vᵧᵧ, r9);\r\n    const mc_ = vᵧᵧ_ * _r9 + _vᵧᵧ * r9_ + abs($mc);\r\n    const $md = $m1 + $r7;\r\n    const md = qaq(m1, r7);\r\n    const md_ = m1_ + r7_ + abs($md);\r\n    const $me = $m2 + $r7;\r\n    const me = qaq(m2, r7);\r\n    const me_ = m2_ + r7_ + abs($me);\r\n    const $mf = c0 * $md;\r\n    const mf = qmd(c0, md);\r\n    const mf_ = _c0 * md_ + abs($mf);\r\n    const $mg = d0 * $me;\r\n    const mg = qmd(d0, me);\r\n    const mg_ = _d0 * me_ + abs($mg);\r\n    const $mh = $c1 * $m3;\r\n    const mh = qmq(c1, m3);\r\n    const mh_ = c1_ * _m3 + _c1 * m3_ + 2 * abs($mh);\r\n    const $mi = $d1 * $m4;\r\n    const mi = qmq(d1, m4);\r\n    const mi_ = d1_ * _m4 + _d1 * m4_ + 2 * abs($mi);\r\n    const $mj = $c3 * $vₓ;\r\n    const mj = qmq(c3, vₓ);\r\n    const mj_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * abs($mj);\r\n    const $mk = $d3 * $vᵧ;\r\n    const mk = qmq(d3, vᵧ);\r\n    const mk_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * abs($mk);\r\n    const $ml = $mf + $mh;\r\n    const ml = qaq(mf, mh);\r\n    const _ml = abs($ml);\r\n    const ml_ = mf_ + mh_ + _ml;\r\n    const $mm = $mg + $mi;\r\n    const mm = qaq(mg, mi);\r\n    const _mm = abs($mm);\r\n    const mm_ = mg_ + mi_ + _mm;\r\n    const $mn = $m7 + $m9;\r\n    const mn = qaq(m7, m9);\r\n    const _mn = abs($mn);\r\n    const mn_ = m7_ + m9_ + _mn;\r\n    const $mo = $m8 + $ma;\r\n    const mo = qaq(m8, ma);\r\n    const _mo = abs($mo);\r\n    const mo_ = m8_ + ma_ + _mo;\r\n    const $mp = $r7 + $r6;\r\n    const mp = qaq(r7, r6);\r\n    const _mp = abs($mp);\r\n    const mp_ = r7_ + r6_ + _mp;\r\n    const $mq = 2 * ($mb + $mc);\r\n    const mq = qm2(qaq(mb, mc));\r\n    const mq_ = 2 * (mb_ + mc_) + abs($mq);\r\n    const $mr = $vₓₓᵧ * $ml;\r\n    const mr = qmq(vₓₓᵧ, ml);\r\n    const mr_ = vₓₓᵧ_ * _ml + _vₓₓᵧ * ml_ + 2 * abs($mr);\r\n    const $ms = $vₓᵧᵧ * $mm;\r\n    const ms = qmq(vₓᵧᵧ, mm);\r\n    const ms_ = vₓᵧᵧ_ * _mm + _vₓᵧᵧ * mm_ + 2 * abs($ms);\r\n    const $mt = $vₓₓₓ * $mn;\r\n    const mt = qmq(vₓₓₓ, mn);\r\n    const mt_ = vₓₓₓ_ * _mn + _vₓₓₓ * mn_ + 2 * abs($mt);\r\n    const $mu = $vᵧᵧᵧ * $mo;\r\n    const mu = qmq(vᵧᵧᵧ, mo);\r\n    const mu_ = vᵧᵧᵧ_ * _mo + _vᵧᵧᵧ * mo_ + 2 * abs($mu);\r\n    const $mv = $vₓᵧ * $mp;\r\n    const mv = qmq(vₓᵧ, mp);\r\n    const mv_ = vₓᵧ_ * _mp + _vₓᵧ * mp_ + 2 * abs($mv);\r\n    const $mw = $mr + $ms;\r\n    const mw = qaq(mr, ms);\r\n    const mw_ = mr_ + ms_ + abs($mw);\r\n    const $mx = $mt + $mu;\r\n    const mx = qaq(mt, mu);\r\n    const mx_ = mt_ + mu_ + abs($mx);\r\n    const $my = $mv + $mq;\r\n    const my = qaq(mv, mq);\r\n    const my_ = mv_ + mq_ + abs($my);\r\n    const $mz = $mj + $mk;\r\n    const mz = qaq(mj, mk);\r\n    const mz_ = mj_ + mk_ + abs($mz);\r\n    const $n1 = $mw + $mx;\r\n    const n1 = qaq(mw, mx);\r\n    const n1_ = mw_ + mx_ + abs($n1);\r\n    const $n2 = $my + $mz;\r\n    const n2 = qaq(my, mz);\r\n    const n2_ = my_ + mz_ + abs($n2);\r\n    const $v3 = $n1 + $n2;\r\n    const v3 = qaq(n1, n2);\r\n    const v3_ = n1_ + n2_ + abs($v3);\r\n    //const ra = c1d1 + c2d0;\r\n    //const rb = c1d1 + c0d2;\r\n    //const v2 =\r\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //    vₓᵧ*(ra + c0d2) +\r\n    //    vₓₓ*(2*c0c2 + c1c1) + \r\n    //    vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //    c2*vₓ + d2*vᵧ;\r\n    const $ra = $c1d1 + $c2d0;\r\n    const ra = qaq(c1d1, c2d0);\r\n    const ra_ = c1d1_ + c2d0_ + abs($ra);\r\n    const $rb = $c1d1 + $c0d2;\r\n    const rb = qaq(c1d1, c0d2);\r\n    const rb_ = c1d1_ + c0d2_ + abs($rb);\r\n    const $l1 = 2 * $ra + $c0d2;\r\n    const l1 = qaq(qm2(ra), c0d2);\r\n    const l1_ = 2 * ra_ + c0d2_ + abs($l1);\r\n    const $l2 = 2 * $rb + $c2d0;\r\n    const l2 = qaq(qm2(rb), c2d0);\r\n    const l2_ = 2 * rb_ + c2d0_ + abs($l2);\r\n    const $l3 = c0 * $l1;\r\n    const l3 = qmd(c0, l1);\r\n    const l3_ = _c0 * l1_ + abs($l3);\r\n    const $l4 = d0 * $c1c1;\r\n    const l4 = qmd(d0, c1c1);\r\n    const l4_ = _d0 * c1c1_ + abs($l4);\r\n    const $l5 = d0 * $l2;\r\n    const l5 = qmd(d0, l2);\r\n    const l5_ = _d0 * l2_ + abs($l5);\r\n    const $l6 = c0 * $d1d1;\r\n    const l6 = qmd(c0, d1d1);\r\n    const l6_ = _c0 * d1d1_ + abs($l6);\r\n    const $l7 = c0 * $c1c1;\r\n    const l7 = qmd(c0, c1c1);\r\n    const l7_ = _c0 * c1c1_ + abs($l7);\r\n    const $l8 = $c2 * $c0c0;\r\n    const l8 = qmq(c2, c0c0);\r\n    const l8_ = c2_ * _c0c0 + 2 * abs($l8);\r\n    const $l9 = d0 * $d1d1;\r\n    const l9 = qmd(d0, d1d1);\r\n    const l9_ = _d0 * d1d1_ + abs($l9);\r\n    const $la = $d2 * $d0d0;\r\n    const la = qmq(d2, d0d0);\r\n    const la_ = d2_ * _d0d0 + 2 * abs($la);\r\n    const $lb = $l3 + $l4;\r\n    const lb = qaq(l3, l4);\r\n    const _lb = l3_ + l4_ + abs($lb);\r\n    const lb_ = l3_ + l4_ + _lb;\r\n    const $lc = $l5 + $l6;\r\n    const lc = qaq(l5, l6);\r\n    const _lc = l5_ + l6_ + abs($lc);\r\n    const lc_ = l5_ + l6_ + _lc;\r\n    const $ld = $l7 + $l8;\r\n    const ld = qaq(l7, l8);\r\n    const _ld = abs($ld);\r\n    const ld_ = l7_ + l8_ + _ld;\r\n    const $le = $l9 + $la;\r\n    const le = qaq(l9, la);\r\n    const _le = abs($le);\r\n    const le_ = l9_ + la_ + _le;\r\n    const $lf = $vₓₓₓ * $ld;\r\n    const lf = qmq(vₓₓₓ, ld);\r\n    const lf_ = vₓₓₓ_ * _ld + _vₓₓₓ * ld_ + 2 * abs($lf);\r\n    const $lg = $vᵧᵧᵧ * $le;\r\n    const lg = qmq(vᵧᵧᵧ, le);\r\n    const lg_ = vᵧᵧᵧ_ * _le + _vᵧᵧᵧ * le_ + 2 * abs($lg);\r\n    const $lh = 3 * ($lf + $lg);\r\n    const lh = qmd(3, qaq(lf, lg));\r\n    const lh_ = 3 * (lf_ + lg_) + 2 * abs($lh);\r\n    const $li = $ra + $c0d2;\r\n    const li = qaq(ra, c0d2);\r\n    const _li = abs($li);\r\n    const li_ = ra_ + c0d2_ + _li;\r\n    const $lj = 2 * $c0c2 + $c1c1;\r\n    const lj = qaq(qm2(c0c2), c1c1);\r\n    const _lj = abs($lj);\r\n    const lj_ = 2 * c0c2_ + c1c1_ + _lj;\r\n    const $lk = 2 * $d0d2 + $d1d1;\r\n    const lk = qaq(qm2(d0d2), d1d1);\r\n    const _lk = abs($lk);\r\n    const lk_ = 2 * d0d2_ + d1d1_ + _lk;\r\n    const $ll = $vₓₓᵧ * $lb;\r\n    const ll = qmq(vₓₓᵧ, lb);\r\n    const ll_ = vₓₓᵧ_ * _lb + _vₓₓᵧ * lb_ + 2 * abs($ll);\r\n    const $lm = $vₓᵧᵧ * $lc;\r\n    const lm = qmq(vₓᵧᵧ, lc);\r\n    const lm_ = vₓᵧᵧ_ * _lc + _vₓᵧᵧ * lc_ + 2 * abs($lm);\r\n    const $ln = $vₓᵧ * $li;\r\n    const ln = qmq(vₓᵧ, li);\r\n    const ln_ = vₓᵧ_ * _li + _vₓᵧ * li_ + 2 * abs($ln);\r\n    const $lo = $vₓₓ * $lj;\r\n    const lo = qmq(vₓₓ, lj);\r\n    const lo_ = vₓₓ_ * _lj + _vₓₓ * lj_ + 2 * abs($lo);\r\n    const $lp = $vᵧᵧ * $lk;\r\n    const lp = qmq(vᵧᵧ, lk);\r\n    const lp_ = vᵧᵧ_ * _lk + _vᵧᵧ * lk_ + 2 * abs($lp);\r\n    const $lq = $c2 * $vₓ;\r\n    const lq = qmq(c2, vₓ);\r\n    const lq_ = c2_ * _vₓ + _c2 * vₓ_ + abs($lq);\r\n    const $lr = $d2 * $vᵧ;\r\n    const lr = qmq(d2, vᵧ);\r\n    const lr_ = d2_ * _vᵧ + _d2 * vᵧ_ + abs($lr);\r\n    const $ls = $lq + $lr;\r\n    const ls = qaq(lq, lr);\r\n    const ls_ = lq_ + lr_ + abs($ls);\r\n    const $lt = $ll + $lm;\r\n    const lt = qaq(ll, lm);\r\n    const lt_ = ll_ + lm_ + abs($lt);\r\n    const $lu = $lh + $ln;\r\n    const lu = qaq(lh, ln);\r\n    const lu_ = lh_ + ln_ + abs($lu);\r\n    const $lv = $lo + $lp;\r\n    const lv = qaq(lo, lp);\r\n    const lv_ = lo_ + lp_ + abs($lv);\r\n    const $lw = $lt + $lu;\r\n    const lw = qaq(lt, lu);\r\n    const lw_ = lt_ + lu_ + abs($lw);\r\n    const $lx = $lv + $ls;\r\n    const lx = qaq(lv, ls);\r\n    const lx_ = lv_ + ls_ + abs($lx);\r\n    const $v2 = $lw + $lx;\r\n    const v2 = qaq(lw, lx);\r\n    const v2_ = lw_ + lx_ + abs($v2);\r\n    //const rc = c1d0 + c0d1;\r\n    //const v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    const $rc = $c1d0 + $c0d1;\r\n    const rc = qaq(c1d0, c0d1);\r\n    const _rc = abs($rc);\r\n    const rc_ = c1d0_ + c0d1_ + _rc;\r\n    const $rd = c0 * $vₓₓᵧ;\r\n    const rd = qmd(c0, vₓₓᵧ);\r\n    const _rd = abs($rd);\r\n    const rd_ = _c0 * vₓₓᵧ_ + _rd;\r\n    const $re = d0 * $vₓᵧᵧ;\r\n    const re = qmd(d0, vₓᵧᵧ);\r\n    const _re = abs($re);\r\n    const re_ = _d0 * vₓᵧᵧ_ + _re;\r\n    const $rf = $rc + $c1d0;\r\n    const rf = qaq(rc, c1d0);\r\n    const _rf = abs($rf);\r\n    const rf_ = rc_ + c1d0_ + _rf;\r\n    const $rg = $rc + $c0d1;\r\n    const rg = qaq(rc, c0d1);\r\n    const _rg = abs($rg);\r\n    const rg_ = rc_ + c0d1_ + _rg;\r\n    const $rx = $c1 * $c0c0;\r\n    const rx = qmq(c1, c0c0);\r\n    const _rx = abs($rx);\r\n    const rx_ = c1_ * _c0c0 + 2 * _rx;\r\n    const $rh = $rx * $vₓₓₓ;\r\n    const rh = qmq(rx, vₓₓₓ);\r\n    const rh_ = rx_ * _vₓₓₓ + _rx * vₓₓₓ_ + 2 * abs($rh);\r\n    const $ry = $d1 * $d0d0;\r\n    const ry = qmq(d1, d0d0);\r\n    const _ry = abs($ry);\r\n    const ry_ = d1_ * _d0d0 + 2 * _ry;\r\n    const $ri = $ry * $vᵧᵧᵧ;\r\n    const ri = qmq(ry, vᵧᵧᵧ);\r\n    const ri_ = ry_ * _vᵧᵧᵧ + _ry * vᵧᵧᵧ_ + 2 * abs($ri);\r\n    const $rj = $vₓᵧ * $rc;\r\n    const rj = qmq(vₓᵧ, rc);\r\n    const rj_ = vₓᵧ_ * _rc + _vₓᵧ * rc_ + 2 * abs($rj);\r\n    const $rk = $c0c1 * $vₓₓ;\r\n    const rk = qmq(c0c1, vₓₓ);\r\n    const rk_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($rk);\r\n    const $rl = $d0d1 * $vᵧᵧ;\r\n    const rl = qmq(d0d1, vᵧᵧ);\r\n    const rl_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($rl);\r\n    const $rm = $rk + $rl;\r\n    const rm = qaq(rk, rl);\r\n    const rm_ = rk_ + rl_ + abs($rm);\r\n    const $rn = $c1 * $vₓ;\r\n    const rn = qmq(c1, vₓ);\r\n    const rn_ = c1_ * _vₓ + _c1 * vₓ_ + abs($rn);\r\n    const $ro = $d1 * $vᵧ;\r\n    const ro = qmq(d1, vᵧ);\r\n    const ro_ = d1_ * _vᵧ + _d1 * vᵧ_ + abs($ro);\r\n    const $rp = $rn + $ro;\r\n    const rp = qaq(rn, ro);\r\n    const rp_ = rn_ + ro_ + abs($rp);\r\n    const $rq = $rd * $rf;\r\n    const rq = qmq(rd, rf);\r\n    const rq_ = rd_ * _rf + _rd * rf_ + 2 * abs($rq);\r\n    const $rr = $re * $rg;\r\n    const rr = qmq(re, rg);\r\n    const rr_ = re_ * _rg + _re * rg_ + 2 * abs($rr);\r\n    const $rs = $rq + $rr;\r\n    const rs = qaq(rq, rr);\r\n    const rs_ = rq_ + rr_ + abs($rs);\r\n    const $rt = 3 * ($rh + $ri);\r\n    const rt = qmd(3, qaq(rh, ri));\r\n    const rt_ = 3 * (rh_ + ri_) + 2 * abs($rt);\r\n    const $ru = $rj + 2 * $rm;\r\n    const ru = qaq(rj, qm2(rm));\r\n    const ru_ = rj_ + 2 * rm_ + abs($ru);\r\n    const $rv = $rs + $rt;\r\n    const rv = qaq(rs, rt);\r\n    const rv_ = rs_ + rt_ + abs($rv);\r\n    const $rw = $ru + $rp;\r\n    const rw = qaq(ru, rp);\r\n    const rw_ = ru_ + rp_ + abs($rw);\r\n    const $v1 = $rv + $rw;\r\n    const v1 = qaq(rv, rw);\r\n    const v1_ = rv_ + rw_ + abs($v1);\r\n    //-----\r\n    // v0\r\n    //-----\r\n    const $t1 = c0 * $vₓₓₓ;\r\n    const t1 = qmd(c0, vₓₓₓ);\r\n    const t1_ = _c0 * vₓₓₓ_ + abs($t1);\r\n    const $t2 = d0 * $vₓₓᵧ;\r\n    const t2 = qmd(d0, vₓₓᵧ);\r\n    const t2_ = _d0 * vₓₓᵧ_ + abs($t2);\r\n    const $p4 = $t1 + $t2;\r\n    const p4 = qaq(t1, t2);\r\n    const p4_ = t1_ + t2_ + abs($p4);\r\n    const $t3 = c0 * $vₓᵧᵧ;\r\n    const t3 = qmd(c0, vₓᵧᵧ);\r\n    const t3_ = _c0 * vₓᵧᵧ_ + abs($t3);\r\n    const $t4 = d0 * $vᵧᵧᵧ;\r\n    const t4 = qmd(d0, vᵧᵧᵧ);\r\n    const t4_ = _d0 * vᵧᵧᵧ_ + abs($t4);\r\n    const $p5 = $t3 + $t4;\r\n    const p5 = qaq(t3, t4);\r\n    const p5_ = t3_ + t4_ + abs($p5);\r\n    const $p7 = $p4 + $vₓₓ;\r\n    const p7 = qaq(p4, vₓₓ);\r\n    const _p7 = abs($p7);\r\n    const p7_ = p4_ + vₓₓ_ + _p7;\r\n    const $p8 = $p5 + $vᵧᵧ;\r\n    const p8 = qaq(p5, vᵧᵧ);\r\n    const _p8 = abs($p8);\r\n    const p8_ = p5_ + vᵧᵧ_ + _p8;\r\n    const $pc = $c0c0 * $p7;\r\n    const pc = qmq(c0c0, p7);\r\n    const pc_ = _c0c0 * p7_ + 2 * abs($pc);\r\n    const $pd = $d0d0 * $p8;\r\n    const pd = qmq(d0d0, p8);\r\n    const pd_ = _d0d0 * p8_ + 2 * abs($pd);\r\n    const $p6 = $pc + $pd;\r\n    const p6 = qaq(pc, pd);\r\n    const p6_ = pc_ + pd_ + abs($p6);\r\n    const $pe = $c0d0 * $vₓᵧ;\r\n    const pe = qmq(c0d0, vₓᵧ);\r\n    const pe_ = _c0d0 * vₓᵧ_ + abs($pe);\r\n    const $p9 = $p6 + $pe;\r\n    const p9 = qaq(p6, pe);\r\n    const p9_ = p6_ + pe_ + abs($p9);\r\n    const $pf = c0 * $vₓ;\r\n    const pf = qmd(c0, vₓ);\r\n    const pf_ = _c0 * vₓ_ + abs($pf);\r\n    const $pg = d0 * $vᵧ;\r\n    const pg = qmd(d0, vᵧ);\r\n    const pg_ = _d0 * vᵧ_ + abs($pg);\r\n    const $pa = $pf + $pg;\r\n    const pa = qaq(pf, pg);\r\n    const pa_ = pf_ + pg_ + abs($pa);\r\n    const $pb = $p9 + $pa;\r\n    const pb = qaq(p9, pa);\r\n    const pb_ = p9_ + pa_ + abs($pb);\r\n    const $v0 = $pb + $v;\r\n    const v0 = qaq(pb, v);\r\n    const v0_ = pb_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v9_, γγ3 * v8_, γγ3 * v7_, γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez1Exact: () => (/* binding */ getCoeffsBez1Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable whose roots are the parameter\r\n * values of the intersection points of two order 1 bezier curves (i.e. 2 lines).\r\n *\r\n * The returned polynomial degree will be 1\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez1Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps1);\r\n    // if both polynomials' linear terms are exactly zero then it really is a point\r\n    //if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn't happen due to being checked for earlier.\r\n    //}\r\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps2);\r\n    //if (eSign(c1) === 0 && eSign(d1) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn't happen due to being checked for earlier.\r\n    //}\r\n    const { vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 1\r\n    (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_5__.getImplicitForm1ExactPb)(ps1pb);\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p1 = epr(c1, vₓ);\r\n    const p2 = epr(d1, vᵧ);\r\n    const v1 = fes(p1, p2);\r\n    //const v0 = c0*vₓ + d0*vᵧ + v_0;\r\n    const p3 = sce(c0, vₓ);\r\n    const p4 = sce(d0, vᵧ);\r\n    const p5 = fes(p3, p4);\r\n    const v0 = fes(p5, v);\r\n    const r = [v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez2Exact: () => (/* binding */ getCoeffsBez1Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs-bez1-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez2Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps1);\r\n    // if both polynomials' linear terms are exactly zero then it really is a point\r\n    // if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn't happen due to being checked for earlier.\r\n    // }\r\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis2Exact)(ps2);\r\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez1Bez1Exact)(ps1, [ps2[0], ps2[2]]);\r\n    }\r\n    const { vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 1\r\n    (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_6__.getImplicitForm1ExactPb)(ps1pb);\r\n    // a2*v_x + b2*v_y\r\n    //const v2 = c2*vₓ + d2*vᵧ;\r\n    const p1 = epr(c2, vₓ);\r\n    const p2 = epr(d2, vᵧ);\r\n    const v2 = fes(p1, p2);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p3 = epr(c1, vₓ);\r\n    const p4 = epr(d1, vᵧ);\r\n    const v1 = fes(p3, p4);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p5 = sce(c0, vₓ);\r\n    const p6 = sce(d0, vᵧ);\r\n    const p7 = fes(p5, p6);\r\n    const v0 = fes(p7, v);\r\n    const r = [v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez1Bez3Exact: () => (/* binding */ getCoeffsBez1Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs-bez1-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js\");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez3Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis1Exact)(ps1);\r\n    // if both polynomials' linear terms are exactly zero then it really is a point\r\n    // if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn't happen due to being checked for earlier.\r\n    // }\r\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_4__.toPowerBasis3Exact)(ps2);\r\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez1Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_6__.cubicToQuadratic)(ps2));\r\n    }\r\n    // it is a precondition that the curve really has order 1\r\n    // keep TypeScript happy; `getImplicitForm1ExactPb` cannot return `undefined` here\r\n    const { vₓ, vᵧ, v } = (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm1ExactPb)(ps1pb);\r\n    // a3*v_x + b3*v_y\r\n    //const v3 = c3*vₓ + d3*vᵧ;\r\n    const p1 = epr(c3, vₓ);\r\n    const p2 = epr(d3, vᵧ);\r\n    const v3 = fes(p1, p2);\r\n    // a2*v_x + b2*v_y\r\n    //const v2 = c2*vₓ + d2*vᵧ;\r\n    const p3 = epr(c2, vₓ);\r\n    const p4 = epr(d2, vᵧ);\r\n    const v2 = fes(p3, p4);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p5 = epr(c1, vₓ);\r\n    const p6 = epr(d1, vᵧ);\r\n    const v1 = fes(p5, p6);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p7 = sce(c0, vₓ);\r\n    const p8 = sce(d0, vᵧ);\r\n    const p9 = fes(p7, p8);\r\n    const v0 = fes(p9, v);\r\n    const r = [v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez1Exact: () => (/* binding */ getCoeffsBez2Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez1-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n  * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez1Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps1);\r\n    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;\r\n    // if both polynomials' quadratic terms are exactly zero then its really a line\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez1Bez1Exact)([ps1[0], ps1[2]], ps2);\r\n    }\r\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis1Exact)(ps2);\r\n    // if (eSign(c1) === 0 && eSign(d1) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn't happen due to being checked for earlier.\r\n    // }\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 2\r\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm2ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d1d1 = epr(d1, d1);\r\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\r\n    const p1 = epr(c1c1, vₓₓ);\r\n    const p2 = epr(d1d1, vᵧᵧ);\r\n    const p3 = epr(c1d1, vₓᵧ);\r\n    const p4 = fes(p1, p2);\r\n    const v2 = fes(p4, p3);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\r\n    const p5 = epr(c0c1, vₓₓ);\r\n    const p6 = epr(d0d1, vᵧᵧ);\r\n    const p7 = fes(c0d1, c1d0);\r\n    const pn = epr(p7, vₓᵧ);\r\n    const p8 = em2(fes(p5, p6));\r\n    const p9 = fes(p8, pn);\r\n    const pa = epr(c1, vₓ);\r\n    const pb = epr(d1, vᵧ);\r\n    const pc = fes(pa, pb);\r\n    const v1 = fes(p9, pc);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\r\n    const pe = epr(c0c0, vₓₓ);\r\n    const pf = epr(c0d0, vₓᵧ);\r\n    const pg = epr(d0d0, vᵧᵧ);\r\n    const ph = fes(pe, pf);\r\n    const pi = fes(ph, pg);\r\n    const pj = sce(c0, vₓ);\r\n    const pk = sce(d0, vᵧ);\r\n    const pl = fes(pj, pk);\r\n    const pm = fes(pi, pl);\r\n    const v0 = fes(pm, v);\r\n    const r = [v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez2Exact: () => (/* binding */ getCoeffsBez2Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez1-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js\");\n/* harmony import */ var _get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-coeffs-bez2-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 2 bezier curves (i.e. 2 quadratic bezier curves).\r\n *\r\n * The returned polynomial degree will be 4\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez2Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps1);\r\n    // if both polynomials' quadratic terms are exactly zero then its really a line\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez1Bez2Exact)([ps1[0], ps1[2]], ps2);\r\n    }\r\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps2);\r\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez2Bez1Exact)(ps1, [ps2[0], ps2[2]]);\r\n    }\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 2\r\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm2ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d2d2 = epr(d2, d2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //const v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    const p1 = epr(c2c2, vₓₓ);\r\n    const p2 = epr(c2d2, vₓᵧ);\r\n    const p3 = epr(d2d2, vᵧᵧ);\r\n    const p4 = fes(p1, p2);\r\n    const v4 = fes(p4, p3);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    const p5 = epr(c1c2, vₓₓ);\r\n    const p6 = epr(d1d2, vᵧᵧ);\r\n    const p7 = fes(c1d2, c2d1);\r\n    const p8 = epr(p7, vₓᵧ);\r\n    const p9 = em2(fes(p5, p6));\r\n    const v3 = fes(p9, p8);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    const pa = fes(em2(c0c2), c1c1);\r\n    const pb = fes(em2(d0d2), d1d1);\r\n    const pc = fes(c0d2, c1d1);\r\n    const pd = fes(pc, c2d0);\r\n    const pe = epr(pa, vₓₓ);\r\n    const pf = epr(pb, vᵧᵧ);\r\n    const pg = epr(pd, vₓᵧ);\r\n    const ph = epr(c2, vₓ);\r\n    const pi = epr(d2, vᵧ);\r\n    const pj = fes(pe, pf);\r\n    const pk = fes(pj, pg);\r\n    const pl = fes(ph, pi);\r\n    const v2 = fes(pk, pl);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    const pm = epr(c0c1, vₓₓ);\r\n    const pn = epr(d0d1, vᵧᵧ);\r\n    const po = fes(c0d1, c1d0);\r\n    const pp = epr(po, vₓᵧ);\r\n    const pq = em2(fes(pm, pn));\r\n    const pr = epr(c1, vₓ);\r\n    const ps = epr(d1, vᵧ);\r\n    const pt = fes(pq, pp);\r\n    const pu = fes(pr, ps);\r\n    const v1 = fes(pt, pu);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    const pv = epr(c0c0, vₓₓ);\r\n    const pw = epr(c0d0, vₓᵧ);\r\n    const px = epr(d0d0, vᵧᵧ);\r\n    const py = sce(c0, vₓ);\r\n    const pz = sce(d0, vᵧ);\r\n    const q1 = fes(pv, pw);\r\n    const q2 = fes(q1, px);\r\n    const q3 = fes(py, pz);\r\n    const q4 = fes(q2, q3);\r\n    const v0 = fes(q4, v);\r\n    const r = [v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez2Bez3Exact: () => (/* binding */ getCoeffsBez2Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez1-bez3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js\");\n/* harmony import */ var _get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-coeffs-bez2-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez3Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps1);\r\n    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;\r\n    // if both polynomials' quadratic terms are exactly zero then its really a line\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez1Bez3Exact)([ps1[0], ps1[2]], ps2);\r\n    }\r\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps2);\r\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez2Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_9__.cubicToQuadratic)(ps2));\r\n    }\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 2\r\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm2ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0c3 = sce(c0, c3);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c0d3 = sce(c0, d3);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1c3 = epr(c1, c3);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c1d3 = epr(c1, d3);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2c3 = epr(c2, c3);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const c2d3 = epr(c2, d3);\r\n    const c3c3 = epr(c3, c3);\r\n    const c3d0 = sce(d0, c3);\r\n    const c3d1 = epr(c3, d1);\r\n    const c3d2 = epr(c3, d2);\r\n    const c3d3 = epr(c3, d3);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d0d3 = sce(d0, d3);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d3d3 = epr(d3, d3);\r\n    const d2d2 = epr(d2, d2);\r\n    const d2d3 = epr(d2, d3);\r\n    const d1d3 = epr(d1, d3);\r\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\r\n    //const v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    const p1 = epr(c3c3, vₓₓ);\r\n    const p2 = epr(c3d3, vₓᵧ);\r\n    const p3 = epr(d3d3, vᵧᵧ);\r\n    const p4 = fes(p1, p2);\r\n    const v6 = fes(p4, p3);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //const v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    vₓᵧ*(c2d3 + c3d2);\r\n    const p5 = epr(c2c3, vₓₓ);\r\n    const p6 = epr(d2d3, vᵧᵧ);\r\n    const p7 = fes(p5, p6);\r\n    const p8 = fes(c2d3, c3d2);\r\n    const p9 = epr(p8, vₓᵧ);\r\n    const v5 = fes(em2(p7), p9);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //const v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    const pa = fes(em2(c1c3), c2c2);\r\n    const pb = fes(em2(d1d3), d2d2);\r\n    const pc = fes(c1d3, c2d2);\r\n    const pd = fes(pc, c3d1);\r\n    const pe = epr(pa, vₓₓ);\r\n    const pf = epr(pb, vᵧᵧ);\r\n    const pg = fes(pe, pf);\r\n    const rp = epr(pd, vₓᵧ);\r\n    const v4 = fes(pg, rp);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //const v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    const ph = fes(c0c3, c1c2);\r\n    const pi = fes(d0d3, d1d2);\r\n    const pj = fes(c0d3, c1d2);\r\n    const pk = fes(c2d1, c3d0);\r\n    const pl = fes(pj, pk);\r\n    const pm = epr(ph, vₓₓ);\r\n    const pn = epr(pi, vᵧᵧ);\r\n    const po = em2(fes(pm, pn));\r\n    const pp = epr(pl, vₓᵧ);\r\n    const rn = epr(c3, vₓ);\r\n    const ro = epr(d3, vᵧ);\r\n    const pq = fes(rn, ro);\r\n    const pr = fes(po, pp);\r\n    const v3 = fes(pr, pq);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //const v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    const ps = fes(em2(c0c2), c1c1);\r\n    const pt = fes(em2(d0d2), d1d1);\r\n    const pu = fes(c0d2, c1d1);\r\n    const pv = fes(pu, c2d0);\r\n    const pw = epr(ps, vₓₓ);\r\n    const px = epr(pt, vᵧᵧ);\r\n    const py = epr(pv, vₓᵧ);\r\n    const pz = fes(pw, px);\r\n    const r1 = fes(pz, py);\r\n    const r2 = epr(c2, vₓ);\r\n    const r3 = epr(d2, vᵧ);\r\n    const r4 = fes(r2, r3);\r\n    const v2 = fes(r1, r4);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //const v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    const r5 = epr(c0c1, vₓₓ);\r\n    const r6 = epr(d0d1, vᵧᵧ);\r\n    const r7 = fes(c0d1, c1d0);\r\n    const r8 = epr(r7, vₓᵧ);\r\n    const r9 = em2(fes(r5, r6));\r\n    const ra = fes(r9, r8);\r\n    const rb = epr(c1, vₓ);\r\n    const rc = epr(d1, vᵧ);\r\n    const rd = fes(rb, rc);\r\n    const v1 = fes(ra, rd);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const re = epr(c0c0, vₓₓ);\r\n    const rf = epr(c0d0, vₓᵧ);\r\n    const rg = epr(d0d0, vᵧᵧ);\r\n    const rh = sce(c0, vₓ);\r\n    const ri = sce(d0, vᵧ);\r\n    const rj = fes(re, rf);\r\n    const rk = fes(rj, rg);\r\n    const rl = fes(rh, ri);\r\n    const rm = fes(rk, rl);\r\n    const v0 = fes(rm, v);\r\n    const r = [v6, v5, v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez1Exact: () => (/* binding */ getCoeffsBez3Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez2-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n  * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez1Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps1);\r\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\r\n    // if both polynomials' cubic terms are exactly zero then its really a quadratic\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez1Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps1), ps2);\r\n    }\r\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis1Exact)(ps2);\r\n    // if (eSign(c1) === 0 && eSign(d1) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn't happen due to being checked for earlier.\r\n    // }\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 3\r\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm3ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d1d1 = epr(d1, d1);\r\n    const z1 = sce(c0, vₓₓₓ);\r\n    const z7 = epr(tp(3, c0), vₓₓₓ);\r\n    const z2 = sce(c0, vₓₓᵧ);\r\n    const z3 = sce(d0, vₓₓᵧ);\r\n    const z4 = sce(c0, vₓᵧᵧ);\r\n    const z5 = sce(d0, vₓᵧᵧ);\r\n    const z6 = sce(d0, vᵧᵧᵧ);\r\n    const z8 = epr(tp(3, d0), vᵧᵧᵧ);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //const v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    const u1 = epr(c1, vₓₓₓ);\r\n    const u2 = epr(c1, vₓᵧᵧ);\r\n    const u3 = epr(d1, vₓₓᵧ);\r\n    const u4 = epr(d1, vᵧᵧᵧ);\r\n    const u5 = fes(u1, u3);\r\n    const u6 = fes(u2, u4);\r\n    const u7 = epr(c1c1, u5);\r\n    const u8 = epr(d1d1, u6);\r\n    const v3 = fes(u7, u8);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //const v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //const v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    const u9 = fes(z7, z3);\r\n    const ua = em2(fes(z2, z5));\r\n    const ub = fes(z4, z8);\r\n    const uc = fes(u9, vₓₓ);\r\n    const ud = fes(ua, vₓᵧ);\r\n    const ue = fes(ub, vᵧᵧ);\r\n    const uf = epr(c1c1, uc);\r\n    const ug = epr(c1d1, ud);\r\n    const uh = epr(d1d1, ue);\r\n    const ui = fes(uf, ug);\r\n    const v2 = fes(ui, uh);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    const uj = em2(fes(z3, vₓₓ));\r\n    const uk = em2(fes(z4, vᵧᵧ));\r\n    const un = fes(z7, uj);\r\n    const uo = fes(z8, uk);\r\n    const up = fes(z2, vₓᵧ);\r\n    const uq = fes(z5, vₓᵧ);\r\n    const ur = epr(c0c1, un);\r\n    const us = epr(d0d1, uo);\r\n    const ut = epr(c0d1, up);\r\n    const uu = epr(c1d0, uq);\r\n    const uv = epr(c1, vₓ);\r\n    const uw = epr(d1, vᵧ);\r\n    const ux = fes(ur, us);\r\n    const uy = fes(ut, uu);\r\n    const uz = fes(ux, uy);\r\n    const u0 = fes(uv, uw);\r\n    const v1 = fes(uz, u0);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //const v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    const f1 = fes(z1, z3);\r\n    const f2 = fes(z6, z4);\r\n    const f3 = fes(f1, vₓₓ);\r\n    const f4 = fes(f2, vᵧᵧ);\r\n    const f5 = epr(c0c0, f3);\r\n    const f6 = epr(d0d0, f4);\r\n    const f7 = epr(c0d0, vₓᵧ);\r\n    const f8 = fes(f5, f6);\r\n    const f9 = fes(f8, f7);\r\n    const fa = sce(c0, vₓ);\r\n    const fb = sce(d0, vᵧ);\r\n    const fc = fes(fa, fb);\r\n    const fd = fes(f9, fc);\r\n    const v0 = fes(fd, v);\r\n    const r = [v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez2Exact: () => (/* binding */ getCoeffsBez3Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez2-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coeffs-bez3-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n  * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez2Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps1);\r\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\r\n    // if both polynomials' cubic terms are exactly zero then its really a quadratic\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez2Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps1), ps2);\r\n    }\r\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis2Exact)(ps2);\r\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Bez1Exact)(ps1, [ps2[0], ps2[2]]);\r\n    }\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 3\r\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm3ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d2d2 = epr(d2, d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //const v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    const e1 = epr(c2, vₓₓₓ);\r\n    const e2 = epr(c2, vₓᵧᵧ);\r\n    const e3 = epr(d2, vₓₓᵧ);\r\n    const e4 = epr(d2, vᵧᵧᵧ);\r\n    const e5 = fes(e1, e3);\r\n    const e6 = fes(e2, e4);\r\n    const e7 = epr(c2c2, e5);\r\n    const e8 = epr(d2d2, e6);\r\n    const v6 = fes(e7, e8);\r\n    const z1 = fes(c0c2, c1c1);\r\n    const z2 = fes(d0d2, d1d1);\r\n    const z3 = fes(em2(c0c2), c1c1);\r\n    const z4 = fes(em2(d0d2), d1d1);\r\n    const z5 = fes(em2(c1d1), c2d0);\r\n    const z6 = fes(em2(c1d1), c0d2);\r\n    const z7 = fes(em2(c2d0), c1d1);\r\n    const z8 = fes(sce(6, c0c2), c1c1);\r\n    const z9 = fes(sce(6, d0d2), d1d1);\r\n    const za = fes(c1d2, c2d1);\r\n    const zb = fes(c0d2, c2d0);\r\n    const zc = fes(em2(c1d0), c0d1);\r\n    const zd = fes(em2(c0d1), c1d0);\r\n    const zf = fes(c0d2, c1d1);\r\n    const ze = fes(zf, c2d0);\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //const v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    const s0 = sce(3, c2c2);\r\n    const t1 = sce(3, d2d2);\r\n    const s1 = epr(s0, vₓₓₓ);\r\n    const s2 = epr(c2c2, vₓₓᵧ);\r\n    const s3 = em2(epr(c2d2, vₓₓᵧ));\r\n    const s4 = em2(epr(c2d2, vₓᵧᵧ));\r\n    const s5 = epr(d2d2, vₓᵧᵧ);\r\n    const s6 = epr(t1, vᵧᵧᵧ);\r\n    const s7 = fes(s1, s3);\r\n    const s8 = fes(s2, s4);\r\n    const s9 = fes(s7, s5);\r\n    const sa = fes(s8, s6);\r\n    const sb = epr(c1, s9);\r\n    const sc = epr(d1, sa);\r\n    const v5 = fes(sb, sc);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //const v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //const v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    const sd = epr(d2, z3);\r\n    const se = epr(d2, z6);\r\n    const sf = epr(c2, z5);\r\n    const sg = epr(c2, z4);\r\n    const sh = epr(sce(3, c2), z1);\r\n    const si = epr(sce(3, d2), z2);\r\n    const sj = fes(sd, sf);\r\n    const sk = fes(se, sg);\r\n    const sl = epr(sh, vₓₓₓ);\r\n    const sm = epr(si, vᵧᵧᵧ);\r\n    const sn = epr(sj, vₓₓᵧ);\r\n    const so = epr(sk, vₓᵧᵧ);\r\n    const sp = fes(sl, sm);\r\n    const sq = fes(sn, so);\r\n    const sr = epr(c2c2, vₓₓ);\r\n    const ss = epr(d2d2, vᵧᵧ);\r\n    const st = epr(c2d2, vₓᵧ);\r\n    const su = fes(sr, ss);\r\n    const sv = fes(sp, sq);\r\n    const sw = fes(su, st);\r\n    const v4 = fes(sv, sw);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //const v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    const sx = epr(c1, z8);\r\n    const sy = epr(d1, z9);\r\n    const sz = sce(2 * c0, za);\r\n    const o1 = epr(em2(d1), zb);\r\n    const o2 = epr(c1, z7);\r\n    const o3 = epr(c1, z4);\r\n    const o4 = fes(sz, o2);\r\n    const o5 = fes(o1, o3);\r\n    const o6 = epr(d1d2, vᵧᵧ);\r\n    const o7 = epr(c1c2, vₓₓ);\r\n    const o8 = epr(za, vₓᵧ);\r\n    const o9 = fes(o6, o7);\r\n    const oa = epr(sx, vₓₓₓ);\r\n    const ob = epr(o4, vₓₓᵧ);\r\n    const oc = epr(sy, vᵧᵧᵧ);\r\n    const od = epr(o5, vₓᵧᵧ);\r\n    const oe = fes(oa, oc);\r\n    const og = fes(ob, od);\r\n    const oh = fes(oe, og);\r\n    const oi = fes(em2(o9), o8);\r\n    const v3 = fes(oh, oi);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    //const v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    const oj = epr(tp(3, c0), z1);\r\n    const ok = epr(tp(3, d0), z2);\r\n    const ol = sce(c0, z6);\r\n    const om = sce(c0, z4);\r\n    const on = sce(d0, z3);\r\n    const oo = sce(d0, z5);\r\n    const op = fes(ol, on);\r\n    const oq = fes(om, oo);\r\n    const or = epr(oj, vₓₓₓ);\r\n    const os = epr(ok, vᵧᵧᵧ);\r\n    const ot = epr(op, vₓₓᵧ);\r\n    const ou = epr(oq, vₓᵧᵧ);\r\n    const ov = epr(z3, vₓₓ);\r\n    const ow = epr(z4, vᵧᵧ);\r\n    const ox = epr(ze, vₓᵧ);\r\n    const oy = epr(c2, vₓ);\r\n    const oz = epr(d2, vᵧ);\r\n    const p1 = fes(or, os);\r\n    const p2 = fes(ot, ou);\r\n    const p3 = fes(ov, ow);\r\n    const p4 = fes(p1, p2);\r\n    const p5 = fes(p3, ox);\r\n    const p6 = fes(oy, oz);\r\n    const p7 = fes(p4, p5);\r\n    const v2 = fes(p7, p6);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    const p8 = epr(tp(3, c0), c0c1);\r\n    const p9 = epr(tp(3, d0), d0d1);\r\n    const pa = sce(c0, zc);\r\n    const pb = sce(d0, zd);\r\n    const pc = epr(c0c1, vₓₓ);\r\n    const pd = epr(d0d1, vᵧᵧ);\r\n    const pe = epr(c0d1, vₓᵧ);\r\n    const pf = epr(c1d0, vₓᵧ);\r\n    const pg = em2(fes(pc, pd));\r\n    const ph = fes(pe, pf);\r\n    const pi = epr(c1, vₓ);\r\n    const pj = epr(d1, vᵧ);\r\n    const pk = epr(p8, vₓₓₓ);\r\n    const pl = epr(p9, vᵧᵧᵧ);\r\n    const pm = epr(pa, vₓₓᵧ);\r\n    const pn = epr(pb, vₓᵧᵧ);\r\n    const po = fes(pk, pl);\r\n    const pp = fes(pm, pn);\r\n    const pq = fes(po, pp);\r\n    const pr = fes(pg, ph);\r\n    const ps = fes(pi, pj);\r\n    const pt = fes(pq, pr);\r\n    const v1 = fes(pt, ps);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const pu = sce(c0, vₓₓₓ);\r\n    const pv = sce(c0, vₓᵧᵧ);\r\n    const pw = sce(d0, vₓₓᵧ);\r\n    const px = sce(d0, vᵧᵧᵧ);\r\n    const py = fes(pu, pw);\r\n    const pz = fes(pv, px);\r\n    const u1 = fes(py, vₓₓ);\r\n    const u2 = fes(pz, vᵧᵧ);\r\n    const u3 = epr(c0c0, u1);\r\n    const u4 = epr(d0d0, u2);\r\n    const u5 = epr(c0d0, vₓᵧ);\r\n    const u6 = sce(c0, vₓ);\r\n    const u7 = sce(d0, vᵧ);\r\n    const u8 = fes(u3, u4);\r\n    const u9 = fes(u8, u5);\r\n    const ua = fes(u6, u7);\r\n    const ub = fes(u9, ua);\r\n    const v0 = fes(ub, v);\r\n    const r = [v6, v5, v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Bez3Exact: () => (/* binding */ getCoeffsBez3Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coeffs-bez3-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js\");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs-bez2-bez3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in in 1 variable\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 3 bezier curves (i.e. 2 cubic bezier curves).\r\n *\r\n * The returned polynomial degree will be 9\r\n * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez3Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps1);\r\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\r\n    // if both polynomials' cubic terms are exactly zero then its really a quadratic\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez3Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps1), ps2);\r\n    }\r\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_6__.toPowerBasis3Exact)(ps2);\r\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_8__.cubicToQuadratic)(ps2));\r\n    }\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 3\r\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm3ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0c3 = sce(c0, c3);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c0d3 = sce(c0, d3);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1c3 = epr(c1, c3);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c1d3 = epr(c1, d3);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2c3 = epr(c2, c3);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const c2d3 = epr(c2, d3);\r\n    const c3c3 = epr(c3, c3);\r\n    const c3d0 = sce(d0, c3);\r\n    const c3d1 = epr(c3, d1);\r\n    const c3d2 = epr(c3, d2);\r\n    const c3d3 = epr(c3, d3);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d0d3 = sce(d0, d3);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d3d3 = epr(d3, d3);\r\n    const d2d2 = epr(d2, d2);\r\n    const d2d3 = epr(d2, d3);\r\n    const d1d3 = epr(d1, d3);\r\n    //const v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;  \r\n    const g1 = epr(c3, c3c3); // c3*c3c3\r\n    const g2 = epr(c3, d3d3); // c3*d3d3\r\n    const g3 = epr(d3, c3c3); // d3*c3c3\r\n    const g4 = epr(d3, d3d3); // d3*d3d3\r\n    const g5 = epr(g1, vₓₓₓ); // g1*vₓₓₓ\r\n    const g6 = epr(g2, vₓᵧᵧ); // g2*vₓᵧᵧ\r\n    const g7 = epr(g3, vₓₓᵧ); // g3*vₓₓᵧ \r\n    const g8 = epr(g4, vᵧᵧᵧ); // g4*vᵧᵧᵧ\r\n    const g9 = fes(g5, g6); // g5 + g6\r\n    const ga = fes(g7, g8); // g7 + g8\r\n    const v9 = fes(g9, ga); // g9 + ga\r\n    //const v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    const w1 = fes(em2(c2d3), c3d2);\r\n    const w2 = fes(em2(c3d2), c2d3);\r\n    const w3 = epr(c3, w1);\r\n    const w4 = epr(d3, w2);\r\n    const w5 = epr(c2, c3c3);\r\n    const w6 = epr(d2, d3d3);\r\n    const w7 = epr(vₓₓₓ, w5);\r\n    const u1 = epr(vᵧᵧᵧ, w6);\r\n    const u2 = epr(vₓₓᵧ, w3);\r\n    const u3 = epr(vₓᵧᵧ, w4);\r\n    const u4 = fes(u2, u3);\r\n    const u5 = sce(3, fes(w7, u1));\r\n    const v8 = fes(u4, u5);\r\n    //const v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    const o1 = epr(c1, c3d3);\r\n    const o2 = epr(d1, c3c3);\r\n    const o3 = epr(c2, d2d3);\r\n    const o4 = epr(c1, d3d3);\r\n    const o5 = epr(c2, c3d2);\r\n    const o6 = epr(d3, c2c2);\r\n    const o7 = epr(c3, d1d3);\r\n    const o8 = epr(d2, c3d2);\r\n    const w8 = fes(o1, o5);\r\n    const w9 = fes(o2, o6);\r\n    const wa = fes(o3, o7);\r\n    const wb = fes(o4, o8);\r\n    const wc = fes(c1c3, c2c2);\r\n    const wd = fes(d1d3, d2d2);\r\n    const we = fes(em2(w8), w9);\r\n    const wf = fes(em2(wa), wb);\r\n    const wg = epr(vₓₓᵧ, we);\r\n    const wh = epr(vₓᵧᵧ, wf);\r\n    const wi = epr(c3, wc);\r\n    const wj = epr(d3, wd);\r\n    const wk = epr(vₓₓₓ, wi);\r\n    const wl = epr(vᵧᵧᵧ, wj);\r\n    const wm = fes(wg, wh);\r\n    const wn = sce(3, fes(wk, wl));\r\n    const v7 = fes(wm, wn);\r\n    //const v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    const wo = fes(c2d3, c3d2);\r\n    const zc = epr(d2, c2c2);\r\n    const zd = em2(epr(c1, wo));\r\n    const wp = fes(zc, zd);\r\n    const wq = em2(fes(c0d3, c2d1));\r\n    const wr = fes(wq, c3d0);\r\n    const ze = epr(c3, wr);\r\n    const ws = fes(wp, ze);\r\n    const zf = epr(c2, d2d2);\r\n    const zg = em2(epr(d1, wo));\r\n    const wt = fes(zf, zg);\r\n    const wu = em2(fes(c1d2, c3d0));\r\n    const wv = fes(wu, c0d3);\r\n    const zh = epr(d3, wv);\r\n    const ww = fes(wt, zh);\r\n    const wx = epr(c2, c2c2);\r\n    const wy = fes(em2(c1c2), c0c3);\r\n    const wz = epr(sce(3, c3), wy);\r\n    const z1 = fes(wx, wz);\r\n    const z2 = epr(d2, d2d2);\r\n    const z3 = fes(em2(d1d2), d0d3);\r\n    const z4 = epr(sce(3, d3), z3);\r\n    const z5 = fes(z2, z4);\r\n    const zi = epr(vₓₓᵧ, ws);\r\n    const zj = epr(vₓᵧᵧ, ww);\r\n    const z6 = fes(zi, zj);\r\n    const zk = epr(vₓₓₓ, z1);\r\n    const zl = epr(vᵧᵧᵧ, z5);\r\n    const z7 = fes(zk, zl);\r\n    const zm = epr(c3c3, vₓₓ);\r\n    const zn = epr(d3d3, vᵧᵧ);\r\n    const z8 = fes(zm, zn);\r\n    const z9 = epr(c3d3, vₓᵧ);\r\n    const za = fes(z6, z7);\r\n    const zb = fes(z8, z9);\r\n    const v6 = fes(za, zb);\r\n    //const r4 = c2d2 + c3d1;\r\n    //const r5 = c1d3 + c2d2;\r\n    //const v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    const r4 = fes(c2d2, c3d1);\r\n    const r5 = fes(c1d3, c2d2);\r\n    const k1 = sce(c0, wo);\r\n    const k2 = sce(d0, wo);\r\n    const k3 = epr(c1, r4);\r\n    const k4 = epr(d1, r5);\r\n    const k5 = fes(em2(c3d0), c2d1);\r\n    const k6 = fes(em2(c0d3), c1d2);\r\n    const k7 = epr(d3, c1c1);\r\n    const k8 = epr(c3, d1d1);\r\n    const k9 = epr(c2, k5);\r\n    const ka = epr(d2, k6);\r\n    const kb = em2(fes(k1, k3));\r\n    const kc = em2(fes(k2, k4));\r\n    const kd = em2(sce(c0, c2c3));\r\n    const ke = em2(sce(d0, d2d3));\r\n    const kf = epr(c1, wc);\r\n    const kg = epr(d1, wd);\r\n    const kh = epr(c2c3, vₓₓ);\r\n    const ki = epr(d2d3, vᵧᵧ);\r\n    const kj = fes(kb, k7);\r\n    const kk = fes(kc, k8);\r\n    const kl = fes(kj, k9);\r\n    const km = fes(kk, ka);\r\n    const kn = fes(kd, kf);\r\n    const ko = fes(ke, kg);\r\n    const kp = em2(fes(kh, ki));\r\n    const kq = epr(vₓₓᵧ, kl);\r\n    const kr = epr(vₓᵧᵧ, km);\r\n    const ks = epr(vₓₓₓ, kn);\r\n    const kt = epr(vᵧᵧᵧ, ko);\r\n    const ku = fes(kq, kr);\r\n    const kv = sce(3, fes(ks, kt));\r\n    const kw = epr(vₓᵧ, wo);\r\n    const kx = fes(ku, kv);\r\n    const ky = fes(kw, kp);\r\n    const v5 = fes(kx, ky);\r\n    //const r1 = c1d3 + r4;\r\n    //const r2 = 2*c1c3 + c2c2;\r\n    //const r3 = 2*d1d3 + d2d2;\r\n    //const v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    const r1 = fes(c1d3, r4);\r\n    const r2 = fes(em2(c1c3), c2c2);\r\n    const r3 = fes(em2(d1d3), d2d2);\r\n    const s1 = sce((2 * c0), r1);\r\n    const s2 = sce((2 * d0), r1);\r\n    const s5 = fes(c1d2, em2(c2d1));\r\n    const s6 = fes(c2d1, em2(c1d2));\r\n    const s3 = sce(d0, r2);\r\n    const s4 = sce(c0, r3);\r\n    const s7 = epr(c1, s5);\r\n    const s8 = epr(d1, s6);\r\n    const s9 = sce(c0, r2);\r\n    const sa = sce(d0, r3);\r\n    const sb = epr(c2, c1c1);\r\n    const sc = epr(d2, d1d1);\r\n    const sd = fes(s1, s3);\r\n    const se = fes(s2, s4);\r\n    const sf = fes(sd, s7);\r\n    const sg = fes(se, s8);\r\n    const sh = fes(s9, sb);\r\n    const si = fes(sa, sc);\r\n    const sj = epr(vₓₓᵧ, sf);\r\n    const sk = epr(vₓᵧᵧ, sg);\r\n    const sl = epr(vₓₓₓ, sh);\r\n    const sm = epr(vᵧᵧᵧ, si);\r\n    const sn = fes(sl, sm);\r\n    const so = fes(sj, sk);\r\n    const sp = fes(so, sce(3, sn));\r\n    const ss = epr(vₓᵧ, r1);\r\n    const st = epr(vₓₓ, r2);\r\n    const sq = fes(ss, st);\r\n    const su = epr(vᵧᵧ, r3);\r\n    const sr = fes(sq, su);\r\n    const v4 = fes(sp, sr);\r\n    //const r6 = c1d2 + c2d1;\r\n    //const r7 = c3d0 + c0d3;\r\n    //const r8 = c1c2 + c0c3;\r\n    //const r9 = d1d2 + d0d3;\r\n    //const v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    const r6 = fes(c1d2, c2d1);\r\n    const r7 = fes(c3d0, c0d3);\r\n    const r8 = fes(c1c2, c0c3);\r\n    const r9 = fes(d1d2, d0d3);\r\n    const m1 = fes(em2(r6), c3d0);\r\n    const m2 = fes(em2(r6), c0d3);\r\n    const m3 = fes(em2(c2d0), c1d1);\r\n    const m4 = fes(em2(c0d2), c1d1);\r\n    const m5 = fes(r8, c1c2);\r\n    const m6 = fes(r9, d1d2);\r\n    const m7 = epr(tp(3, c0), m5);\r\n    const m8 = epr(tp(3, d0), m6);\r\n    const m9 = epr(c1, c1c1);\r\n    const ma = epr(d1, d1d1);\r\n    const mb = epr(vₓₓ, r8);\r\n    const mc = epr(vᵧᵧ, r9);\r\n    const md = fes(m1, r7);\r\n    const me = fes(m2, r7);\r\n    const mf = sce(c0, md);\r\n    const mg = sce(d0, me);\r\n    const mh = epr(c1, m3);\r\n    const mi = epr(d1, m4);\r\n    const mj = epr(c3, vₓ);\r\n    const mk = epr(d3, vᵧ);\r\n    const ml = fes(mf, mh);\r\n    const mm = fes(mg, mi);\r\n    const mn = fes(m7, m9);\r\n    const mo = fes(m8, ma);\r\n    const mp = fes(r7, r6);\r\n    const mq = em2(fes(mb, mc));\r\n    const mr = epr(vₓₓᵧ, ml);\r\n    const ms = epr(vₓᵧᵧ, mm);\r\n    const mt = epr(vₓₓₓ, mn);\r\n    const mu = epr(vᵧᵧᵧ, mo);\r\n    const mv = epr(vₓᵧ, mp);\r\n    const mw = fes(mr, ms);\r\n    const mx = fes(mt, mu);\r\n    const my = fes(mv, mq);\r\n    const mz = fes(mj, mk);\r\n    const n1 = fes(mw, mx);\r\n    const n2 = fes(my, mz);\r\n    const v3 = fes(n1, n2);\r\n    //const ra = c1d1 + c2d0;\r\n    //const rb = c1d1 + c0d2;\r\n    //const v2 =\r\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //    vₓᵧ*(ra + c0d2) +\r\n    //    vₓₓ*(2*c0c2 + c1c1) + \r\n    //    vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //    c2*vₓ + d2*vᵧ;\r\n    const ra = fes(c1d1, c2d0);\r\n    const rb = fes(c1d1, c0d2);\r\n    const l1 = fes(em2(ra), c0d2);\r\n    const l2 = fes(em2(rb), c2d0);\r\n    const l3 = sce(c0, l1);\r\n    const l4 = sce(d0, c1c1);\r\n    const l5 = sce(d0, l2);\r\n    const l6 = sce(c0, d1d1);\r\n    const l7 = sce(c0, c1c1);\r\n    const l8 = epr(c2, c0c0);\r\n    const l9 = sce(d0, d1d1);\r\n    const la = epr(d2, d0d0);\r\n    const lb = fes(l3, l4);\r\n    const lc = fes(l5, l6);\r\n    const ld = fes(l7, l8);\r\n    const le = fes(l9, la);\r\n    const lf = epr(vₓₓₓ, ld);\r\n    const lg = epr(vᵧᵧᵧ, le);\r\n    const lh = sce(3, fes(lf, lg));\r\n    const li = fes(ra, c0d2);\r\n    const lj = fes(em2(c0c2), c1c1);\r\n    const lk = fes(em2(d0d2), d1d1);\r\n    const ll = epr(vₓₓᵧ, lb);\r\n    const lm = epr(vₓᵧᵧ, lc);\r\n    const ln = epr(vₓᵧ, li);\r\n    const lo = epr(vₓₓ, lj);\r\n    const lp = epr(vᵧᵧ, lk);\r\n    const lq = epr(c2, vₓ);\r\n    const lr = epr(d2, vᵧ);\r\n    const ls = fes(lq, lr);\r\n    const lt = fes(ll, lm);\r\n    const lu = fes(lh, ln);\r\n    const lv = fes(lo, lp);\r\n    const lw = fes(lt, lu);\r\n    const lx = fes(lv, ls);\r\n    const v2 = fes(lw, lx);\r\n    //const rc = c1d0 + c0d1;\r\n    //const v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    const rc = fes(c1d0, c0d1);\r\n    const rd = sce(c0, vₓₓᵧ);\r\n    const re = sce(d0, vₓᵧᵧ);\r\n    const rf = fes(rc, c1d0);\r\n    const rg = fes(rc, c0d1);\r\n    const rx = epr(c1, c0c0);\r\n    const rh = epr(rx, vₓₓₓ);\r\n    const ry = epr(d1, d0d0);\r\n    const ri = epr(ry, vᵧᵧᵧ);\r\n    const rj = epr(vₓᵧ, rc);\r\n    const rk = epr(c0c1, vₓₓ);\r\n    const rl = epr(d0d1, vᵧᵧ);\r\n    const rm = fes(rk, rl);\r\n    const rn = epr(c1, vₓ);\r\n    const ro = epr(d1, vᵧ);\r\n    const rp = fes(rn, ro);\r\n    const rq = epr(rd, rf);\r\n    const rr = epr(re, rg);\r\n    const rs = fes(rq, rr);\r\n    const rt = sce(3, fes(rh, ri));\r\n    const ru = fes(rj, em2(rm));\r\n    const rv = fes(rs, rt);\r\n    const rw = fes(ru, rp);\r\n    const v1 = fes(rv, rw);\r\n    // v0\r\n    const t1 = sce(c0, vₓₓₓ);\r\n    const t2 = sce(d0, vₓₓᵧ);\r\n    const p4 = fes(t1, t2);\r\n    const t3 = sce(c0, vₓᵧᵧ);\r\n    const t4 = sce(d0, vᵧᵧᵧ);\r\n    const p5 = fes(t3, t4);\r\n    const p7 = fes(p4, vₓₓ);\r\n    const p8 = fes(p5, vᵧᵧ);\r\n    const pc = epr(c0c0, p7);\r\n    const pd = epr(d0d0, p8);\r\n    const p6 = fes(pc, pd);\r\n    const pe = epr(c0d0, vₓᵧ);\r\n    const p9 = fes(p6, pe);\r\n    const pf = sce(c0, vₓ);\r\n    const pg = sce(d0, vᵧ);\r\n    const pa = fes(pf, pg);\r\n    const pb = fes(p9, pa);\r\n    const v0 = fes(pb, v);\r\n    const r = [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBezBez: () => (/* binding */ getCoeffsBezBez)\n/* harmony export */ });\n/* harmony import */ var _double_double_get_coeffs_bez1_bez1_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez1-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez1_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez1-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez1_dd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez1-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez1_bez2_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez2-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez2_dd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez2-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez2_dd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez2-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez1_bez3_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez3-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez3_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez3-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js\");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez3_dd_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez3-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js\");\n/* harmony import */ var _exact_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js\");\n/* harmony import */ var _exact_get_coeffs_bez3_bez3_exact_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst coeffFunctionsDd = [\r\n    [_double_double_get_coeffs_bez1_bez1_dd_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsBez1Bez1Dd, _double_double_get_coeffs_bez1_bez2_dd_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsBez1Bez2Dd, _double_double_get_coeffs_bez1_bez3_dd_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBez1Bez3Dd],\r\n    [_double_double_get_coeffs_bez2_bez1_dd_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez2Bez1Dd, _double_double_get_coeffs_bez2_bez2_dd_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez2Bez2Dd, _double_double_get_coeffs_bez2_bez3_dd_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez2Bez3Dd],\r\n    [_double_double_get_coeffs_bez3_bez1_dd_js__WEBPACK_IMPORTED_MODULE_6__.getCoeffsBez3Bez1Dd, _double_double_get_coeffs_bez3_bez2_dd_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez3Bez2Dd, _double_double_get_coeffs_bez3_bez3_dd_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez3Bez3Dd]\r\n];\r\nconst coeffFunctionsExact = [\r\n    [_exact_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez1Bez1Exact, _exact_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_10__.getCoeffsBez1Bez2Exact, _exact_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_11__.getCoeffsBez1Bez3Exact],\r\n    [_exact_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_12__.getCoeffsBez2Bez1Exact, _exact_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_13__.getCoeffsBez2Bez2Exact, _exact_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_14__.getCoeffsBez2Bez3Exact],\r\n    [_exact_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_15__.getCoeffsBez3Bez1Exact, _exact_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_16__.getCoeffsBez3Bez2Exact, _exact_get_coeffs_bez3_bez3_exact_js__WEBPACK_IMPORTED_MODULE_17__.getCoeffsBez3Bez3Exact]\r\n];\r\n/**\r\n * Returns an object with properties containing (1) the coefficients (in double-double\r\n * precision) of a polynomial in 1 variable whose roots are the parameter values\r\n * (of the second curve) of the intersection points of two given order 1, 2 or 3 bezier curves (i.e. lines,\r\n * quadratic and cubic bezier curves), (2) the coefficientwise error bound of the polyomial,\r\n * and (3) a function that returns the *exact* polynomial coefficients as\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * if there is an infinite number of intersections `undefined` is returned\r\n * * intermediate calculations are done in double-double precision with\r\n * fallback to infinite precision (bar underflow / overflow)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @doc mdx\r\n */\r\nfunction getCoeffsBezBez(ps1, ps2) {\r\n    const { coeffs, errBound } = coeffFunctionsDd[ps1.length - 2][ps2.length - 2](ps1, ps2);\r\n    const getPExact = () => coeffFunctionsExact[ps1.length - 2][ps2.length - 2](ps1, ps2);\r\n    return { coeffs, errBound, getPExact };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez-bez.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPFromBox: () => (/* binding */ getPFromBox)\n/* harmony export */ });\n/** @internal */\r\nfunction getPFromBox(box) {\r\n    const tl = box[0];\r\n    const br = box[1];\r\n    return [\r\n        (tl[0] + br[0]) / 2,\r\n        (tl[1] + br[1]) / 2,\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=x.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bAbs: () => (/* binding */ bAbs)\n/* harmony export */ });\n/** @internal */\r\nfunction bAbs(n) {\r\n    return n < 0n ? -n : n;\r\n}\r\n\r\n//# sourceMappingURL=b-abs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bCbrt: () => (/* binding */ bCbrt)\n/* harmony export */ });\n/* harmony import */ var _b_abs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-abs.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js\");\n/* harmony import */ var _b_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-sign.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js\");\n\r\n\r\nconst { round, cbrt } = Math;\r\n/**\r\n * Returns the cube root of a bigint.\r\n *\r\n * * see https://stackoverflow.com/a/53684036/2010061\r\n *\r\n * * **precondition**: the given bigint must be a perfect cube\r\n *\r\n * @internal\r\n */\r\nfunction bCbrt(n) {\r\n    const sgn = (0,_b_sign_js__WEBPACK_IMPORTED_MODULE_0__.bSign)(n);\r\n    n = (0,_b_abs_js__WEBPACK_IMPORTED_MODULE_1__.bAbs)(n);\r\n    if (n <= 1n) {\r\n        return sgn * n;\r\n    }\r\n    let x0 = BigInt(round(cbrt(Number(n))));\r\n    while (true) {\r\n        const x1 = (2n * x0 + n / (x0 * x0)) / 3n;\r\n        if (x1 === x0) {\r\n            return sgn * x0;\r\n        }\r\n        x0 = x1;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-cbrt.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bSign: () => (/* binding */ bSign)\n/* harmony export */ });\n/** @internal */\r\nfunction bSign(v) {\r\n    return v > 0n ? 1n : v < 0n ? -1n : 0n;\r\n}\r\n\r\n//# sourceMappingURL=b-sign.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bSqrt: () => (/* binding */ bSqrt)\n/* harmony export */ });\nconst { round, sqrt } = Math;\r\n/**\r\n * Returns the square root of a bigint.\r\n *\r\n * * see https://stackoverflow.com/a/53684036/2010061\r\n *\r\n * * **precondition**: the given bigint must be a perfect square\r\n *\r\n * @internal\r\n */\r\nfunction bSqrt(v) {\r\n    if (v <= 1n) {\r\n        if (v < 0n) {\r\n            throw new Error('square root of negative numbers are not allowed');\r\n        }\r\n        return v;\r\n    }\r\n    let x0 = BigInt(round(sqrt(Number(v))));\r\n    while (true) {\r\n        const x1 = (x0 + v / x0) >> 1n;\r\n        if (x1 === x0) {\r\n            return x0;\r\n        }\r\n        x0 = x1;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-sqrt.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bigintToExpansion: () => (/* binding */ bigintToExpansion)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n\r\nconst maxSafe = BigInt(2 ** 53);\r\n/**\r\n * Returns the [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansion of the given bigint.\r\n *\r\n * * it is assumed that the given bigint doesn't cause floating point overflow\r\n *\r\n * @internal\r\n */\r\nfunction bigintToExpansion(b) {\r\n    if (b === 0n) {\r\n        return [0];\r\n    }\r\n    const e = [];\r\n    let i = 0;\r\n    let q = b;\r\n    while (q !== 0n) {\r\n        q = b / maxSafe;\r\n        const r = b % maxSafe;\r\n        e.push(Number(r) * 2 ** (i * 53));\r\n        b = q;\r\n        i++;\r\n    }\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompress)(e);\r\n}\r\n\r\n//# sourceMappingURL=bigint-to-expansion.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcExactCubeRoot: () => (/* binding */ calcExactCubeRoot)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js\");\n/* harmony import */ var _bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bigint-to-expansion.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js\");\n/* harmony import */ var _b_cbrt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./b-cbrt.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js\");\n/* harmony import */ var _sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sum-bigints.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js\");\n\r\n\r\n\r\n\r\n/**\r\n * * **precondition**: the given value must be a perfect cube\r\n *\r\n * @param a the rational value for which the square root is sought given as\r\n * `[N,D]` to represent the value `N/D` where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions\r\n *\r\n * @internal\r\n */\r\nfunction calcExactCubeRoot(a) {\r\n    const [NN, DD] = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.scaleFloatssToBigintss)(a).map(_sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__.sumBigints);\r\n    const gcd = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.bGcdInt)(NN, DD);\r\n    // the *exact* positive root `c` is given as the rational number `N/D` \r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    const N = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_cbrt_js__WEBPACK_IMPORTED_MODULE_4__.bCbrt)(NN / gcd));\r\n    const D = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_cbrt_js__WEBPACK_IMPORTED_MODULE_4__.bCbrt)(DD / gcd));\r\n    return [N, D];\r\n}\r\n\r\n//# sourceMappingURL=calc-exact-cube-root.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcExactSquareRoot: () => (/* binding */ calcExactSquareRoot)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js\");\n/* harmony import */ var _bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bigint-to-expansion.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js\");\n/* harmony import */ var _b_sqrt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./b-sqrt.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js\");\n/* harmony import */ var _b_abs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./b-abs.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js\");\n/* harmony import */ var _sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sum-bigints.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * * **precondition**: the given value must be a perfect square\r\n *\r\n * @param a the rational value for which the square root is sought given as\r\n * `[N,D]` to represent the value `N/D` where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions\r\n *\r\n * @internal\r\n */\r\nfunction calcExactSquareRoot(a) {\r\n    const [NN, DD] = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.scaleFloatssToBigintss)(a).map(_sum_bigints_js__WEBPACK_IMPORTED_MODULE_1__.sumBigints);\r\n    const gcd = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.bGcdInt)(NN, DD);\r\n    // the *exact* positive root `c` is given as the rational number `N/D` \r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    const N = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_sqrt_js__WEBPACK_IMPORTED_MODULE_4__.bSqrt)((0,_b_abs_js__WEBPACK_IMPORTED_MODULE_5__.bAbs)(NN / gcd)));\r\n    const D = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_3__.bigintToExpansion)((0,_b_sqrt_js__WEBPACK_IMPORTED_MODULE_4__.bSqrt)((0,_b_abs_js__WEBPACK_IMPORTED_MODULE_5__.bAbs)(DD / gcd)));\r\n    return [N, D];\r\n}\r\n\r\n//# sourceMappingURL=calc-exact-square-root.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureRange: () => (/* binding */ ensureRange)\n/* harmony export */ });\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\n/**\r\n * @param t\r\n * @param min1Sign\r\n *\r\n * @internal\r\n */\r\nfunction ensureRange(t, min1Sign) {\r\n    return (min1Sign < 0\r\n        ? (t < 1 ? t : 1 - u)\r\n        : min1Sign === 0\r\n            ? 1\r\n            : (t > 1 ? t : 1 + eps));\r\n}\r\n\r\n//# sourceMappingURL=ensure-range.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erCompare: () => (/* binding */ erCompare)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n/**\r\n * Compares two expansion rationals.\r\n *\r\n * @internal\r\n */\r\nfunction erCompare(a, b) {\r\n    return ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult)(a[0], b[1]), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult)(a[1], b[0])) *\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(a[1]) *\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(b[1]));\r\n}\r\n\r\n//# sourceMappingURL=er-compare.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erEstimate: () => (/* binding */ erEstimate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-div.js\");\n\r\n/**\r\n * Estimates the result of the given expansion rational.\r\n *\r\n * * the sign of the returned result is guaranteed to be correct\r\n * * the result is guaranteed accurate to within 2 ulps\r\n *\r\n * @param a\r\n *\r\n * @internal\r\n */\r\nfunction erEstimate(a) {\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiv)(a[0], a[1], 2));\r\n}\r\n\r\n//# sourceMappingURL=er-estimate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erSign: () => (/* binding */ erSign)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n\r\n/**\r\n * Returns the sign of the given expansion rational.\r\n *\r\n * @param a\r\n *\r\n * @internal\r\n */\r\nfunction erSign(a) {\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[1]);\r\n}\r\n\r\n//# sourceMappingURL=er-sign.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB: () => (/* binding */ getAB)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _ensure_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ensure-range.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js\");\n/* harmony import */ var _er_estimate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./er-estimate.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js\");\n/* harmony import */ var _er_sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./er-sign.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js\");\n\r\n\r\n\r\n\r\n/** @internal */\r\nfunction getAB(getTransform) {\r\n    return (psA, psB) => {\r\n        const xyA = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA);\r\n        const xyB = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psB);\r\n        const xyAR = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA.slice().reverse());\r\n        const xyBR = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psB.slice().reverse());\r\n        const d = getTransform(xyA, xyB);\r\n        const d_AR = getTransform(xyAR, xyB);\r\n        const d_BR = getTransform(xyA, xyBR);\r\n        const d_ARBR = getTransform(xyAR, xyBR);\r\n        // Get the *certified* sign of `tA_B0 - 1`.\r\n        const sgn_tA_B0_min1 = -(0,_er_sign_js__WEBPACK_IMPORTED_MODULE_1__.erSign)(d_AR);\r\n        const sgn_tA_B1_min1 = -(0,_er_sign_js__WEBPACK_IMPORTED_MODULE_1__.erSign)(d_ARBR);\r\n        const _tA_B0 = (0,_er_estimate_js__WEBPACK_IMPORTED_MODULE_2__.erEstimate)(d);\r\n        const _tA_B1 = (0,_er_estimate_js__WEBPACK_IMPORTED_MODULE_2__.erEstimate)(d_BR);\r\n        const tA_B0 = (0,_ensure_range_js__WEBPACK_IMPORTED_MODULE_3__.ensureRange)(_tA_B0, sgn_tA_B0_min1);\r\n        const tA_B1 = (0,_ensure_range_js__WEBPACK_IMPORTED_MODULE_3__.ensureRange)(_tA_B1, sgn_tA_B1_min1);\r\n        return [tA_B0, tA_B1];\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-ab.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB1: () => (/* binding */ getAB1)\n/* harmony export */ });\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-ab.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js\");\n/* harmony import */ var _get_transform_1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-1.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js\");\n\r\n\r\n/** @internal */\r\nconst getAB1 = (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_0__.getAB)(_get_transform_1_js__WEBPACK_IMPORTED_MODULE_1__.getTransform1);\r\n\r\n//# sourceMappingURL=get-ab1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB2: () => (/* binding */ getAB2)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _get_transform_2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-transform-2.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n/* harmony import */ var _get_ab1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-ab1.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js\");\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-ab.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js\");\n\r\n\r\n\r\n\r\n\r\n/** @internal */\r\nfunction getAB2(psA, psB) {\r\n    const _xyA = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA);\r\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can't be zero else we would have had\r\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \r\n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\r\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign)(_xyA[0][0]) === 0 ? 0 : (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign)(_xyA[1][0]) === 0 ? 1 : -1;\r\n    if (coord !== -1) {\r\n        const psA0c = psA[0][coord];\r\n        const psA2c = psA[2][coord];\r\n        const psB0c = psB[0][coord];\r\n        const psB2c = psB[2][coord];\r\n        return (0,_get_ab1_js__WEBPACK_IMPORTED_MODULE_2__.getAB1)([[psA0c, psA0c], [psA2c, psA2c]], [[psB0c, psB0c], [psB2c, psB2c]]);\r\n    }\r\n    return (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_3__.getAB)(_get_transform_2_js__WEBPACK_IMPORTED_MODULE_4__.getTransform2)(psA, psB);\r\n}\r\n\r\n//# sourceMappingURL=get-ab2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAB3: () => (/* binding */ getAB3)\n/* harmony export */ });\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-ab.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js\");\n/* harmony import */ var _get_transform_3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-3.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js\");\n\r\n\r\n/** @internal */\r\nconst getAB3 = (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_0__.getAB)(_get_transform_3_js__WEBPACK_IMPORTED_MODULE_1__.getTransform3);\r\n\r\n//# sourceMappingURL=get-ab3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEndpointIntersections: () => (/* binding */ getEndpointIntersections)\n/* harmony export */ });\n/* harmony import */ var _bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../bezier-bezier-intersection/x.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js\");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transformation/reduce-order-if-possible.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js\");\n/* harmony import */ var _get_ab1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-ab1.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js\");\n/* harmony import */ var _get_ab2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-ab2.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js\");\n/* harmony import */ var _get_ab3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-ab3.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../sub-1-ulp.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/sub-1-ulp.js\");\n/* harmony import */ var _add_1_ulp_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../add-1-ulp.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/add-1-ulp.js\");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../boxes/intersect-boxes.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/boxes/intersect-boxes.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Returns the intersection range (given as 2 intersections (`X`s)) where the\r\n * endpoints of the two given *algebraically identical* curves\r\n * overlap (provided they overlap, else an empty array is returned).\r\n *\r\n * * **precondition:** the two given curves must be *algebraically identical*\r\n * (i.e. identical except possibly for endpoints)\r\n *\r\n * * **precondition**: not all bezier control points collinear\r\n *\r\n * @param psA an order 1,2 or 3 bezier curve\r\n * @param psB another bezier curve\r\n *\r\n * @internal but still exported for backwards compatibility\r\n */\r\nfunction getEndpointIntersections(psA, psB, orderAlreadyReduced = false) {\r\n    if (!orderAlreadyReduced) {\r\n        psA = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__.reduceOrderIfPossible)(psA);\r\n        psB = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_0__.reduceOrderIfPossible)(psB);\r\n    }\r\n    // `psB.length` should equal `psB.length` (due to precondition)\r\n    const getABs = [, , _get_ab1_js__WEBPACK_IMPORTED_MODULE_1__.getAB1, _get_ab2_js__WEBPACK_IMPORTED_MODULE_2__.getAB2, _get_ab3_js__WEBPACK_IMPORTED_MODULE_3__.getAB3];\r\n    const [tA_B0, tA_B1] = getABs[psA.length](psA, psB);\r\n    const [tB_A0, tB_A1] = getABs[psA.length](psB, psA);\r\n    //------------------------------------------------\r\n    // Perform a simple unrolled sweep line algorithm\r\n    //------------------------------------------------\r\n    const infos = [\r\n        { tA: tA_B0, tB: 0, bez: 'B', start: true },\r\n        { tA: tA_B1, tB: 1, bez: 'B', start: false },\r\n        { tA: 0, tB: tB_A0, bez: 'A', start: true },\r\n        { tA: 1, tB: tB_A1, bez: 'A', start: false }\r\n    ].sort((a, b) => a.tA - b.tA);\r\n    if (infos[1].tA === infos[2].tA) {\r\n        const info = infos[1];\r\n        const tA = info.tA; // `tA` will be either exactly `0` or exactly `1`\r\n        const tB = info.tB; // `tB` will be either exactly `0` or exactly `1`\r\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psA, [tA, tA]);\r\n        return [{\r\n                p: box[0], kind: 4, box,\r\n                t1: tA, ri1: { tS: tA, tE: tA, multiplicity: 1 },\r\n                t2: tB, ri2: { tS: tB, tE: tB, multiplicity: 1 }\r\n            }];\r\n    }\r\n    if (infos[0].bez === infos[1].bez) {\r\n        return [];\r\n    }\r\n    const start = infos[1];\r\n    const end = infos[2];\r\n    const [tSAMin, tSAMax] = getMinMaxT(start.tA);\r\n    const [tSBMin, tSBMax] = getMinMaxT(start.tB);\r\n    const [tEAMin, tEAMax] = getMinMaxT(end.tA);\r\n    const [tEBMin, tEBMax] = getMinMaxT(end.tB);\r\n    const boxSA = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psA, [tSAMin, tSAMax]);\r\n    const boxSB = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psB, [tSBMin, tSBMax]);\r\n    const boxEA = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psA, [tEAMin, tEAMax]);\r\n    const boxEB = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(psB, [tEBMin, tEBMax]);\r\n    const boxS = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__.intersectBoxes)(boxSA, boxSB);\r\n    const boxE = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__.intersectBoxes)(boxEA, boxEB);\r\n    const riSA = { tS: tSAMin, tE: tSAMax, multiplicity: 1 };\r\n    const riSB = { tS: tSBMin, tE: tSBMax, multiplicity: 1 };\r\n    const riEA = { tS: tEAMin, tE: tEAMax, multiplicity: 1 };\r\n    const riEB = { tS: tEBMin, tE: tEBMax, multiplicity: 1 };\r\n    return [\r\n        {\r\n            p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__.getPFromBox)(boxS), kind: 5, box: boxS,\r\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riSA), ri1: riSA,\r\n            t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riSB), ri2: riSB\r\n        }, {\r\n            p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_6__.getPFromBox)(boxE), kind: 5, box: boxE,\r\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riEA), ri1: riEA,\r\n            t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(riEB), ri2: riEB\r\n        }\r\n    ];\r\n}\r\n/** @internal */\r\nfunction sub2Ulp(v) {\r\n    return (0,_sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_8__.sub1Ulp)((0,_sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_8__.sub1Ulp)(v));\r\n}\r\n/** @internal */\r\nfunction add2Ulp(v) {\r\n    return (0,_add_1_ulp_js__WEBPACK_IMPORTED_MODULE_9__.add1Ulp)((0,_add_1_ulp_js__WEBPACK_IMPORTED_MODULE_9__.add1Ulp)(v));\r\n}\r\n/** @internal */\r\nfunction getMinMaxT(t) {\r\n    if (t === 0 || t === 1) {\r\n        return [t, t];\r\n    }\r\n    const tMin = sub2Ulp(t);\r\n    const tMax = add2Ulp(t);\r\n    return [tMin, tMax];\r\n}\r\n\r\n//# sourceMappingURL=get-endpoint-intersections.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTransform1: () => (/* binding */ getTransform1)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\r\n/** @internal */\r\nfunction getTransform1(_xyA, _xyB) {\r\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can't be zero else we would have had\r\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \r\n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\r\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(_xyA[0][0]) === 0 ? 1 : 0;\r\n    const xyA = _xyA[coord];\r\n    const xyB = _xyB[coord];\r\n    return getTransformedTs1(xyA, xyB);\r\n}\r\n/**\r\n * Given two algebraically identical bezier curves (but with possibly different\r\n * endpoints) return the transformation parameters (the `c` and `d` in\r\n * `t = cx + d`) for transforming the second curve into the first so that it has\r\n * exactly the same control points but such that the parameter `t` values run\r\n * from `t0` to `t1` where `t0` and `t1` can be obtained via `t0 = -d/c`\r\n * and `t1 = (1 - d)/c` (or in reverse: `t0_ = d` and `t1_ = c + d`).\r\n *\r\n * * **precondition**: the given pair of bezier curves must be algebraically\r\n * identical, e.g. `ps = [[1,1],[2,2],[3,2],[3,-1]]`\r\n * and `ps_ = [[-1,-21],[-3.25,-29.25],[-6.625,-40.3125],[-11.546875,-55.03125]]`\r\n *\r\n * * **precondition**: the given pair of bezier curves are in lowest possible\r\n * order\r\n *\r\n * @internal\r\n */\r\nfunction getTransformedTs1(A, B) {\r\n    const [p1, p0] = A;\r\n    const [, r0] = B;\r\n    // The (over-determined) set of equations used to solve `c` and `d`\r\n    // (1)   r1 = c*p1       => c = r1/p1\r\n    // (2)   r0 = d*p1 + p0  => d = (r0 - p0)/p1\r\n    //---------------\r\n    // Calculate `d`\r\n    //---------------\r\n    // (1)   d = (r0 - p0)/p1\r\n    // the *exact* `d` is given as the rational number `N/D`\r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    return [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff)(r0, p0), p1];\r\n}\r\n\r\n//# sourceMappingURL=get-transform-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTransform2: () => (/* binding */ getTransform2)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var _er_compare_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./er-compare.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js\");\n/* harmony import */ var _calc_exact_square_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc-exact-square-root.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js\");\n\r\n\r\n\r\n/** @internal */\r\nfunction getTransform2(xyA, xyB) {\r\n    const [D1x, D2x] = getTransformedTs2(xyA[0], xyB[0]);\r\n    const [D1y, D2y] = getTransformedTs2(xyA[1], xyB[1]);\r\n    if ((0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D1x, D1y) === 0 ||\r\n        (0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D1x, D2y) === 0) {\r\n        return D1x;\r\n    }\r\n    if ((0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D2x, D1y) === 0 ||\r\n        (0,_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare)(D2x, D2y) === 0) {\r\n        return D2x;\r\n    }\r\n    throw new Error('An unexpected error occured.');\r\n}\r\n/**\r\n * @param A A coordinate (x or y) of a bezier curve in power basis\r\n * @param B A coordinate (x or y) of another bezier curve in power basis\r\n *\r\n * @internal\r\n */\r\nfunction getTransformedTs2(A, B) {\r\n    const [p2, p1] = A;\r\n    const [r2, r1] = B;\r\n    // The (over-determined) set of equations used to solve `c` and `d`\r\n    // (1)   r2 = cc*p2\r\n    // (2)   r1 = c*p1 + 2*c*d*p2\r\n    // (3)   r0 = dd*p2 + d*p1 + p0\r\n    // Note that since `r2,r1,r0,p2,p1,p0` are rational we must have \r\n    // (non-trivially) that `c` is rational and thus `d` also rational.\r\n    //-----------------------------------\r\n    // Calculate `c` *exactly* using (1)\r\n    //-----------------------------------\r\n    // the *exact* positive root `c` is given as the rational number `N/D` \r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    const [N, D] = (0,_calc_exact_square_root_js__WEBPACK_IMPORTED_MODULE_1__.calcExactSquareRoot)([r2, p2]);\r\n    //-----------------------------------\r\n    // Calculate `d` *exactly* using (2)\r\n    //-----------------------------------\r\n    // (2)   r1 = c*p1 + 2*c*d*p2  =>\r\n    //       r1 = c*(p1 + 2*d*p2)  =>\r\n    // dA = (r1/c - p1)/(2*p2)\r\n    //    = r1/(c*2*p2) - c*p1/(c*2*p2)\r\n    //    = (r1 - c*p1)/(c*2*p2)\r\n    //    = (r1 - N*p1/D)/(N*2*p2/D)\r\n    //    = (D*r1 - N*p1)/(N*2*p2)\r\n    // dB = (r1/(-c) - p1)/(2*p2)\r\n    //    = r1/(-c*2*p2) - c*p1/(c*2*p2)\r\n    //    = (-r1 - c*p1)/(c*2*p2)\r\n    //    = (-r1 - N*p1/D)/(N*2*p2/D)\r\n    //    = (-r1*D - N*p1)/(N*2*p2)\r\n    return [\r\n        [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(r1, D), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(p1, N)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(N, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2)(p2))],\r\n        [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(r1, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eNegativeOf)(D)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(p1, N)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(N, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultBy2)(p2))]\r\n    ].sort(_er_compare_js__WEBPACK_IMPORTED_MODULE_0__.erCompare);\r\n}\r\n\r\n//# sourceMappingURL=get-transform-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTransform3: () => (/* binding */ getTransform3)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var _calc_exact_cube_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc-exact-cube-root.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js\");\n\r\n\r\n/** @internal */\r\nfunction getTransform3(xyA, xyB) {\r\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can't be zero else we would have had\r\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \r\n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\r\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(xyA[0][0]) === 0 ? 1 : 0;\r\n    const xyA_ = xyA[coord];\r\n    const xyB_ = xyB[coord];\r\n    return getTransformedTs3(xyA_, xyB_);\r\n}\r\n/**\r\n * Given two algebraically identical bezier curves (but with possibly different\r\n * endpoints) return the transformation parameters (the `c` and `d` in\r\n * `t = cx + d`) for transforming the second curve into the first so that it has\r\n * exactly the same control points but such that the parameter `t` values run\r\n * from `t0` to `t1` where `t0` and `t1` can be obtained via `t0 = -d/c`\r\n * and `t1 = (1 - d)/c` (or in reverse: `t0_ = d` and `t1_ = c + d`).\r\n *\r\n * * **precondition**: the given pair of bezier curves must be algebraically\r\n * identical, e.g. `ps = [[1,1],[2,2],[3,2],[3,-1]]`\r\n * and `ps_ = [[-1,-21],[-3.25,-29.25],[-6.625,-40.3125],[-11.546875,-55.03125]]`\r\n *\r\n * * **precondition**: the given pair of bezier curves are in lowest possible\r\n * order\r\n *\r\n * @internal\r\n */\r\nfunction getTransformedTs3(A, B) {\r\n    const [p3, p2] = A;\r\n    const [r3, r2] = B;\r\n    // The (over-determined) set of equations used to solve `c` and `d`\r\n    // (1)   r3 = p3*ccc\r\n    // (2)   r2 = 3*cc*p3*d + cc*p2\r\n    // (3)   r1 = 3*c*p3*dd + 2*c*p2*d + c*p1\r\n    // (4)   r0 = p3*ddd + p2*dd + p1*d + p0\r\n    //-------------------------\r\n    // Calculate `c` *exactly*\r\n    //-------------------------\r\n    const C = (0,_calc_exact_cube_root_js__WEBPACK_IMPORTED_MODULE_1__.calcExactCubeRoot)([r3, p3]);\r\n    //-------------------------\r\n    // Calculate `d` *exactly*\r\n    //-------------------------\r\n    // (2)   3*cc*p3*d + cc*p2 = r2\r\n    //  =>   d = (r2/cc - p2)/(3*p3)\r\n    const NN = eSquare(C[0]);\r\n    return [\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(r2, eSquare(C[1])), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(p2, NN)),\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.scaleExpansion2)(3, p3), NN)\r\n    ];\r\n}\r\n/** @internal */\r\nfunction eSquare(v) {\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(v, v);\r\n}\r\n\r\n//# sourceMappingURL=get-transform-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sumBigints: () => (/* binding */ sumBigints)\n/* harmony export */ });\n/** @internal */\r\nfunction sumBigints(vs) {\r\n    let total = 0n;\r\n    for (let i = 0; i < vs.length; i++) {\r\n        total += vs[i];\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=sum-bigints.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierSelfIntersection: () => (/* binding */ bezierSelfIntersection)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-abs.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coefficients/double/get-coeffs-bez3-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js\");\n/* harmony import */ var _get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coefficients/exact/get-coeffs-bez3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\r\n\r\n\r\n\r\n\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_3__.twoDiff;\r\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_3__.twoSum;\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_3__.ddNegativeOf;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst qdivq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddDivDd;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.growExpansion;\r\nconst eps = Number.EPSILON;\r\nconst eps2 = 2 * eps;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γ\"])(1);\r\n/**\r\n * Returns the unique self-intersection parameter `t` values of the given\r\n * bezier curve if they exist, else return `[]` (see also the `inRange`\r\n * parameter below).\r\n *\r\n * * only cubic (or higher order) bezier curves can have unique self-intersections\r\n * * this algorithm is mathematically guaranteed accurate to within an absolute\r\n * error of `4 * Number.EPSILON` for the returned `t` values satisfying `|t| <= 1`\r\n * or a relative error of the same `4 * Number.EPSILON` otherwise.\r\n * * **special case:** a cusp is considered a degenerate self-intersection and\r\n * the (duplicate) `t` values will be returned\r\n *\r\n * @param ps a bezier curve given as an array of its control points\r\n * @param inRange if `inRange === true` (the default) then return the two `t`\r\n * parameter values only if both are in [0,1] else return `[]`.\r\n * If `inRange === false` then return the (0,1 or 2) `t` values in `[0,1]` even\r\n * if only one is in that range.\r\n *\r\n * @doc mdx\r\n */\r\nfunction bezierSelfIntersection(ps, inRange = true) {\r\n    if (ps.length < 4) {\r\n        // lines and quadratics don't have uniqure self-intersections.\r\n        return [];\r\n    }\r\n    // First get fast naively calculated coefficients\r\n    const { coeffs: [a, b, c], errBound: [a_, b_, c_] } = (0,_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez3WithRunningError)(ps);\r\n    // if error in `a` cannot discern it from zero\r\n    if (abs(a) <= a_) {\r\n        // it is rare to get here \r\n        // check for sure if a === 0 exactly\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        //const a3 = (x3 - x0) + 3*(x1 - x2);\r\n        //const a2 = (x2 + x0) - 2*x1;\r\n        //const b3 = (y3 - y0) + 3*(y1 - y2);\r\n        //const b2 = (y2 + y0) - 2*y1;\r\n        const a3 = fes(td(x3, x0), sce(3, (td(x1, x2))));\r\n        const a2 = ge(ts(x2, x0), -2 * x1);\r\n        const b3 = fes(td(y3, y0), sce(3, (td(y1, y2))));\r\n        const b2 = ge(ts(y2, y0), -2 * y1);\r\n        const a2b3 = epr(a2, b3);\r\n        const a3b2 = epr(a3, b2);\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.eCompare)(a2b3, a3b2) === 0) {\r\n            // a === 0 => no roots possible! (also b === 0 always if a === 0)\r\n            // This type of curve is usually shaped like an S where both \r\n            // extreme curvatures are identical...\r\n            // ...this is an explicit cubic curve!\r\n            return [];\r\n        }\r\n    }\r\n    // `Discr` = discriminant = b^2 - 4ac\r\n    // calculate `Discr` and its absolute error Discr_\r\n    const bb = b * b;\r\n    const bb_ = 2 * b_ * abs(b) + γ1 * bb; // the error in b**2\r\n    const ac4 = 4 * a * c;\r\n    const ac4_ = 4 * (a_ * abs(c) + abs(a) * c_) + γ1 * abs(ac4);\r\n    const Discr = bb - ac4;\r\n    const Discr_ = bb_ + ac4_ + γ1 * abs(Discr);\r\n    // if the discriminant is smaller than negative the error bound then\r\n    // certainly there are no roots, i.e. no cusp and no self-intersections\r\n    if (Discr < -Discr_) {\r\n        // discriminant is definitely negative\r\n        return [];\r\n    }\r\n    // if the discriminant is definitely positive\r\n    if (Discr > Discr_) {\r\n        // calculate roots naively as a fast pre-filter\r\n        const { est: D, err: D_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.sqrtWithErr)(Discr, Discr_);\r\n        let q1;\r\n        if (b >= 0) {\r\n            // const r1 = (-b - D) / 2*a;\r\n            // const r2 = (2*c) / (-b - D);\r\n            q1 = -b - D;\r\n        }\r\n        else {\r\n            // const r2 = (-b + D) / 2*a;\r\n            // const r1 = (2*c) / (-b + D);\r\n            q1 = -b + D;\r\n        }\r\n        const q1_ = b_ + D_ + γ1 * abs(q1);\r\n        const { est: r1, err: r1_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.divWithErr)(q1, 2 * a, q1_, 2 * a_);\r\n        const { est: r2, err: r2_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.divWithErr)(2 * c, q1, 2 * c_, q1_);\r\n        // the actual 'filter' follows\r\n        if (inRange) {\r\n            // IF at least one root is not in [0,1]\r\n            // THEN no self-intersection (in [0,1])\r\n            if (r1 + r1_ < 0 || r1 - r1_ > 1 ||\r\n                r2 + r2_ < 0 || r2 - r2_ > 1) {\r\n                return [];\r\n            }\r\n        }\r\n        else {\r\n            // IF both roots not in [0,1] \r\n            // THEN no self-intersection (in [0,1])\r\n            if ((r1 + r1_ < 0 || r1 - r1_ > 1) &&\r\n                (r2 + r2_ < 0 || r2 - r2_ > 1)) {\r\n                return [];\r\n            }\r\n        }\r\n    }\r\n    // we need to check exactly - (a !== 0) at this point - tested for earlier\r\n    let [A, B, C] = (0,_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Exact)(ps);\r\n    // exact - Discr = b^2 - 4ac\r\n    const eDiscr = edif(epr(B, B), sce(4, epr(A, C)));\r\n    const sgnDiscr = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(eDiscr);\r\n    if (sgnDiscr < 0) {\r\n        // sgn < 0 => no real roots => no cusp or double point for t in [0,1]\r\n        return [];\r\n    }\r\n    if (sgnDiscr > 0) {\r\n        const D = (0,double_double__WEBPACK_IMPORTED_MODULE_3__.ddSqrt)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(eDiscr));\r\n        A = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(A);\r\n        B = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(B);\r\n        C = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(C);\r\n        let nBD;\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(B) >= 0) {\r\n            nBD = qno(qaq(B, D));\r\n            //t1 = (-B - D) / (2*A);\r\n            //t2 = (2*C) / (-B - D);\r\n        }\r\n        else {\r\n            nBD = qaq(qno(B), D);\r\n            //t1 = (2*C) / (-B + D);\r\n            //t2 = (-B + D) / (2*A);\r\n        }\r\n        let t1 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_12__.eEstimate)(qdivq(nBD, qm2(A))); // max 1 ulps out\r\n        let t2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_12__.eEstimate)(qdivq(qm2(C), nBD)); // max 1 ulps out\r\n        if (inRange) {\r\n            // if any root is outside the range => no double point for t in [0,1]\r\n            if (t1 < -eps2 || t1 > 1 + eps2 ||\r\n                t2 < -eps2 || t2 > 1 + eps2) {\r\n                return [];\r\n            }\r\n        }\r\n        else {\r\n            // if both roots are outside the range => no double point for t in [0,1]\r\n            if ((t1 < -eps2 || t1 > 1 + eps2) &&\r\n                (t2 < -eps2 || t2 > 1 + eps2)) {\r\n                return [];\r\n            }\r\n        }\r\n        // coerce to 0/1\r\n        //t1 = (t1 >= -eps4 && t1 < 0)\r\n        //    ? 0\r\n        //    : (t1 > 1 && t1 <= 1 + eps4) ? 1 : t1;\r\n        //t2 = (t2 >= -eps4 && t2 < 0)\r\n        //    ? 0\r\n        //    : (t2 > 1 && t2 <= 1 + eps4) ? 1 : t2;\r\n        [t1, t2] = t1 < t2 ? [t1, t2] : [t2, t1];\r\n        return t1 >= 0 - eps2 && t1 <= 1 + eps2\r\n            ? t2 >= 0 - eps2 && t2 <= 1 + eps2\r\n                ? [t1, t2]\r\n                : [t1]\r\n            : t2 >= 0 - eps2 && t2 <= 1 + eps2\r\n                ? [t2]\r\n                : [];\r\n    }\r\n    // sign === 0 => cusp\r\n    // set t = b/d = b/-2a\r\n    const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_13__.eMultByNeg2)(A);\r\n    const sgnB = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(B);\r\n    const sgnD = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign)(d);\r\n    // if result is negative the cusp is outside the bezier endpoints\r\n    const sgn_ = sgnB * sgnD;\r\n    if (sgn_ < 0) {\r\n        return [];\r\n    }\r\n    // if result is > 1 the cusp is outside the bezier endpoints\r\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_14__.eAbs)(B), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_14__.eAbs)(d)) > 0) {\r\n        return [];\r\n    }\r\n    const qB = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(B);\r\n    const qd = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_11__.eToDd)(d);\r\n    const qt = qdivq(qB, qd);\r\n    const t = qt[1] + qt[0];\r\n    return [t, t];\r\n}\r\n\r\n//# sourceMappingURL=bezier-self-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3WithRunningError: () => (/* binding */ getCoeffsBez3WithRunningError)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js\");\n\r\n\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__[\"γ\"])(1);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the self-intersection points of the\r\n * given cubic bezier curve.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of double\r\n * precision floating point numbers from highest to lowest power,\r\n * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned need **not** be scaled before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve.\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3WithRunningError(ps) {\r\n    const { coeffs: [[a3, a2, a1], [b3, b2, b1]], errorBound: [[a3_, a2_], [b3_, b2_]] } = (0,_to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3WithRunningError)(ps);\r\n    const _a3 = abs(a3);\r\n    const _a2 = abs(a2);\r\n    const _a1 = abs(a1);\r\n    const _b3 = abs(b3);\r\n    const _b2 = abs(b2);\r\n    const _b1 = abs(b1);\r\n    const a2b3 = a2 * b3;\r\n    const a3b2 = a3 * b2;\r\n    const a3b1 = a3 * b1;\r\n    const a1b3 = a1 * b3;\r\n    const a2b1 = a2 * b1;\r\n    const a1b2 = a1 * b2;\r\n    // Note: a variable prepended with and underscore is an absolute value,\r\n    // postpended with an underscore denotes an absolute error (before \r\n    // multiplication by the round-off unit `u`) - both underscores present \r\n    // means it is both an absolute value and a round-off error.\r\n    const _a2b3 = abs(a2b3);\r\n    const _a3b2 = abs(a3b2);\r\n    const _a3b1 = abs(a3b1);\r\n    const _a1b3 = abs(a1b3);\r\n    const _a2b1 = abs(a2b1);\r\n    const _a1b2 = abs(a1b2);\r\n    const a2b3_ = a2_ * _b3 + _a2 * b3_ + _a2b3;\r\n    const a3b2_ = a3_ * _b2 + _a3 * b2_ + _a3b2;\r\n    const a3b1_ = a3_ * _b1 + _a3b1;\r\n    const a1b3_ = _a1 * b3_ + _a1b3;\r\n    const a2b1_ = a2_ * _b1 + _a2b1;\r\n    const a1b2_ = _a1 * b2_ + _a1b2;\r\n    const f4 = a2b3 - a3b2;\r\n    const _f4 = abs(f4);\r\n    const f4_ = a2b3_ + a3b2_ + _f4;\r\n    const f5 = a1b3 - a3b1;\r\n    const _f5 = abs(f5);\r\n    const f5_ = a1b3_ + a3b1_ + _f5;\r\n    const f6 = a2b1 - a1b2;\r\n    const _f6 = abs(f6);\r\n    const f6_ = a2b1_ + a1b2_ + _f6;\r\n    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    //const u2 = a2b3*(-2*a3b2 + a2b3) + a3b2*a3b2\r\n    //const u2 = (a2b3 - a3b2)*(a2b3 - a3b2)\r\n    const u2 = f4 * f4;\r\n    const u2_ = 2 * f4_ * _f4 + abs(u2);\r\n    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    //const u1 = a1*b3*-a3*b2 + a1*b3*a2*b3 + a3*b1*-a2*b3 + a3*b1*a3*b2\r\n    //const u1 = a1b3*(a2b3 - a3b2) - a3b1*(a2b3 - a3b2)\r\n    //const u1 = a1b3*f4 - a3b1*f4 = f4*(a1b3 - a3b1);\r\n    const u1 = f4 * f5;\r\n    const u1_ = f4_ * _f5 + _f4 * f5_ + abs(u1);\r\n    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    //const u0 = \r\n    //       a2b3*(a2b1 - a1b2) - a3b2*(a2b1 - a1b2) +\r\n    //       a1b3*(-2*a3b1 + a1b3) + a3b1*a3b1;\r\n    //const u0 = \r\n    //       f6*f4 + \r\n    //       (a1b3 - a3b1)*(a1b3 - a3b1);\r\n    //const u0 = f6*f4 + f5*f5;\r\n    const g7 = f6 * f4;\r\n    const g7_ = f6_ * _f4 + _f6 * f4_ + abs(g7);\r\n    const g9 = f5 * f5;\r\n    const g9_ = 2 * _f5 * f5_ + abs(g9);\r\n    const u0 = g7 + g9;\r\n    const u0_ = g7_ + g9_ + abs(u0);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return {\r\n        coeffs: [u2, u1, u0],\r\n        errBound: [u2_, u1_, u0_].map(c => γ1 * c)\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoeffsBez3Exact: () => (/* binding */ getCoeffsBez3Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\r\n/**\r\n * Returns an error-free polynomial in 1 variable whose roots are the parameter\r\n * values of the self-intersection points of the given cubic bezier curve.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve.\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Exact(ps) {\r\n    const [[a3, a2, a1], [b3, b2, b1]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3Exact)(ps);\r\n    const a2b3 = epr(a2, b3);\r\n    const a3b2 = epr(a3, b2);\r\n    const a3b1 = epr(a3, b1);\r\n    const a1b3 = epr(a1, b3);\r\n    const a2b1 = epr(a2, b1);\r\n    const a1b2 = epr(a1, b2);\r\n    const f4 = ediff(a2b3, a3b2);\r\n    const f5 = ediff(a1b3, a3b1);\r\n    const f6 = ediff(a2b1, a1b2);\r\n    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    const u2 = epr(f4, f4);\r\n    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    const u1 = epr(f4, f5);\r\n    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    const g7 = epr(f4, f6);\r\n    const g9 = epr(f5, f5);\r\n    const u0 = fes(g7, g9);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return [u2, u1, u0];\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/curvature.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/curvature.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curvature: () => (/* binding */ curvature),\n/* harmony export */   \"κ\": () => (/* binding */ κ)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js\");\n\r\n\r\n\r\n/**\r\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\r\n * curve at a specific given parameter value `t`.\r\n *\r\n * * returns `Number.NaN` at a cusp - this can be tested for with `Number.isNaN`\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the curvature should be evaluated\r\n *\r\n * @doc mdx\r\n */\r\nfunction curvature(ps, t) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    const [ddX, ddY] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_2ndDerivative)(ps);\r\n    const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(dX, t);\r\n    const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(dY, t);\r\n    const ddx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(ddX, t);\r\n    const ddy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.Horner)(ddY, t);\r\n    const a = dx * ddy - dy * ddx;\r\n    const b = Math.sqrt((dx * dx + dy * dy) ** 3);\r\n    return a / b;\r\n}\r\n/**\r\n * Alias for [[κ]].\r\n *\r\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\r\n * curve at a specific given parameter value `t`.\r\n *\r\n * * **alias**: [[curvature]]\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the curvature should be evaluated\r\n *\r\n * @doc\r\n */\r\nconst κ = curvature;\r\n\r\n//# sourceMappingURL=curvature.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/curvature.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauDd: () => (/* binding */ evalDeCasteljauDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\r\n/**\r\n * Returns the resulting point (in double-double precision) of evaluating the\r\n * given bezier curve at the given parameter `t` (given as a double-double\r\n * precision floating point number).\r\n *\r\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * with intermediate calculations done in double-double precision floating point\r\n * arithmetic.\r\n *\r\n * * to get an absolute error bound on the result call [[evalDeCasteljauError]]\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated (given in\r\n * double-double precision)\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljauDd(ps, t) {\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        return ps[0].map(c => [c]);\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        return ps[ps.length - 1].map(c => [c]);\r\n    }\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const a01 = qad(qmq(td(x1, x0), t), x0);\r\n        const a11 = qad(qmq(td(x2, x1), t), x1);\r\n        const a21 = qad(qmq(td(x3, x2), t), x2);\r\n        const a02 = qaq(a01, qmq(qdq(a11, a01), t));\r\n        const a12 = qaq(a11, qmq(qdq(a21, a11), t));\r\n        const x = qaq(a02, qmq(qdq(a12, a02), t));\r\n        const b01 = qad(qmq(td(y1, y0), t), y0);\r\n        const b11 = qad(qmq(td(y2, y1), t), y1);\r\n        const b21 = qad(qmq(td(y3, y2), t), y2);\r\n        const b02 = qaq(b01, qmq(qdq(b11, b01), t));\r\n        const b12 = qaq(b11, qmq(qdq(b21, b11), t));\r\n        const y = qaq(b02, qmq(qdq(b12, b02), t));\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const a01 = qaq([0, x0], qmq(td(x1, x0), t));\r\n        const a11 = qaq([0, x1], qmq(td(x2, x1), t));\r\n        const x = qaq(a01, qmq(qdq(a11, a01), t));\r\n        const b01 = qaq([0, y0], qmq(td(y1, y0), t));\r\n        const b11 = qaq([0, y1], qmq(td(y2, y1), t));\r\n        const y = qaq(b01, qmq(qdq(b11, b01), t));\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const x = qad(qmq(td(x1, x0), t), x0);\r\n        const y = qad(qmq(td(y1, y0), t), y0);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 1) {\r\n        const [x, y] = ps[0];\r\n        return [[0, x], [0, y]];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauWithErr: () => (/* binding */ evalDeCasteljauWithErr)\n/* harmony export */ });\n/* harmony import */ var _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../eval-de-casteljau-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js\");\n/* harmony import */ var _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eval-de-casteljau.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst evalDeCasteljau = _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau;\r\nconst evalDeCasteljauError = _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__[\"γ\"])(1);\r\n/**\r\n * Returns the resulting point of evaluating the given bezier curve at the given\r\n * parameter `t` including a coordinate-wise error bound.\r\n *\r\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * in double precision floating point arithmetic\r\n *\r\n * The resulting point is returned as `{ p: number[], pE: number[] }`,\r\n * where `p` is the point `[x,y]` and `pE` is the corresponding coordinate-wise\r\n * absolute error bound of the calculation.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljauWithErr(ps, t) {\r\n    const p = evalDeCasteljau(ps, t);\r\n    const pE = evalDeCasteljauError(ps, [0, t]);\r\n    if (ps.length === 4) {\r\n        return { p, pE: pE.map(e => 9 * γ1 * e) };\r\n    }\r\n    if (ps.length === 3) {\r\n        return { p, pE: pE.map(e => 6 * γ1 * e) };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { p, pE: pE.map(e => 3 * γ1 * e) };\r\n    }\r\n    if (ps.length === 1) {\r\n        return { p: ps[0], pE: [0, 0] };\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-with-err.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljau: () => (/* binding */ evalDeCasteljau)\n/* harmony export */ });\n/**\r\n * Returns the resulting point of evaluating the given bezier curve at the\r\n * given parameter `t`.\r\n *\r\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * in double precision floating point arithmetic\r\n *\r\n * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are\r\n * double precision floating point numbers.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljau(ps, t) {\r\n    if (t === 0) {\r\n        return ps[0];\r\n    }\r\n    else if (t === 1) {\r\n        return ps[ps.length - 1];\r\n    }\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const a01 = x0 + (x1 - x0) * t;\r\n        const a11 = x1 + (x2 - x1) * t;\r\n        const a21 = x2 + (x3 - x2) * t;\r\n        const a02 = a01 + (a11 - a01) * t;\r\n        const a12 = a11 + (a21 - a11) * t;\r\n        const x = a02 + (a12 - a02) * t;\r\n        const b01 = y0 + (y1 - y0) * t;\r\n        const b11 = y1 + (y2 - y1) * t;\r\n        const b21 = y2 + (y3 - y2) * t;\r\n        const b02 = b01 + (b11 - b01) * t;\r\n        const b12 = b11 + (b21 - b11) * t;\r\n        const y = b02 + (b12 - b02) * t;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const a01 = x0 + (x1 - x0) * t;\r\n        const a11 = x1 + (x2 - x1) * t;\r\n        const x = a01 + (a11 - a01) * t;\r\n        const b01 = y0 + (y1 - y0) * t;\r\n        const b11 = y1 + (y2 - y1) * t;\r\n        const y = b01 + (b11 - b01) * t;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const x = x0 + (x1 - x0) * t;\r\n        const y = y0 + (y1 - y0) * t;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 1) {\r\n        return ps[0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljauError: () => (/* binding */ evalDeCasteljauError)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when evaluating the given bezier curve at the parameter `t`\r\n * using [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm).\r\n *\r\n * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n * The `T` in the error counter formula is the input error given as an error\r\n * counter on `t`. For example, if the exact `t` (let's call it `te`) is bounded\r\n * by `(|t| - 5u) < |te| < (|t| + 5u)` where `u === Number.EPSILON/2` then `T`\r\n * should be given as `5`. If `t` is exact then `T` is zero.\r\n *\r\n * ```\r\n * // for cubic bezier curves\r\n * return [\r\n * \tx_,  // <E> === 3T + 9\r\n * \ty_   // <E> === 3T + 9\r\n * ];\r\n * // for quadratic bezier curves\r\n * return [\r\n * \tx_,  // <E> === 2T + 6\r\n * \ty_   // <E> === 2T + 6\r\n * ];\r\n * // for linear bezier curves (i.e. lines)\r\n * return [\r\n * \tx_,  // <E> === T + 3\r\n * \ty_   // <E> === T + 3\r\n * ];\r\n * ```\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated (given in\r\n * double-double precision)\r\n *\r\n * @example\r\n * ```typescript\r\n * const ps = [[1.1,1.1],[2.3,2.3],[0.7,2.1],[3.11,-1.27]];  // some cubic bezier curve\r\n * const t = [0,0.1];  // some `t` in double-double precision, i.e. `t` equals `0.1`\r\n * const r = evalDeCasteljau(ps, t[1]) //=> [1.3828099999999999, 1.41623]\r\n * let error = evalDeCasteljauError(ps,t); //=> [2.32521, 2.3695700000000004]\r\n * const γ1 = 1*(Number.EPSILON)/(1-1*(Number.EPSILON));  // this is the error constant for double precision\r\n * error = error.map(c => γ1*c); //=> [5.163003358177322e-16, 5.261502344922066e-16]\r\n * // so, for instance, the *real* x coordinate of the point, i.e. `r[0]`, is somewhere between\r\n * // `1.3828099999999999 - 5.163003358177322e-16` and `1.3828099999999999 + 5.163003358177322e-16`, i.e.\r\n * // `1.3828099999999994 < r[0] < 1.3828100000000003`\r\n * ```\r\n *\r\n * @internal\r\n **/\r\nfunction evalDeCasteljauError(ps, t) {\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        return [0, 0]; // No error\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        return [0, 0]; // No error\r\n    }\r\n    const t_ = abs(t[1]); // <T>\r\n    // <M> --> the cost of multiplication === <1> except for `qmq` in which\r\n    // case it is <2>. One might as well just double the error in the end for\r\n    // double-double precision calculations (thus losing 1 bit) and take \r\n    // <M> === 1 always. This simplifies the calculation a bit.\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const _x0 = abs(x0); // <0>\r\n        const _y0 = abs(y0); // <0>\r\n        const _x1 = abs(x1); // <0>\r\n        const _y1 = abs(y1); // <0>\r\n        const _x2 = abs(x2); // <0>\r\n        const _y2 = abs(y2); // <0>\r\n        const _x3 = abs(x3); // <0>\r\n        const _y3 = abs(y3); // <0>\r\n        // a01<T+3> <-- <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\r\n        const a01_ = _x0 + (_x1 + _x0) * t_;\r\n        // a11<T+3> <-- <T+3>(x1 + <1>(<0>(x2 + x1)*<T>t));\r\n        const a11_ = _x1 + (_x2 + _x1) * t_;\r\n        // a21<T+3> <-- <T+3>(x2 + <1>(<0>(x3 + x2)*<T>t));\r\n        const a21_ = _x2 + (_x3 + _x2) * t_;\r\n        // a02<2T+6> <-- <2T+6>(<T+3>a01 + <2T+5>(<T+4>(<T+3>a11 + <T+3>a01)*<T>t));\r\n        const a02_ = a01_ + (a11_ + a01_) * t_;\r\n        // a12<2T+6> <-- <2T+6>(<T+3>a11 + <2T+5>(<T+4>(<T+3>a21 + <T+3>a11)*<T>t));\r\n        const a12_ = a11_ + (a21_ + a11_) * t_;\r\n        // x<3T+9> <-- <3T+9>(<2T+6>a02 + <3T+8>(<2T+7>(<2T+6>a12 + <2T+6>a02)*<T>t));\r\n        const x_ = a02_ + (a12_ + a02_) * t_;\r\n        const b01_ = _y0 + (_y1 + _y0) * t_;\r\n        const b11_ = _y1 + (_y2 + _y1) * t_;\r\n        const b21_ = _y2 + (_y3 + _y2) * t_;\r\n        const b02_ = b01_ + (b11_ + b01_) * t_;\r\n        const b12_ = b11_ + (b21_ + b11_) * t_;\r\n        const y_ = b02_ + (b12_ + b02_) * t_;\r\n        return [x_, y_];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const _x0 = abs(x0);\r\n        const _y0 = abs(y0);\r\n        const _x1 = abs(x1);\r\n        const _y1 = abs(y1);\r\n        const _x2 = abs(x2);\r\n        const _y2 = abs(y2);\r\n        // <T+3>a01 <-- <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\r\n        const a01_ = _x0 + (_x1 + _x0) * t_;\r\n        // <T+3>a11 <-- <T+3>(x1 + <T+2>(<1>(x2 + x1)*<T>t));\r\n        const a11_ = _x1 + (_x2 + _x1) * t_;\r\n        // <2T+6>x <-- <2T+6>(<T+3>a01 + <2T+5>(<T+4>(<T+3>a11 + <T+3>a01)*<T>t));\r\n        const x_ = a01_ + (a11_ + a01_) * t_;\r\n        const b01_ = _y0 + (_y1 + _y0) * t_;\r\n        const b11_ = _y1 + (_y2 + _y1) * t_;\r\n        const y_ = b01_ + (b11_ + b01_) * t_;\r\n        return [x_, y_];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const _x0 = abs(x0);\r\n        const _y0 = abs(y0);\r\n        const _x1 = abs(x1);\r\n        const _y1 = abs(y1);\r\n        // <T+3>x = <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\r\n        const x_ = _x0 + (_x1 + _x0) * t_;\r\n        const y_ = _y0 + (_y1 + _y0) * t_;\r\n        return [x_, y_];\r\n    }\r\n    if (ps.length === 1) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tangent: () => (/* binding */ tangent)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js\");\n\r\n\r\n/**\r\n * Returns the tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at a specific given parameter value `t`, i.e.\r\n * returns the `[x,y]` value of the once differentiated (with respect to `t`)\r\n * bezier curve's power basis when evaluated at `t`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps a linear, quadratic or cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the t parameter\r\n *\r\n * @doc mdx\r\n */\r\nfunction tangent(ps, t) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    return [\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dX, t),\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dY, t)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=tangent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointOnBezierCertified: () => (/* binding */ closestPointOnBezierCertified)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-3-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js\");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-2-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js\");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-1-dd.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js\");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js\");\n/* harmony import */ var _get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-coeffs/get-closest-on-bezier-from-point-error-counters.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/root-interval.js\");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var _intersection_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../intersection/bezier-bezier-intersection/x.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMult;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eAdd;\r\nconst eps = Number.EPSILON;\r\nconst { sqrt } = Math;\r\nconst γγ6 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_3__[\"γγ\"])(6);\r\n/**\r\n * Returns the closest point(s) (and parameter `t` value(s)) on the given\r\n * bezier curve to the given point (with `t ∈ [0,1]`).\r\n *\r\n * * guaranteed accurate to within `4*Number.EPSILON` in the returned `t`\r\n * value(s)\r\n * * in some cases there can be more than one closest point, e.g. on the axis\r\n * of symmetry of a parabola\r\n * * the returned point(s) are objects with the following properties:\r\n *     * `p`: the best estimate point on the bezier curve (calculated from the root interval `ri`)\r\n *     * `t`: the best estimate `t` parameter value (calculated from the root interval `ri`)\r\n *     * `d`: the best estimate closest distance from the point to the bezier curve (calculated from the root interval `ri`)\r\n *     * `ri`: a root interval guaranteed to contain the actual `t` value\r\n *     * `box`: a small box guaranteed to contain the relevant point on the bezier curve\r\n *     * `dSquaredI`: a small squared distance interval guaranteed to contain the actual distance squared\r\n *        between the point and the bezier curve\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @doc\r\n */\r\nfunction closestPointOnBezierCertified(ps, p) {\r\n    const order = ps.length - 1;\r\n    let ris;\r\n    if (order === 3) {\r\n        // keep TypeScript happy; `ris` cannot be `undefined` here\r\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_5__.getFootpointPoly3Dd)(ps, p), 0, 1, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__.getClosestOnBezier3FromPointErrorCounters)(ps, p).map(e => 10 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_7__.getFootpointPoly3Exact)(ps, p));\r\n    }\r\n    else if (order === 2) {\r\n        // keep TypeScript happy; `ris` cannot be `undefined` here\r\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_8__.getFootpointPoly2Dd)(ps, p), 0, 1, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__.getClosestOnBezier2FromPointErrorCounters)(ps, p).map(e => 8 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_9__.getFootpointPoly2Exact)(ps, p));\r\n    }\r\n    else if (order === 1) {\r\n        // keep TypeScript happy; `ris` cannot be `undefined` here\r\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_10__.getFootpointPoly1Dd)(ps, p), 0, 1, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__.getClosestOnBezier1FromPointErrorCounters)(ps, p).map(e => 6 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_11__.getFootpointPoly1Exact)(ps, p));\r\n    }\r\n    else if (order === 0) {\r\n        return [];\r\n    }\r\n    else {\r\n        throw new Error('The given bezier curve must be of order <= 3');\r\n    }\r\n    ris.push({ tS: 0, tE: 0, multiplicity: 1 });\r\n    ris.push({ tS: 1, tE: 1, multiplicity: 1 });\r\n    const infos = ris.map(ri => {\r\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_12__.getIntervalBox)(ps, [ri.tS, ri.tE]);\r\n        const dSquaredI = rootIntervalToDistanceSquaredInterval(box, p);\r\n        return {\r\n            p: (0,_intersection_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_13__.getPFromBox)(box),\r\n            t: (0,flo_poly__WEBPACK_IMPORTED_MODULE_14__.mid)(ri),\r\n            d: (sqrt(dSquaredI[0]) + sqrt(dSquaredI[1])) / 2,\r\n            dSquaredI,\r\n            box,\r\n            ri\r\n        };\r\n    });\r\n    /** the minimum max interval value */\r\n    let minMax = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < infos.length; i++) {\r\n        const diMax = infos[i].dSquaredI[1];\r\n        if (diMax < minMax) {\r\n            minMax = diMax;\r\n        }\r\n    }\r\n    const closestPointInfos = [];\r\n    for (let i = 0; i < infos.length; i++) {\r\n        const info = infos[i];\r\n        if (info.dSquaredI[0] <= minMax) {\r\n            closestPointInfos.push(info);\r\n        }\r\n    }\r\n    return closestPointInfos;\r\n}\r\n/**\r\n * Returns the distance interval squared given the root interval (currently\r\n * ignoring multiplicity)\r\n *\r\n * @param box\r\n * @param p\r\n *\r\n * @internal\r\n */\r\nfunction rootIntervalToDistanceSquaredInterval(box, p) {\r\n    const bl = box[0];\r\n    const tr = box[1];\r\n    const minX = bl[0];\r\n    const minY = bl[1];\r\n    const maxX = tr[0];\r\n    const maxY = tr[1];\r\n    const x = p[0]; // <0>\r\n    const y = p[1]; // <0>\r\n    let minDSquared = Number.POSITIVE_INFINITY;\r\n    let maxDSquared = Number.NEGATIVE_INFINITY;\r\n    // for each corner of the interval box\r\n    for (const [a, b] of [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]]) {\r\n        /*\r\n        // distance to 1st corner of interval box - `distance² = x² + y²`\r\n        const dc1 = (a - x)**2 + (b - y)**2;\r\n        // max absolute roundoff error of `dc1`\r\n        // <4>dc1 <-- <4>(<3>(<1>(a - x)**2) + <3>(<1>((b - y)**2))\r\n        const dc1E = 4*γ1*((a + x)**2 + (b + y)**2);\r\n        const dc1Min = dc1 - dc1E;  // distance minus max error\r\n        const dc1Max = dc1 + dc1E;  // distance plus max error\r\n        */\r\n        /** distance to 1st corner of interval box - `distance² = x² + y²` */\r\n        const ax = td(a, x);\r\n        const by = td(b, y);\r\n        const dc1Exact = eadd(emult(ax, ax), emult(by, by));\r\n        const dc1 = estimate(dc1Exact);\r\n        const dc1Min = dc1 * (1 - eps); // distance minus max error\r\n        const dc1Max = dc1 * (1 + eps); // distance plus max error\r\n        if (dc1Min <= minDSquared) {\r\n            minDSquared = dc1Min;\r\n        }\r\n        if (dc1Max >= maxDSquared) {\r\n            maxDSquared = dc1Max;\r\n        }\r\n    }\r\n    return [minDSquared, maxDSquared];\r\n}\r\n\r\n/**\r\n * Returns the closest point on the bezier to the given point - returns the point\r\n * and the t value.\r\n *\r\n * * this function also acts as an excellent inversion formula.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\n/*\r\n function closestPointOnBezierPrecise(\r\n        ps: number[][],\r\n        p: number[]): {\r\n            p: number[];\r\n            t: number;\r\n        } {\r\n\r\n    const polyE = getFootpointPolyExact(ps, p);\r\n    const polyDd = polyE.map(eToDd);\r\n    const polyErr = polyE.map((c,i) => Math.abs(eEstimate(eDiff(c,polyDd[i]))));\r\n    function getPExact() { return polyE; }\r\n\r\n    let ts = allRootsCertified(\r\n        polyDd,\r\n        0, 1,\r\n        polyErr,\r\n        getPExact\r\n    ).map(mid);\r\n\r\n    ts.push(0);\r\n    ts.push(1);\r\n\r\n    let ps_ = ts.map(t => ({ p: evaluateExact(ps, t).map(eEstimate), t }));\r\n\r\n    // Get point with minimum distance\r\n    let minD = Number.POSITIVE_INFINITY;\r\n    let minT: { p: number[], t: number } | undefined = undefined;\r\n    ps_.forEach(p_ => {\r\n        let d = squaredDistanceBetween(p_.p, p);\r\n        if (d < minD) {\r\n            minD = d;\r\n            minT = p_;\r\n        }\r\n    });\r\n\r\n    return minT!;\r\n}\r\n*/ \r\n//# sourceMappingURL=closest-point-on-bezier-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly1Dd: () => (/* binding */ getFootpointPoly1Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmn2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultByNeg2;\r\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the polynomial whose roots are all the `t` values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 1 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly1Dd(ps, p) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = x0 - x;\r\n    const xx1 = x1 - x;\r\n    const yy0 = y0 - y;\r\n    const yy1 = y1 - y;\r\n    const x00 = tp(xx0, xx0);\r\n    const x01 = tp(xx0, xx1);\r\n    const x11 = tp(xx1, xx1);\r\n    const y00 = tp(yy0, yy0);\r\n    const y01 = tp(yy0, yy1);\r\n    const y11 = tp(yy1, yy1);\r\n    const s1 = qaq(x01, y01);\r\n    const s2 = qaq(y00, x00);\r\n    //const t1 = (x11 + y11) + (s2 - 2*s1)\r\n    const t1 = qaq(qaq(x11, y11), qaq(s2, qmn2(s1)));\r\n    //const t0 = s1 - s2;\r\n    const t0 = qdifq(s1, s2);\r\n    return [t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-1-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly2Dd: () => (/* binding */ getFootpointPoly2Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\r\n/**\r\n * Returns the polynomial whose roots are all the `t` values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 2 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly2Dd(ps, p) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const xx2 = td(x2, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const yy2 = td(y2, y);\r\n    const x00 = qmq(xx0, xx0);\r\n    const x01 = qmq(xx0, xx1);\r\n    const x02 = qmq(xx0, xx2);\r\n    const x11 = qmq(xx1, xx1);\r\n    const x12 = qmq(xx1, xx2);\r\n    const x22 = qmq(xx2, xx2);\r\n    const y00 = qmq(yy0, yy0);\r\n    const y01 = qmq(yy0, yy1);\r\n    const y02 = qmq(yy0, yy2);\r\n    const y11 = qmq(yy1, yy1);\r\n    const y12 = qmq(yy1, yy2);\r\n    const y22 = qmq(yy2, yy2);\r\n    const q1 = qaq(y02, qm2(y11));\r\n    const r1 = qaq(x02, qm2(x11));\r\n    //const t3 = ((y22 + y00) + 2*q1 - 4*(y12 + y01)) + \r\n    //           ((x22 + x00) + 2*r1 - 4*(x12 + x01));\r\n    const t3 = qaq(qdifq(qaq(qaq(y22, y00), qm2(q1)), qm4(qaq(y12, y01))), qdifq(qaq(qaq(x22, x00), qm2(r1)), qm4(qaq(x12, x01))));\r\n    //const t2 = 3*(((y12 - q1) + (3*y01 - y00)) + \r\n    //              ((x12 - r1) + (3*x01 - x00)));\r\n    const t2 = qmd(3, qaq(qaq(qdifq(y12, q1), qdifq(qmd(3, y01), y00)), qaq(qdifq(x12, r1), qdifq(qmd(3, x01), x00))));\r\n    //const t1 = (q1 - 3*(2*y01 - y00)) + \r\n    //           (r1 - 3*(2*x01 - x00));\r\n    const t1 = qaq(qdifq(q1, qmd(3, qdifq(qm2(y01), y00))), qdifq(r1, qmd(3, qdifq(qm2(x01), x00))));\r\n    //const t0 = (y01 - y00) + \r\n    //           (x01 - x00);\r\n    const t0 = qaq(qdifq(y01, y00), qdifq(x01, x00));\r\n    return [t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-2-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly3Dd: () => (/* binding */ getFootpointPoly3Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the polynomial whose roots are all the `t` values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly3Dd(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x); // exact\r\n    const xx1 = td(x1, x); // exact\r\n    const xx2 = td(x2, x); // exact\r\n    const xx3 = td(x3, x); // exact\r\n    const yy0 = td(y0, y); // exact\r\n    const yy1 = td(y1, y); // exact\r\n    const yy2 = td(y2, y); // exact\r\n    const yy3 = td(y3, y); // exact\r\n    const x00 = qmq(xx0, xx0);\r\n    const x01 = qmd(6, qmq(xx0, xx1));\r\n    const x02 = qmd(6, qmq(xx0, xx2));\r\n    const x03 = qm2(qmq(xx0, xx3));\r\n    const x11 = qmd(9, qmq(xx1, xx1));\r\n    const x12 = qmd(18, qmq(xx1, xx2));\r\n    const x13 = qmd(6, qmq(xx1, xx3));\r\n    const x22 = qmd(9, qmq(xx2, xx2));\r\n    const x23 = qmd(6, qmq(xx2, xx3));\r\n    const x33 = qmq(xx3, xx3);\r\n    const y00 = qmq(yy0, yy0);\r\n    const y01 = qmd(6, qmq(yy0, yy1));\r\n    const y02 = qmd(6, qmq(yy0, yy2));\r\n    const y03 = qm2(qmq(yy0, yy3));\r\n    const y11 = qmd(9, qmq(yy1, yy1));\r\n    const y12 = qmd(18, qmq(yy1, yy2));\r\n    const y13 = qmd(6, qmq(yy1, yy3));\r\n    const y22 = qmd(9, qmq(yy2, yy2));\r\n    const y23 = qmd(6, qmq(yy2, yy3));\r\n    const y33 = qmq(yy3, yy3);\r\n    const q1 = qaq(x13, x22);\r\n    const q2 = qaq(x03, x12);\r\n    const q3 = qaq(x02, x11);\r\n    const r1 = qaq(y13, y22);\r\n    const r2 = qaq(y03, y12);\r\n    const r3 = qaq(y02, y11);\r\n    // const t5 = 6*(((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) + \r\n    //               ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));\r\n    const t5 = qmd(6, qaq(qaq(qaq(qaq(qdq(x33, x23), qdq(x00, x01)), q1), qdq(q3, q2)), qaq(qaq(qaq(qdq(y33, y23), qdq(y00, y01)), r1), qdq(r3, r2))));\r\n    //const t4 = 5*((((x23 + 5*x01) + 3*q2) - 2*(q1 + 2*q3 + 3*x00)) +\r\n    //              (((y23 + 5*y01) + 3*r2) - 2*(r1 + 2*r3 + 3*y00)));\r\n    const t4 = qmd(5, qaq(qdq(qaq(qaq(x23, qmd(5, x01)), qmd(3, q2)), qm2(qaq(qaq(q1, qm2(q3)), qmd(3, x00)))), qdq(qaq(qaq(y23, qmd(5, y01)), qmd(3, r2)), qm2(qaq(qaq(r1, qm2(r3)), qmd(3, y00))))));\r\n    //const t3 = 4*(((q1 - 3*(q2 - 2*q3)) - 5*(2*x01 - 3*x00)) +\r\n    //              ((r1 - 3*(r2 - 2*r3)) - 5*(2*y01 - 3*y00)));\r\n    const t3 = qm4(qaq(qdq(qdq(q1, qmd(3, (qdq(q2, qm2(q3))))), qmd(5, qdq(qm2(x01), qmd(3, x00)))), qdq(qdq(r1, qmd(3, (qdq(r2, qm2(r3))))), qmd(5, qdq(qm2(y01), qmd(3, y00))))));\r\n    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\r\n    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\r\n    const t2 = qmd(3, qaq(qdq(q2, qm2(qdq(qm2(q3), qmd(5, qdq(x01, qm2(x00)))))), qdq(r2, qm2(qdq(qm2(r3), qmd(5, qdq(y01, qm2(y00))))))));\r\n    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +\r\n    //              (r3 - 5*(y01 - 3*y00)));\r\n    const t1 = qm2(qaq(qdq(q3, qmd(5, (qdq(x01, qmd(3, x00))))), qdq(r3, qmd(5, (qdq(y01, qmd(3, y00)))))));\r\n    //const t0 = ((x01 - 6*x00) +\r\n    //            (y01 - 6*y00));\r\n    const t0 = qaq(qdq(x01, qmd(6, x00)), qdq(y01, qmd(6, y00)));\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-3-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly1Exact: () => (/* binding */ getFootpointPoly1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\r\nconst emn2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultByNeg2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eDiff;\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 1 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly1Exact(ps, p) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const x00 = emult(xx0, xx0);\r\n    const x01 = emult(xx0, xx1);\r\n    const x11 = emult(xx1, xx1);\r\n    const y00 = emult(yy0, yy0);\r\n    const y01 = emult(yy0, yy1);\r\n    const y11 = emult(yy1, yy1);\r\n    const s1 = eadd(x01, y01);\r\n    const s2 = eadd(y00, x00);\r\n    //const t1 = x11 + y11 - 2*s1 + s2;\r\n    const t1 = eadd(eadd(x11, y11), eadd(emn2(s1), s2));\r\n    //const t0 = s1 - s2;\r\n    const t0 = ediff(s1, s2);\r\n    return [t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-1-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly2Exact: () => (/* binding */ getFootpointPoly2Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMultBy2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eDiff;\r\n/**\r\n * Returns the result of multiplying a floating point expansion by 4.\r\n *\r\n * * **error free**\r\n *\r\n * * see [[Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n *\r\n * @internal\r\n */\r\nfunction em4(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(4 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 2 curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly2Exact(ps, p) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const xx2 = td(x2, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const yy2 = td(y2, y);\r\n    const x00 = emult(xx0, xx0);\r\n    const x01 = emult(xx0, xx1);\r\n    const x02 = emult(xx0, xx2);\r\n    const x11 = emult(xx1, xx1);\r\n    const x12 = emult(xx1, xx2);\r\n    const x22 = emult(xx2, xx2);\r\n    const y00 = emult(yy0, yy0);\r\n    const y01 = emult(yy0, yy1);\r\n    const y02 = emult(yy0, yy2);\r\n    const y11 = emult(yy1, yy1);\r\n    const y12 = emult(yy1, yy2);\r\n    const y22 = emult(yy2, yy2);\r\n    const q1 = eadd(y02, em2(y11));\r\n    const r1 = eadd(x02, em2(x11));\r\n    //const t3 = y22 + 2*q1 - 4*(y12 + y01) + y00 + \r\n    //           x22 + 2*r1 - 4*(x12 + x01) + x00;\r\n    const t3a = eadd(ediff(eadd(x22, em2(r1)), em4(eadd(x12, x01))), x00);\r\n    const t3b = eadd(ediff(eadd(y22, em2(q1)), em4(eadd(y12, y01))), y00);\r\n    const t3 = eadd(t3a, t3b);\r\n    //const t2 = 3*(y12 - q1 + 3*y01 - y00 + \r\n    //              x12 - r1 + 3*x01 - x00);\r\n    const t2a = eadd(ediff(x12, r1), ediff(sce(3, x01), x00));\r\n    const t2b = eadd(ediff(y12, q1), ediff(sce(3, y01), y00));\r\n    const t2 = sce(3, eadd(t2a, t2b));\r\n    //const t1 = q1 - 3*(2*y01 - y00) + \r\n    //           r1 - 3*(2*x01 - x00);\r\n    const t1a = ediff(q1, sce(3, ediff(em2(y01), y00)));\r\n    const t1b = ediff(r1, sce(3, ediff(em2(x01), x00)));\r\n    const t1 = eadd(t1a, t1b);\r\n    //const t0 = y01 - y00 + \r\n    //           x01 - x00;\r\n    const t0a = ediff(y01, y00);\r\n    const t0b = ediff(x01, x00);\r\n    const t0 = eadd(t0a, t0b);\r\n    return [t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-2-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFootpointPoly3Exact: () => (/* binding */ getFootpointPoly3Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMult;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMultBy2;\r\nconst emn2 = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eMultByNeg2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eAdd;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eDiff;\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\nfunction getFootpointPoly3Exact(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const xx2 = td(x2, x);\r\n    const xx3 = td(x3, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const yy2 = td(y2, y);\r\n    const yy3 = td(y3, y);\r\n    const x00 = emult(xx0, xx0);\r\n    const x01 = sce(6, emult(xx0, xx1));\r\n    const x02 = sce(6, emult(xx0, xx2));\r\n    const x03 = em2(emult(xx0, xx3));\r\n    const x11 = sce(9, emult(xx1, xx1));\r\n    const x12 = sce(18, emult(xx1, xx2));\r\n    const x13 = sce(6, emult(xx1, xx3));\r\n    const x22 = sce(9, emult(xx2, xx2));\r\n    const x23 = sce(6, emult(xx2, xx3));\r\n    const x33 = emult(xx3, xx3);\r\n    const y00 = emult(yy0, yy0);\r\n    const y01 = sce(6, emult(yy0, yy1));\r\n    const y02 = sce(6, emult(yy0, yy2));\r\n    const y03 = em2(emult(yy0, yy3));\r\n    const y11 = sce(9, emult(yy1, yy1));\r\n    const y12 = sce(18, emult(yy1, yy2));\r\n    const y13 = sce(6, emult(yy1, yy3));\r\n    const y22 = sce(9, emult(yy2, yy2));\r\n    const y23 = sce(6, emult(yy2, yy3));\r\n    const y33 = emult(yy3, yy3);\r\n    const q1 = eadd(x13, x22);\r\n    const q2 = eadd(x03, x12);\r\n    const q3 = eadd(x02, x11);\r\n    const r1 = eadd(y13, y22);\r\n    const r2 = eadd(y03, y12);\r\n    const r3 = eadd(y02, y11);\r\n    //const t5 = 6*((x33 - x23 + q1 - q2 + q3 - x01 + x00) + \r\n    //              (y33 - y23 + r1 - r2 + r3 - y01 + y00));\r\n    const t5a = ediff(eadd(eadd(x33, x00), eadd(q1, q3)), (eadd(eadd(q2, x23), x01)));\r\n    const t5b = ediff(eadd(eadd(y33, y00), eadd(r1, r3)), (eadd(eadd(r2, y23), y01)));\r\n    const t5 = sce(6, eadd(t5a, t5b));\r\n    //const t4 = 5*((x23 - 2*(q1 + 2*q3 + 3*x00) + 3*q2 + 5*x01) +\r\n    //              (y23 - 2*(r1 + 2*r3 + 3*y00) + 3*r2 + 5*y01));\r\n    const t4a = eadd(emn2(eadd(eadd(q1, em2(q3)), sce(3, x00))), eadd(eadd(x23, sce(3, q2)), sce(5, x01)));\r\n    const t4b = eadd(emn2(eadd(eadd(r1, em2(r3)), sce(3, y00))), eadd(eadd(y23, sce(3, r2)), sce(5, y01)));\r\n    const t4 = sce(5, eadd(t4a, t4b));\r\n    //const t3 = 4*((q1 - 3*(q2 - 2*q3) - 5*(2*x01 - 3*x00)) +\r\n    //              (r1 - 3*(r2 - 2*r3) - 5*(2*y01 - 3*y00)));\r\n    const t3a = eadd(eadd(q1, sce(3, (ediff(em2(q3), q2)))), sce(5, (ediff(sce(3, x00), em2(x01)))));\r\n    const t3b = eadd(eadd(r1, sce(3, (ediff(em2(r3), r2)))), sce(5, (ediff(sce(3, y00), em2(y01)))));\r\n    const t3 = sce(4, eadd(t3a, t3b));\r\n    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\r\n    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\r\n    const t2a = ediff(q2, em2(ediff(em2(q3), sce(5, (ediff(x01, em2(x00)))))));\r\n    const t2b = ediff(r2, em2(ediff(em2(r3), sce(5, (ediff(y01, em2(y00)))))));\r\n    const t2 = sce(3, eadd(t2a, t2b));\r\n    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +\r\n    //              (r3 - 5*(y01 - 3*y00)));\r\n    const t1a = ediff(q3, sce(5, (ediff(x01, sce(3, x00)))));\r\n    const t1b = ediff(r3, sce(5, (ediff(y01, sce(3, y00)))));\r\n    const t1 = em2(eadd(t1a, t1b));\r\n    //const t0 = ((x01 - 6*x00) +\r\n    //            (y01 - 6*y00));\r\n    const t0a = ediff(x01, sce(6, x00));\r\n    const t0b = ediff(y01, sce(6, y00));\r\n    const t0 = eadd(t0a, t0b);\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-3-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js":
/*!*******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js ***!
  \*******************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClosestOnBezier1FromPointErrorCounters: () => (/* binding */ getClosestOnBezier1FromPointErrorCounters),\n/* harmony export */   getClosestOnBezier2FromPointErrorCounters: () => (/* binding */ getClosestOnBezier2FromPointErrorCounters),\n/* harmony export */   getClosestOnBezier3FromPointErrorCounters: () => (/* binding */ getClosestOnBezier3FromPointErrorCounters)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error when calculating the polynomial whose\r\n * roots are all the `t` values on the given bezier curve such that the line\r\n * from the given point to the point on the bezier evaluated at `t` is tangent\r\n * to the bezier at `t`.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * ```\r\n * return [\r\n *      t5_,  // <9>\r\n *      t4_,  // <10>\r\n *      t3_,  // <10>\r\n *      t2_,  // <10>\r\n *      t1_,  // <9>\r\n *      t0_   // <7>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getClosestOnBezier3FromPointErrorCounters(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0_ = abs(p0[0]); // <0>  (error counters)\r\n    const y0_ = abs(p0[1]); // <0>\r\n    const x1_ = abs(p1[0]); // <0>\r\n    const y1_ = abs(p1[1]); // <0>\r\n    const x2_ = abs(p2[0]); // <0>\r\n    const y2_ = abs(p2[1]); // <0>\r\n    const x3_ = abs(p3[0]); // <0>\r\n    const y3_ = abs(p3[1]); // <0>\r\n    const xp_ = abs(p[0]); // <0>\r\n    const yp_ = abs(p[1]); // <0>\r\n    // <1>xx0 <-- <1>(x0 - xp);\r\n    const xx0_ = x0_ + xp_;\r\n    // <1>xx1 <-- <1>(x1 - xp);\r\n    const xx1_ = x1_ + xp_;\r\n    // <1>xx2 <-- <1>(x2 - xp);\r\n    const xx2_ = x2_ + xp_;\r\n    // <1>xx3 <-- <1>(x3 - xp);\r\n    const xx3_ = x3_ + xp_;\r\n    // <1>yy0 <-- <1>(y0 - yp);\r\n    const yy0_ = y0_ + yp_;\r\n    // <1>yy1 <-- <1>(y1 - yp);\r\n    const yy1_ = y1_ + yp_;\r\n    // <1>yy2 <-- <1>(y2 - yp);\r\n    const yy2_ = y2_ + yp_;\r\n    // <1>yy3 <-- <1>(y3 - yp);\r\n    const yy3_ = y3_ + yp_;\r\n    // <3>x00 <-- <3>(<1>xx0*<1>xx0);\r\n    const x00_ = xx0_ * xx0_;\r\n    // <4>x01 <-- <4>(6 *<3>(<1>xx0*<1>xx1));\r\n    const x01_ = 6 * xx0_ * xx1_;\r\n    // <4>x02 <-- <4>(6 *<3>(<1>xx0*<1>xx2));\r\n    const x02_ = 6 * xx0_ * xx2_;\r\n    // <3>x03 <-- 2 *<3>(<1>xx0*<1>xx3);\r\n    const x03_ = 2 * xx0_ * xx3_;\r\n    // <4>x11 <-- <4>(9 *<3>(<1>xx1*<1>xx1));\r\n    const x11_ = 9 * xx1_ * xx1_;\r\n    // <4>x12 <-- <4>(18*<3>(<1>xx1*<1>xx2));\r\n    const x12_ = 18 * xx1_ * xx2_;\r\n    // <4>x13 <-- <4>(6 *<3>(<1>xx1*<1>xx3));\r\n    const x13_ = 6 * xx1_ * xx3_;\r\n    // <4>x22 <-- <4>(9 *<3>(<1>xx2*<1>xx2));\r\n    const x22_ = 9 * xx2_ * xx2_;\r\n    // <4>x23 <-- <4>(6 *<3>(<1>xx2*<1>xx3));\r\n    const x23_ = 6 * xx2_ * xx3_;\r\n    // <3>x33 <--    <3>(<1>xx3*<1>xx3);\r\n    const x33_ = xx3_ * xx3_;\r\n    const y00_ = yy0_ * yy0_;\r\n    const y01_ = 6 * yy0_ * yy1_;\r\n    const y02_ = 6 * yy0_ * yy2_;\r\n    const y03_ = 2 * yy0_ * yy3_;\r\n    const y11_ = 9 * yy1_ * yy1_;\r\n    const y12_ = 18 * yy1_ * yy2_;\r\n    const y13_ = 6 * yy1_ * yy3_;\r\n    const y22_ = 9 * yy2_ * yy2_;\r\n    const y23_ = 6 * yy2_ * yy3_;\r\n    const y33_ = yy3_ * yy3_;\r\n    // <5>q1 <-- (5>(<4>x13 + <4>x22);\r\n    const q1_ = x13_ + x22_;\r\n    // <5>q2 <-- (5>(<3>x03 + <4>x12);\r\n    const q2_ = x03_ + x12_;\r\n    // <5>q3 <-- (5>(<4>x02 + <4>x11);\r\n    const q3_ = x02_ + x11_;\r\n    const r1_ = y13_ + y22_; // <5>\r\n    const r2_ = y03_ + y12_; // <5>\r\n    const r3_ = y02_ + y11_; // <5>\r\n    // <9>t5 <-- <9>(6*<8>(<7>(<6>(<5>(<4>(x33 - x23) + <4>(x00 - x01)) + <5>q1) + <6>(q3 - q2)) + \r\n    //                     <7>(<6>(<5>(<4>(y33 - y23) + <4>(y00 - y01)) + <5>r1) + <6>(r3 - r2))));\r\n    const t5_ = 6 * (((((x33_ + x23_) + (x00_ + x01_)) + q1_) + (q3_ + q2_)) +\r\n        ((((y33_ + y23_) + (y00_ + y01_)) + r1_) + (r3_ + r2_)));\r\n    // <10>t4 <-- <10>(5*<9>(<8>(<7>(<6>(x23 + <5>(5*x01)) + <6>(3*q2)) - 2*<7>(<6>(q1 + 2*q3) + <5>(3*x00))) +\r\n    //                       <8>(<7>(<6>(y23 + <5>(5*y01)) + <6>(3*r2)) - 2*<7>(<6>(r1 + 2*r3) + <5>(3*y00)))));\r\n    const t4_ = 5 * ((((x23_ + 5 * x01_) + 3 * q2_) + 2 * (q1_ + 2 * q3_ + 3 * x00_)) +\r\n        (((y23_ + 5 * y01_) + 3 * r2_) + 2 * (r1_ + 2 * r3_ + 3 * y00_)));\r\n    // <10>t3 <-- 4*<10>(<9>(<8>(q1 - <7>(3*<6>(q2 - 2*q3))) - <7>(5*<6>(2*x01 - <5>(3*x00)))) +\r\n    //                 <9>(<8>(r1 - <7>(3*<6>(r2 - 2*r3))) - <7>(5*<6>(2*y01 - <5>(3*y00)))))\r\n    const t3_ = 4 * (((q1_ + 3 * (q2_ + 2 * q3_)) + 5 * (2 * x01_ + 3 * x00_)) +\r\n        ((r1_ + 3 * (r2_ + 2 * r3_)) + 5 * (2 * y01_ + 3 * y00_)));\r\n    // <10>t2 <-- <10>(3*<9>(<8>(q2 - 2*<7>(2*q3 - <6>(5*<5>(x01 - 2*x00)))) +\r\n    //                       <8>(r2 - 2*<7>(2*r3 - <6>(5*<5>(y01 - 2*y00))))));\r\n    const t2_ = 3 * ((q2_ + 2 * (2 * q3_ + 5 * (x01_ + 2 * x00_))) +\r\n        (r2_ + 2 * (2 * r3_ + 5 * (y01_ + 2 * y00_))));\r\n    // <9>t1 <-- 2*<9>(<8>(q3 - <7>(5*<6>(x01 - <5>(3*x00)))) +\r\n    //                 <8>(r3 - <7>(5*<6>(y01 - <5>(3*y00)))));\r\n    const t1_ = 2 * ((q3_ + 5 * (x01_ + 3 * x00_)) +\r\n        (r3_ + 5 * (y01_ + 3 * y00_)));\r\n    // <7>t0 <-- <7>(<6>(x01 - <5>(6*x00)) +\r\n    //              <6>(y01 - <5>(6*y00)));\r\n    const t0_ = ((x01_ + 6 * x00_) +\r\n        (y01_ + 6 * y00_));\r\n    return [\r\n        t5_,\r\n        t4_,\r\n        t3_,\r\n        t2_,\r\n        t1_,\r\n        t0_ // <7>\r\n    ];\r\n}\r\n/**\r\n * Returns a representation of the error when calculating the polynomial whose\r\n * roots are all the `t` values on the given bezier curve such that the line\r\n * from the given point to the point on the bezier evaluated at `t` is tangent\r\n * to the bezier at `t`.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n * ```\r\n * return [\r\n *      t3_,  // <7>\r\n *      t2_,  // <8>\r\n *      t1_,  // <7>\r\n *      t0_   // <5>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getClosestOnBezier2FromPointErrorCounters(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0_ = abs(p0[0]); // <0>\r\n    const y0_ = abs(p0[1]); // <0>\r\n    const x1_ = abs(p1[0]); // <0>\r\n    const y1_ = abs(p1[1]); // <0>\r\n    const x2_ = abs(p2[0]); // <0>\r\n    const y2_ = abs(p2[1]); // <0>\r\n    const xp_ = abs(p[0]); // <0>\r\n    const yp_ = abs(p[1]); // <0>\r\n    // <1>xx0 <-- <1>(x0 - xp);\r\n    const xx0_ = x0_ + xp_;\r\n    // <1>xx1 <-- <1>(x1 - xp);\r\n    const xx1_ = x1_ + xp_;\r\n    // <1>xx2 <-- <1>(x2 - xp);\r\n    const xx2_ = x2_ + xp_;\r\n    // <1>yy0 <-- <1>(y0 - yp);\r\n    const yy0_ = y0_ + yp_;\r\n    // <1>yy1 <-- <1>(y1 - yp);\r\n    const yy1_ = y1_ + yp_;\r\n    // <1>yy2 <-- <1>(y2 - yp);\r\n    const yy2_ = y2_ + yp_;\r\n    // <3>x00 <-- <3>(xx0*xx0);\r\n    const x00_ = xx0_ * xx0_;\r\n    // <3>x01 <-- <3>(xx0*xx1);\r\n    const x01_ = xx0_ * xx1_;\r\n    // <3>x02 <-- <3>(xx0*xx2);\r\n    const x02_ = xx0_ * xx2_;\r\n    // <3>x11 <-- <3>(xx1*xx1);\r\n    const x11_ = xx1_ * xx1_;\r\n    // <3>x12 <-- <3>(xx1*xx2);\r\n    const x12_ = xx1_ * xx2_;\r\n    // <3>x22 <-- <3>(xx2*xx2);\r\n    const x22_ = xx2_ * xx2_;\r\n    const y00_ = yy0_ * yy0_;\r\n    const y01_ = yy0_ * yy1_;\r\n    const y02_ = yy0_ * yy2_;\r\n    const y11_ = yy1_ * yy1_;\r\n    const y12_ = yy1_ * yy2_;\r\n    const y22_ = yy2_ * yy2_;\r\n    // <4>q1 <-- <4>(y02 + 2*y11);\r\n    const q1_ = y02_ + 2 * y11_;\r\n    // <4>r1 <-- <4>(x02 + 2*x11);\r\n    const r1_ = x02_ + 2 * x11_;\r\n    // <7>t3 <-- <7>(<6>(<5>(<4>(y22 + y00) + 2*q1) - 4*<4>(y12 + y01))) + \r\n    //              (<6>(<5>(<4>(x22 + x00) + 2*r1) - 4*<4>(x12 + x01)));\r\n    const t3_ = ((y22_ + y00_) + 2 * q1_ + 4 * (y12_ + y01_)) +\r\n        ((x22_ + x00_) + 2 * r1_ + 4 * (x12_ + x01_));\r\n    // <8>t2 <-- <8>(3*<7>(<6>(<5>(y12 - q1) + <5>(<4>(3*y01) - y00)) + \r\n    //                     <6>(<5>(x12 - r1) + <5>(<4>(3*x01) - x00))));\r\n    const t2_ = 3 * (((y12_ + q1_) + (3 * y01_ + y00_)) +\r\n        ((x12_ + r1_) + (3 * x01_ + x00_)));\r\n    // <7>t1 <-- <7>(<6>(<4>q1 - <5>(3*<4>(2*y01 - y00))) + \r\n    //               <6>(<4>r1 - <5>(3*<4>(2*x01 - x00))));\r\n    const t1_ = (q1_ + 3 * (2 * y01_ + y00_)) +\r\n        (r1_ + 3 * (2 * x01_ + x00_));\r\n    // <5>t0 <-- <5>(<4>(y01 - y00) + \r\n    //              <4>(x01 - x00));\r\n    const t0_ = (y01_ + y00_) +\r\n        (x01_ + x00_);\r\n    return [\r\n        t3_,\r\n        t2_,\r\n        t1_,\r\n        t0_ // <5>\r\n    ];\r\n}\r\n/**\r\n * Returns a representation of the error when calculating the polynomial whose\r\n * roots are all the `t` values on the given bezier curve such that the line\r\n * from the given point to the point on the bezier evaluated at `t` is tangent\r\n * to the bezier at `t`.\r\n *\r\n * @param ps a linear bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * ```\r\n * return [\r\n *     t1,  // <6>\r\n *     t0   // <5>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getClosestOnBezier1FromPointErrorCounters(ps, p) {\r\n    //const [[x0, y0], [x1, y1]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0_ = abs(p0[0]); // <0>\r\n    const y0_ = abs(p0[1]); // <0>\r\n    const x1_ = abs(p1[0]); // <0>\r\n    const y1_ = abs(p1[1]); // <0>\r\n    const xp_ = abs(p[0]); // <0>\r\n    const yp_ = abs(p[1]); // <0>\r\n    // <1>xx0 <-- <1>(x0 - xp);\r\n    const xx0_ = x0_ + xp_;\r\n    // <1>xx1 <-- <1>(x1 - xp);    \r\n    const xx1_ = x1_ + xp_;\r\n    // <1>yy0 <-- <1>(y0 - yp);    \r\n    const yy0_ = y0_ + yp_;\r\n    // <1>yy1 <-- <1>(y1 - yp);    \r\n    const yy1_ = y1_ + yp_;\r\n    // <3>x00 <-- <3>(xx0*xx0);\r\n    const x00_ = xx0_ * xx0_;\r\n    // <3>x01 <-- <3>(xx0*xx1);\r\n    const x01_ = xx0_ * xx1_;\r\n    // <3>x11 <-- <3>(xx1*xx1);\r\n    const x11_ = xx1_ * xx1_;\r\n    const y00_ = yy0_ * yy0_;\r\n    const y01_ = yy0_ * yy1_;\r\n    const y11_ = yy1_ * yy1_;\r\n    // <4>s1 <-- <4>(x01 + y01);\r\n    const s1_ = x01_ + y01_;\r\n    // <4>s2 <-- <4>(y00 + x00);\r\n    const s2_ = y00_ + x00_;\r\n    // <6>t1 = <6>(<4>(x11 + y11) + <5>(s2 - 2*s1));\r\n    const t1 = x11_ + y11_ + 2 * s1_ + s2_;\r\n    // <5>t0 = <5>(s1 - s2);\r\n    const t0 = s1_ + s2_;\r\n    return [\r\n        t1,\r\n        t0 // <5>\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-closest-on-bezier-from-point-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/equal.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/equal.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equal: () => (/* binding */ equal)\n/* harmony export */ });\n/**\r\n * Returns `true` if the two given bezier curves are exactly equal when compared\r\n * by value (deep equality), `false` otherwise\r\n *\r\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param ps2 another bezier curve\r\n *\r\n * @doc\r\n */\r\nfunction equal(ps1, ps2) {\r\n    if (ps1 === ps2) {\r\n        return true;\r\n    }\r\n    if (ps1.length !== ps2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < ps1.length; i++) {\r\n        if (ps1[i][0] !== ps2[i][0] || ps1[i][1] !== ps2[i][1]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/equal.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension1: () => (/* binding */ isPointOnBezierExtension1)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form1-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js\");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eToDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γγ\"])(3);\r\n/**\r\n * Returns `true` if the given point is on the given line where\r\n * the parameter `t` is allowed to extend to ±infinity, i.e. `t` is an\r\n * element of `[-∞, +∞]`, `false` otherwise.\r\n *\r\n * * there are alternative implementations to this function, e.g. ccw, etc;\r\n * it is kept for symmetry with the order 2 and 3 implementations.\r\n *\r\n * @param ps a linear bezier curve (a line)\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n *\r\n * @internal\r\n */\r\nfunction isPointOnBezierExtension1(ps, p) {\r\n    const [xe, ye] = p;\r\n    const lenX = xe.length;\r\n    const lenY = ye.length;\r\n    const x = xe[lenX - 1]; // get higest order double\r\n    const y = ye[lenY - 1]; // ...\r\n    const isDouble = (lenX === 1 && lenY === 1);\r\n    {\r\n        //---- pre-filter\r\n        const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm1DdWithRunningError)(ps);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // const h = vₓ*x + vᵧ*y + v;\r\n        const xd = etodd(xe);\r\n        const yd = etodd(ye);\r\n        const _x = abs(x);\r\n        const _y = abs(y);\r\n        const _vₓ = abs(vₓ[1]);\r\n        const _vᵧ = abs(vᵧ[1]);\r\n        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\r\n        // and hence we need to divide the error by 3.\r\n        const x_ = _x / 3;\r\n        const y_ = _y / 3;\r\n        const $vₓx = vₓ[1] * x;\r\n        const vₓx = qmq(xd, vₓ);\r\n        const _vₓx = abs($vₓx);\r\n        const vₓx_ = _vₓ * x_ + 2 * _vₓx;\r\n        const $vᵧy = vᵧ[1] * y;\r\n        const vᵧy = qmq(yd, vᵧ);\r\n        const _vᵧy = abs($vᵧy);\r\n        const vᵧy_ = _vᵧ * y_ + 2 * _vᵧy;\r\n        // group the terms to reduce error, e.g. `v` usually has the highest bitlength\r\n        //const h = (vₓx + vᵧy) + v;\r\n        const q7 = qaq(vₓx, vᵧy);\r\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        const h = qaq(q7, v);\r\n        const h_ = q7_ + v_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (γγ3 * h_ < abs(estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    {\r\n        const implictForm = (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm1Exact)(ps);\r\n        if (implictForm === undefined) {\r\n            // both ps are the same point\r\n            return isDouble && x === ps[0][0] && y === ps[0][1];\r\n        }\r\n        const { vₓ, vᵧ, v } = implictForm;\r\n        const vₓx = epr(xe, vₓ);\r\n        const vᵧy = epr(ye, vᵧ);\r\n        // const h = vₓ*x + vᵧ*y + v;\r\n        const hh = fes(fes(vₓx, vᵧy), v);\r\n        return sign(hh) === 0; // <= calculation was exact\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension2: () => (/* binding */ isPointOnBezierExtension2)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../implicit-form/double/get-implicit-form2.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../implicit-form/get-error-counters/get-implicit-form2-error-counters.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form2-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\r\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eToDd;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γ\"])(1);\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γγ\"])(3);\r\n/**\r\n * Returns `true` if the given point is on the given quadratic bezier curve where\r\n * the parameter `t` is allowed to extend to ±infinity, i.e. `t` is an element of\r\n * `[-∞, +∞]`, `false` otherwise.\r\n *\r\n * @param ps a quadratic bezier curve\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n *\r\n * @internal\r\n */\r\nfunction isPointOnBezierExtension2(ps, p) {\r\n    const [xe, ye] = p;\r\n    const lenX = xe.length;\r\n    const lenY = ye.length;\r\n    const x = xe[lenX - 1]; // get higest order double\r\n    const y = ye[lenY - 1]; // ...\r\n    const isDouble = (lenX === 1 && lenY === 1);\r\n    //---- first pre-filter\r\n    {\r\n        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = (0,_implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm2)(ps);\r\n        const { vₓₓ_, // <5>\r\n        vₓᵧ_, // <5>\r\n        vᵧᵧ_, // <5>\r\n        vₓ_, // <8>\r\n        vᵧ_, // <8>\r\n        v_ // <10>\r\n         } = (0,_implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm2ErrorCounters)(ps);\r\n        // In the below a a postfix underscore means \r\n        // an error bound (>= absolute value)\r\n        // `h` (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // In the below, if x is given as a double then the error counter on\r\n        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the\r\n        // error counter with a <D> so that for a point with double precion \r\n        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.\r\n        // `0` if we have only double precision coordinates, `1` otherwise\r\n        const D = isDouble ? 0 : 1;\r\n        const x_ = abs(x); // <D>x\r\n        const y_ = abs(y); // <D>y\r\n        const xx_ = x_ * x_; // <2D+1>xx\r\n        const xy_ = x_ * y_; // <2D+1>xy\r\n        const yy_ = y_ * y_; // <2D+1>yy\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        const h = (((vₓₓ * x * x + vₓᵧ * x * y) +\r\n            vᵧᵧ * y * y) +\r\n            (vₓ * x + vᵧ * y)) +\r\n            v;\r\n        // <D+12>h <-- <D+12>(<D+11>(<2D+9>(<2D+8> + <2D+7>) + <D+10>) + <10>);\r\n        const h_ = ((\r\n        // <2D+8>(<2D+7>(<5>vₓₓ*<2D+1>(xx)) + <2D+7>(<5>vₓᵧ*<2D+1>(xy)))\r\n        (vₓₓ_ * xx_ + vₓᵧ_ * xy_) +\r\n            // <2D+7>(<5>vᵧᵧ*<2D+1>(xy))\r\n            vᵧᵧ_ * yy_) + (\r\n        // <D+10>(<D+9>(<8>vₓ*<D>x) + <D+9>(<8>vᵧ*<D>y))\r\n        vₓ_ * x_ + vᵧ_ * y_)) +\r\n            // <10>v\r\n            v_;\r\n        // if the error is not too high too discern h away from zero\r\n        if ((D + 12) * γ1 * h_ < abs(h)) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error too high - const's try double-double precision\r\n    {\r\n        const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm2DdWithRunningError)(ps);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // const h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const xd = etodd(xe);\r\n        const yd = etodd(ye);\r\n        const _x = abs(x);\r\n        const _y = abs(y);\r\n        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\r\n        // and hence we need to divide the error by 3.\r\n        const x_ = _x / 3;\r\n        const y_ = _y / 3;\r\n        const xx = qmq(xd, xd);\r\n        const _xx = xx[1];\r\n        const xx_ = 2 * (_x * x_ + _xx);\r\n        const yy = qmq(yd, yd);\r\n        const _yy = yy[1];\r\n        const yy_ = 2 * (_y * y_ + _yy);\r\n        const xy = qmq(xd, yd);\r\n        const _xy = abs(xy[1]);\r\n        const xy_ = _x * y_ + x_ * _y + 2 * _xy;\r\n        const vₓₓxx = qmq(vₓₓ, xx);\r\n        const vₓₓxx_ = abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\r\n        const vₓᵧxy = qmq(vₓᵧ, xy);\r\n        const vₓᵧxy_ = abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\r\n        const vᵧᵧyy = qmq(vᵧᵧ, yy);\r\n        const vᵧᵧyy_ = abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\r\n        const vₓx = qmq(xd, vₓ);\r\n        const vₓx_ = abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * abs(vₓx[1]);\r\n        const vᵧy = qmq(yd, vᵧ);\r\n        const vᵧy_ = abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * abs(vᵧy[1]);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //const h = \r\n        //    (\r\n        //      ((vₓₓxx + vₓᵧxy) + vᵧᵧyy) + \r\n        //      (vₓx + vᵧy)\r\n        //    ) + \r\n        //    v;\r\n        const q4 = qaq(vₓₓxx, vₓᵧxy);\r\n        const q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\r\n        const q5 = qaq(q4, vᵧᵧyy);\r\n        const q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\r\n        const q7 = qaq(vₓx, vᵧy);\r\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        const q8 = qaq(q5, q7);\r\n        const q8_ = q5_ + q7_ + abs(q8[1]);\r\n        const h = qaq(q8, v);\r\n        const h_ = q8_ + v_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (γγ3 * h_ < abs(estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error still too high - let's go exact\r\n    {\r\n        const implictForm = (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm2Exact)(ps);\r\n        if (implictForm === undefined) {\r\n            // all ps are the same point\r\n            return isDouble && x === ps[0][0] && y === ps[0][1];\r\n        }\r\n        if (!implictForm.hasOwnProperty('vₓₓ')) {\r\n            implictForm.vₓₓ = [0];\r\n            implictForm.vₓᵧ = [0];\r\n            implictForm.vᵧᵧ = [0];\r\n        }\r\n        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;\r\n        // h (say height) is the the result of evaluating the implicit equation; \r\n        // if it is 0 we are on the curve, else we're not.\r\n        // const h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const h = fes(fes(fes(epr(vₓₓ, epr(xe, xe)), epr(vₓᵧ, epr(xe, ye))), epr(vᵧᵧ, epr(ye, ye))), fes(fes(epr(xe, vₓ), epr(ye, vᵧ)), v));\r\n        return sign(h) === 0; // <= calculation was exact\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension3: () => (/* binding */ isPointOnBezierExtension3)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../implicit-form/double/get-implicit-form3.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js\");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../implicit-form/get-error-counters/get-implicit-form3-error-counters.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js\");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js\");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form3-exact.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\r\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eToDd;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γ\"])(1);\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_6__[\"γγ\"])(3);\r\n/**\r\n * Returns `true` if the given point is on the given cubic bezier curve where\r\n * the parameter, `t`, is allowed to extend to `±∞`, i.e. if `t ∈ (-∞, +∞)`,\r\n * `false` otherwise.\r\n *\r\n * @param ps a cubic bezier curve\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n *\r\n * @internal\r\n */\r\nfunction isPointOnBezierExtension3(ps, p) {\r\n    const [xe, ye] = p;\r\n    const lenX = xe.length;\r\n    const lenY = ye.length;\r\n    const x = xe[lenX - 1]; // get higest order double\r\n    const y = ye[lenY - 1]; // ...\r\n    const isDouble = (lenX === 1 && lenY === 1);\r\n    //---- first pre-filter\r\n    {\r\n        // The below takes about 1.2 micro-seconds on a 1st gen i7 and Chrome 79\r\n        const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = (0,_implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_7__.getImplicitForm3)(ps);\r\n        const { vₓₓₓ_, // <11>\r\n        vₓₓᵧ_, // <12>\r\n        vₓᵧᵧ_, // <12>\r\n        vᵧᵧᵧ_, // <11>\r\n        vₓₓ_, // <19>\r\n        vₓᵧ_, // <18>\r\n        vᵧᵧ_, // <19>\r\n        vₓ_, // <22>\r\n        vᵧ_, // <22>\r\n        v_ // <24>\r\n         } = (0,_implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_8__.getImplicitForm3ErrorCounters)(ps);\r\n        // In the below a a postfix underscore means \r\n        // an error bound (>= absolute value)\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // const h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        // const h = \r\n        //    (\r\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \r\n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\r\n        //    ) + \r\n        //    (\r\n        //        (vₓx + vᵧy) + \r\n        //        v\r\n        //    );\r\n        const xx = x * x;\r\n        const yy = y * y;\r\n        const h = (((vₓₓₓ * (xx * x) + vₓₓᵧ * (xx * y)) +\r\n            (vₓᵧᵧ * (x * yy) + vᵧᵧᵧ * (yy * y))) +\r\n            ((vₓₓ * xx + vₓᵧ * (x * y)) + vᵧᵧ * yy)) +\r\n            ((vₓ * x + vᵧ * y) +\r\n                v);\r\n        //-------------------\r\n        // Error calculation\r\n        //-------------------\r\n        // In the below, if x is given as a double then the error counter on\r\n        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the\r\n        // error counter with a <D> so that for a point with double precion \r\n        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.\r\n        // `0` if we have only double precision coordinates, `1` otherwise\r\n        const D = isDouble ? 0 : 1;\r\n        const x_ = abs(x); // <D>x\r\n        const y_ = abs(y); // <D>y\r\n        const xx_ = x_ * x_; // <2D+1>xx\r\n        const xy_ = x_ * y_; // <2D+1>xy\r\n        const yy_ = y_ * y_; // <2D+1>yy\r\n        // <D+26>h <-- <D+26>(<2D+24>(<3D+17>(<3D+16> + <3D+16>) + <2D+23>) + <D+25>(<D+24> + <24>))\r\n        const h_ = (\r\n        // <3D+16> <-- <3D+16>((<3D+14>(<11>vₓₓₓ*<3D+2>(xx*x)) + <3D+15>(<12>vₓₓᵧ*<3D+2>(xx*y)))) +\r\n        (vₓₓₓ_ * (xx_ * x_) + vₓₓᵧ_ * (xx_ * y_)) +\r\n            // <3D+16> <-- <3D+16>((<3D+15>(<12>vₓᵧᵧ*<3D+2>(x*yy)) + <3D+14>(<11>vᵧᵧᵧ*<3D+2>(yy*y)))) +\r\n            (vₓᵧᵧ_ * (x_ * yy_) + vᵧᵧᵧ_ * (yy_ * y_)) +\r\n            // <2D+23> <-- <2D+23>(<2D+22>(<2D+21>(<19>vₓₓ*<2D+1>xx) + <2D+20>(<18>vₓᵧ*<2D+1>(x*y))) + <2D+20>(<18>vᵧᵧ*<2D+1>yy))\r\n            ((vₓₓ_ * xx_ + vₓᵧ_ * (xy_)) + vᵧᵧ_ * yy_)) +\r\n            (\r\n            // <24> <-- <D+24>(<D+23>(<22>vₓ*<D>x) + <D+23>(<22>vᵧ*<D>y))\r\n            (vₓ_ * x_ + vᵧ_ * y_) +\r\n                // <24>\r\n                v_);\r\n        // if the error is not too high too discern `h` away from zero\r\n        if ((D + 26) * γ1 * h_ < abs(h)) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error too high - let's try double-double precision\r\n    {\r\n        // The below takes about 15 micro-seconds on a 1st gen i7 and Chrome 79\r\n        const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__.getImplicitForm3DdWithRunningError)(ps);\r\n        const _vₓₓₓ = abs(vₓₓₓ[1]);\r\n        const _vₓₓᵧ = abs(vₓₓᵧ[1]);\r\n        const _vₓᵧᵧ = abs(vₓᵧᵧ[1]);\r\n        const _vᵧᵧᵧ = abs(vᵧᵧᵧ[1]);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // const h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const xd = etodd(xe);\r\n        const yd = etodd(ye);\r\n        const _x = abs(x);\r\n        const _y = abs(y);\r\n        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\r\n        // and hence we need to divide the error by 3.\r\n        const x_ = _x / 3;\r\n        const y_ = _y / 3;\r\n        const xx = qmq(xd, xd);\r\n        const _xx = xx[1];\r\n        const xx_ = 2 * (_x * x_ + _xx);\r\n        const xxx = qmq(xd, xx);\r\n        const _xxx = abs(xxx[1]);\r\n        const xxx_ = _x * xx_ + x_ * _xx + 2 * _xxx;\r\n        const yy = qmq(yd, yd);\r\n        const _yy = yy[1];\r\n        const yy_ = 2 * (_y * y_ + _yy);\r\n        const yyy = qmq(yd, yy);\r\n        const _yyy = abs(yyy[1]);\r\n        const yyy_ = _y * yy_ + y_ * _yy + 2 * _yyy;\r\n        const xxy = qmq(yd, xx);\r\n        const _xxy = abs(xxy[1]);\r\n        const xxy_ = _y * xx_ + y_ * _xx + 2 * _xxy;\r\n        const xyy = qmq(xd, yy);\r\n        const _xyy = abs(xyy[1]);\r\n        const xyy_ = _x * yy_ + x_ * _yy + 2 * _xyy;\r\n        const xy = qmq(xd, yd);\r\n        const _xy = abs(xy[1]);\r\n        const xy_ = _x * y_ + x_ * _y + 2 * _xy;\r\n        const vₓₓₓxxx = qmq(vₓₓₓ, xxx);\r\n        const vₓₓₓxxx_ = _vₓₓₓ * xxx_ + vₓₓₓ_ * _xxx + 2 * abs(vₓₓₓxxx[1]);\r\n        const vₓₓᵧxxy = qmq(vₓₓᵧ, xxy);\r\n        const vₓₓᵧxxy_ = _vₓₓᵧ * xxy_ + vₓₓᵧ_ * _xxy + 2 * abs(vₓₓᵧxxy[1]);\r\n        const vₓᵧᵧxyy = qmq(vₓᵧᵧ, xyy);\r\n        const vₓᵧᵧxyy_ = _vₓᵧᵧ * xyy_ + vₓᵧᵧ_ * _xyy + 2 * abs(vₓᵧᵧxyy[1]);\r\n        const vᵧᵧᵧyyy = qmq(vᵧᵧᵧ, yyy);\r\n        const vᵧᵧᵧyyy_ = _vᵧᵧᵧ * yyy_ + vᵧᵧᵧ_ * _yyy + 2 * abs(vᵧᵧᵧyyy[1]);\r\n        const vₓₓxx = qmq(vₓₓ, xx);\r\n        const vₓₓxx_ = abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\r\n        const vₓᵧxy = qmq(vₓᵧ, xy);\r\n        const vₓᵧxy_ = abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\r\n        const vᵧᵧyy = qmq(vᵧᵧ, yy);\r\n        const vᵧᵧyy_ = abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\r\n        const vₓx = qmq(xd, vₓ);\r\n        const vₓx_ = abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * abs(vₓx[1]);\r\n        const vᵧy = qmq(yd, vᵧ);\r\n        const vᵧy_ = abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * abs(vᵧy[1]);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //const h = \r\n        //    (\r\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \r\n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\r\n        //    ) + \r\n        //    (\r\n        //        (vₓx + vᵧy) + \r\n        //        v\r\n        //    );\r\n        const q1 = qaq(vₓₓₓxxx, vₓₓᵧxxy);\r\n        const q1_ = vₓₓₓxxx_ + vₓₓᵧxxy_ + abs(q1[1]);\r\n        const q2 = qaq(vₓᵧᵧxyy, vᵧᵧᵧyyy);\r\n        const q2_ = vₓᵧᵧxyy_ + vᵧᵧᵧyyy_ + abs(q2[1]);\r\n        const q3 = qaq(q1, q2);\r\n        const q3_ = q1_ + q2_ + abs(q3[1]);\r\n        const q4 = qaq(vₓₓxx, vₓᵧxy);\r\n        const q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\r\n        const q5 = qaq(q4, vᵧᵧyy);\r\n        const q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\r\n        const q6 = qaq(q3, q5);\r\n        const q6_ = q3_ + q5_ + abs(q6[1]);\r\n        const q7 = qaq(vₓx, vᵧy);\r\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        const q8 = qaq(q7, v);\r\n        const q8_ = q7_ + v_ + abs(q8[1]);\r\n        const h = qaq(q6, q8);\r\n        const h_ = q6_ + q8_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (γγ3 * h_ < abs(estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error still too high - const's go exact\r\n    {\r\n        // The below takes about 155 micro-seconds on a 1st gen i7 and Chrome 79\r\n        const implictForm = (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_10__.getImplicitForm3Exact)(ps);\r\n        if (implictForm === undefined) {\r\n            // all ps are the same point\r\n            return isDouble && x === ps[0][0] && y === ps[0][1];\r\n        }\r\n        if (!implictForm.hasOwnProperty('vₓₓₓ')) {\r\n            implictForm.vₓₓₓ = [0];\r\n            implictForm.vₓₓᵧ = [0];\r\n            implictForm.vₓᵧᵧ = [0];\r\n            implictForm.vᵧᵧᵧ = [0];\r\n        }\r\n        if (!implictForm.hasOwnProperty('vₓₓ')) {\r\n            implictForm.vₓₓ = [0];\r\n            implictForm.vₓᵧ = [0];\r\n            implictForm.vᵧᵧ = [0];\r\n        }\r\n        const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;\r\n        // `h` (say height) is the the result of evaluating the implicit \r\n        // equation; if it is 0 we are on the curve, else we're not.\r\n        // const h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const xx = epr(xe, xe); // <= error free\r\n        const xxx = epr(xe, xx);\r\n        const yy = epr(ye, ye); // <= error free\r\n        const yyy = epr(ye, yy);\r\n        const xxy = epr(ye, xx);\r\n        const xyy = epr(xe, yy);\r\n        const xy = epr(xe, ye); // <= error free\r\n        const vₓₓₓxxx = epr(vₓₓₓ, xxx);\r\n        const vₓₓᵧxxy = epr(vₓₓᵧ, xxy);\r\n        const vₓᵧᵧxyy = epr(vₓᵧᵧ, xyy);\r\n        const vᵧᵧᵧyyy = epr(vᵧᵧᵧ, yyy);\r\n        const vₓₓxx = epr(vₓₓ, xx);\r\n        const vₓᵧxy = epr(vₓᵧ, xy);\r\n        const vᵧᵧyy = epr(vᵧᵧ, yy);\r\n        const vₓx = epr(xe, vₓ);\r\n        const vᵧy = epr(ye, vᵧ);\r\n        const q1 = fes(vₓₓₓxxx, vₓₓᵧxxy);\r\n        const q2 = fes(vₓᵧᵧxyy, vᵧᵧᵧyyy);\r\n        const q3 = fes(q1, q2);\r\n        const q4 = fes(vₓₓxx, vₓᵧxy);\r\n        const q5 = fes(q4, vᵧᵧyy);\r\n        const q6 = fes(q3, q5);\r\n        const q7 = fes(vₓx, vᵧy);\r\n        const q8 = fes(q7, v);\r\n        const h = fes(q6, q8);\r\n        return sign(h) === 0; // <= calculation was exact\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPointOnBezierExtension: () => (/* binding */ isPointOnBezierExtension)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compress.js\");\n/* harmony import */ var _is_point_on_bezier_extension_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-point-on-bezier-extension-1.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js\");\n/* harmony import */ var _is_point_on_bezier_extension_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-point-on-bezier-extension-2.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js\");\n/* harmony import */ var _is_point_on_bezier_extension_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-point-on-bezier-extension-3.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Returns `true` if the given point is on the given bezier curve where the\r\n * parameter `t` is allowed to extend to ±∞, i.e. `t` is an element of\r\n * `(-∞, +∞)`, `false` otherwise.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n */\r\nfunction isPointOnBezierExtension(ps, p) {\r\n    if (ps.length === 4) {\r\n        return (0,_is_point_on_bezier_extension_3_js__WEBPACK_IMPORTED_MODULE_0__.isPointOnBezierExtension3)(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_is_point_on_bezier_extension_2_js__WEBPACK_IMPORTED_MODULE_1__.isPointOnBezierExtension2)(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_is_point_on_bezier_extension_1_js__WEBPACK_IMPORTED_MODULE_2__.isPointOnBezierExtension1)(ps, p);\r\n    }\r\n    if (ps.length === 1) {\r\n        const x = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eCompress)(p[0]);\r\n        const y = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eCompress)(p[1]);\r\n        return (x.length === 1 && y.length === 1 &&\r\n            x[0] === ps[0][0] && y[0] === ps[0][1]);\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3');\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/sub-1-ulp.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/sub-1-ulp.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sub1Ulp: () => (/* binding */ sub1Ulp)\n/* harmony export */ });\nconst { EPSILON: eps } = Number;\r\nconst u = eps / 2;\r\nconst es = (eps ** 2) / 2;\r\nconst ups = u + es;\r\n/**\r\n * Subtract one unit in the last place (ulp) from the given number\r\n *\r\n * * subnormal numbers (and 0) are returned unaltered\r\n * @internal\r\n */\r\nfunction sub1Ulp(n) {\r\n    return n > 0 ? n - n * ups : n + n * ups;\r\n}\r\n\r\n//# sourceMappingURL=sub-1-ulp.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/sub-1-ulp.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_1stDerivative: () => (/* binding */ toPowerBasis_1stDerivative)\n/* harmony export */ });\n/**\r\n * Returns the derivative of the power basis representation of a\r\n * bezier curve of order cubic or less (with intermediate calculations done in\r\n * double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_1stDerivative(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3_1stDerivative(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2_1stDerivative(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1_1stDerivative(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error('The bezier curve must be of order <= 3.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3_1stDerivative(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            3 * ((x3 - x0) + 3 * (x1 - x2)),\r\n            6 * ((x2 + x0) - 2 * x1),\r\n            3 * (x1 - x0)\r\n        ], [\r\n            3 * ((y3 - y0) + 3 * (y1 - y2)),\r\n            6 * ((y2 + y0) - 2 * y1),\r\n            3 * (y1 - y0)\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2_1stDerivative(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            2 * ((x2 + x0) - 2 * x1),\r\n            2 * (x1 - x0)\r\n        ], [\r\n            2 * ((y2 + y0) - 2 * y1),\r\n            2 * (y1 - y0)\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1_1stDerivative(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            x1 - x0\r\n        ], [\r\n            y1 - y0\r\n        ]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-1st-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_2ndDerivative: () => (/* binding */ toPowerBasis_2ndDerivative)\n/* harmony export */ });\n/**\r\n * Returns the 2nd derivative of the power basis representation of a\r\n * bezier curve of order cubic or less (with intermediate calculations done in\r\n * double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_2ndDerivative(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                6 * ((x3 - x0) + 3 * (x1 - x2)),\r\n                6 * ((x2 + x0) - 2 * x1)\r\n            ], [\r\n                6 * ((y3 - y0) + 3 * (y1 - y2)),\r\n                6 * ((y2 + y0) - 2 * y1)\r\n            ]];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                2 * (x2 - 2 * x1 + x0)\r\n            ], [\r\n                2 * (y2 - 2 * y1 + y0)\r\n            ]];\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-2nd-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis_3rdDerivative: () => (/* binding */ toPowerBasis_3rdDerivative)\n/* harmony export */ });\n/**\r\n * Returns the 3rd derivative of the power basis representation of a bezier\r\n * curve of order cubic or less (with intermediate calculations done in\r\n * double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_3rdDerivative(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * ((x3 - x0) + 3 * (x1 - x2)),\r\n            6 * ((y3 - y0) + 3 * (y1 - y2))\r\n        ];\r\n    }\r\n    if (ps.length <= 3) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n    // Side note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], \r\n    // then max(dddx)(t) <= 48*X for all t.\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-3rd-derivative.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis1DdWithRunningError: () => (/* binding */ toPowerBasis1DdWithRunningError),\n/* harmony export */   toPowerBasis2DdWithRunningError: () => (/* binding */ toPowerBasis2DdWithRunningError),\n/* harmony export */   toPowerBasis3DdWithRunningError: () => (/* binding */ toPowerBasis3DdWithRunningError),\n/* harmony export */   toPowerBasisDdWithRunningError: () => (/* binding */ toPowerBasisDdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\r\nconst abs = Math.abs;\r\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less including a coefficient-wise absolute error bound that need to be multiplied\r\n * by `γγ(3)`\r\n *\r\n * * intermediate calculations done in double-double precision\r\n * * the error bound need to be multiplied by `γγ(3) === 3.697785493223493e-32` before use\r\n * * returns the power basis x and y coordinate polynomials from highest power\r\n * to lowest, e.g. if `x(t) = at^3 + bt^2 + ct + d`\r\n * and `y(t) = et^3 + ft^2 + gt + h` then the result is returned\r\n * as `[[a,b,c,d],[e,f,g,h]]`, where the `a,b,c,...` are in double-double\r\n * precision\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisDdWithRunningError(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3DdWithRunningError(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2DdWithRunningError(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return {\r\n            coeffs: toPowerBasis1DdWithRunningError(ps),\r\n            errorBound: [[0, 0], [0, 0]]\r\n        };\r\n    }\r\n    if (ps.length === 1) {\r\n        return {\r\n            coeffs: toPowerBasis0DdWithRunningError(ps),\r\n            errorBound: [[0], [0]]\r\n        };\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= cubic.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3DdWithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // ----------------------------\r\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\r\n    // ----------------------------\r\n    const xa = td(x3, x0); // error free\r\n    const xb = td(x1, x2); // error free\r\n    const $xc = 3 * (x1 - x2);\r\n    const xc = qmd(3, xb);\r\n    const _xc_ = abs($xc);\r\n    const xx3 = qaq(xa, xc);\r\n    const xx3_ = _xc_ + abs(x3 - x0 + $xc);\r\n    // ----------------------------\r\n    // xx2 = 3*(x2 - 2*x1 + x0)\r\n    // ----------------------------\r\n    const xd = td(x2, 2 * x1); // error free\r\n    const xe = qad(xd, x0);\r\n    const _xe_ = abs(x2 - 2 * x1 + x0);\r\n    const xx2 = qmd(3, xe);\r\n    //const xx2_ = 3*_xe_ + 3*_xe_;\r\n    const xx2_ = 6 * _xe_;\r\n    // ----------------------------\r\n    // xx1 = 3*(x1 - x0)\r\n    // ----------------------------\r\n    const xg = td(x1, x0); // error free\r\n    const xx1 = qmd(3, xg);\r\n    const xx1_ = abs(3 * (x1 - x0));\r\n    // ----------------------------\r\n    // yy3 = y3 + 3*(y1 - y2) - y0\r\n    // ----------------------------\r\n    const ya = td(y3, y0); // error free\r\n    const yb = td(y1, y2); // error free\r\n    const $yc = 3 * (y1 - y2);\r\n    const yc = qmd(3, yb);\r\n    const _yc_ = abs($yc);\r\n    const yy3 = qaq(ya, yc);\r\n    const yy3_ = _yc_ + abs(y3 - y0 + $yc);\r\n    // ----------------------------\r\n    // yy2 = 3*(y2 - 2*y1 + y0)\r\n    // ----------------------------\r\n    const yd = td(y2, 2 * y1); // error free\r\n    const ye = qad(yd, y0);\r\n    const _ye_ = abs(y2 - 2 * y1 + y0);\r\n    const yy2 = qmd(3, ye);\r\n    //const yy2_ = 3*_ye_ + 3*_ye_;\r\n    const yy2_ = 6 * _ye_;\r\n    // ----------------------------\r\n    // yy1 = 3*(y1 - y0)\r\n    // ----------------------------\r\n    const yg = td(y1, y0); // error free\r\n    const yy1 = qmd(3, yg);\r\n    const yy1_ = abs(3 * (y1 - y0));\r\n    return {\r\n        coeffs: [[xx3, xx2, xx1, [0, x0]], [yy3, yy2, yy1, [0, y0]]],\r\n        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2DdWithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // ---------------------\r\n    // xx2 = x2 - 2*x1 + x0\r\n    // ---------------------\r\n    const $a = x2 - 2 * x1;\r\n    const a = td(x2, 2 * x1); // error free\r\n    const xx2 = qad(a, x0);\r\n    const xx2_ = abs($a + x0);\r\n    // ---------------------\r\n    // xx1 = 2*(x1 - x0)\r\n    // ---------------------\r\n    const xx1 = td(2 * x1, 2 * x0); // error free\r\n    // ---------------------\r\n    // yy2 = y2 - 2*y1 + y0\r\n    // ---------------------\r\n    const $b = y2 - 2 * y1;\r\n    const b = td(y2, 2 * y1); // error free\r\n    const yy2 = qad(b, y0);\r\n    const yy2_ = abs($b + y0);\r\n    // ---------------------\r\n    // yy1 = 2*(y1 - y0)\r\n    // ---------------------\r\n    const yy1 = td(2 * y1, 2 * y0); // error free\r\n    return {\r\n        coeffs: [[xx2, xx1, [0, x0]], [yy2, yy1, [0, y0]]],\r\n        errorBound: [[xx2_, 0, 0], [yy2_, 0, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1DdWithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            td(x1, x0),\r\n            [0, x0]\r\n        ], [\r\n            td(y1, y0),\r\n            [0, y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0DdWithRunningError(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[[0, x0]], [[0, y0]]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-dd-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis1WithRunningError: () => (/* binding */ toPowerBasis1WithRunningError),\n/* harmony export */   toPowerBasis2WithRunningError: () => (/* binding */ toPowerBasis2WithRunningError),\n/* harmony export */   toPowerBasis3WithRunningError: () => (/* binding */ toPowerBasis3WithRunningError),\n/* harmony export */   toPowerBasisWithRunningError: () => (/* binding */ toPowerBasisWithRunningError)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less including a coefficient-wise absolute error bound.\r\n *\r\n * * intermediate calculations are done in double precision\r\n * * the error bound need to be multiplied by `γ(1) === u/(1-u)`\r\n * where `u = Number.EPSILON/2` before use\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisWithRunningError(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3WithRunningError(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2WithRunningError(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1WithRunningError(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0WithRunningError(ps);\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3WithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // ----------------------------\r\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\r\n    // ----------------------------\r\n    const xa = x3 - x0;\r\n    const _xa_ = abs(xa);\r\n    const xb = x1 - x2;\r\n    const _xb_ = abs(xb);\r\n    const xc = 3 * xb;\r\n    const xc_ = 6 * _xb_; // === 3*_xb_ + 3*abs(xc)\r\n    const xx3 = xa + xc;\r\n    const xx3_ = _xa_ + xc_ + abs(xx3);\r\n    // ----------------------------\r\n    // xx2 = 3*((x2 + x0) - 2*x1)\r\n    // ----------------------------\r\n    const xd = x2 + x0;\r\n    const _xd_ = abs(xd);\r\n    const xe = xd - 2 * x1;\r\n    const _xe_ = _xd_ + abs(xe);\r\n    const xx2 = 3 * xe;\r\n    const xx2_ = 6 * _xe_; // 3*_xe_ + abs(xx2)\r\n    // ----------------------------\r\n    // xx1 = 3*(x1 - x0)\r\n    // ----------------------------\r\n    const xg = x1 - x0;\r\n    const _xg_ = abs(xg);\r\n    const xx1 = 3 * xg;\r\n    const xx1_ = 6 * _xg_; // 3*_xg_ + abs(3*xg)\r\n    // ------------------------------\r\n    // yy3 = (y3 - y0) + 3*(y1 - y2)\r\n    // ------------------------------\r\n    const ya = y3 - y0;\r\n    const _ya_ = abs(ya);\r\n    const yb = y1 - y2;\r\n    const _yb_ = abs(yb);\r\n    const yc = 3 * yb;\r\n    const yc_ = 6 * _yb_; // === 3*_yb_ + 3*abs(yc)\r\n    const yy3 = ya + yc;\r\n    const yy3_ = _ya_ + yc_ + abs(yy3);\r\n    // ----------------------------\r\n    // yy2 = 3*((y2 + y0) - 2*y1)\r\n    // ----------------------------\r\n    const yd = y2 + y0;\r\n    const _yd_ = abs(yd);\r\n    const ye = yd - 2 * y1;\r\n    const _ye_ = _yd_ + abs(ye);\r\n    const yy2 = 3 * ye;\r\n    const yy2_ = 6 * _ye_; // 3*_ye_ + abs(yy2)\r\n    // ----------------------------\r\n    // yy1 = 3*(y1 - y0)\r\n    // ----------------------------\r\n    const yg = y1 - y0;\r\n    const _yg_ = abs(yg);\r\n    const yy1 = 3 * yg;\r\n    const yy1_ = 6 * _yg_; // 3*_yg_ + abs(3*yg)\r\n    return {\r\n        coeffs: [[xx3, xx2, xx1, x0], [yy3, yy2, yy1, y0]],\r\n        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2WithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // ---------------------\r\n    // xx2 = (x2 + x0) - 2*x1\r\n    // ---------------------\r\n    const xa = x2 + x0;\r\n    const _xa_ = abs(xa);\r\n    const xx2 = xa - 2 * x1;\r\n    const xx2_ = _xa_ + abs(xx2);\r\n    // ---------------------\r\n    // xx1 = 2*(x1 - x0)\r\n    // ---------------------\r\n    const xx1 = 2 * (x1 - x0);\r\n    const xx1_ = abs(xx1);\r\n    // ---------------------\r\n    // yy2 = (y2 + y0) - 2*y1\r\n    // ---------------------\r\n    const ya = y2 + y0;\r\n    const _ya_ = abs(ya);\r\n    const yy2 = ya - 2 * y1;\r\n    const yy2_ = _ya_ + abs(yy2);\r\n    // ---------------------\r\n    // yy1 = 2*(y1 - y0)\r\n    // ---------------------\r\n    const yy1 = 2 * (y1 - y0);\r\n    const yy1_ = abs(yy1);\r\n    return {\r\n        coeffs: [[xx2, xx1, x0], [yy2, yy1, y0]],\r\n        errorBound: [[xx2_, xx1_, 0], [yy2_, yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1WithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const xx1 = x1 - x0;\r\n    const xx1_ = abs(xx1);\r\n    const yy1 = y1 - y0;\r\n    const yy1_ = abs(yy1);\r\n    return {\r\n        coeffs: [[xx1, x0], [yy1, y0]],\r\n        errorBound: [[xx1_, 0], [yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0WithRunningError(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return {\r\n        coeffs: [[x0], [y0]],\r\n        errorBound: [[0], [0]]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis: () => (/* binding */ toPowerBasis),\n/* harmony export */   toPowerBasis0: () => (/* binding */ toPowerBasis0),\n/* harmony export */   toPowerBasis1: () => (/* binding */ toPowerBasis1),\n/* harmony export */   toPowerBasis2: () => (/* binding */ toPowerBasis2),\n/* harmony export */   toPowerBasis3: () => (/* binding */ toPowerBasis3)\n/* harmony export */ });\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less.\r\n *\r\n * * intermediate calculations are done in double precision\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0(ps);\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            (x3 - x0) + 3 * (x1 - x2),\r\n            3 * ((x2 + x0) - 2 * x1),\r\n            3 * (x1 - x0),\r\n            x0\r\n        ], [\r\n            (y3 - y0) + 3 * (y1 - y2),\r\n            3 * ((y2 + y0) - 2 * y1),\r\n            3 * (y1 - y0),\r\n            y0\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            (x2 + x0) - 2 * x1,\r\n            2 * (x1 - x0),\r\n            x0\r\n        ], [\r\n            (y2 + y0) - 2 * y1,\r\n            2 * (y1 - y0),\r\n            y0\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            x1 - x0,\r\n            x0,\r\n        ], [\r\n            y1 - y0,\r\n            y0,\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[x0], [y0]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis0Exact: () => (/* binding */ toPowerBasis0Exact),\n/* harmony export */   toPowerBasis1Exact: () => (/* binding */ toPowerBasis1Exact),\n/* harmony export */   toPowerBasis2Exact: () => (/* binding */ toPowerBasis2Exact),\n/* harmony export */   toPowerBasis3Exact: () => (/* binding */ toPowerBasis3Exact),\n/* harmony export */   toPowerBasisExact: () => (/* binding */ toPowerBasisExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoSum;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.growExpansion;\r\nconst eAdd = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eAdd;\r\n/**\r\n * Returns the *exact* power basis representation of a bezier curve of order\r\n * cubic or less.\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\r\n * expansions\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisExact(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3Exact(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2Exact(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1Exact(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0Exact(ps);\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= cubic.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3Exact(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            // (x3 - x0) + 3*(x1 - x2)\r\n            eAdd(td(x3, x0), sce(3, td(x1, x2))),\r\n            // OR\r\n            // (x3 - x0) - (2*x2 + x2) + (2*x1 + x1)\r\n            //eAdd(eAdd(td(x3,x0), ts(-2*x2, -x2)), ts(2*x1, x1))\r\n            // 3*((x2 + x0) - 2*x1)\r\n            sce(3, ge(ts(x2, x0), -2 * x1)),\r\n            // 3*(x1 - x0)\r\n            sce(3, td(x1, x0)),\r\n            // x0\r\n            [x0]\r\n        ], [\r\n            //ge(ge(sce(3, td(y1, y2)), y3), -y0),\r\n            eAdd(td(y3, y0), sce(3, td(y1, y2))),\r\n            //sce(3, ge(td(y2, 2*y1), y0)),\r\n            sce(3, ge(ts(y2, y0), -2 * y1)),\r\n            sce(3, td(y1, y0)),\r\n            [y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2Exact(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            // x2 - 2*x1 + x0\r\n            ge(ts(x2, x0), -2 * x1),\r\n            // 2*(x1 - x0)\r\n            td(2 * x1, 2 * x0),\r\n            //x0\r\n            [x0]\r\n        ], [\r\n            ge(ts(y2, y0), -2 * y1),\r\n            td(2 * y1, 2 * y0),\r\n            [y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1Exact(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            //x1 - x0,\r\n            td(x1, x0),\r\n            //x0\r\n            [x0]\r\n        ], [\r\n            td(y1, y0),\r\n            [y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0Exact(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[[x0]], [[y0]]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-exact.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPowerBasis1ErrorCounters: () => (/* binding */ toPowerBasis1ErrorCounters),\n/* harmony export */   toPowerBasis2ErrorCounters: () => (/* binding */ toPowerBasis2ErrorCounters),\n/* harmony export */   toPowerBasis3ErrorCounters: () => (/* binding */ toPowerBasis3ErrorCounters),\n/* harmony export */   toPowerBasisErrorCounters: () => (/* binding */ toPowerBasisErrorCounters)\n/* harmony export */ });\n// Note: \r\n// Error counters of double-double will actually be slightly less but\r\n// we can use this for both double and double-double precision.\r\n// For double precision the error bound === γ * <counter> * `error_`\r\n// For double-double precision the error bound === γγ3 * <counter> * `error_`\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the power basis representation of a\r\n * bezier curve of order <= 3 (using e.g. `toPowerBasis` or `toPowerBasisDd`).\r\n *\r\n * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * // for cubic bezier curves\r\n * return [\r\n * \t[\r\n * \t\tx3,  // <E> === 3\r\n * \t\tx2,  // <E> === 3\r\n * \t\tx1,  // <E> === 2\r\n * \t\t0,\r\n * \t],\r\n * \t[\r\n * \t\ty3,  // <E> === 3\r\n * \t\ty2,  // <E> === 3\r\n * \t\ty1,  // <E> === 2\r\n * \t\t0,\r\n * \t]\r\n * ]\r\n *\r\n * // for quadratic bezier curves\r\n * return [\r\n * \t[\r\n * \t\tx2,  // <E> === 2\r\n * \t\tx1,  // <E> === 1\r\n * \t\t0,\r\n * \t],\r\n * \t[\r\n * \t\ty2,  // <E> === 2\r\n * \t\ty1,  // <E> === 1\r\n * \t\t0,\r\n * \t]\r\n * ];\r\n *\r\n * // for linear bezier curves (i.e. lines)\r\n * return [\r\n * \t[\r\n * \t\tx1_,  // <E> === 1\r\n * \t\tx0_   // <E> === 0\r\n * \t],\r\n * \t[\r\n * \t\ty1_,  // <E> === 1\r\n * \t\ty0_   // <E> === 0\r\n * \t]\r\n * ];\r\n * ```\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction toPowerBasisErrorCounters(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3ErrorCounters(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2ErrorCounters(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1ErrorCounters(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1ErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    return [\r\n        [\r\n            _x1 + _x0,\r\n            0,\r\n        ], [\r\n            _y1 + _y0,\r\n            0,\r\n        ]\r\n    ];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2ErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    return [\r\n        [\r\n            _x2 + _x0 + 2 * _x1,\r\n            2 * (_x1 + _x0),\r\n            0,\r\n        ], [\r\n            _y2 + _y0 + 2 * _y1,\r\n            2 * (_y1 + _y0),\r\n            0,\r\n        ]\r\n    ];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3ErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _x3 = abs(x3);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _y3 = abs(y3);\r\n    return [\r\n        [\r\n            _x3 + _x0 + 3 * (_x1 + _x2),\r\n            3 * (_x2 + _x0 + 2 * _x1),\r\n            3 * (_x1 + _x0),\r\n            0,\r\n        ], [\r\n            _y3 + _y0 + 3 * (_y1 + _y2),\r\n            3 * (_y2 + _y0 + 2 * _y1),\r\n            3 * (_y1 + _y0),\r\n            0,\r\n        ]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-error-counters.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicToQuadratic: () => (/* binding */ cubicToQuadratic)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eEstimate;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.scaleExpansion;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.twoSum;\r\n/**\r\n * Returns a quadratic approximation to the given cubic bezier curve.\r\n *\r\n * * the initial and final control points of the resulting bezier coincide with\r\n * that of the curve being approximated\r\n *\r\n * * if `preserveTangents` is `true` and the cubic's initial and final tangents\r\n * are parallel (and not coincident) then `undefined` is returned\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param preserveTangents optional; defaults to `false`; if `true` then the approximation\r\n * must also preserve the tangents of the cubic at the initial and final control\r\n * points\r\n *\r\n * @doc mdx\r\n */\r\nfunction cubicToQuadratic(ps, preserveTangents = false) {\r\n    // Note: if cubic is really a quad then\r\n    //   x3 + 3*(x1 - x2) === x0 && \r\n    //   y3 + 3*(y1 - y2) === y0\r\n    // Take the midpoint of the moving line of the hybrid quadratic version of \r\n    // the cubic as the new quadratic's middle control point.\r\n    if (!preserveTangents) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [\r\n                // [\r\n                //   (3*(x1 + x2) - (x0 + x3)) / 4, \r\n                //   (3*(y1 + y2) - (y0 + y3)) / 4\r\n                // ]\r\n                estimate(ediff(sce(ts(x1 / 4, x2 / 4), 3), ts(x0 / 4, x3 / 4))),\r\n                estimate(ediff(sce(ts(y1 / 4, y2 / 4), 3), ts(y0 / 4, y3 / 4)))\r\n            ],\r\n            [x3, y3]\r\n        ];\r\n    }\r\n    // At this point: `preserveTangents === true`\r\n    const [p0, p1, p2, p3] = ps;\r\n    const l1 = [p0, p1];\r\n    const l2 = [p3, p2];\r\n    const pM = llIntersection(l1, l2);\r\n    if (pM === undefined) {\r\n        return undefined;\r\n        //return [\r\n        //    p0,\r\n        //    [(p0[0] + p3[0])/2, (p0[1] + p3[1])/2],\r\n        //    p3\r\n        //];\r\n    }\r\n    return [p0, pM, p3];\r\n}\r\n/**\r\n * Returns the point of intersection of the given two lines or `undefined` if\r\n * the lines are parallel.\r\n *\r\n * * returns `undefined` *iff* the lines are *exactly* parallel\r\n *\r\n * @param l1\r\n * @param l2\r\n *\r\n * @internal\r\n */\r\nfunction llIntersection(l1, l2) {\r\n    const [[x1, y1], [x2, y2]] = l1;\r\n    const [[x3, y3], [x4, y4]] = l2;\r\n    const x1_ = td(x2, x1);\r\n    const y1_ = td(y2, y1);\r\n    const x2_ = td(x4, x3);\r\n    const y2_ = td(y4, y3);\r\n    const denom = ediff(epr(x2_, y1_), epr(y2_, x1_));\r\n    if (esign(denom) === 0) {\r\n        // definitely parallel\r\n        return undefined;\r\n    }\r\n    const x3_ = td(x3, x1);\r\n    const y3_ = td(y3, y1);\r\n    const b = ediff(epr(y3_, x1_), epr(x3_, y1_));\r\n    const bb = estimate(b) / estimate(denom);\r\n    return [\r\n        x3 + bb * estimate(x2_),\r\n        y3 + bb * estimate(y2_)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=cubic-to-quadratic.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/get-hodograph.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/get-hodograph.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHodograph: () => (/* binding */ getHodograph)\n/* harmony export */ });\n/**\r\n * Returns the hodograph of the given bezier curve.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getHodograph(ps) {\r\n    // * **bitlength**: If the coordinates of the control points are bit-aligned then\r\n    // * max bitlength increase === 3, max shift === 3 (for cubics)\r\n    // * max bitlength increase === 1, max shift === 2 (for quadratics)\r\n    // * max bitlength increase === 1, max shift === 1 (for lines)\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [3 * (x1 - x0), 3 * (y1 - y0)],\r\n            [3 * (x2 - x1), 3 * (y2 - y1)],\r\n            [3 * (x3 - x2), 3 * (y3 - y2)]\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            [2 * (x1 - x0), 2 * (y1 - y0)],\r\n            [2 * (x2 - x1), 2 * (y2 - y1)]\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        // a line\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            [x1 - x0, y1 - y0]\r\n        ];\r\n    }\r\n    throw new Error('The given bezier curve must be of order 1, 2 or 3.');\r\n}\r\n\r\n//# sourceMappingURL=get-hodograph.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/get-hodograph.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reduceOrderIfPossible: () => (/* binding */ reduceOrderIfPossible)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./degree-or-type/cubic-to-quadratic.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js\");\n/* harmony import */ var _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global-properties/classification/is-quad-really-line.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js\");\n/* harmony import */ var _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global-properties/classification/is-really-point.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Returns a reduced order version of the given bezier curve *if* it can be\r\n * represented as such without loss.\r\n *\r\n * Crucially, the reduced order bezier will have exactly the same `t` values\r\n * at specific `x` and `y` coordinates as the original.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction reduceOrderIfPossible(ps) {\r\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_0__.isCubicReallyQuad)(ps)) {\r\n        ps = (0,_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__.cubicToQuadratic)(ps);\r\n    }\r\n    if (ps.length === 3 && (0,_global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_2__.isQuadReallyLine)(ps)) {\r\n        ps = [ps[0], ps[2]];\r\n    }\r\n    if (ps.length === 2 && (0,_global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__.isReallyPoint)(ps)) {\r\n        ps = [ps[0]];\r\n    }\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=reduce-order-if-possible.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reverse.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reverse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reverse: () => (/* binding */ reverse)\n/* harmony export */ });\n/**\r\n * Returns the given points (e.g. bezier curve) in reverse order.\r\n *\r\n * Implementation details:\r\n * ```\r\n * const reverse = ps => ps.slice().reverse()\r\n * ```\r\n *\r\n * @param ps a bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction reverse(ps) {\r\n    return ps.slice().reverse();\r\n}\r\n\r\n//# sourceMappingURL=reverse.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/reverse.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo: () => (/* binding */ fromTo)\n/* harmony export */ });\n/* harmony import */ var _from_to_from_to_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to/from-to-3.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js\");\n/* harmony import */ var _from_to_from_to_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to/from-to-2.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js\");\n/* harmony import */ var _from_to_from_to_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to/from-to-1.js */ \"./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js\");\n\r\n\r\n\r\nconst fromTo3 = _from_to_from_to_3_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3;\r\nconst fromTo2 = _from_to_from_to_2_js__WEBPACK_IMPORTED_MODULE_1__.fromTo2;\r\nconst fromTo1 = _from_to_from_to_1_js__WEBPACK_IMPORTED_MODULE_2__.fromTo1;\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @doc mdx\r\n */\r\nfunction fromTo(ps, tS, tE) {\r\n    if (ps.length === 4) {\r\n        return fromTo3(ps, tS, tE);\r\n    }\r\n    if (ps.length === 3) {\r\n        return fromTo2(ps, tS, tE);\r\n    }\r\n    if (ps.length === 2) {\r\n        return fromTo1(ps, tS, tE);\r\n    }\r\n    if (ps.length === 1) {\r\n        return ps;\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=from-to.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo1InclErrorBound: () => (/* binding */ fromTo1InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/** error free error bounds */\r\nconst psErrorFree = [[0, 0], [0, 0]];\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `3u` before use,\r\n * where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a linear bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo1InclErrorBound(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return { ps, _ps: psErrorFree };\r\n        }\r\n        return splitLeft1(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight1(ps, tS);\r\n    }\r\n    return splitAtBoth1(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given `t` parameter and ends\r\n * at `t === 1` including an error bound (that needs to be multiplied\r\n * by `3u`, where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const psR = [\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0],\r\n        [x1,\r\n            y1] // yy1\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // <3>xx0 <= <3>(<2>(t*<1>(x1 - x0)) + x0)\r\n    const _xx0 = _t * (_x1 + _x0) + _x0;\r\n    const _yy0 = _t * (_y1 + _y0) + _y0;\r\n    /** the coordinate-wise error bound */\r\n    //const psR_ = [\r\n    //    [3*u*_xx0, 3*u*_yy0],\r\n    //    [0, 0]\r\n    //];\r\n    const psR_ = [\r\n        [_xx0, _yy0],\r\n        [0, 0]\r\n    ];\r\n    return {\r\n        ps: psR,\r\n        _ps: psR_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter including an error bound (that needs to be multiplied by `3u`,\r\n * where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0]; // exact \r\n    const p1 = ps[1]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const psL = [\r\n        [x0,\r\n            y0],\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0] // yy1\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // <3>xx1 <= <3>(<2>(t*<1>(x1 - x0)) + x0)\r\n    const _xx1 = _t * (_x1 + _x0) + _x0;\r\n    const _yy1 = _t * (_y1 + _y0) + _y0;\r\n    /** the coordinate-wise error bound */\r\n    //const psL_ = [\r\n    //    [0, 0],\r\n    //    [3*u*_xx1, 3*u*_yy1],\r\n    //];\r\n    const psL_ = [\r\n        [0, 0],\r\n        [_xx1, _yy1],\r\n    ];\r\n    return {\r\n        ps: psL,\r\n        _ps: psL_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `3u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth1(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const psB = [\r\n        [tS * (x1 - x0) + x0,\r\n            tS * (y1 - y0) + y0],\r\n        [tE * (x1 - x0) + x0,\r\n            tE * (y1 - y0) + y0] // yy1\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _tS = abs(tS);\r\n    const _tE = abs(tE);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // <3>xx0 <= <3>(<2>(tS*<1>(x1 - x0)) + x0)\r\n    const _xx0 = _tS * (_x1 + _x0) + _x0;\r\n    // <3>xx1\r\n    const _xx1 = _tE * (_x1 + _x0) + _x0;\r\n    const _yy0 = _tS * (_y1 + _y0) + _y0;\r\n    const _yy1 = _tE * (_y1 + _y0) + _y0;\r\n    /** the coordinate-wise error bound */\r\n    //const psR_ = [\r\n    //    [3*u*_xx0, 3*u*_yy0],\r\n    //    [0, 0]\r\n    //];\r\n    const psB_ = [\r\n        [_xx0, _yy0],\r\n        [_xx1, _yy1]\r\n    ];\r\n    return {\r\n        ps: psB,\r\n        _ps: psB_\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=from-to-1-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo1: () => (/* binding */ fromTo1)\n/* harmony export */ });\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo1(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return ps;\r\n        }\r\n        return splitLeft1(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight1(ps, tS);\r\n    }\r\n    return splitAtBoth1(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given `t` parameter and ends\r\n * at `t === 1`.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    // --------------------------------------------------------\r\n    return [\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0],\r\n        [x1,\r\n            y1] // yy1\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    // --------------------------------------------------------\r\n    return [\r\n        [x0,\r\n            y0],\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0] // yy1\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth1(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    // --------------------------------------------------------\r\n    return [\r\n        [tS * (x1 - x0) + x0,\r\n            tS * (y1 - y0) + y0],\r\n        [tE * (x1 - x0) + x0,\r\n            tE * (y1 - y0) + y0] // yy1\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=from-to-1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo2InclErrorBound: () => (/* binding */ fromTo2InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/** error free error bounds */\r\nconst psErrorFree = [[0, 0], [0, 0], [0, 0]];\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `5u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo2InclErrorBound(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return { ps, _ps: psErrorFree };\r\n        }\r\n        return splitLeft2(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight2(ps, tS);\r\n    }\r\n    return splitAtBoth2(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1` including an error bound (that needs to be multiplied\r\n * by `5u`, where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)\r\n    const xA = x0 - x1; // <1>xA\r\n    const xB = x2 - x1; // <1>xB\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const psR = [\r\n        [tt * (xA + xB) - (2 * t * xA - x0),\r\n            tt * (yA + yB) - (2 * t * yA - y0)],\r\n        [t * xB + x1,\r\n            t * yB + y1],\r\n        [x2,\r\n            y2] // yy2\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _xB = _x2 + _x1;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    const _yB = _y2 + _y1;\r\n    // <5>xx0 <= <5>(<4>(<1>tt*<2>(<1>xA + <1>xB)) - <3>(<2>(2*t*<1>xA) - x0))\r\n    const _xx0 = tt * (_xA + _xB) + (2 * _t * _xA + _x0);\r\n    // <3>xx1 <= <3>(<2>(t*<1>xB) + x1)\r\n    const _xx1 = _t * _xB + _x1;\r\n    const _yy0 = tt * (_yA + _yB) + (2 * _t * _yA + _y0);\r\n    const _yy1 = 0;\r\n    /** the coordinate-wise error bound */\r\n    //const psR_ = [\r\n    //    [5*u*_xx0, 5*u*_yy0],\r\n    //    [3*u*_xx1, 3*u*_yy1],\r\n    //    [0, 0]\r\n    //];\r\n    const psR_ = [\r\n        [_xx0, _yy0],\r\n        [_xx1, _yy1],\r\n        [0, 0]\r\n    ];\r\n    return {\r\n        ps: psR,\r\n        _ps: psR_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter including an error bound (that needs to be multiplied by `5u`,\r\n * where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0]; // exact \r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)\r\n    const xA = x0 - x1; // <1>xA\r\n    const yA = y0 - y1;\r\n    const psL = [\r\n        [x0,\r\n            y0],\r\n        [-t * xA + x0,\r\n            -t * yA + y0],\r\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0),\r\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    // <3>xx1 <= <3>(<2>(-t*<1>xA) + x0)\r\n    const _xx1 = _t * _xA + _x0;\r\n    // <5>xx2 <= <5>(<4>(<1>tt*<2>(<1>xA + <1>(x2 - x1))) - <3>(<2>(2*t*<1>xA) - x0))\r\n    const _xx2 = tt * (_xA + (_x2 + _x1)) + (2 * _t * _xA + _x0);\r\n    const _yy1 = _t * _yA + _y0;\r\n    const _yy2 = tt * (_yA + (_y2 + _y1)) + (2 * _t * _yA + _y0);\r\n    /** the coordinate-wise error bound */\r\n    //const psL_ = [\r\n    //    [0, 0],\r\n    //    [3*u*_xx1, 3*u*_yy1],\r\n    //    [5*u*_xx2, 5*u*_yy2],\r\n    //];\r\n    const psL_ = [\r\n        [0, 0],\r\n        [_xx1, _yy1],\r\n        [_xx2, _yy2]\r\n    ];\r\n    return {\r\n        ps: psL,\r\n        _ps: psL_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `5u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth2(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const ttS = tS * tS; // <1>ttS  <= <0>tS<0>tS   (by counter rule 2)\r\n    const ttE = tE * tE; // ...\r\n    const tStE = tS * tE; // <1>tStE\r\n    const xA = x0 - x1; // <1>xA\r\n    const xB = x2 - x1; // <1>xB\r\n    const xC = xA + xB; // <2>xC\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = yA + yB;\r\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\r\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\r\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\r\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\r\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\r\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _tS = abs(tS);\r\n    const _tE = abs(tE);\r\n    const _tStE = abs(tStE);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _xC = _xA + _x2 + _x1;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    const _yC = _yA + _y2 + _y1;\r\n    // <5>xx0 = <5>(<4>(<1>ttS*<2>xC) - <3>(<2>(2*tS*<1>xA) - x0))\r\n    const _xx0 = ttS * _xC + (2 * _tS * _xA + _x0);\r\n    // <5>xx1 = <5>(<4>(<1>tStE*<2>xC) - <4>((<3>(<1>xA*<1>(tE + tS)) - x0)))\r\n    const _xx1 = _tStE * _xC + (_xA * (_tE + _tS) + _x0);\r\n    // <5>xx2 = <5>(<4>(<1>ttE*<2>xC) - <3>(<2>(2*tE*<1>xA) - x0))\r\n    const _xx2 = ttE * _xC + (2 * _tE * _xA + _x0);\r\n    const _yy0 = ttS * _yC + (2 * _tS * _yA + _y0);\r\n    const _yy1 = _tStE * yC + (_yA * (_tE + _tS) + _y0);\r\n    const _yy2 = ttE * _yC + (2 * _tE * _yA + _y0);\r\n    return {\r\n        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2]],\r\n        //ps_: [\r\n        //    [5*u*_xx0, 5*u*_yy0],\r\n        //    [5*u*_xx1, 5*u*_yy1],\r\n        //    [5*u*_xx2, 5*u*_yy2]\r\n        //]\r\n        _ps: [\r\n            [_xx0, _yy0],\r\n            [_xx1, _yy1],\r\n            [_xx2, _yy2]\r\n        ]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=from-to-2-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo2: () => (/* binding */ fromTo2)\n/* harmony export */ });\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo2(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return ps;\r\n        }\r\n        return splitLeft2(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight2(ps, tS);\r\n    }\r\n    return splitAtBoth2(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1`.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    // --------------------------------------------------------\r\n    const tt = t * t;\r\n    const xA = x0 - x1;\r\n    const xB = x2 - x1;\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    return [\r\n        [tt * (xA + xB) - (2 * t * xA - x0),\r\n            tt * (yA + yB) - (2 * t * yA - y0)],\r\n        [t * xB + x1,\r\n            t * yB + y1],\r\n        [x2,\r\n            y2] // yy2\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    // --------------------------------------------------------\r\n    const tt = t * t;\r\n    const xA = x0 - x1;\r\n    const yA = y0 - y1;\r\n    return [\r\n        [x0,\r\n            y0],\r\n        [-t * xA + x0,\r\n            -t * yA + y0],\r\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0),\r\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth2(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    // --------------------------------------------------------\r\n    const ttS = tS * tS;\r\n    const ttE = tE * tE;\r\n    const tStE = tS * tE;\r\n    const xA = x0 - x1;\r\n    const xB = x2 - x1;\r\n    const xC = xA + xB;\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = yA + yB;\r\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\r\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\r\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\r\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\r\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\r\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\r\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2]];\r\n}\r\n\r\n//# sourceMappingURL=from-to-2.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo3InclErrorBound: () => (/* binding */ fromTo3InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/** error free error bounds */\r\nconst psErrorFree = [[0, 0], [0, 0], [0, 0], [0, 0]];\r\n/**\r\n * Returns a bezier curve that starts and ends at the given t parameters\r\n * including an error bound (that needs to be multiplied by `9u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo3InclErrorBound(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return { ps, _ps: psErrorFree };\r\n        }\r\n        return splitLeft3(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight3(ps, tS);\r\n    }\r\n    return splitAtBoth3(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1` including an error bound (that needs to be multiplied\r\n * by `9u`, where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x00 = abs(x00);\r\n    const _x10 = abs(x10);\r\n    const _x20 = abs(x20);\r\n    const _x30 = abs(x30);\r\n    const _y00 = abs(y00);\r\n    const _y10 = abs(y10);\r\n    const _y20 = abs(y20);\r\n    const _y30 = abs(y30);\r\n    const _x01 = _x00 + _t * (_x00 + _x10); // <3>x01 = <3>(x00 - <2>(t*<1>(x00 - x10)))\r\n    const _x11 = _x10 + _t * (_x10 + _x20); // <3>x11\r\n    const _x21 = _x20 + _t * (_x20 + _x30); // <3>x21\r\n    const _x02 = _x01 + _t * (_x01 + _x11); // <6>x02 = <6>(x01 - <5>(t*<4>(<3>x01 - <3>x11)))\r\n    const _x12 = _x11 + _t * (_x11 + _x21); // <6>x12\r\n    const _x03 = _x02 + _t * (_x02 + _x12); // <9>x03 = <9>(x02 - <8>(t*<7>(<6>x02 - <6>x12)))\r\n    const _y01 = _y00 + _t * (_y00 + _y10);\r\n    const _y11 = _y10 + _t * (_y10 + _y20);\r\n    const _y21 = _y20 + _t * (_y20 + _y30);\r\n    const _y02 = _y01 + _t * (_y01 + _y11);\r\n    const _y12 = _y11 + _t * (_y11 + _y21);\r\n    const _y03 = _y02 + _t * (_y02 + _y12);\r\n    return {\r\n        ps: [[x03, y03], [x12, y12], [x21, y21], [x30, y30]],\r\n        _ps: [\r\n            // the coordinate-wise error bounds\r\n            [_x03, _y03],\r\n            [_x12, _y12],\r\n            [_x21, _y21],\r\n            [0, 0] // [0, 0],\r\n        ]\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\r\n * parameter including an error bound (that needs to be multiplied by `9u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x00 = abs(x00);\r\n    const _x10 = abs(x10);\r\n    const _x20 = abs(x20);\r\n    const _x30 = abs(x30);\r\n    const _y00 = abs(y00);\r\n    const _y10 = abs(y10);\r\n    const _y20 = abs(y20);\r\n    const _y30 = abs(y30);\r\n    const _x01 = _x00 + _t * (_x00 + _x10); // <3>x01 = <3>(x00 - <2>(t*<1>(x00 - x10)))\r\n    const _x11 = _x10 + _t * (_x10 + _x20); // <3>x11\r\n    const _x21 = _x20 + _t * (_x20 + _x30); // <3>x21\r\n    const _x02 = _x01 + _t * (_x01 + _x11); // <6>x02 = <6>(x01 - <5>(t*<4>(<3>x01 - <3>x11)))\r\n    const _x12 = _x11 + _t * (_x11 + _x21); // <6>x12\r\n    const _x03 = _x02 + _t * (_x02 + _x12); // <9>x03 = <9>(x02 - <8>(t*<7>(<6>x02 - <6>x12)))\r\n    const _y01 = _y00 + _t * (_y00 + _y10);\r\n    const _y11 = _y10 + _t * (_y10 + _y20);\r\n    const _y21 = _y20 + _t * (_y20 + _y30);\r\n    const _y02 = _y01 + _t * (_y01 + _y11);\r\n    const _y12 = _y11 + _t * (_y11 + _y21);\r\n    const _y03 = _y02 + _t * (_y02 + _y12);\r\n    return {\r\n        ps: [[x00, y00], [x01, y01], [x02, y02], [x03, y03]],\r\n        _ps: [\r\n            // the coordinate-wise error bounds\r\n            [0, 0],\r\n            [_x01, _y01],\r\n            [_x02, _y02],\r\n            [_x03, _y03] // [9*u*_x03, 9*u*_y03]\r\n        ]\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `8u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth3(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2];\r\n    const p3 = ps[3]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    const x3 = p3[0];\r\n    const y3 = p3[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const ttS = tS * tS; // <1>ttS  <= <0>tS<0>tS   (by counter rule 2)\r\n    const tttS = tS * ttS; // <2>tttS <= <0>tS<1>ttS  (again by counter rule 2)\r\n    const ttE = tE * tE; // ...\r\n    const tttE = tE * ttE; // ...\r\n    const tStE = tS * tE; // <1>tStE\r\n    const xA = x0 - x1; // <1>xA\r\n    const xB = x2 - x1; // <1>xB\r\n    const xC = x3 - x0; // <1>xC\r\n    const xD = xA + xB; // <2>xD\r\n    const tSxA = tS * xA; // <2>tSxA\r\n    const tExA = tE * xA; // <2>tExA\r\n    const xC3xB = xC - 3 * xB; // <3>xC3xB = <3>(<1>xC - <2>(3*<1>xB))\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = y3 - y0;\r\n    const yD = yA + yB;\r\n    const tSyA = tS * yA;\r\n    const tEyA = tE * yA;\r\n    const yC3yB = yC - 3 * yB;\r\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\r\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\r\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\r\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\r\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\r\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\r\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\r\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\r\n    // ----------------------------------------------\r\n    // Calculate error bounds\r\n    // ----------------------------------------------\r\n    const _tS = abs(tS);\r\n    const _tE = abs(tE);\r\n    const _tStE = abs(tStE);\r\n    const _tttS = abs(tttS);\r\n    const _tttE = abs(tttE);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _xB = _x2 + _x1;\r\n    const _xD = _xA + _xB;\r\n    const _tSxA = _tS * _xA;\r\n    const _tExA = _tE * _xA;\r\n    const _xC3xB = abs(xC) + 3 * _xB;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    const _yB = _y2 + _y1;\r\n    const _yD = _yA + _yB;\r\n    const _tSyA = _tS * _yA;\r\n    const _tEyA = _tE * _yA;\r\n    const _yC3yB = abs(yC) + 3 * _yB;\r\n    // <8>xx0 = <8>(<6>(<2>tttS*<3>xC3xB) + <7>(<6>(<1>(3*tS)*(<4>(<3>(tS*<2>xD) - <1>xA))) + x0));\r\n    const _xx0 = _tttS * _xC3xB + (3 * _tS * (_tS * _xD + _xA) + _x0);\r\n    // <7>xx1 = <7>(<6>(<1>tStE*<5>(<4>(tS*<3>xC3xB) + <2>(2*xD))) + <6>(<5>(<4>(<1>ttS*<2>xD) + x0) - <3>(<2>tExA + <2>(2*tSxA))));\r\n    const _xx1 = _tStE * (_tS * _xC3xB + 2 * _xD) + ((ttS * _xD + _x0) + (_tExA + 2 * _tSxA));\r\n    // <7>xx2 = <7>(<6>(<1>tStE*<5>(<4>(tE*<3>xC3xB) + <2>(2*xD))) + <6>(<5>(<4>(<1>ttE*<2>xD) + x0) - <3>(<2>(2*tExA) + <2>tSxA)));\r\n    const _xx2 = _tStE * (_tE * _xC3xB + 2 * _xD) + ((ttE * _xD + _x0) + (2 * _tExA + _tSxA));\r\n    // <8>xx3 = <8>(<6>(<2>tttE*<3>xC3xB) + <7>(<6>(<1>(3*tE)*(<4>(<3>(tE*<2>xD) - <1>xA))) + x0));\r\n    const _xx3 = _tttE * _xC3xB + (3 * _tE * (_tE * _xD + _xA) + _x0);\r\n    const _yy0 = _tttS * _yC3yB + (3 * _tS * (_tS * _yD + _yA) + _y0);\r\n    const _yy1 = _tStE * (_tS * _yC3yB + 2 * _yD) + ((ttS * _yD + _y0) + (_tEyA + 2 * _tSyA));\r\n    const _yy2 = _tStE * (_tE * _yC3yB + 2 * _yD) + ((ttE * _yD + _y0) + (2 * _tEyA + _tSyA));\r\n    const _yy3 = _tttE * _yC3yB + (3 * _tE * (_tE * _yD + _yA) + _y0);\r\n    return {\r\n        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]],\r\n        _ps: [\r\n            [_xx0, _yy0],\r\n            [_xx1, _yy1],\r\n            [_xx2, _yy2],\r\n            [_xx3, _yy3] // [8*u*_xx3, 8*u*_yy3]\r\n        ]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=from-to-3-incl-error-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo3: () => (/* binding */ fromTo3)\n/* harmony export */ });\n/**\r\n * Returns a bezier curve that starts and ends at the given t parameters.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo3(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return ps;\r\n        }\r\n        return splitLeft3(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight3(ps, tS);\r\n    }\r\n    return splitAtBoth3(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1`.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    return [[x03, y03], [x12, y12], [x21, y21], [x30, y30]];\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\r\n * parameter.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    return [[x00, y00], [x01, y01], [x02, y02], [x03, y03]];\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth3(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    // --------------------------------------------------------\r\n    const ttS = tS * tS;\r\n    const tttS = tS * ttS;\r\n    const ttE = tE * tE;\r\n    const tttE = tE * ttE;\r\n    const tStE = tS * tE;\r\n    const xA = x0 - x1;\r\n    const xB = x2 - x1;\r\n    const xC = x3 - x0;\r\n    const xD = xA + xB;\r\n    const tSxA = tS * xA;\r\n    const tExA = tE * xA;\r\n    const xC3xB = xC - 3 * xB;\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = y3 - y0;\r\n    const yD = yA + yB;\r\n    const tSyA = tS * yA;\r\n    const tEyA = tE * yA;\r\n    const yC3yB = yC - 3 * yB;\r\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\r\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\r\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\r\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\r\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\r\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\r\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\r\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\r\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]];\r\n}\r\n\r\n//# sourceMappingURL=from-to-3.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-boolean/node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw-fs.js":
/*!***********************************************!*\
  !*** ./node_modules/flo-draw/node/draw-fs.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawFs: () => (/* binding */ drawFs)\n/* harmony export */ });\n/* harmony import */ var _draw_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw/circle.js */ \"./node_modules/flo-draw/node/draw/circle.js\");\n/* harmony import */ var _draw_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw/cross-hair.js */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\n/* harmony import */ var _draw_dot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw/dot.js */ \"./node_modules/flo-draw/node/draw/dot.js\");\n/* harmony import */ var _draw_line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./draw/line.js */ \"./node_modules/flo-draw/node/draw/line.js\");\n/* harmony import */ var _draw_rect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw/rect.js */ \"./node_modules/flo-draw/node/draw/rect.js\");\n/* harmony import */ var _draw_polygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./draw/polygon.js */ \"./node_modules/flo-draw/node/draw/polygon.js\");\n/* harmony import */ var _draw_loop_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./draw/loop.js */ \"./node_modules/flo-draw/node/draw/loop.js\");\n/* harmony import */ var _draw_polyline_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./draw/polyline.js */ \"./node_modules/flo-draw/node/draw/polyline.js\");\n/* harmony import */ var _draw_beziers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./draw/beziers.js */ \"./node_modules/flo-draw/node/draw/beziers.js\");\n/* harmony import */ var _draw_cubic_bezier_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./draw/cubic-bezier.js */ \"./node_modules/flo-draw/node/draw/cubic-bezier.js\");\n/* harmony import */ var _draw_bezier_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./draw/bezier.js */ \"./node_modules/flo-draw/node/draw/bezier.js\");\n/* harmony import */ var _draw_bezier_piece_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./draw/bezier-piece.js */ \"./node_modules/flo-draw/node/draw/bezier-piece.js\");\n/* harmony import */ var _draw_quad_bezier_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./draw/quad-bezier.js */ \"./node_modules/flo-draw/node/draw/quad-bezier.js\");\n/* harmony import */ var _draw_text_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./draw/text.js */ \"./node_modules/flo-draw/node/draw/text.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst drawFs = {\r\n    circle: _draw_circle_js__WEBPACK_IMPORTED_MODULE_0__.circle,\r\n    crossHair: _draw_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__.crossHair,\r\n    dot: _draw_dot_js__WEBPACK_IMPORTED_MODULE_2__.dot,\r\n    line: _draw_line_js__WEBPACK_IMPORTED_MODULE_3__.line,\r\n    rect: _draw_rect_js__WEBPACK_IMPORTED_MODULE_4__.rect,\r\n    beziers: _draw_beziers_js__WEBPACK_IMPORTED_MODULE_5__.beziers,\r\n    bezier: _draw_bezier_js__WEBPACK_IMPORTED_MODULE_6__.bezier,\r\n    bezierPiece: _draw_bezier_piece_js__WEBPACK_IMPORTED_MODULE_7__.bezierPiece,\r\n    quadBezier: _draw_quad_bezier_js__WEBPACK_IMPORTED_MODULE_8__.quadBezier,\r\n    cubicBezier: _draw_cubic_bezier_js__WEBPACK_IMPORTED_MODULE_9__.cubicBezier,\r\n    polygon: _draw_polygon_js__WEBPACK_IMPORTED_MODULE_10__.polygon,\r\n    loop: _draw_loop_js__WEBPACK_IMPORTED_MODULE_11__.loop,\r\n    polyline: _draw_polyline_js__WEBPACK_IMPORTED_MODULE_12__.polyline,\r\n    text: _draw_text_js__WEBPACK_IMPORTED_MODULE_13__.text\r\n};\r\n\r\n//# sourceMappingURL=draw-fs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw-fs.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierFromBezierPiece: () => (/* binding */ bezierFromBezierPiece)\n/* harmony export */ });\n/* harmony import */ var _evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./evaluate-bezier.js */ \"./node_modules/flo-draw/node/draw/evaluate-bezier.js\");\n/* harmony import */ var _split_at_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-at.js */ \"./node_modules/flo-draw/node/draw/split-at.js\");\n\r\n\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Duplicated here so we don't circularly depend on flo-bezier.\r\n *\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * @param ps a bezier\r\n * @param tRange a t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        const p = (0,_evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_0__.evaluateBezier)(ps, tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return (0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)(ps, tRange[1])[0];\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return (0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)(ps, tRange[0])[1];\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return (0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)((0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)(ps, tRange[0])[1], (tRange[1] - tRange[0]) / (1 - tRange[0]))[0];\r\n}\r\n\r\n//# sourceMappingURL=bezier-from-bezier-piece.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier-piece.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier-piece.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierPiece: () => (/* binding */ bezierPiece)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _cross_hair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cross-hair.js */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\n/* harmony import */ var _bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bezier.js */ \"./node_modules/flo-draw/node/draw/bezier.js\");\n/* harmony import */ var _evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./evaluate-bezier.js */ \"./node_modules/flo-draw/node/draw/evaluate-bezier.js\");\n/* harmony import */ var _bezier_from_bezier_piece_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bezier-from-bezier-piece.js */ \"./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Draws a bezier piece, i.e. a bezier within a specified t range.\r\n * @param snap\r\n * @param bezierPiece\r\n * @param class\r\n * @param delay\r\n */\r\nfunction bezierPiece(g, ps_, tRange, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const $elems = (tRange[0] === tRange[1])\r\n        // Draw crosshair if t range bounds are equal.\r\n        ? (0,_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__.crossHair)(g, (0,_evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_2__.evaluateBezier)(ps_, tRange[0]), class_, 1.5)\r\n        : (0,_bezier_js__WEBPACK_IMPORTED_MODULE_3__.bezier)(g, (0,_bezier_from_bezier_piece_js__WEBPACK_IMPORTED_MODULE_4__.bezierFromBezierPiece)(ps_, tRange), class_);\r\n    if (delay) {\r\n        setTimeout(() => $elems.forEach(e => e.remove()), delay);\r\n    }\r\n    return $elems;\r\n}\r\n\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezier: () => (/* binding */ bezier)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line.js */ \"./node_modules/flo-draw/node/draw/line.js\");\n/* harmony import */ var _quad_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quad-bezier.js */ \"./node_modules/flo-draw/node/draw/quad-bezier.js\");\n/* harmony import */ var _cubic_bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubic-bezier.js */ \"./node_modules/flo-draw/node/draw/cubic-bezier.js\");\n\r\n\r\n\r\n\r\nfunction bezier(g, bezier, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    if (bezier.length === 2) {\r\n        return (0,_line_js__WEBPACK_IMPORTED_MODULE_1__.line)(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 3) {\r\n        return (0,_quad_bezier_js__WEBPACK_IMPORTED_MODULE_2__.quadBezier)(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 4) {\r\n        return (0,_cubic_bezier_js__WEBPACK_IMPORTED_MODULE_3__.cubicBezier)(g, bezier, class_, delay);\r\n    }\r\n    return [];\r\n}\r\n\r\n//# sourceMappingURL=bezier.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/beziers.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/beziers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beziers: () => (/* binding */ beziers)\n/* harmony export */ });\n/* harmony import */ var _bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier.js */ \"./node_modules/flo-draw/node/draw/bezier.js\");\n\r\nconst COLORS = ['red', 'green', 'cyan', 'blue'];\r\n/**\r\n * Draws beziers.\r\n * @param snap\r\n * @param beziers\r\n * @param delay\r\n */\r\nfunction beziers(g, beziers, classes, delay) {\r\n    const alternateColors = classes === undefined;\r\n    const $beziers = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        const ps = beziers[i];\r\n        const color = COLORS[i % COLORS.length];\r\n        const class_ = alternateColors\r\n            ? 'thin5 nofill ' + color\r\n            : classes;\r\n        $beziers.push(...(0,_bezier_js__WEBPACK_IMPORTED_MODULE_0__.bezier)(g, ps, class_));\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $beziers.forEach(e => e.remove()), delay);\r\n    }\r\n    return $beziers;\r\n}\r\n\r\n//# sourceMappingURL=beziers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/beziers.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/circle.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/circle.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circle: () => (/* binding */ circle)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\n/**\r\n * Draws a circle\r\n * @param g An SVG group element wherein to draw the circle.\r\n * @param circle\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction circle(g, circle, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const c = circle.center;\r\n    const r = circle.radius;\r\n    const $circle = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", c[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", c[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", r.toString());\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    if (delay) {\r\n        setTimeout(() => $circle.remove(), delay);\r\n    }\r\n    return [$circle];\r\n}\r\n\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/circle.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/cross-hair.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/cross-hair.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crossHair: () => (/* binding */ crossHair)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./circle.js */ \"./node_modules/flo-draw/node/draw/circle.js\");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.js */ \"./node_modules/flo-draw/node/draw/line.js\");\n\r\n\r\n\r\n/**\r\n * Draws a crosshair.\r\n */\r\nfunction crossHair(g, p, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, r = 3, delay) {\r\n    const circle_ = { center: p, radius: r };\r\n    const $circle = (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circle)(g, circle_, classes);\r\n    const l1 = [[p[0] - r, p[1]], [p[0] + r, p[1]]];\r\n    const l2 = [[p[0], p[1] - r], [p[0], p[1] + r]];\r\n    const $l1 = (0,_line_js__WEBPACK_IMPORTED_MODULE_2__.line)(g, l1, classes);\r\n    const $l2 = (0,_line_js__WEBPACK_IMPORTED_MODULE_2__.line)(g, l2, classes);\r\n    if (delay) {\r\n        setTimeout(() => {\r\n            $circle.forEach(e => e.remove());\r\n            $l1.forEach(e => e.remove());\r\n            $l2.forEach(e => e.remove());\r\n        }, delay);\r\n    }\r\n    return [...$circle, ...$l1, ...$l2];\r\n}\r\n\r\n//# sourceMappingURL=cross-hair.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/cross-hair.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/cubic-bezier.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/cubic-bezier.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cubicBezier: () => (/* binding */ cubicBezier)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n/* harmony import */ var _cross_hair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cross-hair.js */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\n\r\n\r\n\r\nfunction cubicBezier(g, bezier, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = bezier;\r\n    if (x0 === x3 && x1 === x3 && x2 === x3 &&\r\n        y0 === y3 && y1 === y3 && y2 === y3) {\r\n        return (0,_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__.crossHair)(g, [x0, y0], class_, 0.2, delay);\r\n    }\r\n    const $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_2__.XMLNS, 'path');\r\n    $path.setAttributeNS(null, \"d\", `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`);\r\n    $path.setAttributeNS(null, \"class\", class_);\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=cubic-bezier.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/cubic-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/default-class.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/default-class.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CLASS: () => (/* binding */ DEFAULT_CLASS)\n/* harmony export */ });\nconst DEFAULT_CLASS = 'red thin10 nofill ';\r\n\r\n//# sourceMappingURL=default-class.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/default-class.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/dot.js":
/*!************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/dot.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dot: () => (/* binding */ dot)\n/* harmony export */ });\n/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circle.js */ \"./node_modules/flo-draw/node/draw/circle.js\");\n\r\n/**\r\n * Draws a dot.\r\n */\r\nfunction dot(g, p, r = 3, color = 'red', delay) {\r\n    const [$dot] = (0,_circle_js__WEBPACK_IMPORTED_MODULE_0__.circle)(g, { center: p, radius: r }, 'dot ' + color, delay);\r\n    if (delay) {\r\n        setTimeout(() => $dot.remove(), delay);\r\n    }\r\n    return [$dot];\r\n}\r\n\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/dot.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/evaluate-bezier.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/evaluate-bezier.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateBezier: () => (/* binding */ evaluateBezier)\n/* harmony export */ });\n/**\r\n * Returns an estimate of evaluating the given bezier at the given t value.\r\n * @param ps An order 1, 2 or bezier\r\n * @param t The parameter ∈ [0,1]\r\n */\r\nfunction evaluateBezier(ps, t) {\r\n    const s = 1 - t;\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const x = x0 * s ** 3 + 3 * x1 * s ** 2 * t + 3 * x2 * s * t ** 2 + x3 * t ** 3;\r\n        const y = y0 * s ** 3 + 3 * y1 * s ** 2 * t + 3 * y2 * s * t ** 2 + y3 * t ** 3;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const x = x0 * s ** 2 + 2 * x1 * s * t + x2 * t ** 2;\r\n        const y = y0 * s ** 2 + 2 * y1 * s * t + y2 * t ** 2;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const x = x0 * s + x1 * t;\r\n        const y = y0 * s + y1 * t;\r\n        return [x, y];\r\n    }\r\n    return [NaN, NaN];\r\n}\r\n\r\n//# sourceMappingURL=evaluate-bezier.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/evaluate-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/line.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/line.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   line: () => (/* binding */ line)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\n/**\r\n *\r\n * @param snap\r\n * @param l\r\n * @param classes\r\n */\r\nfunction line(g, l, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const $line = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'line');\r\n    $line.setAttributeNS(null, \"x1\", l[0][0].toString());\r\n    $line.setAttributeNS(null, \"y1\", l[0][1].toString());\r\n    $line.setAttributeNS(null, \"x2\", l[1][0].toString());\r\n    $line.setAttributeNS(null, \"y2\", l[1][1].toString());\r\n    $line.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($line);\r\n    if (delay) {\r\n        setTimeout(() => $line.remove(), delay);\r\n    }\r\n    return [$line];\r\n}\r\n\r\n//# sourceMappingURL=line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/line.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/loop.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/loop.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loop: () => (/* binding */ loop)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\nfunction loop(g, curves, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    if (!curves.length) {\r\n        return [];\r\n    }\r\n    const $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'path');\r\n    let d = `M${curves[0][0][0]} ${curves[0][0][1]} `;\r\n    for (let i = 0; i < curves.length; i++) {\r\n        const curve = curves[i];\r\n        d += `${getType(curve.length)} `;\r\n        for (let j = 1; j < curve.length; j++) {\r\n            d += `${curve[j][0]} ${curve[j][1]} `;\r\n        }\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nfunction getType(len) {\r\n    if (len === 2) {\r\n        return 'L';\r\n    }\r\n    if (len === 3) {\r\n        return 'Q';\r\n    }\r\n    if (len === 4) {\r\n        return 'C';\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/loop.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/polygon.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/polygon.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polygon: () => (/* binding */ polygon)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\n/**\r\n * Draws a polygon\r\n * @param g\r\n * @param poly the polygon specified as an array of points - the last point does\r\n * not have to be specified\r\n * @param class_\r\n * @param delay\r\n */\r\nfunction polygon(g, poly, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'path');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=polygon.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/polygon.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/polyline.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/polyline.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyline: () => (/* binding */ polyline)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\nfunction polyline(g, poly, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    if (poly.length < 2) {\r\n        return [];\r\n    }\r\n    const $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'path');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=polyline.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/polyline.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/quad-bezier.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/quad-bezier.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   quadBezier: () => (/* binding */ quadBezier)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\nfunction quadBezier(g, ps, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'path');\r\n    $path.setAttributeNS(null, \"d\", `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=quad-bezier.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/quad-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/rect.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/rect.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rect: () => (/* binding */ rect)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\nfunction rect(g, rect, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const [[x0, y0], [x1, y1]] = rect;\r\n    const x = x0 < x1 ? x0 : x1;\r\n    const y = y0 < y1 ? y0 : y1;\r\n    const width = Math.abs(x0 - x1);\r\n    const height = Math.abs(y0 - y1);\r\n    const $rect = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'rect');\r\n    $rect.setAttributeNS(null, \"x\", x.toString());\r\n    $rect.setAttributeNS(null, \"y\", y.toString());\r\n    $rect.setAttributeNS(null, \"width\", width.toString());\r\n    $rect.setAttributeNS(null, \"height\", height.toString());\r\n    if (classes) {\r\n        $rect.setAttributeNS(null, \"class\", classes);\r\n    }\r\n    g.appendChild($rect);\r\n    if (delay) {\r\n        setTimeout(() => $rect.remove(), delay);\r\n    }\r\n    return [$rect];\r\n}\r\n\r\n//# sourceMappingURL=rect.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/rect.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/split-at.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/split-at.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitAt: () => (/* binding */ splitAt)\n/* harmony export */ });\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitAt(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAt(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAt(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAt(ps, t);\r\n    }\r\n    return [];\r\n}\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const s = 1 - t;\r\n    const t2 = t * t;\r\n    const t3 = t2 * t;\r\n    const s2 = s * s;\r\n    const s3 = s2 * s;\r\n    /** The split point */\r\n    const p = [\r\n        t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n        t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0\r\n    ];\r\n    const ps1 = [\r\n        [x0, y0],\r\n        [t * x1 + s * x0,\r\n            t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0,\r\n            t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        p\r\n    ];\r\n    const ps2 = [\r\n        p,\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1,\r\n            t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2,\r\n            t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const s = 1 - t;\r\n    /** The split point */\r\n    const p = [\r\n        s * s * x0 + 2 * s * t * x1 + t * t * x2,\r\n        s * s * y0 + 2 * s * t * y1 + t * t * y2\r\n    ];\r\n    const ps1 = [\r\n        [x0, y0],\r\n        [s * x0 + t * x1,\r\n            s * y0 + t * y1],\r\n        p\r\n    ];\r\n    const ps2 = [\r\n        p,\r\n        [s * x1 + t * x2,\r\n            s * y1 + t * y2],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const s = 1 - t;\r\n    /** The split point */\r\n    const p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    const ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    const ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/split-at.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/text.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/text.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   text: () => (/* binding */ text)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\n/**\r\n * Draws text\r\n * @param g a SVG group element wherein to draw\r\n * @param p\r\n * @param str\r\n * @param fontSize\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction text(g, p, str, fontSize, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    const $text = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'text');\r\n    $text.setAttributeNS(null, \"x\", p[0].toString());\r\n    $text.setAttributeNS(null, \"y\", p[1].toString());\r\n    $text.setAttributeNS(null, \"font-size\", fontSize.toString());\r\n    $text.setAttributeNS(null, \"class\", classes);\r\n    $text.textContent = str;\r\n    g.appendChild($text);\r\n    if (delay) {\r\n        setTimeout(() => $text.remove(), delay);\r\n    }\r\n    return [$text];\r\n}\r\n\r\n//# sourceMappingURL=text.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/text.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/xmlns.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/xmlns.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XMLNS: () => (/* binding */ XMLNS)\n/* harmony export */ });\nconst XMLNS = 'http://www.w3.org/2000/svg';\r\n\r\n//# sourceMappingURL=xmlns.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-draw/node/draw/xmlns.js?");

/***/ }),

/***/ "./node_modules/flo-gauss-quadrature/node/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-gauss-quadrature/node/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gaussQuadrature: () => (/* binding */ gaussQuadrature)\n/* harmony export */ });\n// TODO A future improvement can be to use the Gauss–Kronrod rules\r\n// to estimate the error and thus choose a number of constants based\r\n// on the error. Maybe not.\r\n// TODO In future, the constants can be calculated and cached so we can\r\n// choose any value for the order.\r\n// TODO - to limit rounding error do pairwise addition of terms\r\n// TODO order abscissas\r\n// TODO - auto calc abscissas and weights (on first call to function only)\r\n/**\r\n * Numerically integrates the given function using the Gaussian Quadrature\r\n * method.\r\n *\r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * @param f The univariate function to be integrated\r\n * @param interval The integration interval\r\n * @param order Can be 2, 4, 8, or 16. Higher values give more accurate results\r\n * but is slower - defaults to 16.\r\n */\r\nfunction gaussQuadrature(f, interval, order = 16) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    const { weights, abscissas } = GAUSS_CONSTANTS[order];\r\n    const [a, b] = interval;\r\n    let result = 0;\r\n    const m1 = (b - a) / 2;\r\n    const m2 = (b + a) / 2;\r\n    for (let i = 0; i <= order - 1; i++) {\r\n        result += weights[i] * f(m1 * abscissas[i] + m2);\r\n    }\r\n    return m1 * result;\r\n}\r\n// The Gaussian Legendre Quadrature method constants. \r\nconst GAUSS_CONSTANTS = {\r\n    2: {\r\n        weights: [1, 1],\r\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\r\n    },\r\n    4: {\r\n        weights: [\r\n            0.6521451548625461, 0.6521451548625461,\r\n            0.3478548451374538, 0.3478548451374538\r\n        ],\r\n        abscissas: [\r\n            -0.3399810435848563, 0.3399810435848563,\r\n            -0.8611363115940526, 0.8611363115940526\r\n        ]\r\n    },\r\n    8: {\r\n        weights: [\r\n            0.3626837833783620, 0.3626837833783620,\r\n            0.3137066458778873, 0.3137066458778873,\r\n            0.2223810344533745, 0.2223810344533745,\r\n            0.1012285362903763, 0.1012285362903763\r\n        ],\r\n        abscissas: [\r\n            -0.1834346424956498, 0.1834346424956498,\r\n            -0.5255324099163290, 0.5255324099163290,\r\n            -0.7966664774136267, 0.7966664774136267,\r\n            -0.9602898564975363, 0.9602898564975363\r\n        ]\r\n    },\r\n    // Taken from http://keisan.casio.com/exec/system/1330940731\r\n    16: {\r\n        weights: [\r\n            0.0271524594117540948518,\r\n            0.062253523938647892863,\r\n            0.0951585116824927848099,\r\n            0.1246289712555338720525,\r\n            0.1495959888165767320815,\r\n            0.169156519395002538189,\r\n            0.182603415044923588867,\r\n            0.189450610455068496285,\r\n            0.1894506104550684962854,\r\n            0.182603415044923588867,\r\n            0.1691565193950025381893,\r\n            0.149595988816576732081,\r\n            0.124628971255533872053,\r\n            0.095158511682492784809,\r\n            0.062253523938647892863,\r\n            0.027152459411754094852\r\n        ],\r\n        abscissas: [\r\n            -0.989400934991649932596,\r\n            -0.944575023073232576078,\r\n            -0.86563120238783174388,\r\n            -0.7554044083550030338951,\r\n            -0.6178762444026437484467,\r\n            -0.4580167776572273863424,\r\n            -0.28160355077925891323,\r\n            -0.0950125098376374401853,\r\n            0.0950125098376374401853,\r\n            0.28160355077925891323,\r\n            0.4580167776572273863424,\r\n            0.617876244402643748447,\r\n            0.755404408355003033895,\r\n            0.8656312023878317438805,\r\n            0.944575023073232576078,\r\n            0.989400934991649932596\r\n        ],\r\n    },\r\n    64: {\r\n        weights: [\r\n            0.048690957009139724,\r\n            0.048690957009139724,\r\n            0.04857546744150343,\r\n            0.04857546744150343,\r\n            0.048344762234802954,\r\n            0.048344762234802954,\r\n            0.04799938859645831,\r\n            0.04799938859645831,\r\n            0.04754016571483031,\r\n            0.04754016571483031,\r\n            0.04696818281621002,\r\n            0.04696818281621002,\r\n            0.046284796581314416,\r\n            0.046284796581314416,\r\n            0.04549162792741814,\r\n            0.04549162792741814,\r\n            0.044590558163756566,\r\n            0.044590558163756566,\r\n            0.04358372452932345,\r\n            0.04358372452932345,\r\n            0.04247351512365359,\r\n            0.04247351512365359,\r\n            0.04126256324262353,\r\n            0.04126256324262353,\r\n            0.03995374113272034,\r\n            0.03995374113272034,\r\n            0.038550153178615626,\r\n            0.038550153178615626,\r\n            0.03705512854024005,\r\n            0.03705512854024005,\r\n            0.035472213256882386,\r\n            0.035472213256882386,\r\n            0.033805161837141606,\r\n            0.033805161837141606,\r\n            0.03205792835485155,\r\n            0.03205792835485155,\r\n            0.030234657072402478,\r\n            0.030234657072402478,\r\n            0.028339672614259483,\r\n            0.028339672614259483,\r\n            0.02637746971505466,\r\n            0.02637746971505466,\r\n            0.024352702568710874,\r\n            0.024352702568710874,\r\n            0.022270173808383253,\r\n            0.022270173808383253,\r\n            0.02013482315353021,\r\n            0.02013482315353021,\r\n            0.017951715775697343,\r\n            0.017951715775697343,\r\n            0.015726030476024718,\r\n            0.015726030476024718,\r\n            0.013463047896718643,\r\n            0.013463047896718643,\r\n            0.011168139460131128,\r\n            0.011168139460131128,\r\n            0.008846759826363947,\r\n            0.008846759826363947,\r\n            0.006504457968978363,\r\n            0.006504457968978363,\r\n            0.004147033260562468,\r\n            0.004147033260562468,\r\n            0.001783280721696433,\r\n            0.001783280721696433\r\n        ],\r\n        abscissas: [\r\n            -0.024350292663424433,\r\n            0.024350292663424433,\r\n            -0.07299312178779904,\r\n            0.07299312178779904,\r\n            -0.12146281929612056,\r\n            0.12146281929612056,\r\n            -0.16964442042399283,\r\n            0.16964442042399283,\r\n            -0.21742364374000708,\r\n            0.21742364374000708,\r\n            -0.2646871622087674,\r\n            0.2646871622087674,\r\n            -0.31132287199021097,\r\n            0.31132287199021097,\r\n            -0.3572201583376681,\r\n            0.3572201583376681,\r\n            -0.4022701579639916,\r\n            0.4022701579639916,\r\n            -0.4463660172534641,\r\n            0.4463660172534641,\r\n            -0.48940314570705296,\r\n            0.48940314570705296,\r\n            -0.5312794640198946,\r\n            0.5312794640198946,\r\n            -0.571895646202634,\r\n            0.571895646202634,\r\n            -0.6111553551723933,\r\n            0.6111553551723933,\r\n            -0.6489654712546573,\r\n            0.6489654712546573,\r\n            -0.6852363130542333,\r\n            0.6852363130542333,\r\n            -0.7198818501716109,\r\n            0.7198818501716109,\r\n            -0.7528199072605319,\r\n            0.7528199072605319,\r\n            -0.7839723589433414,\r\n            0.7839723589433414,\r\n            -0.8132653151227975,\r\n            0.8132653151227975,\r\n            -0.8406292962525803,\r\n            0.8406292962525803,\r\n            -0.8659993981540928,\r\n            0.8659993981540928,\r\n            -0.8893154459951141,\r\n            0.8893154459951141,\r\n            -0.9105221370785028,\r\n            0.9105221370785028,\r\n            -0.9295691721319396,\r\n            0.9295691721319396,\r\n            -0.9464113748584028,\r\n            0.9464113748584028,\r\n            -0.9610087996520538,\r\n            0.9610087996520538,\r\n            -0.973326827789911,\r\n            0.973326827789911,\r\n            -0.983336253884626,\r\n            0.983336253884626,\r\n            -0.9910133714767443,\r\n            0.9910133714767443,\r\n            -0.9963401167719553,\r\n            0.9963401167719553,\r\n            -0.9993050417357722,\r\n            0.9993050417357722\r\n        ]\r\n    }\r\n};\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-gauss-quadrature/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSmallestIndxYThenX: () => (/* binding */ getSmallestIndxYThenX)\n/* harmony export */ });\n/**\r\n * @internal\r\n */\r\nfunction getSmallestIndxYThenX(ps) {\r\n    let smallest = [\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY\r\n    ];\r\n    let smallestI = undefined;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        const y = ps[i][1];\r\n        if ((y < smallest[1]) ||\r\n            (y === smallest[1] && ps[i][0] < smallest[0])) {\r\n            smallestI = i;\r\n            smallest = ps[i];\r\n        }\r\n    }\r\n    return smallestI;\r\n}\r\n\r\n//# sourceMappingURL=get-smallest-indx-y-then-x.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/index.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   grahamScan: () => (/* binding */ grahamScan)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js\");\n/* harmony import */ var _get_smallest_indx_y_then_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-smallest-indx-y-then-x.js */ \"./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js\");\n/* harmony import */ var _swap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./swap.js */ \"./node_modules/flo-graham-scan/node/swap.js\");\n\r\n\r\n\r\n/**\r\n * Finds the convex hull of the given set of 2d points using the\r\n * Graham Scan algorithm and returns the hull as an array of points.\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n *\r\n * Robust: This algorithm is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n *\r\n * @param ps A set of points\r\n * @param includeAllBoundaryPoints Set this to true to if all boundary points\r\n * should be returned, even redundant ones - defaults to `false`\r\n */\r\nfunction grahamScan(ps, includeAllBoundaryPoints = false) {\r\n    if (!ps.length) {\r\n        return undefined;\r\n    }\r\n    function fail(p1, p2, p3) {\r\n        const res = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(p1, p2, p3);\r\n        return includeAllBoundaryPoints\r\n            ? res < 0\r\n            : res <= 0;\r\n    }\r\n    const ps_ = ps.slice();\r\n    const n = ps_.length;\r\n    const idx = (0,_get_smallest_indx_y_then_x_js__WEBPACK_IMPORTED_MODULE_1__.getSmallestIndxYThenX)(ps_);\r\n    const [p] = ps_.splice(idx, 1);\r\n    ps_.sort((a, b) => {\r\n        let res = -(0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(p, a, b);\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        res = a[1] - b[1];\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        return a[0] - b[0];\r\n    });\r\n    ps_.unshift(p);\r\n    let m = 1;\r\n    for (let i = 2; i < n; i++) {\r\n        while (fail(ps_[m - 1], ps_[m], ps_[i])) {\r\n            if (m > 1) {\r\n                m -= 1;\r\n                continue;\r\n            }\r\n            else if (i === n - 1) {\r\n                m -= 1;\r\n                break;\r\n            }\r\n            else {\r\n                i += 1;\r\n            }\r\n        }\r\n        m += 1;\r\n        (0,_swap_js__WEBPACK_IMPORTED_MODULE_2__.swap)(ps_, m, i);\r\n    }\r\n    return ps_.slice(0, m + 1);\r\n}\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-graham-scan/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/swap.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/swap.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   swap: () => (/* binding */ swap)\n/* harmony export */ });\n/**\r\n * In-place swap two elements in the given array.\r\n *\r\n * @internal\r\n */\r\nfunction swap(arr, a, b) {\r\n    if (a === b) {\r\n        return;\r\n    }\r\n    const temp = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = temp;\r\n}\r\n\r\n//# sourceMappingURL=swap.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-graham-scan/node/swap.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/tree.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/tree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   LEFT: () => (/* binding */ LEFT),\n/* harmony export */   LlRbTree: () => (/* binding */ LlRbTree),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   RED: () => (/* binding */ RED),\n/* harmony export */   RIGHT: () => (/* binding */ RIGHT),\n/* harmony export */   isRed: () => (/* binding */ isRed)\n/* harmony export */ });\n// Concise, Destructive, Left Leaning Red Black Tree implementation.\r\n// See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\r\n// See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\r\n// See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html \r\nconst LEFT = -1;\r\nconst RIGHT = 1;\r\nconst BLACK = 1;\r\nconst RED = 0;\r\n/**\r\n * Red Black Tree node.\r\n */\r\nclass Node {\r\n    constructor(datum) {\r\n        this.datum = datum;\r\n        this.color = RED;\r\n    }\r\n}\r\nfunction isRed(node) {\r\n    return !!node && node.color === RED;\r\n}\r\nclass LlRbTree {\r\n    /**\r\n     * @param compare a comparator function\r\n     * @param duplicatesAllowed defaults to `true`; if `false` then if a\r\n     * duplicate is inserted (as per the equivalence relation induced by the\r\n     * compare function) then replace it; if `true` then instead still insert\r\n     * it (so there can be multiple nodes with the same value in the tree)\r\n     * @param data an optional initial array of data\r\n     */\r\n    constructor(compare, duplicatesAllowed = true, data) {\r\n        this.compare = compare;\r\n        this.duplicatesAllowed = duplicatesAllowed;\r\n        // eslint-disable-next-line\r\n        this.getMinNode = this.getMinOrMaxNode(LEFT);\r\n        // eslint-disable-next-line\r\n        this.getMaxNode = this.getMinOrMaxNode(RIGHT);\r\n        this.root = undefined;\r\n        this.nodeCount = 0;\r\n        this.valueCount = 0;\r\n        if (!data) {\r\n            return;\r\n        }\r\n        for (const datum of data) {\r\n            this.insert(datum);\r\n        }\r\n    }\r\n    isEmpty() { return !this.root; }\r\n    /**\r\n     * Find and returns the (first) node in the tree with the given datum using\r\n     * the tree compare function. Returns `undefined` if the node was not found.\r\n     */\r\n    find(datum) {\r\n        const tree = this;\r\n        let node = this.root;\r\n        while (node) {\r\n            const c = tree.compare(datum, node.datum);\r\n            if (c === 0) {\r\n                return node;\r\n            }\r\n            node = node[c > 0 ? RIGHT : LEFT];\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Returns an ordered (by the tree compare function) array of data as\r\n     * contained in the nodes of the tree by doing an in order traversal.\r\n     */\r\n    toArrayInOrder() {\r\n        const values = [];\r\n        f(this.root);\r\n        function f(node) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            f(node[LEFT]);\r\n            values.push(node.datum);\r\n            if (node.extras !== undefined) {\r\n                values.push(...node.extras);\r\n            }\r\n            f(node[RIGHT]);\r\n        }\r\n        return values;\r\n    }\r\n    insertMulti(data) {\r\n        const tree = this;\r\n        for (const datum of data) {\r\n            tree.insert(datum);\r\n        }\r\n    }\r\n    /**\r\n     * Inserts a node with the given datum into the tree.\r\n     */\r\n    insert(datum) {\r\n        const tree = this;\r\n        tree.root = f(tree.root, datum);\r\n        tree.root.color = BLACK;\r\n        tree.root.parent = undefined;\r\n        function f(h, datum) {\r\n            if (h === undefined) {\r\n                tree.valueCount++;\r\n                tree.nodeCount++;\r\n                return new Node(datum);\r\n            }\r\n            const c = tree.compare(datum, h.datum);\r\n            if (c === 0) {\r\n                if (tree.duplicatesAllowed) {\r\n                    tree.valueCount++;\r\n                    if (h.extras === undefined) {\r\n                        h.extras = [datum];\r\n                    }\r\n                    else {\r\n                        h.extras.push(datum);\r\n                    }\r\n                }\r\n                else {\r\n                    h.datum = datum; // replace old value\r\n                }\r\n            }\r\n            if (c !== 0) {\r\n                const dir = c > 0 ? RIGHT : LEFT;\r\n                h[dir] = f(h[dir], datum);\r\n                h[dir].parent = h;\r\n            }\r\n            if (isRed(h[RIGHT]) && !isRed(h[LEFT])) {\r\n                h = rotate(LEFT, h);\r\n            }\r\n            if (isRed(h[LEFT]) && isRed(h[LEFT][LEFT])) {\r\n                h = rotate(RIGHT, h);\r\n            }\r\n            if (isRed(h[LEFT]) && isRed(h[RIGHT])) {\r\n                flipColors(h);\r\n            }\r\n            return h;\r\n        }\r\n    }\r\n    /**\r\n     * Removes an item from the tree based on the given datum and returns the\r\n     * item that was removed or `undefined` if nothing was removed.\r\n     *\r\n     * @param datum\r\n     * @param all defaults to `false`; if `true` and duplicates exist, remove all\r\n     * @param compareStrict if provided then only delete an item if it passes the\r\n     * strict comparison function, i.e. if `compareStrict(item,node_value) === true`.\r\n     */\r\n    remove(datum, all = false, compareStrict) {\r\n        const tree = this;\r\n        if (tree.root === undefined) {\r\n            return undefined;\r\n        }\r\n        let removed = undefined;\r\n        const root = f(tree.root, datum);\r\n        if (root === null) {\r\n            return undefined;\r\n        }\r\n        tree.root = root;\r\n        if (tree.root !== undefined) {\r\n            tree.root.color = BLACK;\r\n            tree.root.parent = undefined;\r\n        }\r\n        return removed;\r\n        function f(h, datum) {\r\n            const theresExtras = tree.duplicatesAllowed && h.extras !== undefined;\r\n            let c = tree.compare(datum, h.datum);\r\n            if ((c < 0 && !h[LEFT]) || (c > 0 && !h[RIGHT])) {\r\n                return h; // end reached - no match\r\n            }\r\n            if (c < 0) {\r\n                if (!isRed(h[LEFT]) &&\r\n                    !isRed(h[LEFT][LEFT])) {\r\n                    h = moveRedLeft(h);\r\n                }\r\n                const g = f(h[LEFT], datum);\r\n                if (g === null) {\r\n                    return null;\r\n                }\r\n                h[LEFT] = g;\r\n                if (h[LEFT]) {\r\n                    h[LEFT].parent = h;\r\n                }\r\n                return fixUp(h);\r\n            }\r\n            if (isRed(h[LEFT])) {\r\n                h = rotate(RIGHT, h);\r\n                c = tree.compare(datum, h.datum);\r\n            }\r\n            if (c === 0 && !h[RIGHT]) {\r\n                if (theresExtras && !all) {\r\n                    // There are multiple items at this node.\r\n                    if (compareStrict === undefined ||\r\n                        (compareStrict(datum, h.datum) === true)) {\r\n                        removed = h.datum;\r\n                        h.datum = h.extras.pop();\r\n                        tree.valueCount--;\r\n                        if (h.extras.length === 0) {\r\n                            h.extras = undefined;\r\n                        }\r\n                        return h;\r\n                    }\r\n                    else {\r\n                        const extras = h.extras;\r\n                        for (let i = 0; i < extras.length; i++) {\r\n                            if (compareStrict(datum, extras[i]) === true) {\r\n                                removed = extras.splice(i, 1)[0];\r\n                                tree.valueCount--;\r\n                                if (extras.length === 0) {\r\n                                    h.extras = undefined;\r\n                                }\r\n                                return h;\r\n                            }\r\n                        }\r\n                        return null;\r\n                    }\r\n                }\r\n                if (compareStrict === undefined ||\r\n                    (compareStrict(datum, h.datum) === true)) {\r\n                    removed = h.datum;\r\n                    tree.valueCount -= 1 + (theresExtras ? h.extras.length : 0);\r\n                    tree.nodeCount--;\r\n                    return undefined;\r\n                }\r\n                else {\r\n                    return null; // no match\r\n                }\r\n            }\r\n            if (!isRed(h[RIGHT]) &&\r\n                !isRed(h[RIGHT][LEFT])) {\r\n                h = moveRedRight(h);\r\n                c = tree.compare(datum, h.datum);\r\n            }\r\n            if (c === 0) {\r\n                if (theresExtras && !all) {\r\n                    // There are multiple items at this node.\r\n                    if (compareStrict === undefined ||\r\n                        (compareStrict(datum, h.datum) === true)) {\r\n                        removed = h.datum;\r\n                        h.datum = h.extras.pop();\r\n                        tree.valueCount--;\r\n                        if (h.extras.length === 0) {\r\n                            h.extras = undefined;\r\n                        }\r\n                        //// const g = f(h[RIGHT]!, datum);\r\n                        // if (g === null) { return null; }\r\n                        //// h[RIGHT] = g!;\r\n                    }\r\n                    else {\r\n                        const extras = h.extras;\r\n                        let found = false;\r\n                        for (let i = 0; i < extras.length; i++) {\r\n                            if (compareStrict(datum, extras[i]) === true) {\r\n                                removed = extras.splice(i, 1)[0];\r\n                                tree.valueCount--;\r\n                                if (extras.length === 0) {\r\n                                    h.extras = undefined;\r\n                                }\r\n                                //// const g = f(h[RIGHT]!, extras[i]);\r\n                                // if (g === null) { return null; }\r\n                                //// h[RIGHT] = g!;\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (compareStrict === undefined ||\r\n                        (compareStrict(datum, h.datum) === true)) {\r\n                        tree.valueCount -= 1 + (theresExtras ? h.extras.length : 0);\r\n                        removed = h.datum;\r\n                        const minNode = tree.getMinNode(h[RIGHT]);\r\n                        // eslint-disable-next-line\r\n                        h.datum = minNode?.datum;\r\n                        // eslint-disable-next-line\r\n                        if (tree.duplicatesAllowed) {\r\n                            h.extras = minNode?.extras;\r\n                        }\r\n                        h[RIGHT] = removeMin(h[RIGHT]);\r\n                        tree.nodeCount--;\r\n                    }\r\n                    else {\r\n                        return null; // no match\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const g = f(h[RIGHT], datum);\r\n                if (g === null) {\r\n                    return null;\r\n                }\r\n                h[RIGHT] = g;\r\n            }\r\n            if (h[RIGHT]) {\r\n                h[RIGHT].parent = h;\r\n            }\r\n            return fixUp(h);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the two ordered nodes bounding the datum.\r\n     *\r\n     * * If the datum falls on a node, that node and the next (to the right) is\r\n     * returned.\r\n     * * If the given datum is smaller than all nodes then the first item in the\r\n     * bounds array is `undefined` and the next is the smallest node\r\n     * * If the given datum is larger than all nodes then the second item in the\r\n     * bounds array is `undefined` and the first item is the largest node\r\n     *\r\n     */\r\n    findBounds(datum) {\r\n        const tree = this;\r\n        let node = tree.root;\r\n        const bounds = [undefined, undefined];\r\n        if (node === undefined) {\r\n            return bounds;\r\n        }\r\n        while (node) {\r\n            const c = tree.compare(datum, node.datum);\r\n            if (c >= 0) {\r\n                bounds[0] = node;\r\n            }\r\n            else {\r\n                bounds[1] = node;\r\n            }\r\n            node = node[c >= 0 ? RIGHT : LEFT];\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Returns the two ordered nodes bounding the datum.\r\n     *\r\n     * * If the datum falls on a node, returns the nodes before and after this\r\n     * one.\r\n     * * If the given datum is smaller than all nodes then the first item in the\r\n     * bounds array is `undefined` and the next is the smallest node\r\n     * * If the given datum is larger than all nodes then the second item in the\r\n     * bounds array is `undefined` and the first item is the largest node\r\n     *\r\n     * @param tree\r\n     * @param datum\r\n     */\r\n    findBoundsExcl(datum) {\r\n        const tree = this;\r\n        const node = tree.root;\r\n        const bounds = [undefined, undefined];\r\n        if (node === undefined) {\r\n            return bounds;\r\n        }\r\n        f(node);\r\n        function f(node) {\r\n            while (node) {\r\n                const c = tree.compare(datum, node.datum);\r\n                if (c === 0) {\r\n                    // Search on both sides\r\n                    f(node[LEFT]);\r\n                    f(node[RIGHT]);\r\n                    return;\r\n                }\r\n                if (c > 0) {\r\n                    bounds[0] = node;\r\n                }\r\n                else if (c < 0) {\r\n                    bounds[1] = node;\r\n                }\r\n                node = node[c > 0 ? RIGHT : LEFT];\r\n            }\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Returns an array of all matching data found.\r\n     *\r\n     * If duplicates are not allowed it's better to just use `find`.\r\n     *\r\n     * @param datum\r\n     */\r\n    findAll(datum) {\r\n        const tree = this;\r\n        let node = this.root;\r\n        while (node) {\r\n            const c = tree.compare(datum, node.datum);\r\n            if (c === 0) {\r\n                return [\r\n                    node.datum,\r\n                    ...(node.extras ? node.extras : [])\r\n                ];\r\n            }\r\n            node = node[c > 0 ? RIGHT : LEFT];\r\n        }\r\n        return [];\r\n    }\r\n    /** @internal */\r\n    getMinOrMaxNode(dir) {\r\n        return (node) => {\r\n            if (node === undefined) {\r\n                node = this.root;\r\n            }\r\n            if (!node) {\r\n                return undefined;\r\n            }\r\n            while (node[dir]) {\r\n                node = node[dir];\r\n            }\r\n            return node;\r\n        };\r\n    }\r\n    /**\r\n     * Returns the minimum value in the tree starting at the given node. If the\r\n     * tree is empty, `undefined` will be returned.\r\n     *\r\n     * If the min value is required for the entire tree call this function\r\n     * as `tree.min(tree.root)`\r\n     *\r\n     * @param node\r\n     */\r\n    min(node) {\r\n        if (node === undefined) {\r\n            node = this.root;\r\n        }\r\n        const minNode = this.getMinNode(node);\r\n        if (minNode !== undefined) {\r\n            return minNode.datum;\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Returns the maximum value in the tree starting at the given node. If the\r\n     * tree is empty, `undefined` will be returned.\r\n     *\r\n     * If the max value is required for the entire tree call this function\r\n     * as `tree.max(tree.root)`\r\n     *\r\n     * @param node\r\n     */\r\n    max(node) {\r\n        if (node === undefined) {\r\n            node = this.root;\r\n        }\r\n        const maxNode = this.getMaxNode(node);\r\n        if (maxNode !== undefined) {\r\n            return maxNode.datum;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * Returns the node that is at the top after the rotation.\r\n *\r\n * Destructively rotates the given node, say h, in the\r\n * given direction as far as tree rotations go.\r\n *\r\n * @param dir\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction rotate(dir, h) {\r\n    const x = h[-dir];\r\n    h[-dir] = x[dir];\r\n    if (x[dir]) {\r\n        x[dir].parent = h;\r\n    }\r\n    x[dir] = h;\r\n    h.parent = x;\r\n    x.color = h.color;\r\n    h.color = RED;\r\n    return x;\r\n}\r\n/**\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction removeMin(h) {\r\n    if (!h[LEFT]) {\r\n        return undefined;\r\n    }\r\n    if (!isRed(h[LEFT]) &&\r\n        !isRed(h[LEFT][LEFT])) {\r\n        h = moveRedLeft(h);\r\n    }\r\n    h[LEFT] = removeMin(h[LEFT]);\r\n    if (h[LEFT]) {\r\n        h[LEFT].parent = h;\r\n    }\r\n    return fixUp(h);\r\n}\r\n/**\r\n * Destructively flips the color of the given node and both\r\n * it's childrens' colors.\r\n *\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction flipColors(h) {\r\n    h.color = (h.color + 1) % 2;\r\n    h[LEFT].color = (h[LEFT].color + 1) % 2;\r\n    h[RIGHT].color = (h[RIGHT].color + 1) % 2;\r\n}\r\n/**\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction moveRedLeft(h) {\r\n    flipColors(h);\r\n    if (isRed(h[RIGHT][LEFT])) {\r\n        const a = rotate(RIGHT, h[RIGHT]);\r\n        h[RIGHT] = a;\r\n        a.parent = h;\r\n        h = rotate(LEFT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * Returns the node that is at the top after the move.\r\n *\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction moveRedRight(h) {\r\n    flipColors(h);\r\n    if (isRed(h[LEFT][LEFT])) {\r\n        h = rotate(RIGHT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * Returns the node that is at the top after the fix.\r\n *\r\n * Fix right-leaning red nodes.\r\n *\r\n * @internal\r\n */\r\nfunction fixUp(h) {\r\n    if (isRed(h[RIGHT])) {\r\n        h = rotate(LEFT, h);\r\n    }\r\n    if (isRed(h[LEFT]) && isRed(h[LEFT][LEFT])) {\r\n        h = rotate(RIGHT, h);\r\n    }\r\n    // Split 4-nodes.\r\n    if (isRed(h[LEFT]) && isRed(h[RIGHT])) {\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=tree.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-ll-rb-tree/node/tree.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/cull-bezier-pieces.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/cull-bezier-pieces.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cullBezierPieces1: () => (/* binding */ cullBezierPieces1)\n/* harmony export */ });\n/* harmony import */ var _get_best_distance_squared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-best-distance-squared.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-best-distance-squared.js\");\n/* harmony import */ var _cull_by_loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cull-by-loose-bounding-box.js */ \"./node_modules/flo-mat/node/closest-boundary-point/cull-by-loose-bounding-box.js\");\n/* harmony import */ var _cull_by_tight_boundary_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cull-by-tight-boundary-box.js */ \"./node_modules/flo-mat/node/closest-boundary-point/cull-by-tight-boundary-box.js\");\n\n\n\n/**\n * @internal\n * @param bezierPieces\n * @param p\n * @param extreme\n */\nfunction cullBezierPieces1(bezierPieces, p) {\n    const bestSquaredDistance = (0,_get_best_distance_squared_js__WEBPACK_IMPORTED_MODULE_0__.getBestDistanceSquared)(bezierPieces, p);\n    bezierPieces = (0,_cull_by_loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.cullByLooseBoundingBox)(bezierPieces, p, bestSquaredDistance);\n    bezierPieces = (0,_cull_by_tight_boundary_box_js__WEBPACK_IMPORTED_MODULE_2__.cullByTightBoundingBox)(bezierPieces, p, bestSquaredDistance);\n    return bezierPieces;\n}\n\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/cull-by-loose-bounding-box.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/cull-by-loose-bounding-box.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cullByLooseBoundingBox: () => (/* binding */ cullByLooseBoundingBox)\n/* harmony export */ });\n/* harmony import */ var _geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/get-closest-square-distance-to-rect.js */ \"./node_modules/flo-mat/node/geometry/get-closest-square-distance-to-rect.js\");\n/* harmony import */ var _geometry_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/get-bounding-box-.js */ \"./node_modules/flo-mat/node/geometry/get-bounding-box-.js\");\n\n\n/**\n * @internal\n * When checking distances, ignore all those with closest possible distance\n * further than 'bestSquaredDistance', i.e. cull them.\n * @param bezierPieces\n * @param p\n * @param dSquared\n */\nfunction cullByLooseBoundingBox(bezierPieces, p, dSquared) {\n    const candidateBezierPieces = [];\n    for (let i = 0; i < bezierPieces.length; i++) {\n        const bezierPiece = bezierPieces[i];\n        const ps = bezierPiece.curve.ps;\n        const boundingBox = (0,_geometry_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.getBoundingBox_)(ps);\n        const d = (0,_geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_1__.getClosestSquareDistanceToRect)(boundingBox, p);\n        if (d <= dSquared) {\n            candidateBezierPieces.push(bezierPiece);\n        }\n    }\n    return candidateBezierPieces;\n}\n\n//# sourceMappingURL=cull-by-loose-bounding-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/cull-by-loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/cull-by-tight-boundary-box.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/cull-by-tight-boundary-box.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cullByTightBoundingBox: () => (/* binding */ cullByTightBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js\");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _geometry_get_closest_squared_distance_to_rotated_rect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/get-closest-squared-distance-to-rotated-rect.js */ \"./node_modules/flo-mat/node/geometry/get-closest-squared-distance-to-rotated-rect.js\");\n\n\n\nconst getBoundingBoxTight_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getBoundingBoxTight);\n/**\n * @internal\n * When checking distances, ignore all those with closest possible distance\n * further than 'bestSquaredDistance', i.e. cull them.\n * @param bezierPieces\n * @param p\n * @param bestSquaredDistance\n */\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\n    const candidateBezierPieces = [];\n    for (let i = 0; i < bezierPieces.length; i++) {\n        const bezierPiece = bezierPieces[i];\n        const ps = bezierPiece.curve.ps;\n        const tightBoundingBox = getBoundingBoxTight_(ps);\n        const d = (0,_geometry_get_closest_squared_distance_to_rotated_rect_js__WEBPACK_IMPORTED_MODULE_2__.getClosestSquaredDistanceToRotatedRect)(tightBoundingBox, p);\n        if (d <= bestSquaredDistance) {\n            candidateBezierPieces.push(bezierPiece);\n        }\n    }\n    return candidateBezierPieces;\n}\n\n//# sourceMappingURL=cull-by-tight-boundary-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/cull-by-tight-boundary-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/dd-deflate-with-running-error.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/dd-deflate-with-running-error.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDeflateWithRunningError: () => (/* binding */ ddDeflateWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../error-analysis/gamma.js */ \"./node_modules/flo-mat/node/error-analysis/gamma.js\");\n// TODO - import from `flo-poly` in the future\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst { abs } = Math;\nconst γγ3 = (0,_error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_1__[\"γγ\"])(3);\n/**\n * Deflates the given polynomial *approximately* by removing a factor (x - t).\n *\n * @param p a polynomial with coefficients given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`\n * @param pE the coefficient-wise absolute error of the input polynomial that\n * still need to be multiplied by γγ3, i.e. it is `γγ3` times too big.\n * @param t an evaluation point of the polynomial.\n *\n * @example\n * ```typescript\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\n * ddDeflate([[0,1], [0,-5], [0,8], [0,-4]], [0,2]); //=> [[0,1], [0,-3], [0,2]]\n * ddDeflate([[0,1], [0,-3], [0,2], [0,2]);          //=> [[0,1], [0,-1]]\n * ddDeflate([[0,1], [0,-1]], [0,1]);                //=> [[0,1]]\n * ```\n *\n * @doc\n */\nfunction ddDeflateWithRunningError(p, pE, t) {\n    //--------------------------------------------------------------------------\n    // `var` -> a variable\n    // `$var` -> the double precision approximation to `var`\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\n    // `_var_` -> means both absolute value and absolute error bound\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\n    // * the returned errors need to be multiplied by 3γ² to get the true error\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\n    //   due to multiplication by 3*γ² and not 3*u²\n    //--------------------------------------------------------------------------\n    const d = p.length - 1;\n    const bs = [p[0]]; // coefficients\n    let b_ = pE[0]; // running error\n    const bEs = [b_]; // coefficient-wise error bound\n    for (let i = 1; i < d; i++) {\n        // p[i] + t*bs[i-1];\n        const a = bs[i - 1];\n        const $m = t * a[1];\n        const _t = abs(t);\n        const m_ = _t * b_ + abs($m);\n        const pi = p[i];\n        const p_ = pE[i];\n        b_ = p_ + m_ + abs(pi[1] + $m);\n        const b = qaq(pi, qmd(t, a));\n        bs.push(b);\n        bEs.push(b_);\n    }\n    return {\n        coeffs: bs,\n        errBound: bEs.map(e => γγ3 * e)\n    };\n}\n\n//# sourceMappingURL=dd-deflate-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/dd-deflate-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/get-best-distance-squared.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/get-best-distance-squared.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBestDistanceSquared: () => (/* binding */ getBestDistanceSquared)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n\n\n/**\n * @internal\n * Finds an initial distance such that the closest point can not be further than\n * this distance away.\n */\nfunction getBestDistanceSquared(bezierPieces, p) {\n    let bestSquaredDistance = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < bezierPieces.length; i++) {\n        const bezierPiece = bezierPieces[i];\n        const ps = bezierPiece.curve.ps;\n        const p1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, bezierPiece.ts[0]);\n        const p2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, bezierPiece.ts[1]);\n        const d = Math.min((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, p1), (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, p2));\n        if (d < bestSquaredDistance) {\n            bestSquaredDistance = d;\n        }\n    }\n    // The extra multiplier is to account for floating point precision.\n    return (1 + 2 ** -10) * bestSquaredDistance;\n}\n\n//# sourceMappingURL=get-best-distance-squared.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/get-best-distance-squared.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCloseBoundaryPointsCertified: () => (/* binding */ getCloseBoundaryPointsCertified)\n/* harmony export */ });\n/* harmony import */ var _get_potential_closest_points_on_curve_certified_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-potential-closest-points-on-curve-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-potential-closest-points-on-curve-certified.js\");\n/* harmony import */ var _cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cull-bezier-pieces.js */ \"./node_modules/flo-mat/node/closest-boundary-point/cull-bezier-pieces.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n\n\n\n/**\n * @internal\n * Returns the closest boundary point to the given point, limited to the given\n * bezier pieces, including the beziers actually checked after culling.\n * @param bezierPieces\n * @param x\n * @param touchedCurve\n * @param t\n * @param extreme\n */\nfunction getCloseBoundaryPointsCertified(bezierPieces, x, touchedCurve = undefined, t = undefined, for1Prong = false, angle = 0) {\n    bezierPieces = (0,_cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_0__.cullBezierPieces1)(bezierPieces, x);\n    const pInfoss = [];\n    for (let i = 0; i < bezierPieces.length; i++) {\n        const bezierPiece = bezierPieces[i];\n        const pInfos = (0,_get_potential_closest_points_on_curve_certified_js__WEBPACK_IMPORTED_MODULE_1__.getPotentialClosestPointsOnCurveCertified)(bezierPiece.curve, x, bezierPiece.ts, touchedCurve, t, for1Prong, angle);\n        pInfoss.push(...pInfos);\n    }\n    /** the minimum max interval value */\n    let minMax = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < pInfoss.length; i++) {\n        const diMax = pInfoss[i].dSquaredI[1];\n        if (diMax < minMax) {\n            minMax = diMax;\n        }\n    }\n    const closestPointInfos = [];\n    for (let i = 0; i < pInfoss.length; i++) {\n        const info = pInfoss[i];\n        if (info.dSquaredI[0] <= minMax) {\n            closestPointInfos.push(info);\n        }\n    }\n    return closestPointInfos.map(info => (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(info.curve, info.t, false));\n}\n\n//# sourceMappingURL=get-close-boundary-points-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/get-closest-boundary-point-certified.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/get-closest-boundary-point-certified.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClosestBoundaryPointCertified: () => (/* binding */ getClosestBoundaryPointCertified)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n/* harmony import */ var _cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cull-bezier-pieces.js */ \"./node_modules/flo-mat/node/closest-boundary-point/cull-bezier-pieces.js\");\n/* harmony import */ var _get_potential_closest_points_on_curve_certified_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-potential-closest-points-on-curve-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-potential-closest-points-on-curve-certified.js\");\n/* harmony import */ var _find_2_prong_squared_distance_between_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../find-2-prong/squared-distance-between-dd.js */ \"./node_modules/flo-mat/node/find-2-prong/squared-distance-between-dd.js\");\n\n\n\n\n\n/**\n * @internal\n * Returns the closest boundary point to the given point, limited to the given\n * bezier pieces, including the beziers actually checked after culling.\n * @param bezierPieces\n * @param x\n * @param touchedCurve\n * @param t\n * @param extreme\n */\nfunction getClosestBoundaryPointCertified(angle, bezierPieces, x, touchedCurve, t, for1Prong) {\n    bezierPieces = (0,_cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_0__.cullBezierPieces1)(bezierPieces, x);\n    let bestDistance = Number.POSITIVE_INFINITY;\n    let pos;\n    for (let i = 0; i < bezierPieces.length; i++) {\n        const bezierPiece = bezierPieces[i];\n        const ps = (0,_get_potential_closest_points_on_curve_certified_js__WEBPACK_IMPORTED_MODULE_1__.getPotentialClosestPointsOnCurveCertified)(bezierPiece.curve, x, bezierPiece.ts, touchedCurve, t, for1Prong, angle);\n        const p = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.getObjClosestTo)(x, ps, p => p.p);\n        if (p === undefined) {\n            continue;\n        }\n        const d = (0,_find_2_prong_squared_distance_between_dd_js__WEBPACK_IMPORTED_MODULE_3__.squaredDistanceBetweenDd)(p.p, x);\n        let curve = bezierPiece.curve;\n        let t_ = p.t;\n        if (d < bestDistance) {\n            if (t_ === 0) {\n                t_ = 1;\n                curve = bezierPiece.curve.prev;\n            }\n            pos = (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_4__.createPos)(curve, t_, false);\n            bestDistance = d;\n        }\n    }\n    return pos;\n}\n\n//# sourceMappingURL=get-closest-boundary-point-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/get-closest-boundary-point-certified.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/get-p-from-box.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/get-p-from-box.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPFromBox: () => (/* binding */ getPFromBox)\n/* harmony export */ });\n/** @internal */\nfunction getPFromBox(box) {\n    const tl = box[0];\n    const br = box[1];\n    return [\n        (tl[0] + br[0]) / 2,\n        (tl[1] + br[1]) / 2,\n    ];\n}\n\n//# sourceMappingURL=get-p-from-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/get-p-from-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/get-potential-closest-points-on-curve-certified.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/get-potential-closest-points-on-curve-certified.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPotentialClosestPointsOnCurveCertified: () => (/* binding */ getPotentialClosestPointsOnCurveCertified)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-foot-points-polys-on-bezier-certified.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\n/* harmony import */ var _dd_deflate_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-deflate-with-running-error.js */ \"./node_modules/flo-mat/node/closest-boundary-point/dd-deflate-with-running-error.js\");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/roots/naive/e-deflate.js\");\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../error-analysis/gamma.js */ \"./node_modules/flo-mat/node/error-analysis/gamma.js\");\n/* harmony import */ var _root_interval_to_distance_squared_interval_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./root-interval-to-distance-squared-interval.js */ \"./node_modules/flo-mat/node/closest-boundary-point/root-interval-to-distance-squared-interval.js\");\n/* harmony import */ var _get_p_from_box_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-p-from-box.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-p-from-box.js\");\n\n\n\n\n\n\n\nconst γγ3 = (0,_error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_0__[\"γγ\"])(3);\nconst { sqrt } = Math;\n/**\n * @internal\n * @param curve The curve\n * @param x The point from which to check\n * @param tRange The allowed t range\n * @param touchedCurve The bezier on which p is located\n * @param t The t value of the bezier that locates p\n */\nfunction getPotentialClosestPointsOnCurveCertified(curve, x, [tS, tE] = [0, 1], touchedCurve = undefined, t = undefined, for1Prong = false, angle = 0) {\n    const ps = curve.ps;\n    const shouldDeflate = angle === 0 && curve === touchedCurve;\n    let { polyDd: polyDdO, polyE: polyEO, getPolyExact: getPolyExactO } = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getFootPointsOnBezierPolysCertified)(ps, x);\n    const def = shouldDeflate\n        ? (0,_dd_deflate_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.ddDeflateWithRunningError)(polyDdO, polyEO.map(e => e / γγ3), t)\n        : undefined;\n    const def2 = for1Prong && shouldDeflate\n        ? (0,_dd_deflate_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.ddDeflateWithRunningError)(def.coeffs, def.errBound.map(e => e / γγ3), t)\n        : undefined;\n    const def3 = for1Prong && shouldDeflate\n        ? (0,_dd_deflate_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.ddDeflateWithRunningError)(def2.coeffs, def2.errBound.map(e => e / γγ3), t)\n        : undefined;\n    const { polyDd, polyE, getPolyExact } = def3 !== undefined\n        ? { polyDd: def3.coeffs, polyE: def3.errBound.map(e => e / γγ3), getPolyExact: () => (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.eDeflate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.eDeflate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.eDeflate)(getPolyExactO(), t), t), t) }\n        : def !== undefined\n            ? { polyDd: def.coeffs, polyE: def.errBound.map(e => e / γγ3), getPolyExact: () => (0,flo_poly__WEBPACK_IMPORTED_MODULE_3__.eDeflate)(getPolyExactO(), t) }\n            : { polyDd: polyDdO, polyE: polyEO, getPolyExact: getPolyExactO };\n    const ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRootsCertified)(polyDd, tS, tE, polyE, getPolyExact);\n    const dontPush0 = ((t === 1 && curve === touchedCurve.next) ||\n        (t === 0 && curve === touchedCurve));\n    const dontPush1 = ((t === 0 && curve === touchedCurve.prev) ||\n        (t === 1 && curve === touchedCurve));\n    if (tS === 0) {\n        if (!dontPush0) {\n            ris.push({ tS: 0, tE: 0, multiplicity: 1 });\n        }\n    }\n    else if (tS === 1) {\n        if (!dontPush1) {\n            ris.push({ tS: 1, tE: 1, multiplicity: 1 });\n        }\n    }\n    else {\n        ris.push({ tS: tS, tE: tS, multiplicity: 1 });\n    }\n    if (tE === 0) {\n        if (!dontPush0) {\n            ris.push({ tS: 0, tE: 0, multiplicity: 1 });\n        }\n    }\n    else if (tE === 1) {\n        if (!dontPush1) {\n            ris.push({ tS: 1, tE: 1, multiplicity: 1 });\n        }\n    }\n    else {\n        ris.push({ tS: tE, tE: tE, multiplicity: 1 });\n    }\n    const infos = ris\n        .map(ri => {\n        const { tS: ts, tE: te } = ri;\n        if (te < tS || ts > tE) {\n            return undefined;\n        }\n        const _t = (ts + te) / 2;\n        const t = _t < 0 ? 0 : _t > 1 ? 1 : _t;\n        const box = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(ps, [ts, te]);\n        const p_ = (0,_get_p_from_box_js__WEBPACK_IMPORTED_MODULE_6__.getPFromBox)(box);\n        const dSquaredI = (0,_root_interval_to_distance_squared_interval_js__WEBPACK_IMPORTED_MODULE_7__.rootIntervalToDistanceSquaredInterval)(box, x);\n        const t_ = t === 0 ? 1 : t;\n        const curve_ = t === 0 ? curve.prev : curve;\n        return {\n            curve: curve_,\n            p: p_,\n            t: t_,\n            d: (sqrt(dSquaredI[0]) + sqrt(dSquaredI[1])) / 2,\n            dSquaredI,\n            box,\n        };\n    });\n    const infos_ = infos.filter(info => info !== undefined);\n    return infos_;\n}\n\n//# sourceMappingURL=get-potential-closest-points-on-curve-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/get-potential-closest-points-on-curve-certified.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/closest-boundary-point/root-interval-to-distance-squared-interval.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/closest-boundary-point/root-interval-to-distance-squared-interval.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rootIntervalToDistanceSquaredInterval: () => (/* binding */ rootIntervalToDistanceSquaredInterval)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMult;\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eAdd;\nconst eps = Number.EPSILON;\n/**\n * Returns the distance interval squared given the root interval (currently\n * ignoring multiplicity).\n *\n * * the result is returned as `[minPossibleSquared, maxPossibleSquared]` distance.\n *\n * @param box\n * @param p\n *\n * @internal\n */\nfunction rootIntervalToDistanceSquaredInterval(box, p) {\n    const bl = box[0];\n    const tr = box[1];\n    const minX = bl[0];\n    const minY = bl[1];\n    const maxX = tr[0];\n    const maxY = tr[1];\n    const x = p[0]; // <0>\n    const y = p[1]; // <0>\n    let minDSquared = Number.POSITIVE_INFINITY;\n    let maxDSquared = Number.NEGATIVE_INFINITY;\n    // for each corner of the interval box\n    for (const [a, b] of [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]]) {\n        /*\n        // distance to 1st corner of interval box - `distance² = x² + y²`\n        const dc1 = (a - x)**2 + (b - y)**2;\n        // max absolute roundoff error of `dc1`\n        // <4>dc1 <-- <4>(<3>(<1>(a - x)**2) + <3>(<1>((b - y)**2))\n        const dc1E = 4*γ1*((a + x)**2 + (b + y)**2);\n        const dc1Min = dc1 - dc1E;  // distance minus max error\n        const dc1Max = dc1 + dc1E;  // distance plus max error\n        */\n        /** distance to 1st corner of interval box - `distance² = x² + y²` */\n        const ax = td(a, x); // a - x\n        const by = td(b, y); // b - y\n        const dc1Exact = eadd(emult(ax, ax), emult(by, by)); // ax**2 + bx**2\n        const dc1 = estimate(dc1Exact);\n        const dc1Min = dc1 * (1 - eps); // distance minus max error\n        const dc1Max = dc1 * (1 + eps); // distance plus max error\n        if (dc1Min <= minDSquared) {\n            minDSquared = dc1Min;\n        }\n        if (dc1Max >= maxDSquared) {\n            maxDSquared = dc1Max;\n        }\n    }\n    return [minDSquared, maxDSquared];\n}\n\n//# sourceMappingURL=root-interval-to-distance-squared-interval.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/closest-boundary-point/root-interval-to-distance-squared-interval.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/contact-point/contact-point.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/contact-point/contact-point.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareCps: () => (/* binding */ compareCps)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_compare_poss_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/compare-poss.js */ \"./node_modules/flo-mat/node/point-on-shape/compare-poss.js\");\n\n/**\n * Primarily for internal use.\n *\n * Compares the two contact points according to their order along the shape\n * boundary. Returns > 0 if a > b, < 0 if a < b or 0 if a === b.\n * @param a The first contact point.\n * @param b The second contact point.\n */\nfunction compareCps(a, b) {\n    let res = (0,_point_on_shape_compare_poss_js__WEBPACK_IMPORTED_MODULE_0__.comparePoss)(a.pointOnShape, b.pointOnShape);\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order - b.order;\n    if (res !== 0) {\n        return res;\n    }\n    return a.order2 - b.order2;\n}\n\n//# sourceMappingURL=contact-point.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/contact-point/contact-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/corner/compare-curvatures-at-interface.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/corner/compare-curvatures-at-interface.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareCurvaturesAtInterface: () => (/* binding */ compareCurvaturesAtInterface)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js\");\n\n\n/**\n * Compare the curvature, κ, between two curves at t === 0.\n *\n * Returns a positive number if κ for psI > κ for psO, negative if κ for psI < κ\n * for psO or zero if the curve extensions are identical (i.e. in same K-family).\n *\n * Precondition: The point psI evaluated at zero must === the point psO\n * evaluated at zero.\n *\n * // TODO - is this correct?\n * Exact: Returns the exact result if the bithlength of all\n * coordinates <= 53 - 5 === 48 and are bit-aligned.\n *\n * @param psI An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * representing the incoming curve\n * @param psO Another bezier representing the outgoing curve\n */\nfunction compareCurvaturesAtInterface(psI, psO) {\n    // Get x' and y' for incoming curve evaluated at 0\n    const [dxI, dyI] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.tangentAt0)(psI); // max bitlength increase / max shift === 3\n    // Get x'' and y'' for incoming curve evaluated at 0\n    const [ddxI, ddyI] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evaluate2ndDerivativeAt0)(psI); // max bitlength increase / max shift === 5\n    // Get x' and y' for outgoing curve evaluated at 0\n    const [dxO, dyO] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.tangentAt0)(psO); // max bitlength increase / max shift === 3\n    // Get x'' and y'' for outgoing curve evaluated at 0\n    const [ddxO, ddyO] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evaluate2ndDerivativeAt0)(psO); // max bitlength increase / max shift === 5\n    //console.log('κI: ', κ(psI, 0));\n    //console.log('κO: ', κ(psO, 0));\n    // Remember the formula for the signed curvature of a parametric curve:\n    // κ = x′y′′ - y′x′′ / sqrt(x′² + y′²)³\n    // κ² = (x′y′′ - y′x′′)² / (x′² + y′²)³\n    // This allows us to do an exact comparison of curvatures\n    // Simplifying the above gives (denoting the incoming curve with a subscript\n    // of 1 and the outgoing with a 2):\n    //      κIncoming > κOutgoing\n    // <=>  (x₁′y₁′′ - y₁′x₁′′)²(x₂′² + y₂′²)³ > (x₂′y₂′′ - y₂′x₂′′)²(x₁′² + y₁′²)³\n    // <=>  a²b³ > c²d³\n    // Note b³ > 0 and d³ > 0\n    // max aggregate bitlength increase (let original bitlength === p):\n    // a -> 2 x ((p+3)+(p+5) + 1) === 4p + 18 -> max p in double precision === 8 -> too low\n    //let a = (dxI*ddyI - dyI*ddxI)**2;\n    // b -> 3 x ((p+3) + 1) === 3p + 12\n    //let b = (dxO*dxO  + dyO*dyO )**3;\n    // c -> 2 x ((p+3)+(p+5) + 1) === 4p + 18\n    //let c = (dxO*ddyO - dyO*ddxO)**2;\n    // d -> 3 x ((p+3) + 1) === 3p + 12\n    //let d = (dxI*dxI  + dyI*dyI )**3;\n    // We need to resort to exact floating point arithmetic at this point\n    const a = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxI, ddyI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyI, ddxI));\n    const c = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxO, ddyO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyO, ddxO));\n    const signA = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eSign)(a);\n    const signC = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eSign)(c);\n    if (signA !== signC) {\n        //console.log('branch 3');\n        return signA - signC;\n    }\n    const b = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxO, dxO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyO, dyO));\n    const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxI, dxI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyI, dyI));\n    const b2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(b, b);\n    const b3 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(b2, b);\n    const d2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(d, d);\n    const d3 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(d2, d);\n    if (signA !== 0 || signC !== 0) {\n        //console.log('branch 4');\n        const a2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(a, a);\n        const c2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(c, c);\n        // max aggregate bitlength increase (let original bitlength === p):\n        // κ -> (2 x ((p+3)+(p+5) + 1)) + (3 x ((p+3) + 1)) === 7p + 30\n        // e.g. for bit-aligned input bitlength p of 10 we get output bitlength \n        // of 100, or for p === 3 (the max exact bitlength allowed to have exact\n        // results without resorting to infinite precision) we get 51 bits.\n        const κI = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(a2, b3);\n        const κO = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(c2, d3);\n        const δκ = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eSign)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)(κI, κO));\n        if (δκ !== 0) {\n            //console.log('branch 5');\n            // At this point signA === signC, both +tive or -tive\n            return signA > 0 ? δκ : -δκ;\n        }\n    }\n    // At this point signA === signC, both +tive or -tive or 0\n    // Now we have to look at the change of curvature w.r.t. the parameter t,\n    // i.e. \n    // κ′ = [(x′²+y′²)(x′y′′′-y′x′′′) - 3(x′y′′-y′x′′)(x′x′′+y′y′′)] / (x′²+y′²)^(5/2)\n    // Therefore: (denoting the incoming curve with a subscript of 1 and the outgoing with a 2)\n    // κ′Incoming > κ′Outgoing\n    // <=> [(x₁′²+y₁′²)(x₁′y₁′′′-y₁′x₁′′′) - 3(x₁′y₁′′-y₁′x₁′′)(x₁′x₁′′+y₁′y₁′′)]²(x₂′²+y₂′²)⁵ >\n    //     [(x₂′²+y₂′²)(x₂′y₂′′′-y₂′x₂′′′) - 3(x₂′y₂′′-y₂′x₂′′)(x₂′x₂′′+y₂′y₂′′)]²(x₁′²+y₁′²)⁵\n    // <=> (de - 3af)²b⁵ > (bg - 3ch)²d⁵\n    // <=> i²b⁵ > j²d⁵\n    // Get x′′′ and y′′′ for incoming curve evaluated at 1\n    const [[dddxI], [dddyI]] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_7__.toPowerBasis_3rdDerivative)(psI); // max bitlength increase === max shift === 6\n    const [[dddxO], [dddyO]] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_7__.toPowerBasis_3rdDerivative)(psO); // max bitlength increase === max shift === 6\n    const e = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxI, dddyI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyI, dddxI));\n    const f = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxI, ddxI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyI, ddyI));\n    const g = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxO, dddyO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyO, dddxO));\n    const h = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dxO, ddxO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoProduct)(dyO, ddyO));\n    // (de - 3af)²b⁵ > (bg - 3ch)²d⁵\n    // i²b⁵ > j²d⁵\n    const i = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(d, e), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.scaleExpansion)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(a, f), 3));\n    const j = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(b, g), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_8__.scaleExpansion)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(c, h), 3));\n    const signI = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eSign)(i);\n    const signJ = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eSign)(j);\n    if (signA !== signC) {\n        return signI - signJ;\n    }\n    if (signI === 0 && signJ === 0) {\n        // Both curve extensions are identical, i.e. in the same K-family\n        return 0;\n    }\n    const i2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(i, i);\n    const b5 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(b2, b3);\n    const j2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(j, j);\n    const d5 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(d2, d3);\n    const dκI = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(i2, b5);\n    const dκO = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct)(j2, d5);\n    const sgn = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eSign)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)(dκI, dκO));\n    return signI > 0 ? sgn : -sgn;\n    // If the above returned value is still zero then the two curve extensions \n    // are identical, i.e. in the same K-family\n}\n\n//# sourceMappingURL=compare-curvatures-at-interface.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/corner/compare-curvatures-at-interface.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/corner/get-corner.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/corner/get-corner.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCorner: () => (/* binding */ getCorner)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/cross.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var _get_interface_ccw_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-interface-ccw.js */ \"./node_modules/flo-mat/node/corner/get-interface-ccw.js\");\n\n\n/**\n * @internal\n * Angle in degrees to radians.\n */\nconst DEGREES = {\n    //'0'    : 0.0000,\n    0.25: 0.0050,\n    1: 0.0167,\n    4: 0.0698,\n    16: 0.2756,\n};\n/** @internal */\n//const DEGREE_LIMIT = DEGREES[1];\nconst DEGREE_LIMIT = DEGREES[4];\n//const DEGREE_LIMIT = DEGREES[16]; \n/**\n * @internal\n * Returns a new corner with properties.\n *\n * PRECONDITION: The beziers has control points with max bit-length of 26 and\n * aligned to a 'grid' to have the same exponent. This is so the vectors between\n * control points can be calculated exactly without resorting to adaptive\n * infinite precision floating point operations.\n *\n * @param psI The incoming bezier that ends in the corner\n * @param psO The outgoing bezier that starts at the corner\n */\nfunction getCorner(psI, psO) {\n    // getInterfaceCcw must return a number !== 0 if psI and psO are not the\n    // same as seen as a curve extension with t ∈ [-∞,+∞]\n    const ccw = (0,_get_interface_ccw_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceCcw)(psI, psO);\n    const isSharp = ccw < 0;\n    const isDull = ccw > 0;\n    // Find (non-normalized) tangent of curve.ps at t === 1\n    const p0E = psI[psI.length - 2];\n    const p1E = psI[psI.length - 1];\n    const xE = p1E[0] - p0E[0];\n    const yE = p1E[1] - p0E[1];\n    const tangentAtEnd = [xE, yE];\n    // Find (non-normalized) tangent of curve.next.ps at t === 0\n    const p0S = psO[0];\n    const p1S = psO[1];\n    const xS = p1S[0] - p0S[0];\n    const yS = p1S[1] - p0S[1];\n    const tangentAtStart = [xS, yS];\n    // These use square root and are thus not exact\n    const tangents_ = [\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)(tangentAtEnd),\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)(tangentAtStart),\n    ];\n    // The cross calculated below should be exact due to beziers having been\n    // normalized!\n    const crossTangents = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.cross)(tangents_[0], tangents_[1]);\n    let isQuiteSharp;\n    let isQuiteDull;\n    const dotTangents = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.dot)(tangentAtEnd, tangentAtStart);\n    if (dotTangents > 0) {\n        // Curves go in same direction\n        isQuiteSharp = crossTangents < -DEGREE_LIMIT;\n        isQuiteDull = crossTangents > +DEGREE_LIMIT;\n    }\n    else {\n        isQuiteSharp = isSharp;\n        isQuiteDull = isDull;\n    }\n    return {\n        tangents: tangents_,\n        crossTangents,\n        isSharp,\n        isDull,\n        isQuiteSharp,\n        isQuiteDull\n    };\n}\n\n//# sourceMappingURL=get-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/corner/get-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/corner/get-interface-ccw.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/corner/get-interface-ccw.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInterfaceCcw: () => (/* binding */ getInterfaceCcw)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var _compare_curvatures_at_interface_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compare-curvatures-at-interface.js */ \"./node_modules/flo-mat/node/corner/compare-curvatures-at-interface.js\");\n\n\n\n/**\n * Returns a positive value if the second bezier (of order 1, 2 or 3) curves\n * anti-clockwise with respect to the first at the point where the first bezier\n * ends and the second one starts. Returns a negative number if the turn is\n * clockwise. Returns 0 otherwise.\n *\n * The algorithm is a generalization of `ccw`, a.k.a `orient2d`.\n *\n * The above obviously necessitates that their endpoints coincide as described.\n *\n * Preconditions (for robustness):\n * * The beziers has control points with max bit-length of 25 and bit-aligned.\n * * The bezier does not have infinite curvature at either endpoint\n *\n * This is so the vectors between control points can be\n * calculated exactly without resorting to adaptive infinite precision floating\n * point operations. Note: aligned to 'grid' here means if you bitwise-and all\n * values together the resulting bitlength === the max bithlength of any value.\n *\n * @param psI The incoming bezier that ends at the interface\n * @param psO The outgoing bezier that starts at the interface\n */\n// TODO - improve and make at least 46-bitlength precondition\nfunction getInterfaceCcw(psI, psO) {\n    const lenI = psI.length;\n    // second last control point of incoming curve\n    const p0 = psI[lenI - 2];\n    // last control point of incoming curve / first control point of outgoing\n    const p1 = psO[0];\n    // second control point of outgoing curve\n    const p2 = psO[1];\n    // Max one bit can be added in the calculations below due to bit-alignment\n    const xE = p1[0] - p0[0]; // tangent x-coordinate\n    const yE = p1[1] - p0[1]; // tangent y-coordinate\n    const xS = p2[0] - p1[0]; // tangent x-coordinate\n    const yS = p2[1] - p1[1]; // tangent y-coordinate\n    // If the tangent is to be found at t === 0 or t === 1 then using a basic \n    // property of bezier curves we can find the tangents easily as below\n    // (non-normalized) tangent of incoming curve at t === 1\n    const tangentAtEnd = [xE, yE];\n    // (non-normalized) tangent of outgoing curve at t === 0\n    const tangentAtStart = [xS, yS];\n    // const crossTangents = orient2d(p0, p1, p2);\n    const crossTangents = orient2dPrecise(p0, p1, p2);\n    if (crossTangents !== 0) {\n        return crossTangents;\n    }\n    // The dot calculated below will have a max bitlength of \n    // (2*(maxBitLength + 1)) + 1 === e.g. (2*(25 + 1)) + 1 === 53\n    // If the preconditions are met it is exact\n    const dotTangents = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(tangentAtEnd, tangentAtStart);\n    if (dotTangents > 0) {\n        // Curves go in same direction at interface - neither clock or \n        // anti-clockwise.\n        // Note: The above comment is not strictly true but as this case is not\n        // important for the algorithm we return 0\n        return 0;\n    }\n    // Curves go in opposite directions at interface starting off with the exact\n    // same tangent - look now at curvature to see which has the largest \n    // curvature so we can base the clock or anti-clockwise result on that\n    // Look at curvature\n    return (0,_compare_curvatures_at_interface_js__WEBPACK_IMPORTED_MODULE_1__.compareCurvaturesAtInterface)(psI.slice().reverse(), psO);\n}\n/** Returns the cross from A to B to C */\nfunction orient2dPrecise(A, B, C) {\n    // const detleft  = (A[0] - C[0]) * (B[1] - C[1]);\n    // const detright = (A[1] - C[1]) * (B[0] - C[0]);\n    // const det = detleft - detright;\n    const a = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoDiff)(A[0], C[0]);\n    const b = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoDiff)(B[1], C[1]);\n    const c = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoDiff)(A[1], C[1]);\n    const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoDiff)(B[0], C[0]);\n    const e = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(a, b);\n    const f = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eMult)(c, d);\n    const g = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eAdd)(e, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eNegativeOf)(f));\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eEstimate)(g);\n}\n\n//# sourceMappingURL=get-interface-ccw.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/corner/get-interface-ccw.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/clone.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/clone.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clone: () => (/* binding */ clone)\n/* harmony export */ });\n/* harmony import */ var _create_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-cp-node.js */ \"./node_modules/flo-mat/node/cp-node/create-cp-node.js\");\n\n/** @internal */\nconst EDGES = ['prev', 'next', 'prevOnCircle', 'nextOnCircle'];\n/**\n * Returns a deep clone of this [[CpNode]]. Can be used to copy the MAT\n * since cloning a single [[CpNode]] necessarily implies cloning all\n * [[CpNode]]s on the same MAT tree.\n */\nfunction clone(cpNode) {\n    // Don't change this function to be recursive, the call stack may \n    // overflow if there are too many CpNodes.\n    const nodeMap = new Map();\n    // const newCpNode = new CpNode(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\n    const newCpNode = (0,_create_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.createCpNode)(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\n    nodeMap.set(cpNode, newCpNode);\n    const cpStack = [{ cpNode, newCpNode }];\n    while (cpStack.length) {\n        const { cpNode, newCpNode } = cpStack.pop();\n        for (const edge of EDGES) {\n            const node = cpNode[edge];\n            let newNode = nodeMap.get(node);\n            if (!newNode) {\n                // newNode = new CpNode(node.cp, node.isHoleClosing, node.isIntersection);\n                newNode = (0,_create_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.createCpNode)(node.cp, node.isHoleClosing, node.isIntersection);\n                nodeMap.set(node, newNode);\n                cpStack.push({ cpNode: node, newCpNode: newNode });\n            }\n            newCpNode[edge] = newNode;\n        }\n    }\n    return newCpNode;\n}\n\n//# sourceMappingURL=clone.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/clone.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/cp-node.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/cp-node.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cpNodeComparator: () => (/* binding */ cpNodeComparator),\n/* harmony export */   getAllOnLoop: () => (/* binding */ getAllOnLoop),\n/* harmony export */   getChildren: () => (/* binding */ getChildren),\n/* harmony export */   getCpNodesOnCircle: () => (/* binding */ getCpNodesOnCircle),\n/* harmony export */   getFirstExit: () => (/* binding */ getFirstExit),\n/* harmony export */   getProngCount: () => (/* binding */ getProngCount),\n/* harmony export */   getRealProngCount: () => (/* binding */ getRealProngCount),\n/* harmony export */   insertCpNode: () => (/* binding */ insertCpNode),\n/* harmony export */   isFullyTerminating: () => (/* binding */ isFullyTerminating),\n/* harmony export */   isOnSameCircle: () => (/* binding */ isOnSameCircle),\n/* harmony export */   isOneProng: () => (/* binding */ isOneProng),\n/* harmony export */   isSharp: () => (/* binding */ isSharp),\n/* harmony export */   isTerminating: () => (/* binding */ isTerminating),\n/* harmony export */   matCurveToNextVertex: () => (/* binding */ matCurveToNextVertex),\n/* harmony export */   removeCpNode: () => (/* reexport safe */ _remove_js__WEBPACK_IMPORTED_MODULE_3__.removeCpNode),\n/* harmony export */   vertexChildren: () => (/* binding */ vertexChildren)\n/* harmony export */ });\n/* harmony import */ var _contact_point_contact_point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contact-point/contact-point.js */ \"./node_modules/flo-mat/node/contact-point/contact-point.js\");\n/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./remove.js */ \"./node_modules/flo-mat/node/cp-node/remove.js\");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n/* harmony import */ var _create_cp_node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-cp-node.js */ \"./node_modules/flo-mat/node/cp-node/create-cp-node.js\");\n\n\n\n\n/**\n * Returns the bezier curve from the maximal disk of this [[CpNode]] to the\n * next [[CpNode]]'s maximal disk and thus directly represents a piece of the\n * medial axis.\n * @deprecated Use [[getCurveToNext]] instead\n * @param cpNode\n */\nfunction matCurveToNextVertex(cpNode) {\n    return (0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_0__.getCurveToNext)(cpNode);\n}\n/**\n * Primarily for internal use.\n *\n * Compares the order of two [[CpNode]]s. The order is cyclic and depends\n * on a [[CpNode]]'s relative position along the shape boundary.\n */\nconst cpNodeComparator = (a, b) => (0,_contact_point_contact_point_js__WEBPACK_IMPORTED_MODULE_1__.compareCps)(a.cp, b.cp);\n/**\n * Returns the children of this [[CpNode]] when seen as a MAT edge. Only\n * children in a 'forward' direction are returned. These include all edges\n * except the 'backward' edge given by [[prevOnCircle]], even terminating\n * edges.\n */\nfunction getChildren(cpNode) {\n    const children = [];\n    const cp = cpNode.next;\n    let cp_ = cp;\n    do {\n        children.push(cp_);\n        cp_ = cp_.nextOnCircle;\n    } while (cp_.nextOnCircle !== cp);\n    return children;\n}\n/**\n * Similar to [[getChildren]] but returns the child nodes of the tree when\n * [[CpNode]] is seen as a MAT vertex point (as opposed to edge). In this\n * way the dual graph of the tree can easily be traversed - see e.g.\n * [[traverseVertices]]. Generally, however, traversing the edges is\n * preferred as it returns the entire Medial Axis (by utilizing\n * [[getCurveToNext]] on each returned edge).\n */\nfunction vertexChildren(cpNode) {\n    if (isTerminating(cpNode)) {\n        return [];\n    }\n    const children = [];\n    let cp_ = cpNode;\n    while (cp_ !== cpNode.prevOnCircle) {\n        if (!isTerminating(cp_)) {\n            children.push(cp_.next);\n        }\n        cp_ = cp_.nextOnCircle;\n    }\n    return children;\n}\n/**\n * Returns all [[CpNode]]s on the MAT that this [[CpNode]] is part of\n * starting from the current one and going anti-clockwise around the shape.\n */\nfunction getAllOnLoop(cpNode) {\n    const cpStart = cpNode;\n    const cpNodes = [cpStart];\n    let cpNode_ = cpNode.next;\n    while (cpNode_ !== cpStart) {\n        cpNodes.push(cpNode_);\n        cpNode_ = cpNode_.next;\n    }\n    return cpNodes;\n}\n/**\n * Primarily for internal use.\n *\n * Insert a [[CpNode]] into the MAT tree graph after the specified point\n * and returns the freshly inserted [[CpNode]].\n * @param isHoleClosing True if this is a hole closing contact point.\n * @param isIntersection True if this is a contact point at a shape boundary\n * intersection point.\n * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\n * @param cp [[ContactPoint]] defining the [[CpNode]].\n * @param prev_ Inserts the new [[CpNode]] right after this item if the\n * loop is not empty, else insert the new [[CpNode]] as the only item in the\n * loop.\n */\nfunction insertCpNode(isHoleClosing, isIntersection, cpTree, cp, prev_) {\n    // const cpNode = new CpNode(cp, isHoleClosing, isIntersection);\n    const cpNode = (0,_create_cp_node_js__WEBPACK_IMPORTED_MODULE_2__.createCpNode)(cp, isHoleClosing, isIntersection);\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.cpNode.push({\n            generated: _debug_.generated,\n            cpNode\n        });\n    }\n    let prev;\n    let next;\n    if (!prev_) {\n        prev = cpNode;\n        next = cpNode;\n    }\n    else {\n        prev = prev_;\n        next = prev.next;\n    }\n    next.prev = cpNode;\n    prev.next = cpNode;\n    cpNode.prev = prev;\n    cpNode.next = next;\n    cpTree.insert(cpNode);\n    return cpNode;\n}\n/**\n * Return this (except if exclThis is truthy) and the the other CpNodes\n * around the maximal disk vertex circle in an anti-clockwise order.\n * @param exclThis If true the returned array does not include this\n * [[CpNode]].\n */\nfunction getCpNodesOnCircle(cpNode, exclThis = false) {\n    // const startCp = this as CpNode;\n    const startCpNode = cpNode;\n    let cpNode_ = startCpNode;\n    const cpNodes = [];\n    do {\n        if (exclThis) {\n            exclThis = false;\n        }\n        else {\n            cpNodes.push(cpNode_);\n        }\n        cpNode_ = cpNode_.nextOnCircle;\n    } while (cpNode_ !== startCpNode);\n    return cpNodes;\n}\n/**\n * Returns true if the 2 given [[CpNode]]s are on the same maximal disk\n * circle.\n * @param cpNode1 A [[CpNode]].\n * @param cpNode2 Another [[CpNode]]\n */\nfunction isOnSameCircle(cpNode1, cpNode2) {\n    const cpNodes = getCpNodesOnCircle(cpNode1, true);\n    return cpNodes.indexOf(cpNode2) >= 0;\n}\n/**\n * Returns true if this [[CpNode]] is terminating, i.e. implies a leaf MAT\n * vertex.\n *\n * This is always the case for sharp corners and maximal disks with\n * a single contact point. Note, however, that even in these cases there are\n * two contact points stored (sitting 'on top' of each other) for the\n * maximal disk. It can be seen as a limiting case of a two-prong where the\n * distance between two of the contact points tend to zero. One point\n * (represented by a [[CpNode]] of course) will be terminating with the\n * other point being its [[next]], whereas the other point will *not* be\n * terminating and 'points' back into the shape.\n */\nfunction isTerminating(cpNode) {\n    // return this === this.next.prevOnCircle;\n    return cpNode === cpNode.next.prevOnCircle;\n}\n/**\n * Like isTerminating() but only returns true if all cpNodes on the circle\n * (except this.prevOnCircle) is terminating.\n */\nfunction isFullyTerminating(cpNode) {\n    const otherOnCircle = getCpNodesOnCircle(cpNode.prevOnCircle, true);\n    const isFullyTerminating = otherOnCircle.every(cpn => isTerminating(cpn));\n    return isFullyTerminating;\n}\n/**\n * Returns the first [[CpNode]] (from this one by successively applying\n * .nextOnCircle) that exits the circle.\n */\nfunction getFirstExit(cpNode) {\n    // const startNode = this as CpNode;\n    const startNode = cpNode;\n    let cpNode_ = startNode;\n    while (cpNode_.next === cpNode_.prevOnCircle) {\n        cpNode_ = cpNode_.next;\n        if (cpNode_ === startNode) {\n            // The very special case the MAT is a single point.\n            return undefined;\n        }\n    }\n    return cpNode_;\n}\n/**\n * Returns true if this [[CpNode]] represents a sharp corner, i.e. the\n * limiting case of a two-prong having zero radius.\n *\n * Note that two [[CpNode]]s are stored for each sharp corner, one being\n * terminating and one not. See [[isTerminating]] for more details.\n */\nfunction isSharp(cpNode) {\n    return cpNode.cp.circle.radius === 0;\n}\n/**\n * Returns the number of contact points on the maximal disk circle implied\n * by this [[CpNode]].\n *\n * Note, however, that even one-prongs and sharp corners will return 2 (see\n * [[isTerminating]] for more details); if this is not desired use\n * [[getRealProngCount]] instead which will return 1 in these cases.\n */\nfunction getProngCount(cpNode) {\n    // const startCp = this as CpNode;\n    const startCpNode = cpNode;\n    let cpNode_ = startCpNode;\n    let i = 0;\n    do {\n        i++;\n        cpNode_ = cpNode_.nextOnCircle;\n    } while (cpNode_ !== startCpNode);\n    return i;\n}\n/**\n * Returns the number of contact points (up to planar coordinates) on the\n * maximal disk circle implied by this [[CpNode]].\n *\n * See also [[getProngCount]].\n */\nfunction getRealProngCount(cpNode) {\n    if (isOneProng(cpNode)) {\n        return 1;\n    }\n    return getProngCount(cpNode);\n}\n/**\n * Returns true if this [[CpNode]]'s maximal disk has only one contact point\n * on the shape boundary (up to planar coordinates). These includes sharp\n * corners.\n *\n * Note, however, that two [[CpNode]]s are stored for each such point to\n * preserve symmetry - see [[isTerminating]] for more details.\n */\nfunction isOneProng(cpNode) {\n    const cp1 = cpNode;\n    if (cp1.cp.circle.radius === 0) {\n        return true;\n    }\n    const cp2 = cp1.nextOnCircle;\n    const p1 = cp1.cp.pointOnShape.p;\n    const p2 = cp2.cp.pointOnShape.p;\n    return (p1[0] === p2[0] && p1[1] === p2[1]);\n}\n\n//# sourceMappingURL=cp-node.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/create-cp-node.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/create-cp-node.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCpNode: () => (/* binding */ createCpNode)\n/* harmony export */ });\nfunction createCpNode(cp, isHoleClosing, isIntersection, prev = undefined, next = undefined, prevOnCircle = undefined, nextOnCircle = undefined) {\n    return {\n        cp, isHoleClosing, isIntersection,\n        prev, next, prevOnCircle, nextOnCircle\n    };\n}\n\n//# sourceMappingURL=create-cp-node.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/create-cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/enhance-cp-node.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/enhance-cp-node.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enhanceCpNode: () => (/* binding */ enhanceCpNode)\n/* harmony export */ });\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _get_cp_node_ordering_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-cp-node-ordering.js */ \"./node_modules/flo-mat/node/cp-node/get-cp-node-ordering.js\");\n\n\nfunction enhanceCpNode(cpNode) {\n    const cp = cpNode.cp;\n    const pos = cp.pointOnShape;\n    const curve = pos.curve;\n    return {\n        ...cpNode,\n        isTerminating: (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode),\n        isFullyTerminating: (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isFullyTerminating)(cpNode),\n        isSharp: (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isSharp)(cpNode),\n        prongCount: (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getProngCount)(cpNode),\n        getRealProngCount: (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getRealProngCount)(cpNode),\n        ordering: (0,_get_cp_node_ordering_js__WEBPACK_IMPORTED_MODULE_1__.getCpNodeOrdering)(cpNode),\n        curve,\n        loop: curve.loop\n    };\n}\n\n//# sourceMappingURL=enhance-cp-node.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/enhance-cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/get-boundary-bezier-parts-to-next.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/get-boundary-bezier-parts-to-next.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundaryBezierPartsToNext: () => (/* binding */ getBoundaryBezierPartsToNext)\n/* harmony export */ });\n/**\n * Returns the ordered bezier curves from this CpNode to the next CpNode\n * on the boundary.\n * @param cpNode\n */\nfunction getBoundaryBezierPartsToNext(cpNode) {\n    const cpThis = cpNode;\n    const cpNext = cpNode.next;\n    const posThis = cpThis.cp.pointOnShape;\n    const posNext = cpNext.cp.pointOnShape;\n    const curveThis = posThis.curve;\n    const curveNext = posNext.curve;\n    if (curveThis.loop !== curveNext.loop) {\n        // It is a hole-closer going over to the other loop - a kind of terminal\n        // CpNode.\n        return undefined;\n    }\n    const bezierParts = [];\n    if (curveNext === curveThis) {\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, posNext.t] });\n    }\n    else {\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, 1] });\n        addSkippedBeziers(bezierParts, posThis.curve, posNext.curve, posNext.t);\n    }\n    return bezierParts;\n}\n/**\n * @internal\n * Adds pieces of skipped beziers.\n */\nfunction addSkippedBeziers(bezierParts, curveStart, curveEnd, t1) {\n    let curveThis = curveStart;\n    do {\n        curveThis = curveThis.next;\n        const bezierPart = curveThis === curveEnd\n            ? { ps: curveThis.ps, ts: [0, t1] }\n            : { ps: curveThis.ps, ts: [0, 1] };\n        bezierParts.push(bezierPart);\n    } while (curveThis !== curveEnd);\n}\n\n//# sourceMappingURL=get-boundary-bezier-parts-to-next.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/get-boundary-bezier-parts-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/get-boundary-beziers-to-next.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/get-boundary-beziers-to-next.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundaryBeziersToNext: () => (/* binding */ getBoundaryBeziersToNext)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n// qqq import { fromTo, fromTTo1, from0ToT } from 'flo-bezier3';\n\n/**\n * Returns the ordered bezier curves from this CpNode to the next CpNode\n * on the boundary.\n * @param cpNode\n */\nfunction getBoundaryBeziersToNext(cpNode) {\n    const cpThis = cpNode;\n    const cpNext = cpNode.next;\n    const posThis = cpThis.cp.pointOnShape;\n    const posNext = cpNext.cp.pointOnShape;\n    const curveThis = posThis.curve;\n    const curveNext = posNext.curve;\n    if (curveThis.loop !== curveNext.loop) {\n        // It is a hole-closer going over to the other loop - a kind of terminal\n        // CpNode.\n        return undefined;\n    }\n    const beziers = [];\n    if (curveNext === curveThis) {\n        beziers.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(posThis.curve.ps, posThis.t, posNext.t));\n    }\n    else {\n        beziers.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(posThis.curve.ps, posThis.t, 1));\n        addSkippedBeziers(beziers, posThis.curve, posNext.curve, posNext.t);\n    }\n    return beziers;\n}\n/**\n * Adds pieces of skipped beziers.\n * @internal\n */\nfunction addSkippedBeziers(beziers, curveStart, curveEnd, t1) {\n    let curveThis = curveStart;\n    do {\n        curveThis = curveThis.next;\n        const tEnd = curveThis === curveEnd ? t1 : 1;\n        beziers.push(\n        // qqq from0ToT(curveThis.ps, tEnd) \n        (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(curveThis.ps, 0, tEnd));\n    } while (curveThis !== curveEnd);\n}\n\n//# sourceMappingURL=get-boundary-beziers-to-next.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/get-boundary-beziers-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/get-cp-node-ordering.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/get-cp-node-ordering.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCpNodeOrdering: () => (/* binding */ getCpNodeOrdering)\n/* harmony export */ });\nfunction getCpNodeOrdering(cpNode) {\n    const cp = cpNode.cp;\n    const pos = cp.pointOnShape;\n    return {\n        'idx': pos.curve.idx,\n        't': pos.t,\n        'order': cp.order,\n        'order2': cp.order2\n    };\n}\n\n//# sourceMappingURL=get-cp-node-ordering.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/get-cp-node-ordering.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/get-curve-to-next.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/get-curve-to-next.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveToNext: () => (/* binding */ getCurveToNext)\n/* harmony export */ });\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../get-curve/get-curve-between.js */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\n\n/**\n * Returns the bezier curve from the maximal disk of the given [[CpNode]] to the\n * next [[CpNode]]'s maximal disk and thus directly represents a piece of the\n * medial axis.\n * @param cpNode\n */\nfunction getCurveToNext(cpNode) {\n    return (0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_0__.getCurveBetween)(cpNode, cpNode.next);\n}\n\n//# sourceMappingURL=get-curve-to-next.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/get-curve-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/remove.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/remove.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeCpNode: () => (/* binding */ removeCpNode)\n/* harmony export */ });\n/**\n * Removes a cpNode from the MAT.\n * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\n * @param cpNode The [[CpNode]] to remove.\n */\nfunction removeCpNode(cpNode, cpTree) {\n    const prev = cpNode.prev;\n    const next = cpNode.next;\n    prev.next = next;\n    next.prev = prev;\n    const nextOpposite = next.prevOnCircle;\n    const prevOpposite = prev.nextOnCircle;\n    nextOpposite.next = prevOpposite;\n    prevOpposite.prev = nextOpposite;\n    if (cpTree) {\n        cpTree.remove(cpNode, false);\n    }\n}\n\n//# sourceMappingURL=remove.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/remove.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/traverse-cp.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/traverse-cp.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   traverseCp: () => (/* binding */ traverseCp)\n/* harmony export */ });\n/**\n * @internal\n *\n * Traverses the shape from the given `CpNode` going around the shortest path\n * so that only a piece of the shape is traversed and returns the visited\n * `CpNode`s (starting from the given `CpNode`).\n *\n * @param cpStart The `CpNode` from where to start the traversal.\n */\nfunction traverseCp(cpStart) {\n    let cpNode = cpStart;\n    if (cpNode === cpNode.next.prevOnCircle) {\n        return [cpNode]; // one-sharp corner\n    }\n    const visitedCps = [];\n    do {\n        visitedCps.push(cpNode);\n        const next = cpNode.next.prevOnCircle;\n        cpNode = cpNode === next\n            ? cpNode = cpNode.next.next // Terminal vertex\n            : cpNode = next; // Take last exit\n    } while (cpNode !== cpStart);\n    return visitedCps;\n}\n\n//# sourceMappingURL=traverse-cp.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/traverse-cp.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/traverse-edges.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/traverse-edges.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   traverseEdges: () => (/* binding */ traverseEdges)\n/* harmony export */ });\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n/**\n * Traverses all edges (depth first) of the given MAT tree starting at the given\n * vertex (represented by a [[CpNode]]).\n * @param cpNode Any [[CpNode]] representing the start vertex.\n * @param f A callback function for each CpNode representing the vertex at the\n * start of an edge.\n  */\nfunction traverseEdges(cpNode, f) {\n    // Since the tree is unrooted we must iterate in all directions from the\n    // given vertex.\n    const cps = (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getCpNodesOnCircle)(cpNode);\n    while (cps.length) {\n        const cp = cps.pop();\n        f(cp);\n        if ((0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cp)) {\n            continue;\n        }\n        cps.push(...(0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getChildren)(cp));\n    }\n}\n\n//# sourceMappingURL=traverse-edges.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/traverse-edges.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/traverse-vertices.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/traverse-vertices.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   traverseVertices: () => (/* binding */ traverseVertices)\n/* harmony export */ });\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n/**\n * Traverses the MAT tree and calls the given callback function for each vertex\n * (represented by a [[CpNode]]) on the MAT.\n *\n * It is usually preferable to use [[traverseEdges]] as it allows for the\n * traversal of all the smooth curves representing the MAT.\n * @param cpNode Any [[CpNode]] representing the start vertex.\n * @param f A callback function taking a single [[CpNode]] as parameter.\n */\nfunction traverseVertices(cpNode, f) {\n    f(cpNode);\n    // Since the tree is unrooted we must iterate in all directions from the\n    // given cpNode.\t\n    (0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getCpNodesOnCircle)(cpNode)\n        .filter(cpNode => !(0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode))\n        .map(cpNode => cpNode.next)\n        .forEach(f_);\n    function f_(cpNode) {\n        const cps = [cpNode];\n        while (cps.length) {\n            const cp = cps.pop();\n            f(cp);\n            cps.push(...(0,_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.vertexChildren)(cp));\n        }\n    }\n}\n\n//# sourceMappingURL=traverse-vertices.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/cp-node/traverse-vertices.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/curve/curve.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/curve/curve.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCorner: () => (/* reexport safe */ _corner_get_corner_js__WEBPACK_IMPORTED_MODULE_1__.getCorner),\n/* harmony export */   getCornerAtEnd: () => (/* binding */ getCornerAtEnd)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _corner_get_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../corner/get-corner.js */ \"./node_modules/flo-mat/node/corner/get-corner.js\");\n\n\n/**\n * @internal\n * Returns information about the corner created at the end of this curve\n * (at t === 1) and the start of the next curve (at t === 0).\n */\nconst getCornerAtEnd = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function (curve) {\n    const psE = curve.ps;\n    const psS = curve.next.ps;\n    return (0,_corner_get_corner_js__WEBPACK_IMPORTED_MODULE_1__.getCorner)(psE, psS);\n});\n\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/curve/curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/debug.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/debug.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableDebugForMat: () => (/* binding */ enableDebugForMat)\n/* harmony export */ });\n/* harmony import */ var _functions_general_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions/general.js */ \"./node_modules/flo-mat/node/debug/functions/general.js\");\n/* harmony import */ var _functions_two_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions/two-prong.js */ \"./node_modules/flo-mat/node/debug/functions/two-prong.js\");\n/* harmony import */ var _functions_three_prong_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions/three-prong.js */ \"./node_modules/flo-mat/node/debug/functions/three-prong.js\");\n/* harmony import */ var _functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions/draw-elem/draw-elem.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\n\n\n\n\nfunction enableDebugForMat(debugOn) {\n    if (!debugOn) {\n        window._debug_ = undefined;\n        return;\n    }\n    let debug = window._debug_;\n    debug = {\n        ...debug,\n        generated: {\n            //...debug?.generated,\n            ...(!debug ? {} : !debug.generated ? {} : debug.generated),\n            elems: {\n                //...debug?.generated?.elems,\n                ...(!debug ? {} : !debug.generated ? {} : !debug.generated.elems ? {} : debug.generated.elems),\n                oneProng: [],\n                oneProngAtDullCorner: [],\n                twoProng_regular: [],\n                twoProng_failed: [],\n                twoProng_notAdded: [],\n                twoProng_deleted: [],\n                twoProng_holeClosing: [],\n                looseBoundingBox: [],\n                tightBoundingBox: [],\n                sharpCorner: [],\n                dullCorner: [],\n                vertex: [],\n                threeProng: [],\n                boundingHull: [],\n                mat: [],\n                sat: [],\n                cpNode: [],\n                maxVertex: [],\n                leaves: [],\n                culls: [],\n            },\n            timing: {\n                //...debug?.generated?.timing,\n                ...(!debug ? {} : !debug.generated ? {} : !debug.generated.timing ? {} : debug.generated.timing),\n                holeClosers: 0,\n                oneAnd2Prongs: 0,\n                threeProngs: 0,\n                sats: 0,\n                simplifyMat: 0,\n            }\n        },\n        fs: {\n            //...debug?.fs,\n            ...(!debug ? {} : !debug.fs ? {} : debug.fs),\n            drawElem: {\n                //...debug?.fs?.drawElem,\n                ...(!debug ? {} : !debug.fs ? {} : !debug.fs.drawElem ? {} : debug.fs.drawElem),\n                ..._functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_0__.drawElemFunctions\n            },\n            ..._functions_general_js__WEBPACK_IMPORTED_MODULE_1__.generalDebugFunctions,\n            twoProng: _functions_two_prong_js__WEBPACK_IMPORTED_MODULE_2__.twoProngDebugFunctions,\n            threeProng: _functions_three_prong_js__WEBPACK_IMPORTED_MODULE_3__.threeProngDebugFunctions,\n        },\n        directives: {\n            //...debug?.directives,\n            ...(!debug ? {} : !debug.directives ? {} : debug.directives),\n            stopAfterHoleClosers: false,\n            stopAfterHoleClosersNum: undefined,\n            stopAfterTwoProngs: false,\n            stopAfterTwoProngsNum: undefined,\n            stopAfterThreeProngs: false,\n            stopAfterThreeProngsNum: undefined,\n        }\n    };\n    window._debug_ = debug;\n}\n\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   boundingHull: () => (/* binding */ boundingHull)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @internal */\nfunction boundingHull(g, hull, classes = 'thin5 black nofill', delay = 0, scaleFactor = 1) {\n    const $polygon = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, hull, classes, delay);\n    return $polygon;\n}\n\n//# sourceMappingURL=bounding-hull.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawBranch: () => (/* binding */ drawBranch)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n\n\n\n/** @internal */\nfunction drawBranch(g, branch, delay) {\n    const classes = 'thin5 purple nofill';\n    const $svgs = [];\n    let i = 0;\n    for (const cpNode of branch) {\n        if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode)) {\n            continue;\n        }\n        //let bezier = cpNode.matCurveToNextVertex;\n        const bezier = (0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_1__.getCurveToNext)(cpNode);\n        if (!bezier) {\n            continue;\n        }\n        i++;\n        $svgs.push(...flo_draw__WEBPACK_IMPORTED_MODULE_2__.drawFs.bezier(g, bezier, classes, delay));\n    }\n    return $svgs;\n}\n\n//# sourceMappingURL=branch.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   culls: () => (/* binding */ culls)\n/* harmony export */ });\n/** @internal */\nfunction culls(g, culls) {\n    const $elems = [];\n    for (const circle of culls) {\n        const p = circle.center;\n        $elems.push(drawCircle(g, p, 0.4, 'cyan thin5 nofill'));\n    }\n    return $elems;\n}\n/** @internal */\nfunction drawCircle(g, center, radiusPercent, classes) {\n    const XMLNS = 'http://www.w3.org/2000/svg';\n    const $circle = document.createElementNS(XMLNS, 'circle');\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\n    $circle.setAttributeNS(null, \"class\", classes);\n    g.appendChild($circle);\n    return $circle;\n}\n\n//# sourceMappingURL=culls.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawCirclePercent: () => (/* binding */ drawCirclePercent)\n/* harmony export */ });\n/** @internal */\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\n    const XMLNS = 'http://www.w3.org/2000/svg';\n    const $circle = document.createElementNS(XMLNS, 'circle');\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\n    $circle.setAttributeNS(null, \"class\", classes);\n    g.appendChild($circle);\n    return $circle;\n}\n\n//# sourceMappingURL=draw-circle-percent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawElemFunctions: () => (/* binding */ drawElemFunctions)\n/* harmony export */ });\n/* harmony import */ var _one_prong_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./one-prong.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js\");\n/* harmony import */ var _two_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./two-prong.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js\");\n/* harmony import */ var _three_prong_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./three-prong.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js\");\n/* harmony import */ var _vertex_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vertex.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js\");\n/* harmony import */ var _bounding_hull_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bounding-hull.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js\");\n/* harmony import */ var _loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loose-bounding-box.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js\");\n/* harmony import */ var _tight_bounding_box_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tight-bounding-box.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js\");\n/* harmony import */ var _sharp_corner_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sharp-corner.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js\");\n/* harmony import */ var _dull_corner_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dull-corner.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js\");\n/* harmony import */ var _mat_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mat.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\n/* harmony import */ var _max_vertex_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max-vertex.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js\");\n/* harmony import */ var _leaves_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./leaves.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js\");\n/* harmony import */ var _culls_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./culls.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js\");\n/* harmony import */ var _one_prong_at_dull_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./one-prong-at-dull-corner.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** @internal */\nfunction notImplementedYet(g, elem) {\n    return [];\n}\n/** @internal */\nconst drawElemFunctions = {\n    oneProng: _one_prong_js__WEBPACK_IMPORTED_MODULE_0__.drawOneProng,\n    oneProngAtDullCorner: _one_prong_at_dull_corner_js__WEBPACK_IMPORTED_MODULE_1__.oneProngAtDullCorner,\n    twoProng_regular: _two_prong_js__WEBPACK_IMPORTED_MODULE_2__.twoProng,\n    twoProng_failed: _two_prong_js__WEBPACK_IMPORTED_MODULE_2__.twoProng,\n    twoProng_notAdded: _two_prong_js__WEBPACK_IMPORTED_MODULE_2__.twoProng,\n    twoProng_deleted: _two_prong_js__WEBPACK_IMPORTED_MODULE_2__.twoProng,\n    twoProng_holeClosing: _two_prong_js__WEBPACK_IMPORTED_MODULE_2__.twoProng,\n    threeProng: _three_prong_js__WEBPACK_IMPORTED_MODULE_3__.threeProng,\n    //minY,\n    boundingHull: _bounding_hull_js__WEBPACK_IMPORTED_MODULE_4__.boundingHull,\n    looseBoundingBox: _loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__.looseBoundingBox,\n    tightBoundingBox: _tight_bounding_box_js__WEBPACK_IMPORTED_MODULE_6__.tightBoundingBox,\n    sharpCorner: _sharp_corner_js__WEBPACK_IMPORTED_MODULE_7__.sharpCorner,\n    dullCorner: _dull_corner_js__WEBPACK_IMPORTED_MODULE_8__.dullCorner,\n    vertex: _vertex_js__WEBPACK_IMPORTED_MODULE_9__.vertex,\n    mat: (0,_mat_js__WEBPACK_IMPORTED_MODULE_10__.drawMat)('mat'),\n    sat: (0,_mat_js__WEBPACK_IMPORTED_MODULE_10__.drawMat)('sat'),\n    //loop,\n    //loops,\n    maxVertex: _max_vertex_js__WEBPACK_IMPORTED_MODULE_11__.maxVertex,\n    leaves: _leaves_js__WEBPACK_IMPORTED_MODULE_12__.leaves,\n    culls: _culls_js__WEBPACK_IMPORTED_MODULE_13__.culls,\n    cpNode: notImplementedYet\n};\n\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dullCorner: () => (/* binding */ dullCorner)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @internal */\nfunction dullCorner(g, curve, classes = 'orange', delay = 0, scaleFactor = 1) {\n    const ps = curve.ps;\n    const p = curve.ps[ps.length - 1];\n    const $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, p, 0.1 * 0.5 * scaleFactor, classes, delay);\n    return $pos;\n}\n\n//# sourceMappingURL=dull-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   leaves: () => (/* binding */ leaves)\n/* harmony export */ });\n/* harmony import */ var _draw_circle_percent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-circle-percent.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js\");\n\n/** @internal */\nfunction leaves(g, leaves) {\n    const $elems = [];\n    for (const cpNode of leaves) {\n        const cp = cpNode.cp;\n        const p = cp.circle.center;\n        $elems.push((0,_draw_circle_percent_js__WEBPACK_IMPORTED_MODULE_0__.drawCirclePercent)(g, p, 0.5, 'pinker thin5 nofill'));\n    }\n    return $elems;\n}\n\n//# sourceMappingURL=leaves.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   looseBoundingBox: () => (/* binding */ looseBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @internal */\nfunction looseBoundingBox(g, box, classes = 'thin5 brown nofill', delay = 0, scaleFactor = 1) {\n    const [[x0, y0], [x1, y1]] = box;\n    box = [[x0, y0], [x1, y0], [x1, y1], [x0, y1]];\n    const $box = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, box, classes, delay);\n    return $box;\n}\n\n//# sourceMappingURL=loose-bounding-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawMat: () => (/* binding */ drawMat)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var _cp_node_traverse_edges_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../cp-node/traverse-edges.js */ \"./node_modules/flo-mat/node/cp-node/traverse-edges.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n\n\n\n/** @internal */\nfunction drawMat(type) {\n    const classes = type === 'mat'\n        ? 'thin5 purple nofill'\n        : 'thin10 red nofill';\n    return (g, mat, classes_, delay = 0, scaleFactor = 1) => {\n        const cpNode = mat.cpNode;\n        // if (!cpNode) { return undefined; }\n        if (!cpNode) {\n            return [];\n        }\n        const $svgs = [];\n        let i = 0;\n        (0,_cp_node_traverse_edges_js__WEBPACK_IMPORTED_MODULE_0__.traverseEdges)(cpNode, cpNode => {\n            if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.isTerminating)(cpNode)) {\n                return;\n            }\n            const bezier = (0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__.getCurveToNext)(cpNode);\n            if (!bezier) {\n                return;\n            }\n            i++;\n            $svgs.push(...flo_draw__WEBPACK_IMPORTED_MODULE_3__.drawFs.bezier(g, bezier, classes, delay));\n        });\n        return $svgs;\n    };\n}\n\n//# sourceMappingURL=mat.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maxVertex: () => (/* binding */ maxVertex)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @internal */\nfunction maxVertex(g, cpNode) {\n    const circle = cpNode.cp.circle;\n    const $elems = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'brown thin10 nofill');\n    return $elems;\n}\n\n//# sourceMappingURL=max-vertex.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   oneProngAtDullCorner: () => (/* binding */ oneProngAtDullCorner)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var _point_on_shape_get_osculating_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../point-on-shape/get-osculating-circle.js */ \"./node_modules/flo-mat/node/point-on-shape/get-osculating-circle.js\");\n\n\n/** @hidden */\nfunction oneProngAtDullCorner(g, pos, classes, delay = 1000, scaleFactor = 1) {\n    //let oCircle = PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\n    const oCircle = (0,_point_on_shape_get_osculating_circle_js__WEBPACK_IMPORTED_MODULE_0__.getOsculatingCircle)(Number.POSITIVE_INFINITY, pos);\n    const $center = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, pos.p, 0.1, 'orange');\n    const $circle = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, oCircle.center, 0.25, 'orange');\n    const $pos = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.circle(g, oCircle, 'orange thin10 nofill');\n    return [...$center, ...$circle, ...$pos];\n}\n\n//# sourceMappingURL=one-prong-at-dull-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawOneProng: () => (/* binding */ drawOneProng)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @hidden */\nfunction drawOneProng(g, cpNodes, classes, delay = 0, scaleFactor = 1) {\n    const cp = cpNodes[0].cp;\n    const { circle, pointOnShape: pos } = cp;\n    const $center = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, pos.p, 0.02 * scaleFactor, 'deeppink', delay);\n    const $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.05 * scaleFactor, 'deeppink', delay);\n    const $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'deeppink thin5 nofill', delay);\n    return [...$center, ...$circle, ...$pos];\n}\n\n//# sourceMappingURL=one-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sharpCorner: () => (/* binding */ sharpCorner)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @internal */\nfunction sharpCorner(g, curve, classes = 'green', delay = 0, scaleFactor = 1) {\n    const p = curve.ps[curve.ps.length - 1];\n    const $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, p, 0.6 * scaleFactor, 'green', delay);\n    return $pos;\n}\n\n//# sourceMappingURL=sharp-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   threeProng: () => (/* binding */ threeProng)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var _geometry_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../geometry/circle.js */ \"./node_modules/flo-mat/node/geometry/circle.js\");\n\n\n/** @internal */\nfunction threeProng(g, threeProng, classes, delay = 0, scaleFactor = 1) {\n    const circle = (0,_geometry_circle_js__WEBPACK_IMPORTED_MODULE_0__.scaleCircle)(threeProng.circle, 1);\n    const poss = threeProng.poss;\n    const $cp1 = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, poss[0].p, 0.01 * 1 * scaleFactor, 'blue', delay);\n    const $cp2 = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, poss[1].p, 0.01 * 2 * scaleFactor, 'blue', delay);\n    const $cp3 = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, poss[2].p, 0.01 * 3 * scaleFactor, 'blue', delay);\n    const $center = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, circle.center, 0.03 * scaleFactor, 'blue', delay);\n    const $circle = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.circle(g, circle, 'blue thin2 nofill', delay);\n    return [...$center, ...$cp1, ...$cp2, ...$cp3, ...$circle];\n}\n\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tightBoundingBox: () => (/* binding */ tightBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n\n/** @internal */\nfunction tightBoundingBox(g, box, classes = 'thin5 pinker nofill', delay = 0, scaleFactor = 1) {\n    const $box = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, box, 'thin5 pinker nofill', delay);\n    return $box;\n}\n\n//# sourceMappingURL=tight-bounding-box.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoProng: () => (/* binding */ twoProng)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var _mat_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../mat/get-two-prong-type.js */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\n\n\n/** @internal */\nfunction twoProng(g, twoProng, classes, delay = 0, scaleFactor = 1) {\n    let $failedDot = [];\n    let $center = [];\n    let $circle = [];\n    let $cp1 = [];\n    let $cp2 = [];\n    let color;\n    let thin;\n    switch ((0,_mat_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_0__.getTwoProngType)(twoProng)) {\n        case 'twoProng_regular': {\n            color = 'red ';\n            thin = '2';\n            break;\n        }\n        case 'twoProng_holeClosing': {\n            color = 'cyan ';\n            thin = '10';\n            break;\n        }\n    }\n    if (twoProng.failed) {\n        $failedDot = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black', delay);\n    }\n    else if (!twoProng.failed) {\n        $center = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, twoProng.circle.center, 0.01 * scaleFactor, 'yellow', delay);\n        $circle = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.circle(g, twoProng.circle, color + 'thin' + thin + ' nofill', delay);\n        $cp1 = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, twoProng.pos.p, 0.0175 * scaleFactor, color, delay);\n        $cp2 = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.dot(g, twoProng.z, 0.035 * scaleFactor, color, delay);\n    }\n    return [...$failedDot, ...$center, ...$circle, ...$cp1, ...$cp2];\n}\n\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertex: () => (/* binding */ vertex)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n\n/** @internal */\nfunction vertex(g, cpNode, classes, delay, /*\nvisible = true*/ scaleFactor = 1) {\n    // const visibleClass = visible ? '' : ' invisible';\n    const circle = cpNode.cp.circle;\n    const THIN = 'thin20';\n    const cps = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getCpNodesOnCircle)(cpNode);\n    console.log(cps);\n    let $svgs = [];\n    const $circle = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.circle(g, circle, 'red ' + THIN + ' nofill ' /* + visibleClass*/, delay);\n    const $crossHair = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.crossHair(g, circle.center, 'red ' + THIN + ' nofill ' /* + visibleClass*/, 3, delay);\n    $svgs = [...$circle, ...$crossHair];\n    for (let i = 0; i < cps.length; i++) {\n        const cp = cps[i];\n        const edgeCircle = cp.next.cp.circle;\n        const $circle = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.circle(g, edgeCircle, 'pink ' + THIN + ' nofill ' /* + visibleClass*/, delay);\n        const $crossHair = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.crossHair(g, edgeCircle.center, 'pink ' + THIN + ' nofill ' /* + visibleClass*/, 3, delay);\n        $svgs.push(...$circle, ...$crossHair);\n        const p1 = circle.center;\n        const p2 = edgeCircle.center;\n        const thin = i === 0 ? 'thin10' : (i === 1 ? 'thin20' : 'thin35');\n        const $line = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.line(g, [p1, p2], 'yellow ' + thin + ' nofill ' /* + visibleClass*/, delay);\n        $svgs.push(...$line);\n    }\n    return $svgs;\n}\n\n//# sourceMappingURL=vertex.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/general.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/general.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generalDebugFunctions: () => (/* binding */ generalDebugFunctions)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_pos_to_human_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../point-on-shape/pos-to-human-string.js */ \"./node_modules/flo-mat/node/point-on-shape/pos-to-human-string.js\");\n\n/** @internal */\nlet i = 0;\n/**\n * @internal\n * Name the given object - for debugging purposes only\n */\nfunction nameObj(o, pre = '') {\n    o.name = '' + pre + i++;\n}\n/**\n * @internal\n * Transforms a boundary piece (δ) into a human readable string.\n * @param cpNodes A boundary piece given by two CpNodes.\n */\nfunction δToString(cpNodes) {\n    return cpNodes.map(cpNode => (0,_point_on_shape_pos_to_human_string_js__WEBPACK_IMPORTED_MODULE_0__.posToHumanString)(cpNode.cp.pointOnShape));\n}\n/**\n * @internal\n * Transforms an array of boundary pieces (δs) into a human readable string.\n * @param cpNodes An array of boundary pieces.\n */\nfunction δsToString(cpNodes) {\n    return cpNodes.map(δToString);\n}\n/**\n * @internal\n * Convert the given points into a human readable string.\n * @param ps\n */\nfunction pointsToStr(ps, decimalPlaces = 3) {\n    return ps.map(p => pointToStr(p, decimalPlaces));\n}\n/**\n * @internal\n * Converts the given point into a human readable string.\n * @param p The point\n * @param decimalPlaces number of decimal places\n */\nfunction pointToStr(p, decimalPlaces = 3) {\n    return p[0].toFixed(decimalPlaces) + ', ' + p[1].toFixed(decimalPlaces);\n}\n/** @internal */\nconst generalDebugFunctions /*: IGeneralDebugFunctions*/ = {\n    δToString,\n    δsToString,\n    pointToStr,\n    pointsToStr,\n    nameObj,\n};\n\n//# sourceMappingURL=general.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/general.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/three-prong.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/three-prong.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   threeProngDebugFunctions: () => (/* binding */ threeProngDebugFunctions)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n\n\n/**\n * @internal\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\n * @param n - The 3-prong's zero-based index.\n */\nfunction drawSpokes(g, n) {\n    const threeProng = _debug_.generated.elems.threeProng[n];\n    const cc = threeProng.circle.center;\n    const poss = threeProng.poss;\n    for (let i = 0; i < poss.length; i++) {\n        const pos = poss[i];\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [pos.p, cc], 'thin5 red');\n    }\n}\n/**\n * @internal\n * Shows the circle for each boundary iteration.\n * @param n_ - The 3-prong's zero-based index. If ommitted, all will be shown.\n * @param idx - The specific boundary iteration index to view. If ommitted, all\n * will be shown.\n */\nfunction traceConvergence(g, n_, idx) {\n    let sIndx;\n    let eIndx;\n    if (n_ === undefined) {\n        sIndx = 0;\n        eIndx = _debug_.generated.elems.threeProng.length;\n    }\n    else {\n        sIndx = n_;\n        eIndx = n_ + 1;\n    }\n    for (let n = sIndx; n < eIndx; n++) {\n        const forDebugging = _debug_.generated.elems.threeProng[n];\n        //const g = forDebugging.generated.g;\n        console.log(forDebugging);\n        const candidateThreeProngs = forDebugging.candidateThreeProngs;\n        //-----------------------------\n        //---- Get start and end index\n        //-----------------------------\n        let startIndx;\n        let endIndx;\n        if (n_ === undefined || idx === -1) {\n            startIndx = forDebugging.bestIndx;\n            endIndx = forDebugging.bestIndx + 1;\n        }\n        else {\n            if (idx === undefined) {\n                startIndx = 0;\n                endIndx = candidateThreeProngs.length;\n            }\n            else {\n                startIndx = idx;\n                endIndx = idx + 1;\n            }\n        }\n        //---------------------------------\n        //---- Draw candidate three-prongs\n        //---------------------------------\n        for (let i = startIndx; i < endIndx; i++) {\n            const circle = candidateThreeProngs[i].circle;\n            if (forDebugging.bestIndx === i) {\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.2, 'green');\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'black thin10 nofill');\n            }\n            else {\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.2, 'cyan');\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'cyan thin5 nofill');\n            }\n        }\n    }\n}\n/**\n * @internal\n * Shows the actual boundary for each iteration.\n * @param n The 3-prong's zero-based index.\n * @param idx The specific boundary iteration index to view. If ommitted will\n * show all.\n */\nfunction showBoundary(g, n, idx) {\n    const debugInfo = _debug_.generated.elems.threeProng[n];\n    //const g = debugInfo.generated.g;\n    const candidateThreeProngs = debugInfo.candidateThreeProngs;\n    const startIndx = idx === undefined ? 0 : idx;\n    const endIndx = idx === undefined ? candidateThreeProngs.length : idx;\n    // Draw relevant δs\n    const cpss = debugInfo.cpss;\n    let j = 0;\n    // For each iteration of δ3s (indexed by j)\n    for (let idx = 1; idx < cpss.length - 1; idx++) {\n        if (!(j >= startIndx && j <= endIndx)) {\n            j++;\n            continue;\n        }\n        const δ3s = [\n            cpss[0],\n            cpss[idx],\n            cpss[cpss.length - 1]\n        ];\n        // For each of the 3 δs\n        for (let i = 0; i < 3; i++) {\n            const δ = δ3s[i];\n            const δS = δ[0]; // Delta Start\n            const δE = δ[1]; // Delta End\n            const posS = δS.cp.pointOnShape;\n            const posE = δE.cp.pointOnShape;\n            const pS = posS.p;\n            const pE = posE.p;\n            const r = 1 + (i * 0.5);\n            if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.equal)(pS, pE)) {\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, pS, 'red thin10 nofill', r);\n            }\n            else {\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, pS, 'green thin10 nofill', r);\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, pE, 'blue thin10 nofill', r);\n            }\n        }\n        j++;\n    }\n}\n/**\n * @internal\n * @param n The 3-prong's zero-based index.\n */\nfunction logδs(n) {\n    const threeProng = _debug_.generated.elems.threeProng[n];\n    console.log(threeProng.cpss);\n}\n/**\n * @internal\n * @param p\n */\nfunction logNearest(showSpokes = true, showTrace = true, showBoundaries = true) {\n    return function (g, p, showDelay = 1000) {\n        const generated = _debug_.generated;\n        const threeProng = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.getObjClosestTo)(p, generated.elems.threeProng, threeProng => threeProng.circle ? threeProng.circle.center : [0, 0]);\n        const circle = threeProng.circle;\n        //const g = threeProng.generated.g;\n        console.log(threeProng);\n        const circle2 = {\n            center: circle.center,\n            radius: circle.radius || 1\n        };\n        //const draw = _debug_.fs.draw;\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle2, 'blue thin10 nofill', showDelay);\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, circle.center, 'red thin2 nofill', 2, showDelay);\n        if (showSpokes) {\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [threeProng.poss[0].p, circle.center], 'blue thin5 nofill', showDelay);\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [threeProng.poss[1].p, circle.center], 'blue thin5 nofill', showDelay);\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [threeProng.poss[2].p, circle.center], 'blue thin5 nofill', showDelay);\n        }\n        if (showBoundaries) {\n            const boundaries = threeProng.boundaries;\n            const boundaryS = boundaries[0];\n            const boundaryE = boundaries[boundaries.length - 1];\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.beziers(g, boundaryS, 'red thin20 nofill', showDelay);\n            for (let i = 1; i < boundaries.length - 1; i++) {\n                const boundary = boundaries[i];\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.beziers(g, boundary, 'green thin20 nofill', showDelay);\n            }\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.beziers(g, boundaryE, 'blue thin20 nofill', showDelay);\n        }\n        if (showTrace) {\n            const traces = threeProng.traces;\n            for (const trace of traces) {\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polyline(g, trace, 'red thin5 nofill', showDelay);\n            }\n        }\n    };\n}\n/** @internal */\nconst threeProngDebugFunctions = {\n    drawSpokes,\n    traceConvergence,\n    showBoundary,\n    logδs,\n    logNearest\n};\n\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/two-prong.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/two-prong.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twoProngDebugFunctions: () => (/* binding */ twoProngDebugFunctions)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/draw-fs.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n\n\n/**\n * @internal\n */\nfunction logδ(n, type = 'twoProng_regular') {\n    const δ = _debug_.generated.elems[type][n].δ;\n    console.log(δ);\n}\n/**\n * @internal\n */\nfunction log(n, type = 'twoProng_regular') {\n    const twoProng = _debug_.generated.elems[type][n];\n    console.log(twoProng);\n}\n/**\n * @internal\n */\nfunction drawNormal(g, twoProng, showDelay = 1000) {\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [twoProng.pos.p, twoProng.circle.center], 'thin10 blue', showDelay);\n}\n/**\n * @internal\n */\nfunction logδBasic(n, type = 'twoProng_regular') {\n    const delta = _debug_.generated.elems[type][n].δ;\n    function logδBasic_(x) {\n        const pos = x.cp.pointOnShape;\n        return {\n            bez: pos.curve.ps,\n            t: pos.t\n        };\n    }\n    console.log(logδBasic_(delta[0]));\n    console.log(logδBasic_(delta[1]));\n}\n/**\n * @internal\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\n * @param n - The 3-prong's zero-based index.\n */\nfunction drawSpokes(g, twoProng, showDelay = 1000) {\n    const cc = twoProng.circle.center;\n    const { pos, circle, cpNode, xs, z, δ } = twoProng;\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [pos.p, cc], 'thin5 red', showDelay);\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [z, cc], 'thin5 red', showDelay);\n}\n/**\n * @internal\n */\nfunction logNearest(showSpokes, showTrace, showBoundaries) {\n    return (g, p, showDelay = 1000, scale = 1) => {\n        const closestPerLoops = [];\n        const generated = _debug_.generated;\n        const twoProng = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.getObjClosestTo)(p, \n        // generated.elems[type], \n        generated.elems['twoProng_regular'], twoProng => twoProng.circle.center);\n        closestPerLoops.push(twoProng);\n        console.log(twoProng);\n        let n;\n        //for (let i=0; i<_debug_.generated.elems[type].length; i++) {\n        //\tconst twoProng_ = _debug_.generated.elems[type][i];\n        for (let i = 0; i < _debug_.generated.elems['twoProng_regular'].length; i++) {\n            const twoProng_ = _debug_.generated.elems['twoProng_regular'][i];\n            if (twoProng_ === twoProng) {\n                n = i;\n                break;\n            }\n        }\n        if (showSpokes) {\n            drawSpokes(g, twoProng, showDelay);\n        }\n        if (n !== undefined && showTrace) {\n            traceConvergence(g, twoProng, showDelay, scale);\n        }\n    };\n}\n/**\n * @internal\n * @param n - The 2-prong's zero-based index.\n * @param range\n */\nfunction traceConvergence(g, twoProng, showDelay = 1000, scale = 1) {\n    const xs = twoProng.xs;\n    console.log(twoProng);\n    console.log(twoProng.xs.map(x => ({\n        x: x.x,\n        y: x.y,\n        z: x.z,\n        d: x.z ? (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.squaredDistanceBetween)(x.y.p, x.z.p) : 0,\n        t: x.t,\n    })));\n    console.log(xs.length);\n    for (let i = 0; i < xs.length; i++) {\n        const x = twoProng.xs[i];\n        const circle = { center: x.x, radius: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.distanceBetween)(x.x, x.y.p) };\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, x.x, 'red thin10 nofill', 0.002 * scale, showDelay);\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'blue thin10 nofill', showDelay);\n        if (x.z !== undefined) {\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, x.z.p, 'yellow thin10 nofill', 0.001 * scale, showDelay);\n        }\n    }\n    // twoProngDebugFunctions.drawNormal(g, twoProng, showDelay);\n}\n/** @internal */\nconst twoProngDebugFunctions = {\n    logδ,\n    log,\n    drawNormal,\n    logδBasic,\n    traceConvergence,\n    logNearest,\n};\n\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/functions/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/three-prong-for-debugging.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/three-prong-for-debugging.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyThreeProngForDebugging: () => (/* binding */ createEmptyThreeProngForDebugging)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_pos_to_human_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/pos-to-human-string.js */ \"./node_modules/flo-mat/node/point-on-shape/pos-to-human-string.js\");\n\nfunction createEmptyThreeProngForDebugging() {\n    return {\n        generated: undefined,\n        circle: undefined,\n        poss: undefined,\n        cp3ss: undefined,\n        cpss: undefined,\n        bestIndx: undefined,\n        candidateThreeProngs: undefined,\n        visitedCps: undefined,\n        boundaries: undefined,\n        traces: undefined,\n    };\n}\nfunction cpsSimple(threeProngForDebugging) {\n    return threeProngForDebugging.cpss.map(δ => [(0,_point_on_shape_pos_to_human_string_js__WEBPACK_IMPORTED_MODULE_0__.posToHumanString)(δ[0].cp.pointOnShape),\n        (0,_point_on_shape_pos_to_human_string_js__WEBPACK_IMPORTED_MODULE_0__.posToHumanString)(δ[1].cp.pointOnShape)]);\n}\n\n//# sourceMappingURL=three-prong-for-debugging.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/debug/three-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/error-analysis/gamma.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-mat/node/error-analysis/gamma.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"γ\": () => (/* binding */ γ),\n/* harmony export */   \"γγ\": () => (/* binding */ γγ)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\nconst uu = u * u;\n/**\n * The canonical floating point error function, γ.\n *\n * * roughly `=== n * (Number.EPSILON / 2)`\n * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)\n * @param n the parameter - typically a small positive integer, e.g. for\n * polynomial evaluation this === 2*d + 1, where d is the degree of the\n * polynomial\n *\n * @doc\n */\nfunction γ(n) {\n    const nu = n * u;\n    return nu / (1 - nu);\n}\n/**\n * The canonical, once compensated (implying double-double precision),\n * floating point error function.\n *\n * * roughly `=== n * (Number.EPSILON / 2)**2`\n * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)\n * @param n the parameter - typically a small positive integer, e.g. for\n * polynomial evaluation this === 2*d + 1, where d is the degree of the\n * polynomial\n *\n * @doc\n */\nfunction γγ(n) {\n    const nuu = n * uu;\n    return nuu / (1 - nuu);\n}\n\n//# sourceMappingURL=gamma.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/error-analysis/gamma.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/add-1-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/add-1-prong.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add1Prong: () => (/* binding */ add1Prong)\n/* harmony export */ });\n/* harmony import */ var _mat_add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mat/add-to-cp-graph.js */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\n/* harmony import */ var _mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mat/is-another-cp-closeby.js */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\n/* harmony import */ var _point_on_shape_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/is-pos-dull-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js\");\n/* harmony import */ var _point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point-on-shape/calc-pos-order.js */ \"./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js\");\n\n\n\n\n/**\n * @hidden\n * Add a 1-prong to the MAT.\n * @param cpGraphs\n * @param pos\n */\nfunction add1Prong(radius, center, cpGraphs, pos) {\n    //if (PointOnShape.isDullCorner(pos)) {\n    if ((0,_point_on_shape_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_0__.isPosDullCorner)(pos)) {\n        // This is a 1-prong at a dull corner.\n        // TODO IMPORTANT \n        // Remove this line, uncomment piece below it and implement the \n        // following strategy to find the 3-prongs: if deltas are conjoined due \n        // to dull corner, split the conjoinment by inserting successively \n        // closer (binary division) 2-prongs. If a 2-prong actually fails, \n        // simply remove the 1-prong at the dull corner. In this way **all** \n        // terminal points are found, e.g. zoom in on top left leg of ant.\n        // Afterthought: there is a better way - split points by two prongs.\n        //toRemove.push(posNode); // this!\n        if (typeof _debug_ !== 'undefined') {\n            // _debug_.generated.elems.oneProngAtDullCorner.push(pos);\n        }\n        return;\n    }\n    // const circle = getOsculatingCircle(maxOsculatingCircleRadius, pos);\n    const circle = { radius, center };\n    const order = (0,_point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__.calcPosOrder)(circle, pos);\n    // Make sure there isn't already a ContactPoint close by - it can cause\n    // floating point stability issues.\n    if ((0,_mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__.isAnotherCpCloseby)(cpGraphs, pos, circle, order, 0, 1000)) {\n        return;\n    }\n    const cpNodes = (0,_mat_add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_3__.addToCpGraph)(circle, [-0.5, +0.5], cpGraphs, [pos, pos]);\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.oneProng.push(cpNodes);\n    }\n}\n\n//# sourceMappingURL=add-1-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/add-1-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/add-2-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/add-2-prong.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add2Prong: () => (/* binding */ add2Prong)\n/* harmony export */ });\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point-on-shape/calc-pos-order.js */ \"./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n/* harmony import */ var _mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mat/is-another-cp-closeby.js */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\n/* harmony import */ var _mat_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mat/get-neighboring-cps.js */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\n\n\n\n\n\n/**\n * @internal\n * Adds a 2-prong contact circle to the shape.\n * @param cpGraphs\n * @param circle Circle containing the 2 contact points\n * @param posSource The source point on shape\n * @param posAntipode The found antipodal point on shape\n * @param holeClosing True if this is a hole-closing 2-prong, false otherwise\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction add2Prong(cpGraphs, circle, posSource, posAntipodes, holeClosing, extreme) {\n    let t_s = posSource.t;\n    if (t_s === 0) {\n        t_s = 1;\n        posSource = (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_0__.createPos)(posSource.curve.prev, t_s, true);\n    }\n    const orderSource = (0,_point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__.calcPosOrder)(circle, posSource);\n    const orderAntipodes = posAntipodes.map(posAntipode => (0,_point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__.calcPosOrder)(circle, posAntipode));\n    // Make sure there isn't already a ContactPoint close by - it can cause\n    // floating point stability issues.\n    let isCloseByAntipodes = false;\n    for (let i = 0; i < posAntipodes.length; i++) {\n        const posAntipode = posAntipodes[i];\n        const orderAntipode = orderAntipodes[i];\n        if (!!(0,_mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__.isAnotherCpCloseby)(cpGraphs, posAntipode, circle, orderAntipode, 0, extreme)) {\n            isCloseByAntipodes = true;\n            break;\n        }\n    }\n    if (!!(0,_mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__.isAnotherCpCloseby)(cpGraphs, posSource, circle, orderSource, 0, extreme) ||\n        isCloseByAntipodes) {\n        if (typeof _debug_ !== 'undefined') {\n            if (holeClosing) {\n                _debug_.generated.elems['twoProng_holeClosing'].pop();\n            }\n            else {\n                _debug_.generated.elems['twoProng_regular'].pop();\n            }\n        }\n        return;\n    }\n    // Antipode\n    const newCpAntipodes = [];\n    const cpAntipodes = [];\n    const cpTreeAntipodes = [];\n    const deltaAntipodes = [];\n    const loopAntipodes = [];\n    for (let i = 0; i < posAntipodes.length; i++) {\n        const posAntipode = posAntipodes[i];\n        const orderAntipode = orderAntipodes[i];\n        const cpAntipode = {\n            pointOnShape: posAntipode, circle, order: orderAntipode, order2: 0\n        };\n        cpAntipodes.push(cpAntipode);\n        const loopAntipode = posAntipode.curve.loop;\n        loopAntipodes.push(loopAntipode);\n        const cpTreeAntipode = cpGraphs.get(loopAntipode);\n        cpTreeAntipodes.push(cpTreeAntipode);\n        const deltaAntipode = (0,_mat_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_3__.getNeighbouringPoints)(cpTreeAntipode, posAntipode, orderAntipode, 0);\n        deltaAntipodes.push(deltaAntipode);\n        newCpAntipodes.push((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_4__.insertCpNode)(holeClosing, false, cpTreeAntipode, cpAntipode, deltaAntipode[0]));\n    }\n    // Source\n    const cpSource = { pointOnShape: posSource, circle, order: orderSource, order2: 0 };\n    const loopSource = posSource.curve.loop;\n    const cpTreeSource = cpGraphs.get(loopSource);\n    const deltaSource = (0,_mat_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_3__.getNeighbouringPoints)(cpTreeSource, posSource, orderSource, 0);\n    const newCpSource = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_4__.insertCpNode)(holeClosing, false, cpTreeSource, cpSource, deltaSource[0]);\n    // Connect graph\n    if (newCpAntipodes.length === 1) {\n        newCpSource.prevOnCircle = newCpAntipodes[0];\n        newCpSource.nextOnCircle = newCpAntipodes[0];\n        newCpAntipodes[0].prevOnCircle = newCpSource;\n        newCpAntipodes[0].nextOnCircle = newCpSource;\n    }\n    else {\n        const cpNodes = newCpAntipodes.slice();\n        cpNodes.push(newCpSource);\n        // Order points according to their angle with the x-axis\n        cpNodes.sort(byAngle(circle));\n        for (let i = 0; i < cpNodes.length; i++) {\n            const iNext = (i + 1 === cpNodes.length) ? 0 : i + 1;\n            const iPrev = (i === 0) ? cpNodes.length - 1 : i - 1;\n            const cpNodeCurr = cpNodes[i];\n            const cpNodeNext = cpNodes[iNext];\n            const cpNodePrev = cpNodes[iPrev];\n            cpNodeCurr.nextOnCircle = cpNodeNext;\n            cpNodeCurr.prevOnCircle = cpNodePrev;\n        }\n    }\n    if (holeClosing) {\n        // TODO - take care of case where there are more than 1 antipode\n        // Duplicate ContactPoints\n        const cpB2 = { pointOnShape: posAntipodes[0], circle, order: cpAntipodes[0].order, order2: +1 };\n        const newCpB2Node = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_4__.insertCpNode)(true, false, cpTreeAntipodes[0], cpB2, newCpAntipodes[0]);\n        const cpB1 = { pointOnShape: posSource, circle, order: cpSource.order, order2: -1 };\n        const newCpB1Node = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_4__.insertCpNode)(true, false, cpTreeSource, cpB1, newCpSource.prev);\n        // Connect graph\n        newCpB1Node.prevOnCircle = newCpB2Node;\n        newCpB1Node.nextOnCircle = newCpB2Node;\n        newCpB2Node.prevOnCircle = newCpB1Node;\n        newCpB2Node.nextOnCircle = newCpB1Node;\n        newCpAntipodes[0].next = newCpSource;\n        newCpSource.prev = newCpAntipodes[0];\n        newCpB1Node.next = newCpB2Node;\n        newCpB2Node.prev = newCpB1Node;\n    }\n    if (typeof _debug_ !== 'undefined') {\n        let elems;\n        if (holeClosing) {\n            elems = _debug_.generated.elems['twoProng_holeClosing'];\n        }\n        else {\n            elems = _debug_.generated.elems['twoProng_regular'];\n        }\n        const elem = elems[elems.length - 1];\n        if (!newCpSource) {\n            console.log('asas');\n        }\n        elem.cpNode = newCpSource;\n    }\n    return newCpSource;\n}\n/** @internal */\nfunction byAngle(circle) {\n    const c = circle.center;\n    return function (_a, _b) {\n        let a = _a.cp.pointOnShape.p;\n        let b = _b.cp.pointOnShape.p;\n        // Move onto origin\n        a = [a[0] - c[0], a[1] - c[1]];\n        b = [b[0] - c[0], b[1] - c[1]];\n        const a_ = Math.atan2(a[1], a[0]);\n        const b_ = Math.atan2(b[1], b[0]);\n        return b_ - a_;\n    };\n}\n\n//# sourceMappingURL=add-2-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/add-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/add-debug-info.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/add-debug-info.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDebugInfo: () => (/* binding */ addDebugInfo)\n/* harmony export */ });\n/* harmony import */ var _mat_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mat/get-two-prong-type.js */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\n\n/** @internal */\nfunction addDebugInfo(bezierPieces, failed, x, y, z, circle, δ, xs, holeClosing) {\n    xs.push({ x, y, z, t: y.t });\n    const twoProng = {\n        generated: _debug_.generated,\n        bezierPieces,\n        pos: y,\n        δ,\n        z: z ? z.p : undefined,\n        circle,\n        xs,\n        failed,\n        holeClosing,\n        notAdded: false,\n        deleted: false,\n        cpNode: undefined\n    };\n    const twoProngType = (0,_mat_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_0__.getTwoProngType)(twoProng);\n    _debug_.generated.elems[twoProngType].push(twoProng);\n}\n\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/cull-bezier-pieces.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/cull-bezier-pieces.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cullBezierPieces2: () => (/* binding */ cullBezierPieces2)\n/* harmony export */ });\n/* harmony import */ var _geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/get-closest-square-distance-to-rect.js */ \"./node_modules/flo-mat/node/geometry/get-closest-square-distance-to-rect.js\");\n/* harmony import */ var _geometry_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/get-bounding-box-.js */ \"./node_modules/flo-mat/node/geometry/get-bounding-box-.js\");\n\n\n/**\n * @internal\n * Cull all bezierPieces not within given radius of a given point.\n * @param extreme\n * @param bezierPieces\n * @param p\n * @param rSquared\n */\nfunction cullBezierPieces2(bezierPieces, p, rSquared) {\n    const TOLERANCE = 1 + 2 ** -10;\n    if (bezierPieces.length <= 1) {\n        return bezierPieces;\n    }\n    const newPieces = [];\n    for (const bezierPiece of bezierPieces) {\n        const ps = bezierPiece.curve.ps;\n        const rect = (0,_geometry_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.getBoundingBox_)(ps);\n        const bd = (0,_geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_1__.getClosestSquareDistanceToRect)(rect, p);\n        if (bd <= TOLERANCE * rSquared) {\n            newPieces.push(bezierPiece);\n        }\n    }\n    return newPieces;\n}\n\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/find-2-prong.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/find-2-prong.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   find2Prong: () => (/* binding */ find2Prong)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var _point_on_shape_get_osculating_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/get-osculating-circle.js */ \"./node_modules/flo-mat/node/point-on-shape/get-osculating-circle.js\");\n/* harmony import */ var _add_debug_info_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./add-debug-info.js */ \"./node_modules/flo-mat/node/find-2-prong/add-debug-info.js\");\n/* harmony import */ var _find_equidistant_point_on_line_dd_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./find-equidistant-point-on-line-dd.js */ \"./node_modules/flo-mat/node/find-2-prong/find-equidistant-point-on-line-dd.js\");\n/* harmony import */ var _get_initial_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-initial-bezier-pieces.js */ \"./node_modules/flo-mat/node/find-2-prong/get-initial-bezier-pieces.js\");\n/* harmony import */ var _closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../closest-boundary-point/get-close-boundary-points-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js\");\n/* harmony import */ var _reduce_radius_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reduce-radius.js */ \"./node_modules/flo-mat/node/find-2-prong/reduce-radius.js\");\n/* harmony import */ var _squared_distance_between_dd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./squared-distance-between-dd.js */ \"./node_modules/flo-mat/node/find-2-prong/squared-distance-between-dd.js\");\n/* harmony import */ var _cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cull-bezier-pieces.js */ \"./node_modules/flo-mat/node/find-2-prong/cull-bezier-pieces.js\");\n/* harmony import */ var _add_1_prong_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./add-1-prong.js */ \"./node_modules/flo-mat/node/find-2-prong/add-1-prong.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst { sqrt, abs, sin, cos } = Math;\n/**\n * @internal\n * Adds a 2-prong to the MAT. The first point on the shape boundary is given and\n * the second one is found by the algorithm.\n *\n * A 2-prong is defined as a MAT circle that touches the shape at exactly 2\n * points.\n *\n * Before any 2-prongs are added the entire shape is our δΩ.\n *\n * As per the paper by Choi, Choi, Moon and Wee:\n *   \"The starting point of this algorithm is a choice of a circle Br(x)\n *    centered at an interior point x which contains two boundary portions c and\n *    d of dΩ as in Fig. 19.\"\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\n * @param loops A shape represented by path loops\n * @param extreme The extreme coordinate value of the shape\n * @param squaredDiagonalLength The squared diagonal length of the shape\n * bounding box.\n * @param y The source point of the 2-prong to be found\n * @param isHoleClosing True if this is a hole-closing two-prong, false otherwise\n * @param k The loop array index\n */\nfunction find2Prong(angle, loops, extreme, squaredDiagonalLength, cpTrees, y, isHoleClosing, k, for1Prong) {\n    const MAX_ITERATIONS = 25;\n    const squaredSeperationTolerance = ((2 ** -21) * extreme) ** 2;\n    const errorTolerance = (2 ** -46) * extreme;\n    const maxOsculatingCircleRadius = sqrt(squaredDiagonalLength);\n    const minCurvature = 1 / maxOsculatingCircleRadius;\n    let xO; // the original x to mitigate drift\n    const p = y.p;\n    let rO;\n    if (isHoleClosing) {\n        xO = [p[0], p[1] - maxOsculatingCircleRadius];\n        rO = maxOsculatingCircleRadius;\n    }\n    else {\n        if (angle === 0) {\n            ({ center: xO, radius: rO } = (0,_point_on_shape_get_osculating_circle_js__WEBPACK_IMPORTED_MODULE_0__.getOsculatingCircle)(minCurvature, y));\n        }\n        else {\n            ({ center: xO, radius: rO } = (0,_point_on_shape_get_osculating_circle_js__WEBPACK_IMPORTED_MODULE_0__.getOsculatingCircle)(minCurvature, y, true));\n            const v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(y.p, xO);\n            const v_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.rotate)(sin(angle), cos(angle))(v);\n            xO = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.translate)(y.p)(v_);\n        }\n    }\n    // The boundary piece that should contain the other point of \n    // the 2-prong circle. (Defined by start and end points).\n    const { bezierPieces, δ } = (0,_get_initial_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_4__.getInitialBezierPieces)(angle, isHoleClosing, k, loops, cpTrees, y, { center: xO, radius: rO });\n    /** The center of the two-prong (successively refined) */\n    let x = xO;\n    // The lines below is an optimization.\n    const r_ = sqrt((0,_reduce_radius_js__WEBPACK_IMPORTED_MODULE_5__.reduceRadius)(extreme, bezierPieces, p, xO));\n    if (rO > r_) {\n        x = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.interpolate)(p, xO, r_ / rO);\n    }\n    /** Trace the convergence (for debugging). */\n    const xs = [];\n    /** The antipode of the two-prong (successively refined) */\n    let zs = undefined;\n    let z = undefined;\n    let bezierPieces_ = bezierPieces;\n    let i = 0;\n    while (i < MAX_ITERATIONS) {\n        const xy = (0,_squared_distance_between_dd_js__WEBPACK_IMPORTED_MODULE_6__.squaredDistanceBetweenDd)(x, y.p);\n        if (i < 5) {\n            bezierPieces_ = (0,_cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_7__.cullBezierPieces2)(bezierPieces_, x, xy);\n        }\n        zs = (0,_closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_8__.getCloseBoundaryPointsCertified)(bezierPieces_, x, y.curve, y.t, for1Prong && i == 0 && rO !== 1 / minCurvature, angle).map(info => (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_9__.createPos)(info.curve, info.t, false));\n        z = zs[0];\n        if (z === undefined) {\n            addDebugInfo2(isHoleClosing);\n            return undefined;\n        }\n        const xz = (0,_squared_distance_between_dd_js__WEBPACK_IMPORTED_MODULE_6__.squaredDistanceBetweenDd)(x, z.p);\n        const yz = (0,_squared_distance_between_dd_js__WEBPACK_IMPORTED_MODULE_6__.squaredDistanceBetweenDd)(y.p, z.p);\n        // if on first try\n        if (i === 0) {\n            if (rO < (1 - 2 ** -6) * sqrt(xz)) {\n                (0,_add_1_prong_js__WEBPACK_IMPORTED_MODULE_10__.add1Prong)(rO, xO, cpTrees, y);\n                return undefined;\n            }\n            // return undefined;\n        }\n        if (typeof _debug_ !== 'undefined') {\n            xs.push({ x, y, z: (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_9__.createPos)(z.curve, z.t, false), t: y.t });\n        }\n        if (!isHoleClosing) {\n            if (yz <= squaredSeperationTolerance) {\n                // if (typeof _debug_ !== 'undefined') { console.log(`failed: seperation too small - ${sqrt(yz)}`); }\n                return undefined;\n            }\n        }\n        // Find the point on the line connecting y with x that is  \n        // equidistant from y and z. This will be our next x.\n        const nextX = (0,_find_equidistant_point_on_line_dd_js__WEBPACK_IMPORTED_MODULE_11__.findEquidistantPointOnLineDd)(x, y.p, z.p);\n        const error = abs(sqrt(xy) - sqrt(xz));\n        // if (xy < xz) { return undefined; }\n        x = nextX;\n        if (error < errorTolerance) {\n            break;\n        }\n        i++;\n        if (i === MAX_ITERATIONS) {\n            // Convergence was too slow.\n            if (typeof _debug_ !== 'undefined') {\n                console.log('failed (slow): max iterations reached');\n            }\n            return undefined;\n        }\n    }\n    const circle = { center: x, radius: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_12__.distanceBetween)(x, z.p) };\n    if (typeof _debug_ !== 'undefined') {\n        (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_13__.addDebugInfo)(bezierPieces, false, x, y, z, circle, δ, xs, isHoleClosing);\n    }\n    return { circle, zs: [z] };\n}\nfunction addDebugInfo2(isHoleClosing) {\n    if (typeof _debug_ !== 'undefined') {\n        const elems = _debug_.generated.elems;\n        const elem = isHoleClosing ? elems.twoProng_holeClosing : elems.twoProng_regular;\n        const elemStr = isHoleClosing ? 'hole-closing: ' + elem.length : 'regular: ' + elem.length;\n        console.log('failed: no closest point - ' + elemStr);\n    }\n}\n\n//# sourceMappingURL=find-2-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/find-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs-on-all-paths.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs-on-all-paths.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndAdd2ProngsOnAllPaths: () => (/* binding */ findAndAdd2ProngsOnAllPaths)\n/* harmony export */ });\n/* harmony import */ var _find_and_add_2_prongs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find-and-add-2-prongs.js */ \"./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs.js\");\n/* harmony import */ var _find_mat_fix_ordering_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../find-mat/fix-ordering.js */ \"./node_modules/flo-mat/node/find-mat/fix-ordering.js\");\n\n\n/**\n * @internal\n * Add 2 prongs. See comments on the add2Prong function.\n * @param loops\n * @param cpGraphs\n * @param for2Prongss\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd2ProngsOnAllPaths(cpNode, loops, cpGraphs, for2Prongss, extreme, for1Prongs) {\n    for (let k = 0; k < for2Prongss.length; k++) {\n        const for2Prongs = for2Prongss[k];\n        const _cpNode = (0,_find_and_add_2_prongs_js__WEBPACK_IMPORTED_MODULE_0__.findAndAdd2Prongs)(loops, cpGraphs, k, for2Prongs, extreme, for1Prongs);\n        cpNode = cpNode || _cpNode;\n    }\n    (0,_find_mat_fix_ordering_js__WEBPACK_IMPORTED_MODULE_1__.fixOrdering)(cpNode);\n    return cpNode;\n}\n\n//# sourceMappingURL=find-and-add-2-prongs-on-all-paths.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs-on-all-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndAdd2Prongs: () => (/* binding */ findAndAdd2Prongs)\n/* harmony export */ });\n/* harmony import */ var _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../svg/get-shape-bounds.js */ \"./node_modules/flo-mat/node/svg/get-shape-bounds.js\");\n/* harmony import */ var _find_2_prong_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./find-2-prong.js */ \"./node_modules/flo-mat/node/find-2-prong/find-2-prong.js\");\n/* harmony import */ var _add_2_prong_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./add-2-prong.js */ \"./node_modules/flo-mat/node/find-2-prong/add-2-prong.js\");\n/* harmony import */ var _corner_get_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../corner/get-corner.js */ \"./node_modules/flo-mat/node/corner/get-corner.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js\");\n\n\n\n\n\nconst { PI, atan2 } = Math;\nconst ANGLE = 15 * PI / 180; // 15 degrees - don't make smaller than 2 degrees\n/**\n * @internal\n * Find and add two-prongs.\n * @param loops\n * @param cpGraphs\n * @param k\n * @param for2Prongs\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme, for1Prongs) {\n    let cpNode_;\n    const bounds = (0,_svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getShapeBounds)(loops);\n    const squaredDiagonalLength = (bounds.maxX.p[0] - bounds.minX.p[0]) ** 2 +\n        (bounds.maxY.p[1] - bounds.minY.p[1]) ** 2;\n    for (let i = 0; i < for2Prongs.length; i++) {\n        // const angles = [0];\n        let angles = [0];\n        const pos = for2Prongs[i];\n        if (pos.t === 1) {\n            const { curve } = pos;\n            const corner = (0,_corner_get_corner_js__WEBPACK_IMPORTED_MODULE_1__.getCorner)(curve.ps, curve.next.ps);\n            if (corner.isQuiteDull) {\n                const tangentI = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.rotateNeg90Degrees)(corner.tangents[0]);\n                const tangentO = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.rotateNeg90Degrees)(corner.tangents[1]);\n                const a1 = ((atan2(tangentI[1], tangentI[0]) + 2 * PI) % (2 * PI));\n                const a2 = ((atan2(tangentO[1], tangentO[0]) + 2 * PI) % (2 * PI));\n                const a3 = ((a2 - a1) + 2 * PI) % (2 * PI);\n                let angle = ANGLE;\n                while (angle <= a3 - (ANGLE / 2)) {\n                    angles.push(angle);\n                    angle += ANGLE;\n                }\n            }\n        }\n        for (let angle of angles) {\n            const twoProngInfo = (0,_find_2_prong_js__WEBPACK_IMPORTED_MODULE_3__.find2Prong)(angle, loops, extreme, squaredDiagonalLength, cpGraphs, pos, false, k, for1Prongs);\n            if (twoProngInfo) {\n                const { circle, zs } = twoProngInfo;\n                const cpNode = (0,_add_2_prong_js__WEBPACK_IMPORTED_MODULE_4__.add2Prong)(cpGraphs, circle, pos, zs, false, extreme);\n                cpNode_ = cpNode_ || cpNode;\n            }\n            if (typeof _debug_ !== 'undefined') {\n                if (i + 1 === _debug_.directives.stopAfterTwoProngsNum) {\n                    return undefined;\n                }\n            }\n        }\n    }\n    return cpNode_;\n}\n\n//# sourceMappingURL=find-and-add-2-prongs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/find-and-add-hole-closing-2-prongs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/find-and-add-hole-closing-2-prongs.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndAddHoleClosing2Prongs: () => (/* binding */ findAndAddHoleClosing2Prongs)\n/* harmony export */ });\n/* harmony import */ var _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../svg/get-shape-bounds.js */ \"./node_modules/flo-mat/node/svg/get-shape-bounds.js\");\n/* harmony import */ var _svg_get_min_y_pos_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../svg/get-min-y-pos.js */ \"./node_modules/flo-mat/node/svg/get-min-y-pos.js\");\n/* harmony import */ var _find_2_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./find-2-prong.js */ \"./node_modules/flo-mat/node/find-2-prong/find-2-prong.js\");\n/* harmony import */ var _add_2_prong_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add-2-prong.js */ \"./node_modules/flo-mat/node/find-2-prong/add-2-prong.js\");\n\n\n\n\n/**\n * @internal\n * Find and add two-prongs that remove any holes in the shape.\n * @param loops The loops (that as a precondition must be ordered from\n * highest (i.e. smallest y-value) topmost point loops to lowest)\n * @param cpTrees\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAddHoleClosing2Prongs(loops, cpTrees, extreme) {\n    const bounds = (0,_svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getShapeBounds)(loops);\n    const squaredDiagonalLength = (bounds.maxX.p[0] - bounds.minX.p[0]) ** 2 +\n        (bounds.maxY.p[1] - bounds.minY.p[1]) ** 2;\n    // Find the topmost points on each loop.\n    const minYs = loops.map(_svg_get_min_y_pos_js__WEBPACK_IMPORTED_MODULE_1__.getMinYPos);\n    // We start at 1 since 0 is the outer (root) loop\n    for (let k = 1; k < minYs.length; k++) {\n        const posSource = minYs[k];\n        const holeClosingTwoProng = (0,_find_2_prong_js__WEBPACK_IMPORTED_MODULE_2__.find2Prong)(0, loops, extreme, squaredDiagonalLength, cpTrees, posSource, true, k, false);\n        if (!holeClosingTwoProng) {\n            throw new Error(`Unable to find hole-closing 2-prong`);\n        }\n        // TODO important - handle case of n-prong, i.e. more than one antipode\n        // - currently we only handle case of single antipode (the general case)\n        const { circle, zs: posAntipodes } = holeClosingTwoProng;\n        (0,_add_2_prong_js__WEBPACK_IMPORTED_MODULE_3__.add2Prong)(cpTrees, circle, posSource, [posAntipodes[0]], true, extreme);\n    }\n}\n\n//# sourceMappingURL=find-and-add-hole-closing-2-prongs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/find-and-add-hole-closing-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/find-equidistant-point-on-line-dd.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/find-equidistant-point-on-line-dd.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findEquidistantPointOnLineDd: () => (/* binding */ findEquidistantPointOnLineDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\nconst { abs } = Math;\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\n/**\n * Returns the point on the line from y to x that is equidistant from y and z.\n *\n * @internal\n * @param x\n * @param y\n * @param z\n  */\nfunction findEquidistantPointOnLineDd(x, y, z) {\n    // Some basic algebra (not shown) finds the required point.\n    // Swap axes if x and y are more aligned to y-axis than to x-axis.\n    const swapAxes = abs(x[1] - y[1]) > abs(x[0] - y[0]);\n    // Cache\n    let x1;\n    let x2;\n    let y1;\n    let y2;\n    let z1;\n    let z2;\n    if (swapAxes) {\n        x1 = x[1];\n        x2 = x[0];\n        y1 = y[1];\n        y2 = y[0];\n        z1 = z[1];\n        z2 = z[0];\n    }\n    else {\n        x1 = x[0];\n        x2 = x[1];\n        y1 = y[0];\n        y2 = y[1];\n        z1 = z[0];\n        z2 = z[1];\n    }\n    // a <= 1 (due to swapped axes)\n    // const a = (x2 - y2) / (x1 - y1); \n    // const b = y2 - a*y1;\n    // const c = (y1*y1 + y2*y2 - z1*z1 - z2*z2) + 2*b*(z2 - y2);\n    // const d = y1 - z1 + a*(y2 - z2);\n    // const t1 = c/(2*d);\n    // const t2 = a*t1 + b;\n    const a = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivDd)(td(x2, y2), td(x1, y1));\n    const b = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd)([0, y2], (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble1)(y1, a));\n    const c = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(((0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd)((0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(tp(y1, y1), tp(y2, y2)), (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(tp(z1, z1), tp(z2, z2)))), (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2)((0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(b, (td(z2, y2)))));\n    const d = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(td(y1, z1), (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(a, td(y2, z2)));\n    const t1 = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivDd)(c, (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2)(d));\n    const t2 = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)((0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(a, t1), b);\n    return swapAxes ? [t2[1], t1[1]] : [t1[1], t2[1]];\n}\n\n//# sourceMappingURL=find-equidistant-point-on-line-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/find-equidistant-point-on-line-dd.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/get-initial-bezier-pieces.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/get-initial-bezier-pieces.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInitialBezierPieces: () => (/* binding */ getInitialBezierPieces)\n/* harmony export */ });\n/* harmony import */ var _mat_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mat/get-neighboring-cps.js */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\n/* harmony import */ var _mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mat/get-boundary-piece-beziers.js */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\n/* harmony import */ var _point_on_shape_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/is-pos-dull-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js\");\n/* harmony import */ var _point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point-on-shape/calc-pos-order.js */ \"./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js\");\n\n\n\n\n/** @internal */\nfunction getInitialBezierPieces(angle, isHoleClosing, k, loops, cpTrees, y, circle) {\n    if (isHoleClosing) {\n        const bezierPieces = [];\n        for (let k2 = 0; k2 < k; k2++) {\n            const pieces = loops[k2].curves\n                .map(curve => ({ curve, ts: [0, 1] }));\n            bezierPieces.push(...pieces);\n        }\n        return { bezierPieces, δ: undefined };\n    }\n    let bezierPieces;\n    const order = (0,_point_on_shape_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_0__.isPosDullCorner)(y)\n        ? y.t === 1 && angle === 0\n            ? -1\n            : y.t === 0\n                ? +1\n                : (0,_point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_1__.calcPosOrder)(circle, y)\n        : 0;\n    const loop = loops[k];\n    const cpNode = (0,_mat_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_2__.getNeighbouringPoints)(cpTrees.get(loop), y, order, 0)[0];\n    const δ = [cpNode, cpNode];\n    if (!cpNode ||\n        // The special case if there is only a single sharp corner or \n        // terminating 2-prong currently in the MAT. Don't remove!\n        (cpNode === cpNode.next.next)) {\n        bezierPieces = loop.curves\n            .map(curve => ({ curve, ts: [0, 1] }));\n    }\n    else {\n        bezierPieces = (0,_mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_3__.getBoundaryPieceBeziers)(δ);\n    }\n    return { bezierPieces, δ };\n}\n\n//# sourceMappingURL=get-initial-bezier-pieces.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/get-initial-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/reduce-radius.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/reduce-radius.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reduceRadius: () => (/* binding */ reduceRadius)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n\n\n/**\n * @internal\n *\n * Reduces the circle radius initially as an optimization step.\n */\nfunction reduceRadius(extreme, bezierPieces, p, x) {\n    const TOLERANCE = 1 + 2 ** -10;\n    let prevP = undefined;\n    let minRadius = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < bezierPieces.length; i++) {\n        const bezierPiece = bezierPieces[i];\n        const ps = bezierPiece.curve.ps;\n        let r1 = Number.POSITIVE_INFINITY;\n        const p1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, bezierPiece.ts[0]);\n        // Prevent evaluating the same points twice\n        if (!prevP || prevP[0] !== p1[0] || prevP[1] !== p1[1]) {\n            const cc1 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1);\n            if (cc1) {\n                r1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, cc1);\n            }\n        }\n        let r2 = Number.POSITIVE_INFINITY;\n        const p2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, bezierPiece.ts[1]);\n        const cc2 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p2);\n        if (cc2) {\n            r2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, cc2);\n        }\n        prevP = p2;\n        const d = Math.min(r1, r2);\n        if (d < minRadius) {\n            minRadius = d;\n        }\n    }\n    // The extra bit is to account for floating point precision.\n    return TOLERANCE * minRadius;\n}\n/**\n * @internal\n * @param p A point on the circle with normal pointing to x towards the center\n * of the circle.\n * @param x\n * @param p1 Another point on the circle.\n */\nfunction getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1) {\n    const TOLERANCE = (2 ** -14 * extreme) ** 2;\n    // Ignore if p and p1 are too close together\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, p1) < TOLERANCE) {\n        return undefined;\n    }\n    /** The perpindicular bisector between the two given points on the circle */\n    const pb = [\n        (p[0] + p1[0]) / 2,\n        (p[1] + p1[1]) / 2,\n    ];\n    const tan = [p1[0] - p[0], p1[1] - p[1]];\n    const norm = [-tan[1], tan[0]]; // Rotate by 90 degrees\n    const pb2 = [pb[0] + norm[0], pb[1] + norm[1]];\n    const res = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.lineLineIntersection)([p, x], [pb, pb2]);\n    if (!res) {\n        return undefined;\n    }\n    const resO = [res[0] - p[0], res[1] - p[1]];\n    const xO = [x[0] - p[0], x[1] - p[1]];\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.dot)(resO, xO) < 0) {\n        return undefined;\n    }\n    return res;\n}\n\n//# sourceMappingURL=reduce-radius.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/reduce-radius.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-2-prong/squared-distance-between-dd.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-2-prong/squared-distance-between-dd.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squaredDistanceBetweenDd: () => (/* binding */ squaredDistanceBetweenDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\nfunction squaredDistanceBetweenDd(x, y) {\n    const [x0, y0] = x;\n    const [x1, y1] = y;\n    // xd = x0 - x1;\n    // yd = y0 - y1;\n    // xx = xd**2;\n    // yy = yd**2;\n    // return xx + yy\n    const xd = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff)(x0, x1);\n    const yd = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff)(y0, y1);\n    const xx = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(xd, xd);\n    const yy = (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(yd, yd);\n    return (0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(xx, yy)[1];\n}\n\n//# sourceMappingURL=squared-distance-between-dd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-2-prong/squared-distance-between-dd.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/add-3-prong.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/add-3-prong.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add3Prong: () => (/* binding */ add3Prong)\n/* harmony export */ });\n/* harmony import */ var _mat_add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mat/add-to-cp-graph.js */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\n/* harmony import */ var _mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mat/is-another-cp-closeby.js */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\n\n\n/**\n * @internal\n *\n * Adds a 3-prong MAT circle according to the 3 given (previously calculated)\n * points on the shape.\n *\n * Returns 3 CpNodes if successful, else return one CpNode that is an offending\n * too close existing CpNode.\n *\n * @param cpTrees\n * @param orders\n * @param threeProng\n */\nfunction add3Prong(cpTrees, orders, threeProng) {\n    const { circle, ps: poss, δ3s } = threeProng;\n    // Keep for possible future debugging.\t\n    /*\n    let ii = -1;\n    if (typeof _debug_ !== 'undefined') {\n        for (let i=0; i<3; i++) {\n            const cpBef = threeProng.δ3s[i][0].cp;\n            const cpAft = threeProng.δ3s[i][1].cp;\n\n            //let cmpBef = PointOnShape.compareInclOrder(cpBef.pointOnShape, poss[i], cpBef.order, orders[i]);\n            //let cmpAft = PointOnShape.compareInclOrder(cpAft.pointOnShape, poss[i], cpAft.order, orders[i]);\n            const cmpBef = compareCps(cpBef, { pointOnShape: poss[i], order: orders[i], order2: 0, circle: undefined });\n            const cmpAft = compareCps(cpAft, { pointOnShape: poss[i], order: orders[i], order2: 0, circle: undefined });\n\n            // const cmpBef = comparePoss(cpBef.pointOnShape, poss[i]);\n            // const cmpAft = comparePoss(cpAft.pointOnShape, poss[i]);\n\n            // len is used by debug functions to reference a particular\n            // three-prong.\n            const len = _debug_.generated.elems.threeProng.length-1;\n            if (cmpBef > 0) {\n                console.log('----------------------------------------');\n                console.log(`3-prong order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\n                console.log(threeProng);\n                console.log(cpBef);\n                console.log(cpAft);\n                console.log(poss[i]);\n                ii = i;\n            }\n            if (cmpAft < 0) {\n                console.log('----------------------------------------');\n                console.log(`3-prong order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\n                console.log(threeProng);\n                console.log(cpBef);\n                console.log(cpAft);\n                console.log(poss[i]);\n            }\n        }\n    }\n    */\n    // TODO - replace 1000 below with correct value\n    const c1 = (0,_mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_0__.isAnotherCpCloseby)(cpTrees, poss[0], circle, orders[0], 0, 1000);\n    const c2 = (0,_mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_0__.isAnotherCpCloseby)(cpTrees, poss[1], circle, orders[1], 0, 1000);\n    const c3 = (0,_mat_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_0__.isAnotherCpCloseby)(cpTrees, poss[2], circle, orders[2], 0, 1000);\n    // for (let pos of poss) {\n    // \tif (pos.t === 0.9978869234519733) {\n    // \t\tconsole.log(pos)\n    // \t}\n    // }\n    // if (!!c1) {\n    // \tconsole.log(getRealProngCount(c1));\n    // }\n    // if (!!c2) {\n    // \tconsole.log(getRealProngCount(c2));\n    // }\n    // if (!!c3) {\n    // \tconsole.log(getRealProngCount(c3));\n    // }\n    // if (!!c1) { return [c1]; }\n    // if (!!c2) { return [c2]; }\n    // if (!!c3) { return [c3]; }\n    const cps = (0,_mat_add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_1__.addToCpGraph)(circle, orders, cpTrees, poss, δ3s);\n    return cps;\n}\n\n//# sourceMappingURL=add-3-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/add-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/calc-better-x.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/calc-better-x.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcBetterX: () => (/* binding */ calcBetterX)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/len.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/triangle-centers/circum-center.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var _get_closest_points_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-closest-points.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/get-closest-points.js\");\n\n\n/**\n * @internal\n * Find new x and ps that are a better estimate of the 3-prong circle.\n * The potential function, V, is defined as the distance to the actual 3 prong\n * circle center.\n * @param bezierPiece3s The three boundary pieces, each of which should contain\n * a point of the 3-prong to be found.\n * @param x The currently best guess at the center of the 3-prong circle.\n * @param vectorToZeroV\n * @param extreme\n */\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\n    const V = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(vectorToZeroV);\n    let nu = 1;\n    let better;\n    let newX;\n    let newPs;\n    let newV;\n    let i = 0; // Safeguard\n    do {\n        const shift = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.scale)(vectorToZeroV, nu);\n        newX = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.translate)(shift, x);\n        newPs = (0,_get_closest_points_js__WEBPACK_IMPORTED_MODULE_3__.getClosestPoints)(newX, bezierPiece3s);\n        // Point of zero V\n        const newCircleCenter = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.circumCenter)(newPs.map(pos => pos.p));\n        const newVectorToZeroV = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.fromTo)(newX, newCircleCenter);\n        newV = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(newVectorToZeroV);\n        better = newV < V;\n        nu = nu / 2;\n        i++;\n    } while (!better && i < 3);\n    return { newX, newV, newPs };\n}\n\n//# sourceMappingURL=calc-better-x.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/calc-better-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/calc-initial-3-prong-center.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/calc-initial-3-prong-center.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcInitial3ProngCenter: () => (/* binding */ calcInitial3ProngCenter)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/triangle-centers/circum-center.js\");\n/* harmony import */ var _closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../closest-boundary-point/get-close-boundary-points-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js\");\n/** @internal */\n\n\n/**\n * @internal\n * Finds an initial 3-prong circle center point from which to iterate. The point\n * must be within the shape.\n * @param δ3s - The three boundary pieces of which we need to find the three\n * 3-prong points.\n * @param bezierPiece3s\n * @param extreme\n */\nfunction calcInitial3ProngCenter(δ3s, bezierPiece3s) {\n    const twoProngCircleCenter = δ3s[0][0].cp.circle.center;\n    const pos = (0,_closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_0__.getCloseBoundaryPointsCertified)(bezierPiece3s[1], twoProngCircleCenter)[0];\n    const meanPoints = [\n        δ3s[0][0].cp.pointOnShape.p,\n        pos.p,\n        δ3s[2][1].cp.pointOnShape.p,\n    ];\n    return (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.circumCenter)(meanPoints);\n}\n\n//# sourceMappingURL=calc-initial-3-prong-center.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/calc-initial-3-prong-center.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong-for-delta3s.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong-for-delta3s.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   find3ProngForDelta3s: () => (/* binding */ find3ProngForDelta3s)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/triangle-centers/circum-center.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/len.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/cross.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _point_on_shape_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../point-on-shape/is-pos-dull-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js\");\n/* harmony import */ var _calc_initial_3_prong_center_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calc-initial-3-prong-center.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/calc-initial-3-prong-center.js\");\n/* harmony import */ var _get_closest_points_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-closest-points.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/get-closest-points.js\");\n/* harmony import */ var _calc_better_x_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./calc-better-x.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/calc-better-x.js\");\n/* harmony import */ var _curve_curve_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../curve/curve.js */ \"./node_modules/flo-mat/node/curve/curve.js\");\n/* harmony import */ var _closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../closest-boundary-point/get-close-boundary-points-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js\");\n\n\n\n\n\n\n\n\n\n/** @internal */\nconst calcVectorToZeroV_StraightToIt = flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo;\n/**\n * @internal\n * Finds a 3-prong using only the 3 given δs.\n * @param δs The boundary pieces\n * @param idx δ identifier\n * @param bezierPiecess\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction find3ProngForDelta3s(δs, idx, k, bezierPiecess, extreme) {\n    const TOLERANCE = 2 ** -32 * extreme;\n    const MAX_ITERATIONS = 10;\n    const δs_ = [\n        δs[0],\n        δs[idx],\n        δs[δs.length - 1]\n    ];\n    const bezierPieces_ = [\n        bezierPiecess[0],\n        bezierPiecess[idx],\n        bezierPiecess[δs.length - 1]\n    ];\n    const δ3ss = [\n        [δs_[0], δs_[1], δs_[2]],\n        [δs_[1], δs_[2], δs_[0]],\n        [δs_[2], δs_[0], δs_[1]],\n    ];\n    const bezierPiecess_ = [\n        [bezierPieces_[0], bezierPieces_[1], bezierPieces_[2]],\n        [bezierPieces_[1], bezierPieces_[2], bezierPieces_[0]],\n        [bezierPieces_[2], bezierPieces_[0], bezierPieces_[1]],\n    ];\n    const δ3s = δ3ss[k];\n    const bezierPiece3s = bezierPiecess_[k];\n    if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.isSharp)(δ3s[0][0])) {\n        return undefined;\n    }\n    let ps;\n    let circumCenter_;\n    let j = 0; // Safeguard for slow convergence\n    let x = (0,_calc_initial_3_prong_center_js__WEBPACK_IMPORTED_MODULE_2__.calcInitial3ProngCenter)(δ3s, bezierPiece3s);\n    if (typeof _debug_ !== 'undefined') {\n        const threeProngs = _debug_.generated.elems.threeProng;\n        const d = threeProngs[threeProngs.length - 1];\n        const trace = d.traces[d.traces.length - 1];\n        trace.push(x);\n    }\n    let tolerance = Number.POSITIVE_INFINITY;\n    while (tolerance > TOLERANCE && j < MAX_ITERATIONS) {\n        j++;\n        ps = (0,_get_closest_points_js__WEBPACK_IMPORTED_MODULE_3__.getClosestPoints)(x, bezierPiece3s);\n        if (!Number.isFinite(x[0]) || !Number.isFinite(x[1])) {\n            // TODO - the code can be cleaned up and sped up a lot if we don't\n            // use this function as is but instead use δs[0] and δs[2] as is\n            // and make δs[1] include all the rest of the beziers around the \n            // loop. This check, for instance, would be eliminated completely.\n            return undefined;\n        }\n        circumCenter_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.circumCenter)(ps.map(x => x.p));\n        const vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter_);\n        if (!Number.isFinite(vectorToZeroV[0]) || !Number.isFinite(vectorToZeroV[1])) {\n            // TODO - the code can be cleaned up and sped up a lot if we don't\n            // use this function as is but instead use δs[0] and δs[2] as is\n            // and make δs[1] include all the rest of the beziers around the \n            // loop. This check, for instance, would be eliminated completely.\n            return undefined;\n        }\n        const upds = (0,_calc_better_x_js__WEBPACK_IMPORTED_MODULE_5__.calcBetterX)(bezierPiece3s, x, vectorToZeroV);\n        x = upds.newX;\n        ps = upds.newPs;\n        if (typeof _debug_ !== 'undefined') {\n            const threeProngs = _debug_.generated.elems.threeProng;\n            const d = threeProngs[threeProngs.length - 1];\n            const trace = d.traces[d.traces.length - 1];\n            trace.push(x);\n        }\n        const V = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.len)(vectorToZeroV); // The 'potential'\n        tolerance = Math.abs(V - upds.newV);\n    }\n    const radius = ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.distanceBetween)(x, ps[0].p) +\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.distanceBetween)(x, ps[1].p) +\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.distanceBetween)(x, ps[2].p)) / 3;\n    const circle = { center: x, radius };\n    //-------------------------------------------------------------------------\n    // Calculate the unit tangent vector at 3-prong circle points - they should \n    // be very close to tangent to the boundary piece tangents at those points \n    // (up to sign). Sharp corners are a common special case.\n    //-------------------------------------------------------------------------\n    let totalAngleError = 0;\n    for (let i = 0; i < 3; i++) {\n        const p = ps[i];\n        //----------------------------\n        // Tangent of circle at point\n        //----------------------------\n        const v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_8__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(p.p, x));\n        const v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_9__.rotate90Degrees)(v);\n        //-----------------------------------\n        // Check if point is on dull crorner\n        //-----------------------------------\n        if ((0,_point_on_shape_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_10__.isPosDullCorner)(p)) {\n            const corner = (0,_curve_curve_js__WEBPACK_IMPORTED_MODULE_11__.getCornerAtEnd)(p.curve);\n            const tans = corner.tangents;\n            const perps = tans.map(flo_vector2d__WEBPACK_IMPORTED_MODULE_9__.rotate90Degrees);\n            const angleError1 = Math.asin((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_12__.cross)(perps[0], v));\n            const angleError2 = Math.asin((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_12__.cross)(v, perps[1]));\n            let angleError = 0;\n            if (angleError1 > 0) {\n                angleError += angleError1;\n            }\n            if (angleError2 > 0) {\n                angleError += angleError2;\n            }\n            totalAngleError += angleError;\n        }\n        else {\n            //---------------------------\n            // Tangent of curve at point\n            //---------------------------\n            const v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_8__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_13__.tangent)(p.curve.ps, p.t));\n            // Cross is more numerically stable than Vector.dot at angles a\n            // multiple of Math.PI **and** is close to the actual angle value\n            // and can thus just be added to cone method of looking at \n            // tolerance.\n            // Should be close to zero and is close to the actual angle.\n            const cross_ = Math.abs(Math.asin((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_12__.cross)(v1, v2)));\n            totalAngleError += cross_;\n        }\n    }\n    //-------------------------------------------------------------------------\n    // Calculate radiusDelta, the difference between the radius and the closest\n    // point to the 3-prong. It should be around 0. If not, this is not a good \n    // candidate for the 3-prong.\n    //-------------------------------------------------------------------------\n    const closestDs = [];\n    for (let i = 0; i < bezierPiecess.length; i++) {\n        const p = (0,_closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_14__.getCloseBoundaryPointsCertified)(bezierPiecess[i], x)[0];\n        closestDs.push((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.distanceBetween)(p.p, x));\n    }\n    const closestD = Math.min(...closestDs);\n    const radiusDelta = Math.abs(radius - closestD);\n    // Weights below still need to be optimized.\n    const W1 = 1;\n    const W2 = 1;\n    const error = W1 * radiusDelta + W2 * totalAngleError;\n    return { ps: ps, circle, error, δ3s };\n}\n\n//# sourceMappingURL=find-3-prong-for-delta3s.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong-for-delta3s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   find3Prong: () => (/* binding */ find3Prong)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/transformation/split/from-to.js\");\n/* harmony import */ var _debug_three_prong_for_debugging_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../debug/three-prong-for-debugging.js */ \"./node_modules/flo-mat/node/debug/three-prong-for-debugging.js\");\n/* harmony import */ var _find_3_prong_for_delta3s_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./find-3-prong-for-delta3s.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong-for-delta3s.js\");\n/* harmony import */ var _mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mat/get-boundary-piece-beziers.js */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\n\n\n\n\n/**\n * @internal\n * Find and return a 3-prong from the given boundary piece.\n * @param δs A boundary piece\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction find3Prong(δs, extreme) {\n    const bezierPiecess = δs.map(_mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_0__.getBoundaryPieceBeziers);\n    addDebugInfo1(bezierPiecess);\n    const candidateThreeProngs = [];\n    // The best candidate amongst the different 'permutations' of the given δs.\n    let threeProng;\n    let bestIndx = undefined;\n    let smallestError = Number.POSITIVE_INFINITY;\n    for (let i = 1; i < δs.length - 1; i++) {\n        for (let k = 0; k < 3; k++) {\n            addDebugInfo2();\n            const threeProngInfo = (0,_find_3_prong_for_delta3s_js__WEBPACK_IMPORTED_MODULE_1__.find3ProngForDelta3s)(δs, i, k, bezierPiecess, extreme);\n            if (!threeProngInfo) {\n                continue;\n            }\n            const { circle, ps: poss, error, δ3s } = threeProngInfo;\n            addDebugInfo3(candidateThreeProngs, circle, poss);\n            if (error < smallestError) {\n                smallestError = error;\n                bestIndx = i - 1;\n                threeProng = { circle, ps: poss, δ3s };\n            }\n        }\n    }\n    addDebugInfo4(threeProng, δs, bestIndx, candidateThreeProngs);\n    return threeProng;\n}\nfunction addDebugInfo2() {\n    if (typeof _debug_ !== 'undefined') {\n        const threeProngs = _debug_.generated.elems.threeProng;\n        const d = threeProngs[threeProngs.length - 1];\n        const trace = [];\n        d.traces.push(trace);\n    }\n}\nfunction addDebugInfo3(candidateThreeProngs, circle, ps) {\n    if (typeof _debug_ !== 'undefined') {\n        candidateThreeProngs.push({ circle, ps });\n    }\n}\nfunction addDebugInfo4(threeProng, δs, bestIndx, candidateThreeProngs) {\n    if (typeof _debug_ !== 'undefined') {\n        const threeProngs = _debug_.generated.elems.threeProng;\n        const d = threeProngs[threeProngs.length - 1];\n        d.generated = _debug_.generated;\n        if (threeProng !== undefined) {\n            d.circle = threeProng.circle;\n            d.poss = threeProng.ps;\n            d.cp3ss = threeProng.δ3s;\n        }\n        d.cpss = δs;\n        d.bestIndx = bestIndx;\n        d.candidateThreeProngs = candidateThreeProngs;\n    }\n}\nfunction addDebugInfo1(bezierPiecess) {\n    if (typeof _debug_ !== 'undefined') {\n        const threeProngs = _debug_.generated.elems.threeProng;\n        threeProngs.push((0,_debug_three_prong_for_debugging_js__WEBPACK_IMPORTED_MODULE_2__.createEmptyThreeProngForDebugging)());\n        const d = threeProngs[threeProngs.length - 1];\n        d.boundaries = [];\n        for (const bezierPieces of bezierPiecess) {\n            const boundary = [];\n            d.boundaries.push(boundary);\n            for (const bezierPiece of bezierPieces) {\n                /* qqq\n                let bezier = fromTo(bezierPiece.curve.ps)(\n                    bezierPiece.ts[0], bezierPiece.ts[1]\n                );\n                */\n                const bezier = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.fromTo)(bezierPiece.curve.ps, bezierPiece.ts[0], bezierPiece.ts[1]);\n                boundary.push(bezier);\n            }\n        }\n        d.traces = [];\n    }\n}\n\n//# sourceMappingURL=find-3-prong.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-3-prongs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-3-prongs.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndAdd3Prongs: () => (/* binding */ findAndAdd3Prongs)\n/* harmony export */ });\n/* harmony import */ var _cp_node_traverse_cp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/traverse-cp.js */ \"./node_modules/flo-mat/node/cp-node/traverse-cp.js\");\n/* harmony import */ var _point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/calc-pos-order.js */ \"./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js\");\n/* harmony import */ var _find_3_prong_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./find-3-prong.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/find-3-prong.js\");\n/* harmony import */ var _add_3_prong_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add-3-prong.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/add-3-prong.js\");\n\n\n\n\n/**\n * @internal\n * Starting from some ContactPoint, traverses the shape going around Vertices\n * and if more than two Vertices have been visited in total then recursively\n * adds 3-prongs until only one or two Vertices have been visited.\n *\n * This process further subdivides the shape.\n *\n * @param cpGraphs\n * @param cpStart The ContactPoint from where to start the process.\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nlet ii = 0;\nfunction findAndAdd3Prongs(cpGraphs, cpStart, extreme) {\n    let visitedCps;\n    do {\n        visitedCps = (0,_cp_node_traverse_cp_js__WEBPACK_IMPORTED_MODULE_0__.traverseCp)(cpStart);\n        if (visitedCps.length > 2) {\n            const newCpNodes = findAndAdd3Prong(cpGraphs, visitedCps, extreme);\n            if (newCpNodes.length === 1) {\n                // There was another closeby cpNode\n                const closeCpNode = newCpNodes[0];\n            }\n            ii++;\n        }\n        if (typeof _debug_ !== 'undefined') {\n            if (ii === _debug_.directives.stopAfterThreeProngsNum) {\n                return undefined;\n            }\n        }\n    } while (visitedCps.length > 2);\n    return visitedCps;\n}\n/**\n * @internal\n * Finds and add a 3-prong MAT circle to the given shape.\n * @param cpGraphs\n * @param visitedCps\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAdd3Prong(cpGraphs, visitedCps, extreme) {\n    const δs = [];\n    for (const visitedCp of visitedCps) {\n        δs.push([visitedCp, visitedCp.next]);\n    }\n    const threeProng = (0,_find_3_prong_js__WEBPACK_IMPORTED_MODULE_1__.find3Prong)(δs, extreme);\n    const orders = [];\n    for (let i = 0; i < 3; i++) {\n        orders.push((0,_point_on_shape_calc_pos_order_js__WEBPACK_IMPORTED_MODULE_2__.calcPosOrder)(threeProng.circle, threeProng.ps[i]));\n    }\n    const newCpNodes = (0,_add_3_prong_js__WEBPACK_IMPORTED_MODULE_3__.add3Prong)(cpGraphs, orders, threeProng);\n    if (typeof _debug_ !== 'undefined') {\n        if (newCpNodes.length === 3) {\n            add3ProngDebugInfo(newCpNodes[0].cp.circle, visitedCps);\n        }\n    }\n    return newCpNodes;\n}\n/** @internal */\nfunction add3ProngDebugInfo(circle, visitedCps) {\n    const threeProngs = _debug_.generated.elems.threeProng;\n    const len = threeProngs.length;\n    const data = threeProngs[len - 1];\n    data.visitedCps = visitedCps;\n    data.circle = circle;\n}\n\n//# sourceMappingURL=find-and-add-3-prongs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-3-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-all-3-prongs.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-all-3-prongs.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndAddAll3Prongs: () => (/* binding */ findAndAddAll3Prongs)\n/* harmony export */ });\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _point_on_shape_is_pos_sharp_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point-on-shape/is-pos-sharp-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-sharp-corner.js\");\n/* harmony import */ var _find_and_add_3_prongs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./find-and-add-3-prongs.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-3-prongs.js\");\n\n\n\n/**\n * @internal\n * Finds and adds all 3-prongs.\n * @param cpGraphs\n * @param cpStart The CpNode to start traversing from.\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n */\nfunction findAndAddAll3Prongs(cpGraphs, cpStart, extreme) {\n    // Don't change this function to be recursive, the call stack may overflow \n    // if there are too many two-prongs.\n    const visitedEdges = new Map();\n    const edgesToCheck = [{ fromCpNode: undefined, cpStart }];\n    while (edgesToCheck.length) {\n        const { fromCpNode, cpStart } = edgesToCheck.shift();\n        markEdgeAsTaken(visitedEdges, fromCpNode, cpStart);\n        for (const cpNode of (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getCpNodesOnCircle)(cpStart)) {\n            if (!(0,_point_on_shape_is_pos_sharp_corner_js__WEBPACK_IMPORTED_MODULE_1__.isPosSharpCorner)(cpNode.cp.pointOnShape)) {\n                if ((0,_find_and_add_3_prongs_js__WEBPACK_IMPORTED_MODULE_2__.findAndAdd3Prongs)(cpGraphs, cpNode, extreme) === undefined) {\n                    console.log('Unable to find 3-prong');\n                    return; // only for debugging purposes\n                }\n            }\n            if (hasEdgeBeenTaken(visitedEdges, cpNode, cpNode.next)) {\n                continue; // We already visited this edge\n            }\n            edgesToCheck.push({ fromCpNode: cpStart, cpStart: cpNode.next });\n        }\n    }\n    // for (const [k,v] of cpGraphs) {\n    //     fixOrdering(v.root!.datum);\n    // }\n}\n/**\n * @internal\n * Marks the given edge as already taken.\n */\nfunction markEdgeAsTaken(visitedEdges, cp1, cp2) {\n    if (cp1 === undefined) {\n        return;\n    }\n    markEdgeAsTaken_(cp1, cp2);\n    markEdgeAsTaken_(cp2, cp1);\n    function markEdgeAsTaken_(cp1, cp2) {\n        let visited = visitedEdges.get(cp1);\n        if (!visited) {\n            visited = new Set();\n            visitedEdges.set(cp1, visited);\n        }\n        visited.add(cp2);\n    }\n}\n/** @internal */\nfunction hasEdgeBeenTaken(visitedEdges, cp1, cp2) {\n    let cps;\n    cps = visitedEdges.get(cp1);\n    const takenForward = cps && cps.has(cp2);\n    cps = visitedEdges.get(cp2);\n    const takenBackwards = cps && cps.has(cp1);\n    return takenForward || takenBackwards;\n}\n\n//# sourceMappingURL=find-and-add-all-3-prongs.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-all-3-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-3-prong.ts/get-closest-points.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-3-prong.ts/get-closest-points.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClosestPoints: () => (/* binding */ getClosestPoints)\n/* harmony export */ });\n/* harmony import */ var _closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../closest-boundary-point/get-close-boundary-points-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-close-boundary-points-certified.js\");\n\n/**\n * @internal\n * @param x\n * @param bezierPiece3s\n * @param extreme\n */\nfunction getClosestPoints(x, bezierPiece3s) {\n    return bezierPiece3s.map(bezierPieces => {\n        return (0,_closest_boundary_point_get_close_boundary_points_certified_js__WEBPACK_IMPORTED_MODULE_0__.getCloseBoundaryPointsCertified)(bezierPieces, x)[0];\n    });\n}\n\n//# sourceMappingURL=get-closest-points.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-3-prong.ts/get-closest-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/add-debug-info.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/add-debug-info.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDebugInfo1: () => (/* binding */ addDebugInfo1),\n/* harmony export */   addDebugInfo2: () => (/* binding */ addDebugInfo2),\n/* harmony export */   addDebugInfo3: () => (/* binding */ addDebugInfo3),\n/* harmony export */   addDebugInfo4: () => (/* binding */ addDebugInfo4)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js\");\n/* harmony import */ var _curve_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curve/curve.js */ \"./node_modules/flo-mat/node/curve/curve.js\");\n/* harmony import */ var _geometry_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/get-bounding-box-.js */ \"./node_modules/flo-mat/node/geometry/get-bounding-box-.js\");\n\n\n\nlet timingStart;\n/** @internal */\nfunction addDebugInfo1(loops) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    timingStart = performance.now();\n    for (const loop of loops) {\n        _debug_.fs.nameObj(loop, 'l|');\n    }\n    const generated = _debug_.generated;\n    //generated.elems.loop.push(...loops);\n    //generated.elems.loops.push(loops);\n    for (const loop of loops) {\n        let i = 0;\n        loop.curves.forEach(function (curve) {\n            const ps = curve.ps;\n            const hull = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingHull)(ps);\n            generated.elems.boundingHull.push(hull);\n            const looseBoundingBox = (0,_geometry_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(ps);\n            generated.elems.looseBoundingBox.push(looseBoundingBox);\n            const tightBoundingBox = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxTight)(ps);\n            generated.elems.tightBoundingBox.push(tightBoundingBox);\n            const corner = (0,_curve_curve_js__WEBPACK_IMPORTED_MODULE_3__.getCornerAtEnd)(curve);\n            if (corner.isQuiteSharp) {\n                generated.elems.sharpCorner.push(curve);\n            }\n            else if (corner.isQuiteDull) {\n                generated.elems.dullCorner.push(curve);\n            }\n            i++;\n        });\n    }\n}\n/** @internal */\nfunction addDebugInfo2() {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    const timing = _debug_.generated.timing;\n    const now = performance.now();\n    timing.holeClosers += now - timingStart;\n    timingStart = now;\n}\nfunction addDebugInfo3() {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    const generated = _debug_.generated;\n    const timing = generated.timing;\n    const now = performance.now();\n    timing.oneAnd2Prongs += now - timingStart;\n    timingStart = now;\n}\nfunction addDebugInfo4(mat) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    const generated = _debug_.generated;\n    const timing = generated.timing;\n    generated.elems.mat.push(mat);\n    timing.threeProngs += performance.now() - timingStart;\n}\n\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/create-initial-cp-graph.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/create-initial-cp-graph.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createInitialCpGraph: () => (/* binding */ createInitialCpGraph)\n/* harmony export */ });\n/* harmony import */ var flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/tree.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n\n/**\n * @internal\n * Creates the initial ContactPoint loops from the given sharp corners.\n * @param shape\n * @param sharpCornerss\n */\nfunction createInitialCpGraph(loops, cpTrees, sharpCornerss /*,\nxMap: Map<number[][],{ ps: number[][] }>*/) {\n    let cpNode;\n    for (let k = 0; k < sharpCornerss.length; k++) {\n        const sharpCorners = sharpCornerss[k];\n        const cpTree = new flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_0__.LlRbTree(_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.cpNodeComparator, false);\n        let cpNode1 = undefined;\n        let cpNode2 = undefined;\n        for (const pos of sharpCorners) {\n            const ps = pos.curve.next.ps;\n            //const x = xMap.get(ps);\n            //const isIntersection = !!x;\n            const circle = { center: pos.p, radius: 0 };\n            const cp1 = { pointOnShape: pos, circle, order: -1, order2: 0 };\n            const cp2 = { pointOnShape: pos, circle, order: +1, order2: 0 };\n            cpNode1 = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.insertCpNode)(false, /*isIntersection*/ false, cpTree, cp1, cpNode2);\n            cpNode2 = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.insertCpNode)(false, /*isIntersection*/ false, cpTree, cp2, cpNode1);\n            cpNode1.prevOnCircle = cpNode2;\n            cpNode2.prevOnCircle = cpNode1;\n            cpNode1.nextOnCircle = cpNode2;\n            cpNode2.nextOnCircle = cpNode1;\n        }\n        if (!cpNode) {\n            cpNode = cpNode1;\n        }\n        const loop = loops[k];\n        cpTrees.set(loop, cpTree);\n    }\n    return cpNode;\n}\n\n//# sourceMappingURL=create-initial-cp-graph.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/create-initial-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/find-mat.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/find-mat.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findMat: () => (/* binding */ findMat)\n/* harmony export */ });\n/* harmony import */ var _find_3_prong_ts_find_and_add_all_3_prongs_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../find-3-prong.ts/find-and-add-all-3-prongs.js */ \"./node_modules/flo-mat/node/find-3-prong.ts/find-and-add-all-3-prongs.js\");\n/* harmony import */ var _create_initial_cp_graph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./create-initial-cp-graph.js */ \"./node_modules/flo-mat/node/find-mat/create-initial-cp-graph.js\");\n/* harmony import */ var _add_debug_info_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-debug-info.js */ \"./node_modules/flo-mat/node/find-mat/add-debug-info.js\");\n/* harmony import */ var _get_sharp_corners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-sharp-corners.js */ \"./node_modules/flo-mat/node/find-mat/get-sharp-corners.js\");\n/* harmony import */ var _get_dull_corners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-dull-corners.js */ \"./node_modules/flo-mat/node/find-mat/get-dull-corners.js\");\n/* harmony import */ var _find_2_prong_find_and_add_2_prongs_on_all_paths_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../find-2-prong/find-and-add-2-prongs-on-all-paths.js */ \"./node_modules/flo-mat/node/find-2-prong/find-and-add-2-prongs-on-all-paths.js\");\n/* harmony import */ var _get_for_2_prongs_on_loop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-for-2-prongs-on-loop.js */ \"./node_modules/flo-mat/node/find-mat/get-for-2-prongs-on-loop.js\");\n/* harmony import */ var _get_for_1_prongs_on_loop_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-for-1-prongs-on-loop.js */ \"./node_modules/flo-mat/node/find-mat/get-for-1-prongs-on-loop.js\");\n/* harmony import */ var _find_2_prong_find_and_add_hole_closing_2_prongs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../find-2-prong/find-and-add-hole-closing-2-prongs.js */ \"./node_modules/flo-mat/node/find-2-prong/find-and-add-hole-closing-2-prongs.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @internal\n * Find the MAT of the given loops.\n * @param loops The loops (that as a precondition must be ordered from highest\n * (i.e. smallest y-value) topmost point loops to lowest)\n */\nfunction findMat(loops, minBezLength, maxCurviness, maxLength, maxCoordinate) {\n    (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_0__.addDebugInfo1)(loops);\n    const getSharpCornersOnLoop_ = (0,_get_sharp_corners_js__WEBPACK_IMPORTED_MODULE_1__.getSharpCornersOnLoop)(minBezLength);\n    const getDullCornersOnLoop_ = (0,_get_dull_corners_js__WEBPACK_IMPORTED_MODULE_2__.getDullCornersOnLoop)(minBezLength);\n    const sharpCornersPerLoop = loops.map(getSharpCornersOnLoop_);\n    const dullCornersPerLoop = loops.map(getDullCornersOnLoop_);\n    const cpTrees = new Map();\n    (0,_create_initial_cp_graph_js__WEBPACK_IMPORTED_MODULE_3__.createInitialCpGraph)(loops, cpTrees, sharpCornersPerLoop);\n    (0,_find_2_prong_find_and_add_hole_closing_2_prongs_js__WEBPACK_IMPORTED_MODULE_4__.findAndAddHoleClosing2Prongs)(loops, cpTrees, maxCoordinate);\n    if (typeof _debug_ !== 'undefined') {\n        if (_debug_.directives.stopAfterHoleClosers) {\n            return undefined;\n        }\n    }\n    (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_0__.addDebugInfo2)();\n    const for1ProngsPerLoop = loops.map((0,_get_for_1_prongs_on_loop_js__WEBPACK_IMPORTED_MODULE_5__.getFor1ProngsOnLoop)(minBezLength));\n    const for2ProngsPerLoop = loops.map((0,_get_for_2_prongs_on_loop_js__WEBPACK_IMPORTED_MODULE_6__.getFor2ProngsOnLoop)(minBezLength, maxCurviness, maxLength));\n    let cpNode;\n    cpNode = (0,_find_2_prong_find_and_add_2_prongs_on_all_paths_js__WEBPACK_IMPORTED_MODULE_7__.findAndAdd2ProngsOnAllPaths)(cpNode, loops, cpTrees, dullCornersPerLoop, maxCoordinate, false);\n    cpNode = (0,_find_2_prong_find_and_add_2_prongs_on_all_paths_js__WEBPACK_IMPORTED_MODULE_7__.findAndAdd2ProngsOnAllPaths)(cpNode, loops, cpTrees, for1ProngsPerLoop, maxCoordinate, true);\n    cpNode = (0,_find_2_prong_find_and_add_2_prongs_on_all_paths_js__WEBPACK_IMPORTED_MODULE_7__.findAndAdd2ProngsOnAllPaths)(cpNode, loops, cpTrees, for2ProngsPerLoop, maxCoordinate, false);\n    (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_0__.addDebugInfo3)();\n    if (typeof _debug_ !== 'undefined') {\n        if (_debug_.directives.stopAfterTwoProngs) {\n            return undefined;\n        }\n    }\n    if (cpNode === undefined) {\n        return undefined;\n    }\n    (0,_find_3_prong_ts_find_and_add_all_3_prongs_js__WEBPACK_IMPORTED_MODULE_8__.findAndAddAll3Prongs)(cpTrees, cpNode, maxCoordinate);\n    if (typeof _debug_ !== 'undefined') {\n        if (_debug_.directives.stopAfterThreeProngs) {\n            return undefined;\n        }\n    }\n    const mat = { cpNode, cpTrees };\n    (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_0__.addDebugInfo4)(mat);\n    return mat;\n}\n\n//# sourceMappingURL=find-mat.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/find-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/find-mats.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/find-mats.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findMats: () => (/* binding */ findMats)\n/* harmony export */ });\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/calc-paths/simplify-paths.js\");\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js\");\n/* harmony import */ var _find_mat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./find-mat.js */ \"./node_modules/flo-mat/node/find-mat/find-mat.js\");\n/* harmony import */ var _get_size_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-size-params.js */ \"./node_modules/flo-mat/node/find-mat/get-size-params.js\");\n\n\n\n/**\n * Finds and returns the Medial Axis Transforms (MATs) from the given array of\n * bezier loops representing shape boundaries.\n *\n * @param bezierLoops An array of (possibly intersecting) loops with each loop\n * representing one or more piecewise smooth closed curves (i.e. shapes). Each\n * loop consists of an array of beziers represented by an array of control\n * points with 2,3 or 4 elements corresponding to linear, quadratic and cubic\n * beziers respectively. Each point is a two-element array (ordered pair), the\n * first of which is the x-coordinate and the second the y-coordinate.\n *\n * @param maxCurviness The maximum value the 'curviness' of a curve can have\n * before an additional MAT point is inserted in between. Defaults to 0.4.\n * (Curviness is measured as the total angle in radians between the consecutive\n * vectors formed by the ordered control points of th bezier curve). The value\n * is clipped in the range `[0.05,3]`.\n * @param maxLength The maximum length a curve can have before an additional MAT\n * point is inserted. This value is scaled to a reference 1024 x 1024\n * grid (e.g. if the shape fits in a 512 x 512 axis-aligned box the value will be\n * halved, e.g. from 10 to 5). Together with maxCurviness it represents a\n * tolerance for the accuracy of the MAT. Defaults to 4. The value is clipped\n * in [1,100].\n */\nfunction findMats(bezierLoops, maxCurviness = 0.4, maxLength = 4) {\n    // if (typeof _debug_ !== 'undefined') { var timingStart = performance.now(); }\n    let maxCoordinate;\n    let minBezLength;\n    ({ maxCurviness, maxLength, maxCoordinate, minBezLength } =\n        (0,_get_size_params_js__WEBPACK_IMPORTED_MODULE_0__.getSizeParams)(bezierLoops, maxCurviness, maxLength));\n    const loopss = (0,flo_boolean__WEBPACK_IMPORTED_MODULE_1__.simplifyPaths)(bezierLoops);\n    // console.log(loopsToSvgPathStr(bezierLoops.map(v => v.map(v => v.map(v => v.map(v => v*2**4))))));\n    // console.log(loopsToSvgPathStr(loopss[0].map(loop => loop.beziers)));\n    const mats = [];\n    for (const loops of loopss) {\n        const mat = (0,_find_mat_js__WEBPACK_IMPORTED_MODULE_2__.findMat)(loops, minBezLength, maxCurviness, maxLength, maxCoordinate);\n        if (mat) {\n            mats.push(mat);\n        }\n    }\n    return mats;\n}\n/**\n * Returns an SVG path string representation of the given bezier loops.\n * @param loops An array of loops having an array of bezier curves each given as\n * an array of control points.\n */\nfunction loopsToSvgPathStr(loops) {\n    let str = '';\n    for (const loop of loops) {\n        str = str + (0,flo_boolean__WEBPACK_IMPORTED_MODULE_3__.beziersToSvgPathStr)(loop) + '\\n';\n    }\n    return str;\n}\n\n//# sourceMappingURL=find-mats.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/find-mats.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/fix-ordering.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/fix-ordering.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixOrdering: () => (/* binding */ fixOrdering)\n/* harmony export */ });\n/**\n * @internal\n *\n * Use only for debugging. Check all nodes around the loop.\n */\nfunction fixOrdering(cpNode) {\n    const cpStart = cpNode;\n    /* holeCloser order causes an issue here\n    {\n        const cpNodes = getAllOnLoop(cpStart);\n\n        cpNodes.sort(cpNodeComparator);\n        // console.log(cpNodes.map(cpn => enhanceCpNode(cpn).ordering))\n\n        const len = cpNodes.length;\n        for (let i=0; i<len; i++) {\n            const cpNode = cpNodes[i];\n            const prev = cpNodes[(i + len - 1)%len];\n            const next = cpNodes[(i + len + 1)%len];\n            if (cpNode.prev !== prev) {\n                // console.log(enhanceCpNode(cpNode));\n            }\n            if (cpNode.next !== next) {\n                // console.log(enhanceCpNode(cpNode));\n            }\n            // cpNode.prev = prev;\n            // cpNode.next = next;\n        }\n    }\n    */\n    /*\n    {\n        let cpNode2 = cpStart.next;\n        while (cpNode2 !== cpStart) {\n            const cpNode1 = cpNode2;\n            cpNode2 = cpNode2.next;\n\n            const c = cpNodeComparator(cpNode1, cpNode2)!;\n            const looplen = cpNode1.cp.pointOnShape.curve.loop.beziers.length;\n            if (c > 0 && !cpNode1.isHoleClosing && !cpNode2.isHoleClosing) {\n                const o1 = cpNode1.cp.pointOnShape.curve.idx;\n                const o2 = cpNode2.cp.pointOnShape.curve.idx;\n                if (if) {\n                   1;\n                } else {\n                    console.log('ORDER IS WRONG!', looplen, o1, o2)\n                    console.log(c);\n                    console.log(enhanceCpNode(cpNode1));\n                    console.log(enhanceCpNode(cpNode2));\n                    console.log('');\n                }\n            }\n        }\n    }\n    */\n    // return cpNodes;\n}\n\n//# sourceMappingURL=fix-ordering.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/fix-ordering.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/get-dull-corners.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/get-dull-corners.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDullCornersOnLoop: () => (/* binding */ getDullCornersOnLoop)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n/* harmony import */ var _curve_curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curve/curve.js */ \"./node_modules/flo-mat/node/curve/curve.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n\n\n\n/** @internal */\nfunction getDullCornersOnLoop(minBezLength) {\n    return (loop) => {\n        const dullCorners = [];\n        for (let i = 0; i < loop.curves.length; i++) {\n            const curve = loop.curves[i];\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(curve.ps) < minBezLength) {\n                continue;\n            }\n            if ((0,_curve_curve_js__WEBPACK_IMPORTED_MODULE_1__.getCornerAtEnd)(curve).isQuiteDull) {\n                dullCorners.push((0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(curve, 1, true));\n                dullCorners.push((0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(curve.next, 0, true));\n            }\n        }\n        return dullCorners;\n    };\n}\n\n//# sourceMappingURL=get-dull-corners.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/get-dull-corners.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/get-for-1-prongs-on-loop.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/get-for-1-prongs-on-loop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFor1ProngsOnLoop: () => (/* binding */ getFor1ProngsOnLoop)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/get-curvature-extrema-dd/get-curvature-extrema-dd.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n\n\n/**\n * @internal\n * Get useful points on the shape - these incude points of maximum curvature and\n * points at the bezier-bezier interfaces.\n * @param loop\n * @param additionalPointCount\n */\nfunction getFor1ProngsOnLoop(minBezLength) {\n    return function (loop) {\n        const for1Prongs = [];\n        for (let i = 0; i < loop.curves.length; i++) {\n            const curve = loop.curves[i];\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(curve.ps) < minBezLength) {\n                continue;\n            }\n            // const { minima, maxima } = getCurvatureExtrema(curve.ps);\n            const { minima, maxima } = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getCurvatureExtremaDd)(curve.ps);\n            // const { minima, maxima } = getCurvatureExtremaE(curve.ps);\n            const maxAbsCurvatures = [...minima, ...maxima].map(t => (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(curve, t, true));\n            for1Prongs.push(...maxAbsCurvatures);\n        }\n        return for1Prongs;\n    };\n}\n\n//# sourceMappingURL=get-for-1-prongs-on-loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/get-for-1-prongs-on-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/get-for-2-prongs-on-loop.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/get-for-2-prongs-on-loop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFor2ProngsOnLoop: () => (/* binding */ getFor2ProngsOnLoop)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n\n\n/**\n * @internal\n * Get useful points on the shape - these incude points of maximum curvature and\n * points at the bezier-bezier interfaces.\n * @param loop\n * @param additionalPointCount\n */\nfunction getFor2ProngsOnLoop(minBezLength, maxCurviness, maxLength) {\n    return function (loop) {\n        const for2Prongs = [];\n        for (let i = 0; i < loop.curves.length; i++) {\n            const curve = loop.curves[i];\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(curve.ps) < minBezLength) {\n                continue;\n            }\n            let ts = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.splitByCurvatureAndLength)(curve.ps, maxCurviness, maxLength);\n            // add at least one in the middle\n            if (ts.length === 2) {\n                ts = [0, 0.5, 1];\n            }\n            const byCurvatureAndLength = ts.slice(1, ts.length - 1).map(t => (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(curve, t, true));\n            for2Prongs.push(...byCurvatureAndLength);\n        }\n        return for2Prongs;\n    };\n}\n\n//# sourceMappingURL=get-for-2-prongs-on-loop.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/get-for-2-prongs-on-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/get-sharp-corners.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/get-sharp-corners.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSharpCornersOnLoop: () => (/* binding */ getSharpCornersOnLoop)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n/* harmony import */ var _curve_curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curve/curve.js */ \"./node_modules/flo-mat/node/curve/curve.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js\");\n\n\n\n/** @internal */\nfunction getSharpCornersOnLoop(minBezLength) {\n    return (loop) => {\n        const sharpCorners = [];\n        for (let i = 0; i < loop.curves.length; i++) {\n            const curve = loop.curves[i];\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(curve.ps) < minBezLength) {\n                continue;\n            }\n            if ((0,_curve_curve_js__WEBPACK_IMPORTED_MODULE_1__.getCornerAtEnd)(curve).isQuiteSharp) {\n                sharpCorners.push((0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(curve, 1, true));\n            }\n        }\n        return sharpCorners;\n    };\n}\n\n//# sourceMappingURL=get-sharp-corners.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/get-sharp-corners.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mat/get-size-params.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mat/get-size-params.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSizeParams: () => (/* binding */ getSizeParams)\n/* harmony export */ });\n/* harmony import */ var _loop_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loop/get-max-coordinate.js */ \"./node_modules/flo-mat/node/loop/get-max-coordinate.js\");\n\nfunction getSizeParams(bezierLoops, maxCurviness, maxLength) {\n    // Gather some shape metrics\n    const { maxCoordinate, maxRadius } = (0,_loop_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_0__.getLoopsMetrics)(bezierLoops);\n    const expMax = Math.ceil(Math.log2(maxCoordinate));\n    const minBezLengthSigBits = 16;\n    /**\n     * If a curve is shorter than this value then no points on it will be\n     * selected for the purpose of finding the MAT.\n     */\n    const minBezLength = 2 ** expMax * 2 ** (-minBezLengthSigBits);\n    // Limit the tolerance to a reasonable level\n    if (maxCurviness < 0.05) {\n        maxCurviness = 0.05;\n    }\n    if (maxCurviness > 3) {\n        maxCurviness = 3;\n    }\n    // Limit the tolerance to a reasonable level\n    if (maxLength < 0.1) {\n        maxLength = 0.1;\n    }\n    if (maxLength > 100) {\n        maxLength = 100;\n    }\n    // Adjust length tolerance according to a reference max coordinate\n    const expMaxRadius = Math.ceil(Math.log2(maxRadius));\n    const maxLengthSigBits = 10; // 1024 x 1024\n    maxLength = maxLength * (2 ** expMaxRadius * 2 ** (-maxLengthSigBits));\n    return { maxCurviness, maxLength, maxCoordinate, minBezLength };\n}\n\n//# sourceMappingURL=get-size-params.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/find-mat/get-size-params.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/geometry/circle.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-mat/node/geometry/circle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   engulfsCircle: () => (/* binding */ engulfsCircle),\n/* harmony export */   scaleCircle: () => (/* binding */ scaleCircle)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n\n/**\n * Returns a scaled version of the given circle without changing its center.\n * @param circle\n * @param s multiplier\n */\nfunction scaleCircle(circle, s) {\n    return { center: circle.center, radius: s * circle.radius };\n}\n/**\n * Returns true if the first circle engulfs the second.\n * @param c1\n * @param c2\n */\nfunction engulfsCircle(c1, c2) {\n    if (c1.radius <= c2.radius) {\n        return false;\n    }\n    const d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(c1.center, c2.center);\n    const dr = c1.radius - c2.radius;\n    const δ = dr * dr;\n    return δ > d;\n}\n/**\n * Returns a human-readable string description of the given circle.\n * @param circle\n */\nfunction toString(circle) {\n    return 'c: ' + circle.center + ' r: ' + circle.radius;\n}\n\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/geometry/circle.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/geometry/get-bounding-box-.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-mat/node/geometry/get-bounding-box-.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingBox_: () => (/* binding */ getBoundingBox_)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n\n\nconst getBoundingBox_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox);\n\n//# sourceMappingURL=get-bounding-box-.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/geometry/get-bounding-box-.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/geometry/get-closest-square-distance-to-rect.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/geometry/get-closest-square-distance-to-rect.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClosestSquareDistanceToRect: () => (/* binding */ getClosestSquareDistanceToRect)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n\nconst squaredDistanceBetween = flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween;\n/**\n * @internal\n */\nfunction getClosestSquareDistanceToRect(box, p) {\n    const p0 = box[0];\n    const p1 = box[1];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const xp = p[0];\n    const yp = p[1];\n    //let [[x0,y0],[x1,y1]] = box;\n    //let [xp,yp] = p;\n    if (xp < x0) {\n        if (yp < y0) {\n            return squaredDistanceBetween(box[0], p);\n        }\n        else if (yp > y1) {\n            return squaredDistanceBetween([x0, y1], p);\n        }\n        else {\n            return (x0 - xp) ** 2;\n        }\n    }\n    else if (xp > x1) {\n        if (yp < y0) {\n            return squaredDistanceBetween([x1, y0], p);\n        }\n        else if (yp > y1) {\n            return squaredDistanceBetween(box[1], p);\n        }\n        else {\n            return (xp - x1) ** 2;\n        }\n    }\n    else {\n        if (yp < y0) {\n            return (y0 - yp) ** 2;\n        }\n        else if (yp > y1) {\n            return (yp - y1) ** 2;\n        }\n        return 0;\n    }\n}\n\n//# sourceMappingURL=get-closest-square-distance-to-rect.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/geometry/get-closest-square-distance-to-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/geometry/get-closest-squared-distance-to-rotated-rect.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/geometry/get-closest-squared-distance-to-rotated-rect.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClosestSquaredDistanceToRotatedRect: () => (/* binding */ getClosestSquaredDistanceToRotatedRect)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n\n/**\n * @internal\n */\nfunction getClosestSquaredDistanceToRotatedRect(ps, p) {\n    const ds = [0, 1, 2, 3].map(i => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetweenPointAndLineSegment)(p, [ps[i], ps[(i + 1) % 4]]));\n    const width = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(ps[0], ps[1]);\n    const height = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(ps[0], ps[3]);\n    if (ds[0] <= height && ds[2] <= height &&\n        ds[1] <= width && ds[3] <= width) {\n        return 0; // Inside rotated rect\n    }\n    return Math.min(...ds);\n}\n\n//# sourceMappingURL=get-closest-squared-distance-to-rotated-rect.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/geometry/get-closest-squared-distance-to-rotated-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-curve/get-curve-between.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-curve/get-curve-between.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveBetween: () => (/* binding */ getCurveBetween)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/cross.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var _get_edge_direction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-edge-direction.js */ \"./node_modules/flo-mat/node/get-curve/get-edge-direction.js\");\n\n\n/** @internal */\nconst TOLERANCE_ADD_2PRONG = 0.01;\n/** @internal */\nconst TOLERANCE_USE_LINE = 0.0001; // else cubic\n/**\n * Returns the bezier curve from the maximal disk of one [[CpNode]] to another\n * [[CpNode]]'s maximal disk.\n * @param cpNodeFrom\n * @param cpNodeTo\n */\nfunction getCurveBetween(cpNodeFrom, cpNodeTo) {\n    const fromCc = cpNodeFrom.cp.circle.center;\n    const fromL = (0,_get_edge_direction_js__WEBPACK_IMPORTED_MODULE_0__.getEdgeDirection)(cpNodeFrom);\n    const toCc = cpNodeTo.cp.circle.center;\n    const toL = (0,_get_edge_direction_js__WEBPACK_IMPORTED_MODULE_0__.getEdgeDirection)(cpNodeTo.prevOnCircle);\n    const mid = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.lineLineIntersection)(fromL, toL);\n    const c = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.fromTo)(fromCc, toCc);\n    let twisted;\n    if (!mid) {\n        twisted = true;\n    }\n    else {\n        const a = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.fromTo)(fromCc, mid);\n        const b = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.fromTo)(toCc, mid);\n        twisted = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.dot)(a, c) < 0 || (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.dot)(b, c) > 0;\n    }\n    if (!twisted) {\n        return [fromCc, mid, toCc];\n    }\n    const r = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.rotate90Degrees)(c);\n    const w1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.fromTo)(fromL[0], fromL[1]); // This is a unit vector\n    const w2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.fromTo)(toL[0], toL[1]); // This is a unit vector\n    const d1 = Math.abs((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.cross)(c, w1)) / (3 * 3);\n    const d2 = Math.abs((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.cross)(c, w2)) / (3 * 3);\n    if (d1 > TOLERANCE_ADD_2PRONG || d2 > TOLERANCE_ADD_2PRONG) {\n        // TODO - not within tolerance - must add additional 2-prong\n        return [fromCc, toCc];\n    }\n    if (d1 > TOLERANCE_USE_LINE || d2 > TOLERANCE_USE_LINE) {\n        // approximate with cubic bezier\n        const m1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.interpolate)(fromCc, toCc, 1 / 3);\n        const m2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.interpolate)(fromCc, toCc, 2 / 3);\n        const v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.translate)(r, m1);\n        const v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.translate)(r, m2);\n        const l1 = [m1, v1];\n        const l2 = [m2, v2];\n        const mid1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.lineLineIntersection)(fromL, l1);\n        const mid2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.lineLineIntersection)(toL, l2);\n        return [fromCc, mid1, mid2, toCc];\n    }\n    // Within tolerance - approximate with a straight line.\n    return [fromCc, toCc];\n}\n\n//# sourceMappingURL=get-curve-between.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/get-curve/get-curve-between.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-curve/get-edge-direction.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-curve/get-edge-direction.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEdgeDirection: () => (/* binding */ getEdgeDirection)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js\");\n/* harmony import */ var _point_on_shape_is_pos_sharp_corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/is-pos-sharp-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-sharp-corner.js\");\n\n\n\n/**\n * @internal\n * Returns a line segment of unit length starting in the given Vertex center and\n * pointing in the direction of the medial axis (viewed as a rooted tree).\n * @param cpNode\n */\nfunction getEdgeDirection(cpNode) {\n    const circleCenter = cpNode.cp.circle.center;\n    const cp1 = cpNode;\n    const cp2 = cpNode.nextOnCircle;\n    const pos1 = cp1.cp.pointOnShape;\n    const pos2 = cp2.cp.pointOnShape;\n    const p1 = pos1.p;\n    const p2 = pos2.p;\n    let vDir;\n    if (!(0,_point_on_shape_is_pos_sharp_corner_js__WEBPACK_IMPORTED_MODULE_0__.isPosSharpCorner)(pos1)) {\n        if (p1[0] === p2[0] && p1[1] === p2[1]) {\n            vDir = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(p1, circleCenter); // A 1-prong\n        }\n        else {\n            vDir = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.rotate90Degrees)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo)(p1, p2)); // not a 1-prong.\n        }\n    }\n    else {\n        let curve1;\n        let curve2;\n        if (pos1.t === 0) {\n            curve1 = pos1.curve;\n            curve2 = pos1.curve.prev;\n        }\n        else if (pos1.t === 1) {\n            curve1 = pos1.curve.next;\n            curve2 = pos1.curve;\n        }\n        const tan1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.tangent)(curve1.ps, 0));\n        const tan2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.reverse)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.tangent)(curve2.ps, 1)));\n        const x = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.dot)(tan1, tan2);\n        // Recall the identities sin(acos(x)) = sqrt(1-x^2), etc. Also \n        // recall the half angle formulas. Then the rotation matrix, R, can \n        // be calculated.\n        const cosθ = Math.sqrt((1 + x) / 2);\n        const sinθ = Math.sqrt((1 - x) / 2);\n        vDir = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_7__.rotate)(sinθ, cosθ, tan2);\n    }\n    const v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_8__.translate)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.toUnitVector)(vDir), circleCenter);\n    return [circleCenter, v];\n}\n\n//# sourceMappingURL=get-edge-direction.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/get-curve/get-edge-direction.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/index.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beziersToSvgPathStr: () => (/* reexport safe */ flo_boolean__WEBPACK_IMPORTED_MODULE_15__.beziersToSvgPathStr),\n/* harmony export */   cpNodeComparator: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.cpNodeComparator),\n/* harmony export */   createCpNode: () => (/* reexport safe */ _cp_node_create_cp_node_js__WEBPACK_IMPORTED_MODULE_10__.createCpNode),\n/* harmony export */   createPos: () => (/* reexport safe */ _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_23__.createPos),\n/* harmony export */   drawBranch: () => (/* reexport safe */ _debug_functions_draw_elem_branch_js__WEBPACK_IMPORTED_MODULE_18__.drawBranch),\n/* harmony export */   drawElemFunctions: () => (/* reexport safe */ _debug_functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_25__.drawElemFunctions),\n/* harmony export */   drawMat: () => (/* reexport safe */ _debug_functions_draw_elem_mat_js__WEBPACK_IMPORTED_MODULE_19__.drawMat),\n/* harmony export */   enableDebugForMat: () => (/* reexport safe */ _debug_debug_js__WEBPACK_IMPORTED_MODULE_29__.enableDebugForMat),\n/* harmony export */   enhanceCpNode: () => (/* reexport safe */ _cp_node_enhance_cp_node_js__WEBPACK_IMPORTED_MODULE_13__.enhanceCpNode),\n/* harmony export */   findMats: () => (/* reexport safe */ _find_mat_find_mats_js__WEBPACK_IMPORTED_MODULE_0__.findMats),\n/* harmony export */   getAllOnLoop: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.getAllOnLoop),\n/* harmony export */   getBoundaryBezierPartsToNext: () => (/* reexport safe */ _cp_node_get_boundary_bezier_parts_to_next_js__WEBPACK_IMPORTED_MODULE_7__.getBoundaryBezierPartsToNext),\n/* harmony export */   getBoundaryBeziersToNext: () => (/* reexport safe */ _cp_node_get_boundary_beziers_to_next_js__WEBPACK_IMPORTED_MODULE_6__.getBoundaryBeziersToNext),\n/* harmony export */   getBoundaryPieceBeziers: () => (/* reexport safe */ _mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_24__.getBoundaryPieceBeziers),\n/* harmony export */   getBranches: () => (/* reexport safe */ _mat_get_branches_js__WEBPACK_IMPORTED_MODULE_5__.getBranches),\n/* harmony export */   getChildren: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.getChildren),\n/* harmony export */   getClosestBoundaryPointCertified: () => (/* reexport safe */ _closest_boundary_point_get_closest_boundary_point_certified_js__WEBPACK_IMPORTED_MODULE_20__.getClosestBoundaryPointCertified),\n/* harmony export */   getClosestSquareDistanceToRect: () => (/* reexport safe */ _geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_27__.getClosestSquareDistanceToRect),\n/* harmony export */   getCpNodesOnCircle: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.getCpNodesOnCircle),\n/* harmony export */   getCurveBetween: () => (/* reexport safe */ _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_22__.getCurveBetween),\n/* harmony export */   getCurveToNext: () => (/* reexport safe */ _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_21__.getCurveToNext),\n/* harmony export */   getFirstExit: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.getFirstExit),\n/* harmony export */   getPathsFromStr: () => (/* reexport safe */ flo_boolean__WEBPACK_IMPORTED_MODULE_16__.getPathsFromStr),\n/* harmony export */   getProngCount: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.getProngCount),\n/* harmony export */   getRealProngCount: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.getRealProngCount),\n/* harmony export */   getShapeBounds: () => (/* reexport safe */ _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_17__.getShapeBounds),\n/* harmony export */   insertCpNode: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.insertCpNode),\n/* harmony export */   isFullyTerminating: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.isFullyTerminating),\n/* harmony export */   isOnSameCircle: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.isOnSameCircle),\n/* harmony export */   isSharp: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.isSharp),\n/* harmony export */   isTerminating: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.isTerminating),\n/* harmony export */   loopFromBeziers: () => (/* reexport safe */ flo_boolean__WEBPACK_IMPORTED_MODULE_28__.loopFromBeziers),\n/* harmony export */   matCurveToNextVertex: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.matCurveToNextVertex),\n/* harmony export */   removeCpNode: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_12__.removeCpNode),\n/* harmony export */   simplifyMat: () => (/* reexport safe */ _mat_simplify_mat_js__WEBPACK_IMPORTED_MODULE_8__.simplifyMat),\n/* harmony export */   simplifyMatMapOnly: () => (/* reexport safe */ _mat_simplify_mat_map_only_js__WEBPACK_IMPORTED_MODULE_9__.simplifyMatMapOnly),\n/* harmony export */   sweepLine: () => (/* reexport safe */ _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_26__.sweepLine),\n/* harmony export */   toScaleAxis: () => (/* reexport safe */ _sat_to_scale_axis_js__WEBPACK_IMPORTED_MODULE_1__.toScaleAxis),\n/* harmony export */   traverseCp: () => (/* reexport safe */ _cp_node_traverse_cp_js__WEBPACK_IMPORTED_MODULE_14__.traverseCp),\n/* harmony export */   traverseEdges: () => (/* reexport safe */ _cp_node_traverse_edges_js__WEBPACK_IMPORTED_MODULE_4__.traverseEdges),\n/* harmony export */   traverseVertices: () => (/* reexport safe */ _cp_node_traverse_vertices_js__WEBPACK_IMPORTED_MODULE_3__.traverseVertices),\n/* harmony export */   trimMat: () => (/* reexport safe */ _mat_trim_mat_js__WEBPACK_IMPORTED_MODULE_2__.trimMat),\n/* harmony export */   vertexChildren: () => (/* reexport safe */ _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__.vertexChildren)\n/* harmony export */ });\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js\");\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/svg/get-paths-from-str.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/remove.js\");\n/* harmony import */ var _cp_node_create_cp_node_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cp-node/create-cp-node.js */ \"./node_modules/flo-mat/node/cp-node/create-cp-node.js\");\n/* harmony import */ var _cp_node_enhance_cp_node_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cp-node/enhance-cp-node.js */ \"./node_modules/flo-mat/node/cp-node/enhance-cp-node.js\");\n/* harmony import */ var _cp_node_traverse_cp_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cp-node/traverse-cp.js */ \"./node_modules/flo-mat/node/cp-node/traverse-cp.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n/* harmony import */ var _find_mat_find_mats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find-mat/find-mats.js */ \"./node_modules/flo-mat/node/find-mat/find-mats.js\");\n/* harmony import */ var _mat_trim_mat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat/trim-mat.js */ \"./node_modules/flo-mat/node/mat/trim-mat.js\");\n/* harmony import */ var _sat_to_scale_axis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sat/to-scale-axis.js */ \"./node_modules/flo-mat/node/sat/to-scale-axis.js\");\n/* harmony import */ var _cp_node_traverse_edges_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cp-node/traverse-edges.js */ \"./node_modules/flo-mat/node/cp-node/traverse-edges.js\");\n/* harmony import */ var _mat_get_branches_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mat/get-branches.js */ \"./node_modules/flo-mat/node/mat/get-branches.js\");\n/* harmony import */ var _cp_node_traverse_vertices_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cp-node/traverse-vertices.js */ \"./node_modules/flo-mat/node/cp-node/traverse-vertices.js\");\n/* harmony import */ var _debug_debug_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./debug/debug.js */ \"./node_modules/flo-mat/node/debug/debug.js\");\n/* harmony import */ var _debug_functions_draw_elem_branch_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./debug/functions/draw-elem/branch.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js\");\n/* harmony import */ var _debug_functions_draw_elem_mat_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./debug/functions/draw-elem/mat.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\n/* harmony import */ var _closest_boundary_point_get_closest_boundary_point_certified_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./closest-boundary-point/get-closest-boundary-point-certified.js */ \"./node_modules/flo-mat/node/closest-boundary-point/get-closest-boundary-point-certified.js\");\n/* harmony import */ var _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./svg/get-shape-bounds.js */ \"./node_modules/flo-mat/node/svg/get-shape-bounds.js\");\n/* harmony import */ var _cp_node_get_boundary_beziers_to_next_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cp-node/get-boundary-beziers-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-boundary-beziers-to-next.js\");\n/* harmony import */ var _cp_node_get_boundary_bezier_parts_to_next_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cp-node/get-boundary-bezier-parts-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-boundary-bezier-parts-to-next.js\");\n/* harmony import */ var _mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./mat/get-boundary-piece-beziers.js */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\n/* harmony import */ var _mat_simplify_mat_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mat/simplify-mat.js */ \"./node_modules/flo-mat/node/mat/simplify-mat.js\");\n/* harmony import */ var _mat_simplify_mat_map_only_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mat/simplify-mat-map-only.js */ \"./node_modules/flo-mat/node/mat/simplify-mat-map-only.js\");\n/* harmony import */ var _debug_functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./debug/functions/draw-elem/draw-elem.js */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./get-curve/get-curve-between.js */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\n/* harmony import */ var _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./sweep-line/sweep-line.js */ \"./node_modules/flo-mat/node/sweep-line/sweep-line.js\");\n/* harmony import */ var _geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./geometry/get-closest-square-distance-to-rect.js */ \"./node_modules/flo-mat/node/geometry/get-closest-square-distance-to-rect.js\");\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/loop/loop.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/get-max-coordinate.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/get-max-coordinate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLoopsMetrics: () => (/* binding */ getLoopsMetrics)\n/* harmony export */ });\nconst max = Math.max;\nconst abs = Math.abs;\n/**\n * @internal\n * Returns the maximum control point coordinate value (x or y) within any loop.\n * @param loops The array of loops\n */\nfunction getLoopsMetrics(loops) {\n    let maxCoordinate = 0;\n    let minX = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (const loop of loops) {\n        for (const ps of loop) {\n            for (const p of ps) {\n                const x = p[0];\n                const y = p[1];\n                const c = max(abs(x), abs(y));\n                if (c > maxCoordinate) {\n                    maxCoordinate = c;\n                }\n                if (x < minX) {\n                    minX = x;\n                }\n                if (x > maxX) {\n                    maxX = x;\n                }\n                if (y < minY) {\n                    minY = y;\n                }\n                if (y > maxY) {\n                    maxY = y;\n                }\n            }\n        }\n    }\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const maxRadius = max(width, height);\n    return { maxCoordinate, maxRadius };\n}\n\n//# sourceMappingURL=get-max-coordinate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/loop/get-max-coordinate.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/add-to-cp-graph.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/add-to-cp-graph.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToCpGraph: () => (/* binding */ addToCpGraph)\n/* harmony export */ });\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-neighboring-cps.js */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\n\n\n/**\n * @internal\n *\n * @param circle\n * @param orders\n * @param cpTrees\n * @param poss\n * @param neighbors\n * @internal\n */\nfunction addToCpGraph(circle, orders, cpTrees, poss, neighbors) {\n    const newCps = poss.map((pos, i) => {\n        const cpTree = cpTrees.get(pos.curve.loop);\n        const newCp_ = { pointOnShape: pos, circle, order: orders[i], order2: 0 };\n        const neighboringCp = neighbors\n            ? neighbors[i]\n            : (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_0__.getNeighbouringPoints)(cpTree, pos, orders[i], 0);\n        const newCp = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.insertCpNode)(false, false, cpTree, newCp_, neighboringCp[0]);\n        return newCp;\n    });\n    const len = poss.length;\n    for (let i = 0; i < len; i++) {\n        const indxPrev = i === 0 ? len - 1 : i - 1;\n        const indxNext = i === len - 1 ? 0 : i + 1;\n        newCps[i].prevOnCircle = newCps[indxPrev];\n        newCps[i].nextOnCircle = newCps[indxNext];\n    }\n    return newCps;\n}\n\n//# sourceMappingURL=add-to-cp-graph.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/add-to-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/create-new-cp-tree.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/create-new-cp-tree.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNewCpTree: () => (/* binding */ createNewCpTree)\n/* harmony export */ });\n/* harmony import */ var flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/tree.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n\n/**\n * @internal\n * @param cpNode\n */\nfunction createNewCpTree(cpNode) {\n    const newCpTrees = new Map();\n    (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getAllOnLoop)(cpNode).forEach(createNewCpTree_);\n    function createNewCpTree_(cpNode) {\n        const loop = cpNode.cp.pointOnShape.curve.loop;\n        let cpTree = newCpTrees.get(loop);\n        if (!cpTree) {\n            cpTree = new flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_1__.LlRbTree(_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.cpNodeComparator, false);\n            newCpTrees.set(loop, cpTree);\n        }\n        cpTree.insert(cpNode);\n    }\n    return newCpTrees;\n}\n\n//# sourceMappingURL=create-new-cp-tree.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/create-new-cp-tree.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundaryPieceBeziers: () => (/* binding */ getBoundaryPieceBeziers)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_is_pos_quite_sharp_corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape/is-pos-quite-sharp-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-quite-sharp-corner.js\");\n/* harmony import */ var _contact_point_contact_point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contact-point/contact-point.js */ \"./node_modules/flo-mat/node/contact-point/contact-point.js\");\n\n\n/**\n * @internal\n * Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\n * from the given boundary piece.\n * @param cpNodes - An ordered pair that represents the start and end points of\n * the boundary piece\n */\nfunction getBoundaryPieceBeziers(cpNodes) {\n    let cpThis = cpNodes[0];\n    const cpEnd = cpNodes[1];\n    const bezierPieces = [];\n    // As opposed to going around the circle and taking the last exit\n    let goStraight = true;\n    do {\n        if (!goStraight) {\n            goStraight = true;\n            cpThis = cpThis.prevOnCircle; // take last exit\n            continue;\n        }\n        goStraight = false;\n        const posThis = cpThis.cp.pointOnShape;\n        const posNext = cpThis.next.cp.pointOnShape;\n        if (posNext.curve === posThis.curve &&\n            //PointOnShape.isQuiteSharpCorner(posThis) && \n            //PointOnShape.isQuiteSharpCorner(posNext)) {\n            (0,_point_on_shape_is_pos_quite_sharp_corner_js__WEBPACK_IMPORTED_MODULE_0__.isPosQuiteSharpCorner)(posThis) &&\n            (0,_point_on_shape_is_pos_quite_sharp_corner_js__WEBPACK_IMPORTED_MODULE_0__.isPosQuiteSharpCorner)(posNext)) {\n            // Do nothing\n        }\n        else if (posNext.curve === posThis.curve &&\n            (0,_contact_point_contact_point_js__WEBPACK_IMPORTED_MODULE_1__.compareCps)(cpThis.next.cp, cpThis.cp) > 0) {\n            bezierPieces.push({ curve: posThis.curve, ts: [posThis.t, posNext.t] });\n        }\n        else {\n            bezierPieces.push({ curve: posThis.curve, ts: [posThis.t, 1] });\n            if (cpThis.cp.pointOnShape.curve.loop === cpThis.next.cp.pointOnShape.curve.loop) {\n                addSkippedBeziers(bezierPieces, posThis.curve, posNext.curve, posNext.t);\n            }\n        }\n        cpThis = cpThis.next;\n    } while (cpThis !== cpEnd);\n    return bezierPieces;\n}\n/**\n * @internal\n * Adds pieces of skipped beziers\n */\nfunction addSkippedBeziers(bezierPieces, curveStart, curveEnd, t1) {\n    let curveThis = curveStart;\n    do {\n        curveThis = curveThis.next;\n        const tEnd = curveThis === curveEnd ? t1 : 1;\n        bezierPieces.push({ curve: curveThis, ts: [0, tEnd] });\n    } while (curveThis !== curveEnd);\n}\n\n//# sourceMappingURL=get-boundary-piece-beziers.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-branches.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-branches.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBranches: () => (/* binding */ getBranches)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/cross.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n\n\n\n\n/** @internal */\nconst defaultTolerance = 1; // 1 degree\n/**\n * Traverses all edges (depth first) of the given MAT tree starting at the given\n * vertex (represented by a [[CpNode]]). Returns the result as an array of\n * smooth branches, where smoothness is total or within a given tolerance.\n * @param cpNode Any [[CpNode]] representing the start vertex.\n * @param tolerance Tolerance given as the degrees difference of the unit\n * direction vectors at the interface between curves. A tolerance of zero means\n * perfect smoothness is required.\n */\nfunction getBranches(cpNode, tolerance = defaultTolerance) {\n    // Start from a leaf\n    while (!(0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isFullyTerminating)(cpNode)) {\n        cpNode = cpNode.next;\n    }\n    const branches = [];\n    // Since the tree is unrooted we must iterate in all directions from the\n    // given vertex.\n    const cps = [cpNode.prevOnCircle];\n    let branchCpNodes = [];\n    while (cps.length) {\n        const cp = cps.pop();\n        branchCpNodes.push(cp);\n        let children = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getChildren)(cp);\n        if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isFullyTerminating)(cp)) {\n            if (branchCpNodes.length > 1) {\n                branches.push(branchCpNodes);\n            }\n            branchCpNodes = [];\n            continue;\n        }\n        if (children.length === 1) {\n            cps.push(children[0]);\n            continue;\n        }\n        children = children.filter(cpNode => !(0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode));\n        if (children.length === 0) {\n            branches.push(branchCpNodes);\n            branchCpNodes = [];\n            continue;\n        }\n        if (children.length > 1) {\n            // More than one branch comes together\n            branches.push(branchCpNodes);\n            branchCpNodes = [];\n            cps.push(...children);\n            continue;\n        }\n        const backPointingTan = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.tangent)((0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_3__.getCurveToNext)(cp.next.prevOnCircle), 0));\n        const forwardPointingTan = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.tangent)((0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_3__.getCurveToNext)(children[0]), 0));\n        const cross_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.cross)(backPointingTan, forwardPointingTan);\n        const angle = Math.abs(Math.asin(cross_) * (180 / Math.PI));\n        if (angle > tolerance) {\n            branches.push(branchCpNodes);\n            branchCpNodes = [];\n        }\n        cps.push(children[0]);\n    }\n    if (branchCpNodes.length) {\n        branches.push(branchCpNodes);\n    }\n    return branches;\n}\n\n//# sourceMappingURL=get-branches.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/get-branches.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-largest-vertex.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-largest-vertex.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLargestVertex: () => (/* binding */ getLargestVertex)\n/* harmony export */ });\n/** @internal */\nfunction getLargestVertex(cpNodes) {\n    return cpNodes.reduce(function (maxCpNode, cpNode) {\n        return maxCpNode.cp.circle.radius >= cpNode.cp.circle.radius\n            ? maxCpNode\n            : cpNode;\n    }, cpNodes[0]);\n}\n\n//# sourceMappingURL=get-largest-vertex.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/get-largest-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-neighboring-cps.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-neighboring-cps.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNeighbouringPoints: () => (/* binding */ getNeighbouringPoints)\n/* harmony export */ });\n/* harmony import */ var _cp_node_create_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/create-cp-node.js */ \"./node_modules/flo-mat/node/cp-node/create-cp-node.js\");\n\n/**\n * @internal\n *\n * Returns the boundary piece that starts at the immediate previous point on the\n * shape and ends at the immediate next point.\n *\n * @param cpTree\n * @param pos\n * @param order\n * @param order2\n */\nfunction getNeighbouringPoints(cpTree, pos, order, order2) {\n    const cps = cpTree.findBounds((0,_cp_node_create_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.createCpNode)({ pointOnShape: pos, circle: undefined, order, order2 }, false, false));\n    if (!cps[0] && !cps[1]) {\n        // The tree is still empty\n        return [undefined, undefined];\n    }\n    if (!cps[0] || !cps[1]) {\n        // Smaller than all -> cptree.min() === cps[1].data OR\n        // Larger  than all -> cptree.max() === cps[0].data\n        return [\n            cpTree.max(cpTree.root),\n            cpTree.min(cpTree.root)\n        ];\n    }\n    return [\n        cps[0].datum,\n        cps[1].datum\n    ];\n}\n\n//# sourceMappingURL=get-neighboring-cps.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/get-neighboring-cps.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-two-prong-type.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-two-prong-type.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTwoProngType: () => (/* binding */ getTwoProngType)\n/* harmony export */ });\n/** @internal */\nfunction getTwoProngType(e) {\n    if (e.holeClosing) {\n        return 'twoProng_holeClosing';\n    }\n    return 'twoProng_regular';\n}\n\n//# sourceMappingURL=get-two-prong-type.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/get-two-prong-type.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/is-another-cp-closeby.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/is-another-cp-closeby.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAnotherCpCloseby: () => (/* binding */ isAnotherCpCloseby)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var _get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-neighboring-cps.js */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\n\n\n/** @internal */\nconst DEGREES = 3;\nconst ANGLE_THRESHOLD = Math.cos(DEGREES * (Math.PI / 180));\n/**\n * @internal\n * If another `CpNode` is close by (to the given implied (via `pos`, `order` and\n * `order2`) then return it, else return `undefined`.\n *\n * @param cpTrees\n * @param pos\n * @param circle\n * @param order\n * @param order2\n * @param extreme The maximum coordinate value used to calculate floating point\n * tolerances.\n * @param color Used for debugging only\n */\nfunction isAnotherCpCloseby(cpTrees, pos, circle, order, order2, extreme) {\n    const DISTANCE_THRESHOLD = extreme * 2e-14;\n    const DISTANCE_THRESHOLD_2 = DISTANCE_THRESHOLD * 2e-2;\n    const cpTree = cpTrees.get(pos.curve.loop);\n    const cpNodes = (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_0__.getNeighbouringPoints)(cpTree, pos, order, order2);\n    if (!cpNodes[0]) {\n        return undefined;\n    }\n    const { p, t } = pos;\n    for (const cpNode of cpNodes) {\n        const pos2 = cpNode.cp.pointOnShape;\n        const p2 = pos2.p;\n        const d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.distanceBetween)(p, p2);\n        if (d > DISTANCE_THRESHOLD) {\n            continue;\n        }\n        const v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.fromTo)(p2, cpNode.cp.circle.center));\n        const v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.fromTo)(p, circle.center));\n        const cosTheta = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.dot)(v1, v2);\n        if (cosTheta > ANGLE_THRESHOLD ||\n            (d < DISTANCE_THRESHOLD_2 && t !== 0 && t !== 1)) {\n            // console.log(d, DISTANCE_THRESHOLD2)\n            return cpNode;\n        }\n    }\n    return undefined;\n}\n\n//# sourceMappingURL=is-another-cp-closeby.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/is-another-cp-closeby.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/simplify-mat-map-only.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/simplify-mat-map-only.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simplifyMatMapOnly: () => (/* binding */ simplifyMatMapOnly)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _get_branches_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-branches.js */ \"./node_modules/flo-mat/node/mat/get-branches.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-curve/get-curve-between.js */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\n\n\n\n\n\n/**\n * Simplifies the given MAT by replacing the piecewise quad beziers composing\n * the MAT with fewer ones to within a given tolerance. Returns the map of\n * to be deleted nodes only - does not actually delete them. Use simplifyMat\n * instead if you want to delete the nodes.\n * @param cpNode A representation of the MAT\n * @param anlgeTolerance Tolerance given as the degrees difference of the unit\n * direction vectors at the interface between curves. A tolerance of zero means\n * perfect smoothness is required - defaults to 15.\n * @param hausdorffTolerance The approximate maximum Hausdorff Distance tolerance -\n * defaults to 0.1\n * @param hausdorffSpacing The spacing on the curves used to calculate the Hausdorff\n * Distance - defaults to 1\n */\nfunction simplifyMatMapOnly(cpNode, anlgeTolerance = 15, hausdorffTolerance = 1e-1, hausdorffSpacing = 1e0) {\n    const simpleMap = new Map();\n    // Start from a leaf\n    while (!(0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode)) {\n        cpNode = cpNode.next;\n    }\n    const branches = (0,_get_branches_js__WEBPACK_IMPORTED_MODULE_1__.getBranches)(cpNode, anlgeTolerance);\n    const canDeletes = [];\n    for (let k = 0; k < branches.length; k++) {\n        const branch = branches[k];\n        // Try to remove some\n        let j = 0;\n        while (j < branch.length) {\n            const i = j;\n            while (true) {\n                j++;\n                if (j === branch.length) {\n                    break;\n                }\n                const hd = getTotalHausdorffDistance(i, j, branch, hausdorffSpacing);\n                if (hd > hausdorffTolerance) {\n                    break;\n                }\n                else {\n                    canDeletes.push(branch[j]);\n                }\n            }\n            if (i + 1 === j) {\n                // no simplification occured\n            }\n            else {\n                const branStart = branch[i];\n                const branEnd = branch[j - 1];\n                const medial = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.toCubic)((0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__.getCurveBetween)(branStart, branEnd.next));\n                const rev = medial.slice().reverse();\n                let curCpNode = branStart;\n                let prevT = 0;\n                while (curCpNode !== branEnd) {\n                    const t = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.closestPointOnBezier)(medial, curCpNode.next.cp.circle.center).t;\n                    simpleMap.set(curCpNode, { ps: medial, ts: [prevT, t] });\n                    const oppositeCpNode = curCpNode.nextOnCircle.prev;\n                    simpleMap.set(oppositeCpNode, { ps: rev, ts: [1 - t, 1 - prevT] });\n                    prevT = t;\n                    curCpNode = curCpNode.next;\n                }\n                simpleMap.set(curCpNode, { ps: medial, ts: [prevT, 1] });\n                const oppositeCpNode = curCpNode.nextOnCircle.prev;\n                simpleMap.set(oppositeCpNode, { ps: rev, ts: [0, 1 - prevT] });\n            }\n        }\n    }\n    return { simpleMap, cpNode };\n}\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\n    const hds = [];\n    const longCurve = (0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__.getCurveBetween)(branch[i], branch[j].next);\n    for (let m = i; m < j + 1; m++) {\n        hds.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_5__.hausdorffDistance)((0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_6__.getCurveToNext)(branch[m]), longCurve, hausdorffSpacing));\n    }\n    return Math.max(...hds);\n}\n\n//# sourceMappingURL=simplify-mat-map-only.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/simplify-mat-map-only.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/simplify-mat.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/simplify-mat.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simplifyMat: () => (/* binding */ simplifyMat)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/remove.js\");\n/* harmony import */ var _get_branches_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-branches.js */ \"./node_modules/flo-mat/node/mat/get-branches.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-curve/get-curve-between.js */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\n\n\n\n\n\n/**\n * Simplifies the given MAT by replacing the piecewise quad beziers composing\n * the MAT with fewer ones to within a given tolerance.\n * @param cpNode A representation of the MAT\n * @param anlgeTolerance Tolerance given as the degrees difference of the unit\n * direction vectors at the interface between curves. A tolerance of zero means\n * perfect smoothness is required - defaults to 15.\n  * @param hausdorffTolerance The approximate maximum Hausdorff Distance tolerance -\n * defaults to `2**-3`\n * @param maxIterations The max iterations, defaults to `50`\n */\nfunction simplifyMat(mat, anlgeTolerance = 15, hausdorffTolerance = 2 ** -3, maxIterations = 50) {\n    let cpNode = mat.cpNode;\n    // Start from a leaf\n    while (!(0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode)) {\n        cpNode = cpNode.next;\n    }\n    const branches = (0,_get_branches_js__WEBPACK_IMPORTED_MODULE_1__.getBranches)(cpNode, anlgeTolerance);\n    const canDeletes = [];\n    for (let k = 0; k < branches.length; k++) {\n        const branch = branches[k];\n        // Try to remove some\n        let j = 0;\n        while (j < branch.length) {\n            const i = j;\n            while (true) {\n                j++;\n                if (j === branch.length) {\n                    break;\n                }\n                const hd = getTotalHausdorffDistance(i, j, branch, maxIterations);\n                if (hd > hausdorffTolerance) {\n                    break;\n                }\n                else {\n                    canDeletes.push(branch[j]);\n                }\n            }\n            if (i + 1 === j) {\n                // no simplification occured\n                break;\n            }\n        }\n    }\n    for (const cpNode of canDeletes) {\n        const isTerminating_ = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cpNode);\n        const onCircleCount = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getCpNodesOnCircle)(cpNode).length;\n        if (isTerminating_ || onCircleCount !== 2) {\n            continue;\n        }\n        (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_2__.removeCpNode)(cpNode);\n    }\n    //return { cpNode, cpTrees: createNewCpTree(cpNode) }; \n    return { cpNode, cpTrees: undefined };\n}\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\n    const hds = [];\n    const longCurve = (0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__.getCurveBetween)(branch[i], branch[j].next);\n    for (; i < j + 1; i++) {\n        hds.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_4__.hausdorffDistance)((0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_5__.getCurveToNext)(branch[i]), longCurve, hausdorffSpacing));\n    }\n    return Math.max(...hds);\n}\n\n//# sourceMappingURL=simplify-mat.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/simplify-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/trim-mat.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/trim-mat.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trimMat: () => (/* binding */ trimMat)\n/* harmony export */ });\n/* harmony import */ var _create_new_cp_tree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-new-cp-tree.js */ \"./node_modules/flo-mat/node/mat/create-new-cp-tree.js\");\n/* harmony import */ var _sat_cull_non_cycles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sat/cull-non-cycles.js */ \"./node_modules/flo-mat/node/sat/cull-non-cycles.js\");\n/* harmony import */ var _cp_node_clone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/clone.js */ \"./node_modules/flo-mat/node/cp-node/clone.js\");\n\n\n\n/**\n * Trims the given Medial Axis Transform so that only cycles remain. Similar to\n * toScaleAxis(mat, Number.POSITIVE_INFINITY).\n * @param mat The MAT to trim.\n */\nfunction trimMat(mat) {\n    const cpNode = (0,_sat_cull_non_cycles_js__WEBPACK_IMPORTED_MODULE_0__.cullNonCycles)((0,_cp_node_clone_js__WEBPACK_IMPORTED_MODULE_1__.clone)(mat.cpNode));\n    if (!cpNode) {\n        return undefined;\n    }\n    return { cpNode, cpTrees: (0,_create_new_cp_tree_js__WEBPACK_IMPORTED_MODULE_2__.createNewCpTree)(cpNode) };\n}\n\n//# sourceMappingURL=trim-mat.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/mat/trim-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcPosOrder: () => (/* binding */ calcPosOrder)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var _is_pos_corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js\");\n/* harmony import */ var _is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-pos-dull-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js\");\n/* harmony import */ var _get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js\");\n\n\n\n\n/**\n * @internal\n *\n * Calculates the order (to distinguish between points lying on top of each\n * other) of the contact point if it is a dull corner.\n *\n * @param circle\n * @param pos\n */\nfunction calcPosOrder(circle, pos) {\n    if (!(0,_is_pos_corner_js__WEBPACK_IMPORTED_MODULE_0__.isPosCorner)(pos)) {\n        return 0;\n    }\n    if (!(0,_is_pos_dull_corner_js__WEBPACK_IMPORTED_MODULE_1__.isPosDullCorner)(pos)) {\n        return 0;\n    }\n    const corner = (0,_get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__.getPosCorner)(pos);\n    const n = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.rotateNeg90Degrees)(corner.tangents[0]);\n    const v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_4__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_5__.fromTo)(pos.p, circle.center));\n    return -(0,flo_vector2d__WEBPACK_IMPORTED_MODULE_6__.dot)(n, v);\n}\n\n//# sourceMappingURL=calc-pos-order.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/calc-pos-order.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/compare-poss.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/compare-poss.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   comparePoss: () => (/* binding */ comparePoss)\n/* harmony export */ });\n/**\n * Compares two [[PointOnShape]]s according to their cyclic ordering imposed\n * by their relative positions on the shape boundary.\n * @param a The first [[PointOnShape]].\n * @param b The second [[PointOnShape]].\n * @internal\n */\nfunction comparePoss(a, b) {\n    let res;\n    res = a.curve.idx - b.curve.idx;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.t - b.t;\n    return res;\n}\n\n//# sourceMappingURL=compare-poss.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/compare-poss.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/create-pos.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/create-pos.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPos: () => (/* binding */ createPos)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js\");\n\nfunction createPos(curve, t, source) {\n    return {\n        curve,\n        t,\n        p: (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauDd)(curve.ps, [0, t]).map(c => c[1]),\n        // angle\n        source\n    };\n}\n\n//# sourceMappingURL=create-pos.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/create-pos.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/get-osculating-circle.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/get-osculating-circle.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOsculatingCircle: () => (/* binding */ getOsculatingCircle)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/dd-curvature.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js\");\n\n/**\n * Returns the osculating circle at this point of the curve.\n * @param maxOsculatingCircleRadius If not Number.POSITIVE_INFINITY then the\n * circle radius will be limited to this value.\n * @param pos The [[PointOnShape]] identifying the point.\n */\nfunction getOsculatingCircle(minCurvature, pos, useMaxRadius = false) {\n    const ps = pos.curve.ps;\n    const { p, t } = pos;\n    let k = -(0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.ddCurvature)(ps, t);\n    if (k < minCurvature || useMaxRadius) {\n        k = minCurvature;\n    }\n    const tangent_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangentExact)(ps, t).map(c => c[c.length - 1]);\n    const normal_ = [-tangent_[1], tangent_[0]];\n    const l = Math.sqrt(normal_[0] ** 2 + normal_[1] ** 2);\n    const circleCenter = [\n        p[0] - normal_[0] / (k * l),\n        p[1] - normal_[1] / (k * l)\n    ];\n    return { center: circleCenter, radius: 1 / k };\n}\n\n//# sourceMappingURL=get-osculating-circle.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/get-osculating-circle.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPosCorner: () => (/* binding */ getPosCorner)\n/* harmony export */ });\n/* harmony import */ var _curve_curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curve/curve.js */ \"./node_modules/flo-mat/node/curve/curve.js\");\n\n/**\n * @internal\n */\nfunction getPosCorner(pos) {\n    return (0,_curve_curve_js__WEBPACK_IMPORTED_MODULE_0__.getCornerAtEnd)(pos.t === 1 ? pos.curve : pos.curve.prev);\n}\n\n//# sourceMappingURL=get-pos-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPosCorner: () => (/* binding */ isPosCorner)\n/* harmony export */ });\n/**\n * @internal\n */\nfunction isPosCorner(pos) {\n    return (pos.t === 0 || pos.t === 1);\n}\n\n//# sourceMappingURL=is-pos-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPosDullCorner: () => (/* binding */ isPosDullCorner)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js\");\n/* harmony import */ var _is_pos_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js\");\n\n\n\n/**\n * @internal\n */\nconst isPosDullCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)((pos) => {\n    if (!(0,_is_pos_corner_js__WEBPACK_IMPORTED_MODULE_1__.isPosCorner)(pos)) {\n        return false;\n    }\n    return (0,_get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__.getPosCorner)(pos).isDull;\n});\n\n//# sourceMappingURL=is-pos-dull-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/is-pos-dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/is-pos-quite-sharp-corner.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/is-pos-quite-sharp-corner.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPosQuiteSharpCorner: () => (/* binding */ isPosQuiteSharpCorner)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _is_pos_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js\");\n/* harmony import */ var _get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js\");\n\n\n\n/**\n * @internal\n */\nconst isPosQuiteSharpCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)((pos) => {\n    if (!(0,_is_pos_corner_js__WEBPACK_IMPORTED_MODULE_1__.isPosCorner)(pos)) {\n        return false;\n    }\n    return (0,_get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__.getPosCorner)(pos).isQuiteSharp;\n});\n\n//# sourceMappingURL=is-pos-quite-sharp-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/is-pos-quite-sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/is-pos-sharp-corner.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/is-pos-sharp-corner.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPosSharpCorner: () => (/* binding */ isPosSharpCorner)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/get-pos-corner.js\");\n/* harmony import */ var _is_pos_corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-pos-corner.js */ \"./node_modules/flo-mat/node/point-on-shape/is-pos-corner.js\");\n\n\n\n/**\n * @internal\n */\nconst isPosSharpCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)((pos) => {\n    if (!(0,_is_pos_corner_js__WEBPACK_IMPORTED_MODULE_1__.isPosCorner)(pos)) {\n        return false;\n    }\n    return (0,_get_pos_corner_js__WEBPACK_IMPORTED_MODULE_2__.getPosCorner)(pos).isSharp;\n});\n\n//# sourceMappingURL=is-pos-sharp-corner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/is-pos-sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape/pos-to-human-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape/pos-to-human-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   posToHumanString: () => (/* binding */ posToHumanString)\n/* harmony export */ });\n/**\n * Returns a human-readable string of the given [[PointOnShape]].\n * For debugging only.\n * @internal\n */\nfunction posToHumanString(pos) {\n    return '' + pos.p[0] + ', ' + pos.p[1] +\n        ' | bz: ' + pos.curve.idx +\n        ' | t: ' + pos.t;\n}\n\n//# sourceMappingURL=pos-to-human-string.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/point-on-shape/pos-to-human-string.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sat/add-debug-info.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-mat/node/sat/add-debug-info.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDebugInfo: () => (/* binding */ addDebugInfo)\n/* harmony export */ });\n/**\n * @internal\n * @param sat\n */\nfunction addDebugInfo(sat, timingStart) {\n    if (typeof _debug_ === 'undefined') {\n        return;\n    }\n    _debug_.generated.elems.sat.push(sat);\n    const timing = _debug_.generated.timing;\n    timing.sats = performance.now() - timingStart;\n}\n\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/sat/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sat/cull-non-cycles.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/sat/cull-non-cycles.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cullNonCycles: () => (/* binding */ cullNonCycles)\n/* harmony export */ });\n/* harmony import */ var _get_leaves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-leaves.js */ \"./node_modules/flo-mat/node/sat/get-leaves.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n\n/**\n * @internal\n * Cull all edges not part of a cycle in the MAT planar graph.\n * @param cpStart The start CpNode which must reprsesent the maximal 3-prong\n * vertex.\n */\nfunction cullNonCycles(cpStart) {\n    let cpNodeKept = cpStart;\n    const leaves = (0,_get_leaves_js__WEBPACK_IMPORTED_MODULE_0__.getLeaves)(cpStart);\n    while (leaves.length) {\n        const leaf = leaves.pop();\n        // Preserve topology - keep cycles.\n        if (leaf.isHoleClosing || leaf.isIntersection) {\n            continue;\n        }\n        let cpNode = leaf.next; // Turn around\n        while (true) {\n            cpNode = cpNode.next;\n            let cut = false;\n            const cp1 = cpNode.prevOnCircle;\n            if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.getProngCount)(cpNode) > 2) {\n                //const cp2 = cp1.prevOnCircle;\n                const cp2 = cpNode.nextOnCircle;\n                //if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\n                if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.isOnSameCircle)(cpNode, cpStart)) {\n                    cut = true; // We are at the max disk - cut whole edge\n                }\n                else if (cpNode.next === cp2) {\n                    cpNode = cp2;\n                }\n                else if (cp2.next !== cp1) {\n                    cut = true; // Cut whole edge\n                }\n            }\n            else if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.isTerminating)(cpNode) && !cpNode.isIntersection) {\n                cpNodeKept = cpNode;\n                return undefined;\n            }\n            if (cut) {\n                cp1.next = cpNode;\n                cpNode.prev = cp1;\n                cpNodeKept = cpNode;\n                break;\n            }\n        }\n    }\n    return cpNodeKept;\n}\n\n//# sourceMappingURL=cull-non-cycles.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/sat/cull-non-cycles.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sat/cull.js":
/*!***********************************************!*\
  !*** ./node_modules/flo-mat/node/sat/cull.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cull: () => (/* binding */ cull)\n/* harmony export */ });\n/* harmony import */ var _get_leaves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-leaves.js */ \"./node_modules/flo-mat/node/sat/get-leaves.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n\n/**\n * @internal\n * Returns the set of Vertices passing the following test: walk the MAT tree and\n * keep all Vertices not in the current cull set and any Vertices that have a\n * non-culled node further down the line toward the tree leaves.\n * @param culls The CpNodes (referred to by circles) that should be culled.\n * @param maxCpNode The start CpNode which must reprsesent the maximal vertex.\n */\nfunction cull(culls, maxCpNode) {\n    const leaves = (0,_get_leaves_js__WEBPACK_IMPORTED_MODULE_0__.getLeaves)(maxCpNode);\n    function getNonTrivialEdges(cpStart) {\n        let cp = cpStart;\n        const cps = [];\n        do {\n            if (cp.next !== cp.nextOnCircle) {\n                cps.push(cp);\n            }\n            cp = cp.nextOnCircle;\n        } while (cp !== cpStart.prevOnCircle);\n        return cps;\n    }\n    while (leaves.length) {\n        const leaf = leaves.pop();\n        // Preserve topology.\n        if (leaf.isHoleClosing || leaf.isIntersection) {\n            continue;\n        }\n        if (!culls.has(leaf.cp.circle)) {\n            continue;\n        }\n        let cpNode = leaf.next; // Turn around\n        while (true) {\n            cpNode = cpNode.next;\n            let cut = false;\n            const cp1 = cpNode.prevOnCircle;\n            if (!culls.has(cpNode.cp.circle)) {\n                // Cut off the edge once a non-cull has been reached.\n                cut = true;\n            }\n            else if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.isOnSameCircle)(cpNode, maxCpNode)) {\n                cut = true; // We are at the max disk - cut whole edge\n            }\n            else {\n                const cps = getNonTrivialEdges(cpNode);\n                if (cps.length === 1) {\n                    cpNode = cps[0];\n                }\n                else {\n                    cut = true;\n                }\n            }\n            if (cut) {\n                cp1.next = cpNode;\n                cpNode.prev = cp1;\n                break;\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=cull.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/sat/cull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sat/get-leaves.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/sat/get-leaves.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLeaves: () => (/* binding */ getLeaves)\n/* harmony export */ });\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n\n/** @internal */\nfunction getLeaves(cpNode) {\n    const leaves = [];\n    const cps = (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.getAllOnLoop)(cpNode);\n    for (const cp of cps) {\n        if ((0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_0__.isTerminating)(cp)) {\n            leaves.push(cp);\n        }\n    }\n    return leaves;\n}\n\n//# sourceMappingURL=get-leaves.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/sat/get-leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sat/to-scale-axis.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/sat/to-scale-axis.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toScaleAxis: () => (/* binding */ toScaleAxis)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/length/length.js\");\n/* harmony import */ var _cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cp-node/cp-node.js */ \"./node_modules/flo-mat/node/cp-node/cp-node.js\");\n/* harmony import */ var _cp_node_traverse_edges_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cp-node/traverse-edges.js */ \"./node_modules/flo-mat/node/cp-node/traverse-edges.js\");\n/* harmony import */ var _cp_node_traverse_vertices_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node/traverse-vertices.js */ \"./node_modules/flo-mat/node/cp-node/traverse-vertices.js\");\n/* harmony import */ var _mat_get_largest_vertex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mat/get-largest-vertex.js */ \"./node_modules/flo-mat/node/mat/get-largest-vertex.js\");\n/* harmony import */ var _get_leaves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-leaves.js */ \"./node_modules/flo-mat/node/sat/get-leaves.js\");\n/* harmony import */ var _cull_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cull.js */ \"./node_modules/flo-mat/node/sat/cull.js\");\n/* harmony import */ var _add_debug_info_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./add-debug-info.js */ \"./node_modules/flo-mat/node/sat/add-debug-info.js\");\n/* harmony import */ var _cp_node_clone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cp-node/clone.js */ \"./node_modules/flo-mat/node/cp-node/clone.js\");\n/* harmony import */ var _cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cp-node/get-curve-to-next.js */ \"./node_modules/flo-mat/node/cp-node/get-curve-to-next.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Apply and returns an enhanced version of the Scale Axis Transform (SAT) to\n * the given MAT. The returned SAT is guaranteed to be a subset of the MAT and\n * preserves topology at any scale.\n *\n * Typically the MAT contains too many branches caused by minute details on the\n * boundary of the shape. The SAT is a simplification of the MAT that preserves\n * less detail the higher the applied scale factor. The severity at which noise\n * are removed depends on the local scale of the shape.\n * @param mat The Medial Axis Transform ([[Mat]]) on which to apply the SAT.\n * @param s The scale factor >= 1 (e.g. 1.3)\n */\nfunction toScaleAxis(mat, s) {\n    let timingStart = 0;\n    if (typeof _debug_ !== 'undefined') {\n        timingStart = performance.now();\n        const leaves = (0,_get_leaves_js__WEBPACK_IMPORTED_MODULE_0__.getLeaves)(mat.cpNode);\n        _debug_.generated.elems.leaves.push(leaves);\n    }\n    /** The largest vertex (as measured by its inscribed disk) */\n    const cpNodes = [];\n    (0,_cp_node_traverse_vertices_js__WEBPACK_IMPORTED_MODULE_1__.traverseVertices)((0,_cp_node_clone_js__WEBPACK_IMPORTED_MODULE_2__.clone)(mat.cpNode), cpNode => { cpNodes.push(cpNode); });\n    const cpNode = (0,_mat_get_largest_vertex_js__WEBPACK_IMPORTED_MODULE_3__.getLargestVertex)(cpNodes);\n    // console.log(cpNodes.map(c => c.cp.circle.radius).length)\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.maxVertex.push(cpNode);\n    }\n    /**\n     * All vertices that are set to be culled initially. This may change later\n     * in order to preserve topology.\n     */\n    const culls = new Set();\n    const rMap = new Map();\n    (0,_cp_node_traverse_edges_js__WEBPACK_IMPORTED_MODULE_4__.traverseEdges)(cpNode, function (cpNode) {\n        /** The occulating radius stored with this vertex. */\n        const R = rMap.get(cpNode) || (s * cpNode.cp.circle.radius);\n        const cpNode_ = cpNode.next;\n        const l = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_5__.length)([0, 1], (0,_cp_node_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_6__.getCurveToNext)(cpNode));\n        const r = cpNode_.cp.circle.radius;\n        const r_ = s * r;\n        if (R - l > r_) {\n            for (const cpNode of (0,_cp_node_cp_node_js__WEBPACK_IMPORTED_MODULE_7__.getCpNodesOnCircle)(cpNode_)) {\n                rMap.set(cpNode, R - l); // Update osculating radii\n            }\n            culls.add(cpNode_.cp.circle);\n        }\n    });\n    (0,_cull_js__WEBPACK_IMPORTED_MODULE_8__.cull)(culls, cpNode);\n    if (typeof _debug_ !== 'undefined') {\n        _debug_.generated.elems.culls.push(Array.from(culls));\n    }\n    // TODO - put line below back - goes into infinite loop\n    //const sat: Mat = { cpNode, cpTrees: createNewCpTree(cpNode) };\n    const sat = { cpNode, cpTrees: undefined };\n    (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_9__.addDebugInfo)(sat, timingStart);\n    return sat;\n}\n\n//# sourceMappingURL=to-scale-axis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/sat/to-scale-axis.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/get-loop-bounds.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/get-loop-bounds.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLoopBounds: () => (/* binding */ getLoopBounds)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js\");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape/create-pos.js */ \"./node_modules/flo-mat/node/point-on-shape/create-pos.js\");\n\n\n\n/** @internal */\nconst INF = Number.POSITIVE_INFINITY;\n/**\n * @internal\n */\nconst getLoopBounds = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function (loop) {\n    const extremes = [\n        [\n            { bezier: undefined, t: undefined, val: INF },\n            { bezier: undefined, t: undefined, val: INF }\n        ],\n        [\n            { bezier: undefined, t: undefined, val: -INF },\n            { bezier: undefined, t: undefined, val: -INF }\n        ]\n    ];\n    loop.curves.forEach(function (curve) {\n        const ps = curve.ps;\n        // const bounds = getBounds_(ps);\n        const bounds = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getBounds)(ps);\n        {\n            {\n                const v = bounds.box[0][0];\n                const x = extremes[0][0].val;\n                if (v < x || (v === x && bounds.ts[0][0] > extremes[0][0].t)) {\n                    extremes[0][0] = {\n                        bezier: curve,\n                        t: bounds.ts[0][0],\n                        val: v\n                    };\n                }\n            }\n            {\n                const v = bounds.box[0][1];\n                const x = extremes[0][1].val;\n                if (v < x || (v === x && bounds.ts[0][1] > extremes[0][1].t)) {\n                    extremes[0][1] = {\n                        bezier: curve,\n                        t: bounds.ts[0][1],\n                        val: v\n                    };\n                }\n            }\n        }\n        {\n            {\n                const v = bounds.box[1][0];\n                const x = extremes[1][0].val;\n                if (v > x || (v === x && bounds.ts[1][0] > extremes[1][0].t)) {\n                    extremes[1][0] = {\n                        bezier: curve,\n                        t: bounds.ts[1][0],\n                        val: v\n                    };\n                }\n            }\n            {\n                const v = bounds.box[1][1];\n                const x = extremes[1][1].val;\n                if (v > x || (v === x && bounds.ts[1][1] > extremes[1][1].t)) {\n                    extremes[1][1] = {\n                        bezier: curve,\n                        t: bounds.ts[1][1],\n                        val: v\n                    };\n                }\n            }\n        }\n    });\n    return {\n        // minX : new PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\n        // minY : new PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\n        // maxX : new PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\n        // maxY : new PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\n        minY: (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(extremes[0][1].bezier, extremes[0][1].t, true),\n        minX: (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(extremes[0][0].bezier, extremes[0][0].t, true),\n        maxX: (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(extremes[1][0].bezier, extremes[1][0].t, true),\n        maxY: (0,_point_on_shape_create_pos_js__WEBPACK_IMPORTED_MODULE_2__.createPos)(extremes[1][1].bezier, extremes[1][1].t, true)\n    };\n});\n\n//# sourceMappingURL=get-loop-bounds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/svg/get-loop-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/get-min-y-pos.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/get-min-y-pos.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMinYPos: () => (/* binding */ getMinYPos)\n/* harmony export */ });\n/* harmony import */ var _get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-loop-bounds.js */ \"./node_modules/flo-mat/node/svg/get-loop-bounds.js\");\n\n/**\n * @internal\n * Get topmost PointOnShape of the given loop.\n */\nfunction getMinYPos(loop) {\n    return (0,_get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getLoopBounds)(loop).minY;\n}\n\n//# sourceMappingURL=get-min-y-pos.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/svg/get-min-y-pos.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/get-shape-bounds.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/get-shape-bounds.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getShapeBounds: () => (/* binding */ getShapeBounds)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/memoize.js\");\n/* harmony import */ var _get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-loop-bounds.js */ \"./node_modules/flo-mat/node/svg/get-loop-bounds.js\");\n\n\n/** @internal */\nconst getShapeBounds = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function (loops) {\n    let minX_ = Number.POSITIVE_INFINITY;\n    let maxX_ = Number.NEGATIVE_INFINITY;\n    let minY_ = Number.POSITIVE_INFINITY;\n    let maxY_ = Number.NEGATIVE_INFINITY;\n    let minX;\n    let maxX;\n    let minY;\n    let maxY;\n    for (const loop of loops) {\n        const bounds = (0,_get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_1__.getLoopBounds)(loop);\n        if (bounds.minX.p[0] < minX_) {\n            minX = bounds.minX;\n            minX_ = bounds.minX.p[0];\n        }\n        if (bounds.maxX.p[0] > maxX_) {\n            maxX = bounds.maxX;\n            maxX_ = bounds.maxX.p[0];\n        }\n        if (bounds.minY.p[1] < minY_) {\n            minY = bounds.minY;\n            minY_ = bounds.minY.p[1];\n        }\n        if (bounds.maxY.p[1] > maxY_) {\n            maxY = bounds.maxY;\n            maxY_ = bounds.maxY.p[1];\n        }\n    }\n    return {\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY\n    };\n});\n\n//# sourceMappingURL=get-shape-bounds.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/svg/get-shape-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sweep-line/sweep-line.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/sweep-line/sweep-line.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sweepLine: () => (/* binding */ sweepLine)\n/* harmony export */ });\n/** @internal */\nconst EVENT_LEFT = 0;\n/** @internal */\nconst EVENT_RIGHT = 1;\n/**\n * @internal\n * Generalized sweepline algorithm.\n *\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\n *\n * @param items An array of items that are to be compared. Items should\n * typically be geometric objects in 2d space with well-defined left and right\n * endpoints.\n * @param getLeftmostPoint A function that returns the leftmost point of the\n * geometric object of interest.\n * @param getRightmostPoint A function that returns the rightmost point of the\n * geometric object of interest.\n * @param predicate A predicate that takes two geometric objects and returns\n * true if they are of interest or false otherwise.\n */\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\n    // Initialize event queue to contain all endpoints.\n    const events = [];\n    for (const item of items) {\n        events.push({\n            type: EVENT_LEFT,\n            item,\n            x: getLeftmost(item)\n        });\n        events.push({\n            type: EVENT_RIGHT,\n            item,\n            x: getRightmost(item)\n        });\n    }\n    events.sort(compare);\n    const activeItems = new Set();\n    /** A list of pairs of items that passed the predicate */\n    const pairedItems = [];\n    for (const event of events) {\n        const { item } = event;\n        if (event.type === EVENT_LEFT) {\n            for (const activeItem of activeItems.values()) {\n                if (predicate(item, activeItem)) {\n                    pairedItems.push([item, activeItem]);\n                }\n            }\n            activeItems.add(item);\n        }\n        else if (event.type === EVENT_RIGHT) {\n            activeItems.delete(event.item);\n        }\n    }\n    return pairedItems;\n}\n/**\n * @internal\n * Compare two Events by their x-axis and then by their type. Since it is\n * open boxes that are compared we must let the right endpoint type come\n * before the left.\n * @param a An event\n * @param b Another event\n */\nfunction compare(a, b) {\n    const res = a.x - b.x;\n    if (res !== 0) {\n        return res;\n    }\n    // Alwys put left events before right ones.\n    return a.type === EVENT_LEFT ? -1 : +1;\n}\n\n//# sourceMappingURL=sweep-line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-mat/node/sweep-line/sweep-line.js?");

/***/ }),

/***/ "./node_modules/flo-memoize/node/memoize.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-memoize/node/memoize.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoize: () => (/* binding */ memoize)\n/* harmony export */ });\n/**\n * Memoize (by reference on the input parameter) the given arity 1 function.\n *\n * * the input parameter must be an `object` (so it can be used as a key to\n * `WeakMap` and thus garbage collected later; this is especially important\n * in functional programming where a lot of garbage collection takes place;\n *\n * * use `memoizePrimitive` instead if it is not important that the keys\n * will *never* be garbage collected\n */\nfunction memoize(f) {\n    const results = new WeakMap();\n    return function (t) {\n        let r = results.get(t);\n        if (r !== undefined) {\n            //console.log('cache hit');\n            return r;\n        }\n        //console.log('cache miss');\n        r = f(t);\n        results.set(t, r);\n        return r;\n    };\n}\n\n//# sourceMappingURL=memoize.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-memoize/node/memoize.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/double/add.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/double/add.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ \"./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\n/**\n * Returns the result of adding two polynomials in double precision.\n *\n * @param p1 a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param p2 another polynomial\n *\n * @example\n * ```typescript\n * add([1,2,3],[3,4]); //=> [1,5,7]\n * ```\n *\n * @doc\n */\nfunction add(p1, p2) {\n    // Initialize result array  \n    const d1 = p1.length - 1;\n    const d2 = p2.length - 1;\n    const Δd = d1 - d2;\n    const Δd1 = Δd < 0 ? +Δd : 0;\n    const Δd2 = Δd > 0 ? -Δd : 0;\n    const d = Math.max(d1, d2);\n    // Add coefficients\n    const result = [];\n    for (let i = 0; i < d + 1; i++) {\n        const c1 = p1[i + Δd1] || 0;\n        const c2 = p2[i + Δd2] || 0;\n        result.push(c1 + c2);\n    }\n    // Ensure the result is a valid polynomial representation\n    return removeLeadingZeros(result);\n}\n\n//# sourceMappingURL=add.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/basic/double/add.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/double/invert.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/double/invert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   invert: () => (/* binding */ invert)\n/* harmony export */ });\n/**\n * Inverts the given polynomial by reversing the order of the coefficients,\n * i.e. p(x) -> x^deg(p) * p(1/x)\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * invert([3,2,-5]);  // => [-5,2,3]\n * ```\n *\n * @doc\n */\nfunction invert(p) {\n    return p.slice().reverse();\n}\n\n//# sourceMappingURL=invert.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/basic/double/invert.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/double/multiply.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/double/multiply.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   multiply: () => (/* binding */ multiply)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ \"./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\n/**\n * Returns the result of multiplying 2 polynomials in double precision.\n *\n * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)\n * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)\n * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)\n *\n * @param p1 a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param p2 another polynomial.\n * @example\n * ```typescript\n * multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\n * ```\n *\n * @doc\n */\nfunction multiply(p1, p2) {\n    const d1 = p1.length - 1;\n    const d2 = p2.length - 1;\n    // if either or both is the zero polynomial\n    if (d1 < 0 || d2 < 0) {\n        return [];\n    }\n    const d = d1 + d2;\n    const r = new Array(d + 1).fill(0);\n    for (let i = 0; i < d1 + 1; i++) {\n        for (let j = 0; j < d2 + 1; j++) {\n            r[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);\n        }\n    }\n    return removeLeadingZeros(r);\n}\n\n//# sourceMappingURL=multiply.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/basic/double/multiply.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/double/negate.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/double/negate.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   negate: () => (/* binding */ negate)\n/* harmony export */ });\n/**\n * Returns the negative of the given polynomial (p -> -p).\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @example\n * ```typescript\n * negate([0.1, -0.2]); //=> [-0.1, 0.2]\n * ```\n *\n * @doc\n */\nfunction negate(p) {\n    const p_ = [];\n    for (let i = 0; i < p.length; i++) {\n        p_.push(-p[i]);\n    }\n    return p_;\n}\n\n//# sourceMappingURL=negate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/basic/double/negate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeLeadingZeros: () => (/* binding */ removeLeadingZeros)\n/* harmony export */ });\n/**\n * If the highest power coefficient of the given polynomial is 0 then\n * removeLeadingZeros can be called to remove all such highest terms so that\n * the returned array is a valid presentation of a polynomial.\n *\n * @param p a polynomial whose leading zeros should be removed\n *\n * @example\n * ```typescript\n * removeLeadingZeros([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\n * removeLeadingZeros([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n * ```\n *\n * @doc\n */\nfunction removeLeadingZeros(p) {\n    let lzCount = 0;\n    for (let i = 0; i <= p.length - 1; i++) {\n        if (p[i] !== 0) {\n            break;\n        }\n        lzCount++;\n    }\n    if (lzCount !== 0) {\n        p = p.slice(lzCount);\n    }\n    return p;\n}\n\n//# sourceMappingURL=remove-leading-zeros.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/double/subtract.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/double/subtract.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   subtract: () => (/* binding */ subtract)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ \"./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\n/**\n * Returns the result of subtracting the second polynomial from the first in\n * double precision; (p1 - p2).\n *\n * @param p1 minuend; the polynomial from which will be subtracted; a polynomial\n * with coefficients given densely as an array of double floating point numbers\n * from highest to lowest power, e.g. `[5,-3,0]` represents the\n * polynomial `5x^2 - 3x`\n * @param p2 subtrahend; the polynomial that will be subtracted\n *\n * @example\n * ```typescript\n * subtract([2,3],[4,4]); //=> [-2, -1]\n * ```\n *\n * @doc\n */\nfunction subtract(p1, p2) {\n    // Initialize result array  \n    const d1 = p1.length - 1;\n    const d2 = p2.length - 1;\n    const Δd = d1 - d2;\n    const Δd1 = Δd < 0 ? +Δd : 0;\n    const Δd2 = Δd > 0 ? -Δd : 0;\n    const d = Math.max(d1, d2);\n    // Add coefficients\n    const result = [];\n    for (let i = 0; i < d + 1; i++) {\n        const c1 = p1[i + Δd1] || 0;\n        const c2 = p2[i + Δd2] || 0;\n        result.push(c1 - c2);\n    }\n    // Ensure the result is a valid polynomial representation\n    return removeLeadingZeros(result);\n}\n\n//# sourceMappingURL=subtract.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/basic/double/subtract.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDifferentiateWithError: () => (/* binding */ ddDifferentiateWithError)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../error-analysis/gamma.js */ \"./node_modules/flo-poly/node/error-analysis/gamma.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eEstimate;\nconst γγ3 = (0,_error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_2__[\"γγ\"])(3);\n/**\n * Returns the result (and resulting coefficient-wise error bound) of\n * differentiating the given polynomial (with coefficients given in\n * double-double precision) in double-double precision.\n *\n * @param pWithErr an object with 2 properties: `p`: a polynomial with\n * coefficients given densely as an array of double-double precision floating\n * point numbers from highest to lowest power, e.g. `[[5],[-3],[0]]` represents\n * the polynomial `5x^2 - 3x` **and** `pE`: the coefficient-wise error bound of\n * the input polynomial\n *\n * @doc\n */\nfunction ddDifferentiateWithError(pWithErr) {\n    const { p, pE } = pWithErr;\n    const dp = [];\n    const dpE = [];\n    const d = p.length - 1;\n    for (let i = 0; i < d; i++) {\n        const deg = d - i;\n        const c = ddMultDouble2(deg, p[i]);\n        dp.push(c);\n        // if 1,2,4 or 8, etc. then no additional error occurs on multiply\n        // if 3,5,7 or 9, etc. then additional error occurs\n        // deg is a power of 2 <=> (deg & deg-1) === 0\n        const extraErr = (deg & deg - 1) === 0 ? 0 : γγ3;\n        const $c = eEstimate(c);\n        dpE.push(\n        //deg * (pE[i] + Math.abs($c)*extraErr)\n        deg * pE[i] + Math.abs($c) * extraErr);\n    }\n    return { p: dp, pE: dpE };\n}\n\n//# sourceMappingURL=dd-differentiate-with-err.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddDifferentiate: () => (/* binding */ ddDifferentiate)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\n/**\n * Returns the result of differentiating the given polynomial (with coefficients\n * given in double-double precision) in double-double precision.\n *\n * @param p a polynomial with coefficients given densely as an array of\n * double-double precision floating point numbers from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * ddDifferentiate([[0,5], [0,4], [0,3], [0,2], [0,1]]); //=> [[0,20], [0,12], [0,6], [0,2]]\n * ```\n *\n * @doc\n */\nfunction ddDifferentiate(p) {\n    const result = [];\n    const d = p.length - 1;\n    for (let i = 0; i < d; i++) {\n        result.push(ddMultDouble2((d - i), p[i]));\n    }\n    return result;\n}\n\n//# sourceMappingURL=dd-differentiate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/calculus/double/differentiate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-poly/node/calculus/double/differentiate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   differentiate: () => (/* binding */ differentiate)\n/* harmony export */ });\n/**\n * Returns the result of differentiating the given polynomial in double\n * precision.\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\n * ```\n *\n * @doc\n */\nfunction differentiate(p) {\n    const result = [];\n    const d = p.length - 1;\n    for (let i = 0; i < d; i++) {\n        result.push((d - i) * p[i]);\n    }\n    return result;\n}\n\n//# sourceMappingURL=differentiate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/calculus/double/differentiate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/calculus/double/integrate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-poly/node/calculus/double/integrate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   integrate: () => (/* binding */ integrate)\n/* harmony export */ });\n/**\n * Returns the result of integrating the given polynomial in double precision.\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param c the constant of intergration\n *\n * @example\n * ```typescript\n * integrate([3, 2, 1]); //=> [1, 1, 1, c]\n * ```\n *\n * @doc\n */\nfunction integrate(p, c) {\n    const result = [];\n    const d = p.length - 1;\n    for (let i = 0; i < d + 1; i++) {\n        result.push(p[i] / (d + 1 - i));\n    }\n    result.push(c);\n    return result;\n}\n\n//# sourceMappingURL=integrate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/calculus/double/integrate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eDifferentiate: () => (/* binding */ eDifferentiate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst scaleExpansion = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\n/**\n * Returns the exact result (bar underflow / overflow) of differentiating the\n * given polynomial (with Shewchuk expansion coefficients).\n *\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * eDifferentiate([[5], [4], [3], [2], [1]]); //=> [[20], [12], [6], [2]]\n * ```\n *\n * @doc\n */\nfunction eDifferentiate(p) {\n    const result = [];\n    const d = p.length - 1;\n    for (let i = 0; i < d; i++) {\n        result.push(scaleExpansion(p[i], d - i));\n    }\n    return result;\n}\n\n//# sourceMappingURL=e-differentiate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reflectAboutYAxis: () => (/* binding */ reflectAboutYAxis)\n/* harmony export */ });\n/**\n * Returns the result of reflecting the given polynomial about the Y-axis, i.e.\n * perform the change of variables: p(x) <- p(-x).\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\n * ```\n *\n * @doc\n */\nfunction reflectAboutYAxis(p) {\n    const d = p.length - 1;\n    if (d < 0) {\n        return [];\n    }\n    const result = p.slice();\n    for (let i = 0; i < d + 1; i++) {\n        if (i % 2) {\n            result[i] = -result[i];\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=reflect-about-y-axis.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eChangeVariablesLinear: () => (/* binding */ eChangeVariablesLinear)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\nconst scaleExpansion2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\n/**\n * Returns the exact result (bar underflow / overflow) of performing a change\n * of variables of the form: p(x) <- p(ax + b) on the given polynomial (with\n * coefficients given as Shewchuk expansions).\n *\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\n *\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\n * represents the polynomial `5x^2 - 3x`\n * @param a the `a` in `ax + b`\n * @param b the `b` in `ax + b`\n *\n * @example\n * ```typescript\n * eChangeVariablesLinear([[1],[2],[7]], 3, 4); //=> [[9], [30], [31]]\n * ```\n *\n * @doc\n */\nfunction eChangeVariablesLinear(p, a, b) {\n    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. \n    // d_i is calculated as d = T*c, where c are the original coefficients.\n    const d = p.length - 1;\n    if (d < 0) {\n        return [];\n    }\n    // Initialize a zero matrix\n    const t = [];\n    for (let i = 0; i < d + 1; i++) {\n        t.push(new Array(d + 1).fill([0]));\n    }\n    // Calculate the triangular matrix T\n    t[0][0] = [1];\n    for (let j = 1; j <= d; j++) {\n        t[0][j] = scaleExpansion2(b, t[0][j - 1]);\n        for (let i = 1; i <= j; i++) {\n            t[i][j] = fastExpansionSum(scaleExpansion2(b, t[i][j - 1]), scaleExpansion2(a, t[i - 1][j - 1]));\n        }\n    }\n    // Multiply\n    const res = new Array(d + 1).fill([0]);\n    for (let i = 0; i <= d; i++) {\n        res[d - i] = [0];\n        for (let j = i; j <= d; j++) {\n            const acc = expansionProduct(t[i][j], p[d - j]);\n            res[d - i] = fastExpansionSum(res[d - i], acc);\n        }\n    }\n    return res;\n}\n\n//# sourceMappingURL=e-change-variables-linear.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/error-analysis/gamma.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-poly/node/error-analysis/gamma.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"γ\": () => (/* binding */ γ),\n/* harmony export */   \"γγ\": () => (/* binding */ γγ)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\nconst uu = u * u;\n/**\n * The canonical floating point error function, γ.\n *\n * * roughly `=== n * (Number.EPSILON / 2)`\n * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)\n * @param n the parameter - typically a small positive integer, e.g. for\n * polynomial evaluation this === 2*d + 1, where d is the degree of the\n * polynomial\n *\n * @doc\n */\nfunction γ(n) {\n    const nu = n * u;\n    return nu / (1 - nu);\n}\n/**\n * The canonical, once compensated (implying double-double precision),\n * floating point error function.\n *\n * * roughly `=== n * (Number.EPSILON / 2)**2`\n * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)\n * @param n the parameter - typically a small positive integer, e.g. for\n * polynomial evaluation this === 2*d + 1, where d is the degree of the\n * polynomial\n *\n * @doc\n */\nfunction γγ(n) {\n    const nuu = n * uu;\n    return nuu / (1 - nuu);\n}\n\n//# sourceMappingURL=gamma.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/error-analysis/gamma.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/double-double/dd-horner.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/double-double/dd-horner.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ddHorner: () => (/* binding */ ddHorner)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\n/**\n * Returns the exact result (bar underflow / overflow) of evaluating a\n * univariate polynomial using Horner's method - the result is returned as a\n * Shewchuk expansion.\n *\n * @param p a polynomial with coefficients given densely as an array of\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\n * represents the polynomial `5x^2 - 3x`\n * @param x the value at which to evaluate the polynomial\n *\n * @doc\n */\nfunction ddHorner(p, x) {\n    let q = [0, 0];\n    for (let i = 0; i < p.length; i++) {\n        // q = p[i] + x*q;\n        q = qaq(p[i], qmd(x, q));\n    }\n    return q;\n}\nddHorner([[0, 1], [0, 1], [0, -2], [0, 3]], 0.25); //?\n\n//# sourceMappingURL=dd-horner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/double-double/dd-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/double/abs-horner.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/double/abs-horner.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsHorner: () => (/* binding */ AbsHorner)\n/* harmony export */ });\nconst abs = Math.abs;\n/**\n * Returns the result of evaluating a univariate polynomial using\n * Horner's method and where the absolute value of each coefficient is taken.\n *\n * * intermediate calculations are done in double precision\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param x the value at which `p` should be evaluated\n *\n * @doc\n */\nfunction AbsHorner(p, x) {\n    let q = 0;\n    for (let i = 0; i < p.length; i++) {\n        q = q * x + abs(p[i]);\n    }\n    return q;\n}\n// inlined (with q => e2, p => p0)\n//let e2 = abs(p0[0]); for (let i=1; i<p0.length; i++) { e2 = e2*x + abs(p0[i]); }\n\n//# sourceMappingURL=abs-horner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/double/abs-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/double/eft-horner.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EFTHorner: () => (/* binding */ EFTHorner)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\nconst twoProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\n/**\n * Returns an EFT (error free transformation) for the Horner evaluation of a\n * polymial at a specified x. The result is returned as an object with\n * properties: r̂ -> the calculated evaluation, pπ and pσ -> two polynomials\n * with coefficients around 2^53 times smaller than the input polynomial.\n *\n * * r̂ + pπ(x) + pσ(x) = the *exact* evaluation (no error)\n *\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\n * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\n * * see also [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param x the value at which to evaluate the polynomial\n *\n * @doc\n */\nfunction EFTHorner(p, x) {\n    const pπ = []; // A polynomial containing part of the error\n    const pσ = []; // Another polynomial containing part of the error\n    let σ;\n    let r̂ = p[0];\n    for (let i = 1; i < p.length; i++) {\n        const [π, pi] = twoProduct(r̂, x);\n        [σ, r̂] = twoSum(pi, p[i]);\n        // inlined\n        //r̂ = pi + p[i]; const bv = r̂ - pi; σ = (pi - (x-bv)) + (p[i]-bv);\n        pπ.push(π);\n        pσ.push(σ);\n    }\n    return { r̂, pπ, pσ };\n}\n// inlined\n//const pπ: number[] = []; const pσ: number[] = []; const σ: number; const r̂ = p[0];\tfor (const i=1; i<p.length; i++) { const [π,pi] = twoProduct(r̂,x); [σ,r̂] = twoSum(pi, p[i]); pπ.push(π); pσ.push(σ); } return { r̂, pπ, pσ }\n\n//# sourceMappingURL=eft-horner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/double/eft-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/double/eval-certified.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/double/eval-certified.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalCertified: () => (/* binding */ evalCertified)\n/* harmony export */ });\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eft-horner.js */ \"./node_modules/flo-poly/node/evaluate/double/eft-horner.js\");\n/* harmony import */ var _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horner-with-running-error.js */ \"./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js\");\n/* harmony import */ var _horner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./horner.js */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _abs_horner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abs-horner.js */ \"./node_modules/flo-poly/node/evaluate/double/abs-horner.js\");\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error-analysis/gamma.js */ \"./node_modules/flo-poly/node/error-analysis/gamma.js\");\n\n\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst γ = _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_0__[\"γ\"];\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_1__.EFTHorner;\nconst hornerWithRunningError = _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.hornerWithRunningError;\nconst Horner = _horner_js__WEBPACK_IMPORTED_MODULE_3__.Horner;\nconst AbsHorner = _abs_horner_js__WEBPACK_IMPORTED_MODULE_4__.AbsHorner;\nconst γ1 = γ(1);\nconst γ2 = γ(2);\n/**\n * Returns the result of evaluating the given polynomial (with specified\n * coefficient-wise error bounds) at x such that the sign is correct when\n * positive or negative and undecided when 0 - an additional `multiplier`\n * parameter can enforce additional bits (beyond the sign) to be correct.\n *\n * * designed to be fast in 'easy' cases (say condition number < 2^53) and\n * harder cases (condition number < 2^106) since nearly all typical\n * calculations will have condition number < 2^106\n * * a staggered approach is used - first double precision, then simulated\n * double-double precision (i.e. once compensated Horner evluation) is tried\n * before giving up and returning 0 - see point below\n * * if zero is returned then the calculated result is too close to 0 to\n * determine the sign; the caller of this function can then resort to a more\n * accurate (possibly exact) evaluation\n *\n * @param p an array of 2 polynomials with coefficients given densely as an\n * array of double precision floating point numbers from highest to\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`;\n * the first polynomial's coefficients represent the 'high part' (a double) of a\n * double-double precision value, while the second polynomial's coefficients\n * represent the 'low part', i.e. designating `hp` for high part and `lp` for\n * low part it must be that they are non-overlapping -> `twoSum(lp,hp)` will\n * equal `[lp,hp]`; put another way, if the given polynomial is given as e.g. a\n * linear polynomial with coefficients in double precision,\n * e.g. `[[1.7053025658242404e-13, 2354.33721613], [-7.105427357601002e-15,284.5673337]]`\n * then this parameter, `p`, should be `[[2354.33721613], 284.5673337], [1.7053025658242404e-13, -7.105427357601002e-15]]`\n * which is simply the result of transposing the original polynomial if it is\n * seen as a matrix\n * @param pE defaults to `undefined`; an error polynomial that provides a\n * coefficient-wise error bound on the input polynomial; all coefficients must\n * be positive; if `undefined` then the input polynomial will be assumed exact\n * @param x the value at which to evaluate the polynomial\n * @param multiplier defaults to 1; the final calculation error needs to be a\n * multiple of this number smaller than the evaluated value, otherwise zero is\n * returned - useful if not only the sign is important but also some bits, e.g.\n * if multiplier = 8 then 3 bits will have to be correct otherwise 0 is returned\n *\n * @doc\n */\nfunction evalCertified(p, x, pE = undefined, multiplier = 1) {\n    const absX = Math.abs(x);\n    const p0 = p[0];\n    // first do a fast evaluation\n    const [r, e1] = hornerWithRunningError(p0, x);\n    // inlined above line:\n    //const r = p0[0]; const e1 = Math.abs(r) / 2; for (const i=1; i<p0.length; i++) { r = r*x + p0[i]; e1 = Math.abs(x)*e1 + Math.abs(r); } e1 = Number.EPSILON * (2*e1 - Math.abs(r));\n    /** the error due to not considering p[1] */\n    // the line below was changed due to negative values of x now also allowed\n    const e2 = γ2 * AbsHorner(p0, absX);\n    // inlined above line:\n    //const e2 = abs(p0[0]); for (const i=1; i<p0.length; i++) { e2 = e2*x + abs(p0[i]); }\n    /** error due to imprecision in coefficients */\n    // the line below was changed due to negative values of x now also allowed\n    const E = pE !== undefined ? Horner(pE, absX) : 0;\n    //const E = p0[0]; for (const i=1; i<p0.length; i++) {E = E*x + p0[i]; }\n    const ee = e1 + e2 + E; // in difficult cases E can be larger than e1+e2\n    if (ee * multiplier < Math.abs(r)) {\n        // we are within bounds\n        return r;\n    }\n    // error is too large - do a more precise evaluation (i.e. once compensated\n    // with K === 2)\n    const EFTHorner_ = EFTHorner(p0, x);\n    const { pπ, pσ } = EFTHorner_;\n    let { r̂ } = EFTHorner_;\n    const [C1, c1] = hornerWithRunningError(pπ, x);\n    const [C2, c2] = hornerWithRunningError(pσ, x);\n    const [C3, c3] = hornerWithRunningError(p[1], x);\n    // typically: c1,c2 < c3 < E\n    let e = (c1 + c2 + c3) + E;\n    // typically: C1,C2 < C3 < r̂ and (C1 + C2 + C3 < r̂)\n    r̂ = (C1 + C2 + C3) + r̂;\n    e += γ1 * r̂;\n    if (e * multiplier < Math.abs(r̂)) {\n        return r̂;\n    }\n    // error is still too large to return the correct sign (if multiplier === 1)\n    return 0;\n}\n\n//# sourceMappingURL=eval-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/double/eval-certified.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hornerWithRunningError: () => (/* binding */ hornerWithRunningError)\n/* harmony export */ });\nconst abs = Math.abs;\nconst u = Number.EPSILON / 2;\n/**\n * Returns the result of evaluating a polyniomial at a point x, including a\n * running error bound as an array in the form `[r,e]` where `r` is the result\n * of the evaluation and `e` is the error.\n *\n * * see e.g. page 95 (at bottom) of [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param x the value at which to evaluate the polynomial\n *\n * @doc\n */\nfunction hornerWithRunningError(p, x) {\n    let r̂ = p[0];\n    let e = abs(r̂) * 0.5;\n    for (let i = 1; i < p.length; i++) {\n        r̂ = r̂ * x + p[i];\n        e = e * abs(x) + abs(r̂);\n    }\n    e = u * (2 * e - abs(r̂));\n    return [r̂, e];\n}\n// inlined (where r̂ => r, e => e1, p => p0)\n//let r = p0[0]; let e1 = Math.abs(r) / 2; for (let i=1; i<p0.length; i++) { r = r*x + p0[i]; e1 = Math.abs(x)*e1 + Math.abs(r); } e1 = Number.EPSILON * (2*e1 - Math.abs(r));\n\n//# sourceMappingURL=horner-with-running-error.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/double/horner.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/double/horner.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Horner: () => (/* binding */ Horner)\n/* harmony export */ });\n/**\n * Returns the result of evaluating a univariate polynomial using\n * Horner's method in double precision floating point arithmetic.\n *\n * * see [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param x the value at which to evaluate the polynomial\n *\n * @doc\n */\nfunction Horner(p, x) {\n    let q = 0;\n    for (let i = 0; i < p.length; i++) {\n        q = q * x + p[i];\n    }\n    return q;\n}\n// inlined (with q => E, p => p0)\n//let E = p0[0]; for (let i=1; i<p0.length; i++) {E = E*x + p0[i]; }\n\n//# sourceMappingURL=horner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/double/horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/expansion/e-horner.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/expansion/e-horner.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eHorner: () => (/* binding */ eHorner)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion;\n/**\n * Returns the exact result (bar underflow / overflow) of evaluating a\n * univariate polynomial using Horner's method - the result is returned as a\n * Shewchuk expansion.\n *\n * @param p a polynomial with coefficients given densely as an array of\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\n * represents the polynomial `5x^2 - 3x`\n * @param x the value at which to evaluate the polynomial\n *\n * @doc\n */\nfunction eHorner(p, x) {\n    let q = [0];\n    for (let i = 0; i < p.length; i++) {\n        // q = p[i] + x*q;\n        q = fes(p[i], sce(q, x));\n    }\n    return q;\n}\n\n//# sourceMappingURL=e-horner.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/evaluate/expansion/e-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bGcdInt: () => (/* binding */ bGcdInt),\n/* harmony export */   bGcdInts: () => (/* binding */ bGcdInts)\n/* harmony export */ });\n/**\n * Computes and returns the greatest common divisor of two integers a and b,\n * using the [Euclidean Algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\n *\n * @doc\n */\nfunction bGcdInt(a, b) {\n    a = a < 0n ? -a : a;\n    b = b < 0n ? -b : b;\n    // The below 2 commented lines represent Euclid's original algorithm.\n    //if (a === b) { return a; }\n    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);\n    if (a === 0n) {\n        return b;\n    }\n    if (b === 0n) {\n        return a;\n    }\n    while (b !== 0n) {\n        const t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n/**\n * Naively computes and returns the greatest common divisor of 2 or more\n * integers by taking each integer in turn and calculating the GCD of that\n * integer and the previously calculated GCD (where the first GCD is simply\n * taken as the first number).\n *\n * @param vals the integers for which the GCD is to be calculated\n *\n * @doc\n */\nfunction bGcdInts(vals) {\n    const vals_ = vals.slice();\n    const len = vals_.length;\n    // make array of numbers all positive\n    for (let i = 0; i < len; i++) {\n        vals_[i] = vals_[i] < 0n ? -vals_[i] : vals_[i];\n    }\n    let a = vals_[0];\n    for (let i = 1; i < len; i++) {\n        a = bGcdInt(a, vals_[i]);\n    }\n    return a;\n}\n/**\n * * ❗ don't use - too slow - use [[bGcdInts]] instead ❗\n *\n * Computes and returns the greatest common divisor of 2 or more integers by\n * calculating GCDs rescursively using a tree (Divide and Conquer).\n *\n * * It turns out this method is *slower* than the naive method\n */ /*\nfunction bGcdIntsTree(vals: bigint[]): bigint {\n   const vals_ = vals.slice();\n\n   // make array of numbers all positive\n   for (const i=0; i<vals_.length; i++) {\n       vals_[i] = vals_[i] < 0n ? -vals_[i] : vals_[i];\n   }\n   \n   // Divide and conquer\n   while (vals_.length > 1) {\n       const newVals = [];\n       const len = vals_.length;\n       for (const i=0; i<len-1; i += 2) {\n           newVals.push(bGcdInt(vals_[i], vals_[i+1]));\n       }\n       if (len % 2 !== 0) {\n           newVals.push(vals_[len-1]);\n       }\n\n       vals_ = newVals;\n   }\n   \n   return vals_[0];\n}\n*/\n\n//# sourceMappingURL=b-integer-gcd.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/predictive-random/double/random.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-poly/node/predictive-random/double/random.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flatCoefficients: () => (/* binding */ flatCoefficients),\n/* harmony export */   flatCoefficientsArr: () => (/* binding */ flatCoefficientsArr),\n/* harmony export */   flatRoots: () => (/* binding */ flatRoots),\n/* harmony export */   flatRootsArr: () => (/* binding */ flatRootsArr),\n/* harmony export */   predictiveRandom: () => (/* binding */ predictiveRandom)\n/* harmony export */ });\n/* harmony import */ var _roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../roots/from-roots/double/from-roots.js */ \"./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js\");\n\n/**\n * Arbitrary seed value for the simple random number generator.\n *\n * @internal\n */\nconst SEED = 123456789;\n/**\n * The range for the simple random number generator, i.e. the generated\n * numbers will be in [0,RANGE].\n *\n * @internal\n */\nconst RANGE = 4294967296;\n/**\n * Creates a function from the given function with parameters similar\n * to flatRoots but with an extra parameter in the beginning indicating\n * the length of the array generated by the original function.\n *\n * @param f\n *\n * @internal\n */\nfunction createArrFunction(f) {\n    return function (n, d, a, b, seed = SEED, odds = 0) {\n        const res = [];\n        for (let i = 0; i < n; i++) {\n            const v = f(d, a, b, seed, odds);\n            const p = v.p;\n            seed = v.seed;\n            res.push(p);\n        }\n        return res;\n    };\n}\n/**\n * Generates and returns an array of polynomials with random **roots** (with coefficients\n * given densely as an array of double floating point numbers from highest to\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\n *\n * * all roots will approximate real values so is not at all representative of\n * a natural random root distribution\n *\n * * the exact same polynomials will be created on each call to this function\n * if the same seed is used; this is by design to improve testing.\n *\n * @param n the number of polynomials to generate.\n * @param d the degree of the polynomials\n * @param a defaults to 0; the lower bound of the coefficients\n * @param b defaults to 1; the upper bound of the coefficients\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\n * @param odds defaults to 0; the odds that a root will be doubled (applied\n * recursively so that some roots could be tripled, etc.\n *\n * @example\n * ```typescript\n * flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n * flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n * ```\n *\n * @doc\n */\nconst flatRootsArr = createArrFunction(flatRoots);\n/**\n * Generates and returns an array of polynomials with random **coefficients** (with coefficients\n * given densely as an array of double floating point numbers from highest to\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\n *\n * * the exact same polynomials will be created on each call to this function\n * if the same seed is used; this is by design to improve testing.\n *\n * @param n the number of polynomials to generate.\n * @param d the length of the polynomial coefficients array\n * @param a defaults to 0; the lower bound of the coefficients\n * @param b defaults to 1; the upper bound of the coefficients\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\n * @param odds defaults to 0; the odds that a root will be doubled (applied\n * recursively so that some roots could be tripled, etc.\n *\n * @example\n * ```typescript\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n * ```\n *\n * @doc\n */\nconst flatCoefficientsArr = createArrFunction(flatCoefficients);\n/**\n * Returns a quasi-random number to be used as the next input to this function.\n *\n * * see [stackoverflow](https://stackoverflow.com/questions/3062746/special-simple-random-number-generator)\n *\n * @param seed\n *\n * @internal\n */\nfunction predictiveRandom(seed) {\n    const a = 134775813;\n    return (a * seed + 1) % RANGE;\n}\n/**\n * Generates a random array of numbers picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values.\n *\n * @param n the number of values to generate\n * @param a defaults to 0; the lower bound of the distribution\n * @param b defaults to 1; the upper bound of the distribution\n * @param seed defaults to 123456789; a seed\n * @param odds defaults to 0; the odds that a number will be doubled (applied\n * recursively so that some numbers will be tripled, etc.\n *\n * @internal\n */\nfunction randomArray(n, a, b, seed, odds = 0) {\n    let vs = [];\n    for (let i = 0; i < n; i++) {\n        seed = predictiveRandom(seed);\n        const v = ((seed / RANGE) * (b - a)) + a;\n        seed = push(seed, vs, v, odds);\n    }\n    vs = vs.slice(0, n);\n    return { vs, seed };\n}\n/**\n * Helper function that will add more numbers to the passed array - modifies the\n * values parameter.\n *\n * @param seed\n * @param values an existing array of values - will be modified!\n * @param x the number that will be added (possibly multiple times)\n * @param odds the odds that the number will be added again (recursively).\n *\n * @internal\n */\nfunction push(seed, values, x, odds) {\n    seed = predictiveRandom(seed);\n    values.push(x);\n    if ((seed / RANGE) < odds) {\n        seed = push(seed, values, x, odds);\n    }\n    return seed;\n}\n/**\n * Generates and returns an array of polynomials with random **roots** (with coefficients\n * given densely as an array of double floating point numbers from highest to\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\n *\n * * also returns a new seed value that can be used as the input to the next\n * call to a predictive random function\n *\n * * all roots will approximate real values so is not at all representative of\n * a natural random root distribution\n *\n * * the exact same polynomial will be created on each call to this function\n * if the same seed is used; this is by design to improve testing.\n *\n * @param d the degree of the polynomials\n * @param a defaults to 0; the lower bound of the coefficients\n * @param b defaults to 1; the upper bound of the coefficients\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\n * @param odds defaults to 0; the odds that a root will be doubled (applied\n * recursively so that some roots could be tripled, etc.\n *\n * @example\n * ```typescript\n * flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\n * ```\n *\n * @doc\n */\nfunction flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\n    const randArr = randomArray(d, a, b, seed, odds);\n    seed = randArr.seed;\n    const p = (0,_roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_0__.fromRoots)(randArr.vs);\n    return { p, seed };\n}\n/**\n * Generates and returns an array of polynomials with random **coefficients** (with coefficients\n * given densely as an array of double floating point numbers from highest to\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\n *\n * * also returns a new seed value that can be used as the input to the next\n * call to a predictive random function\n *\n * * the exact same polynomial will be created on each call to this function\n * if the same seed is used; this is by design to improve testing.\n *\n * @param d the length of the polynomial coefficients array\n * @param a defaults to 0; the lower bound of the coefficients\n * @param b defaults to 1; the upper bound of the coefficients\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\n * @param odds defaults to 0; the odds that a root will be doubled (applied\n * recursively so that some roots could be tripled, etc.\n *\n * @example\n * ```typescript\n * flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\n * ```\n *\n * @doc\n */\nfunction flatCoefficients(d, a = -1, b = +1, seed = SEED) {\n    const randArr = randomArray(d, a, b, seed);\n    seed = randArr.seed;\n    const p = randArr.vs;\n    return { p, seed };\n}\n\n//# sourceMappingURL=random.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/predictive-random/double/random.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allRootsCertifiedSimplified: () => (/* binding */ allRootsCertifiedSimplified)\n/* harmony export */ });\n/* harmony import */ var _all_roots_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./all-roots-certified.js */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n\nfunction allRootsCertifiedSimplified(p, lb = Number.NEGATIVE_INFINITY, ub = Number.POSITIVE_INFINITY, returnUndefinedForZeroPoly) {\n    return (0,_all_roots_certified_js__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(p.map(c => [0, c]), lb, ub, undefined, undefined, returnUndefinedForZeroPoly);\n}\n\n//# sourceMappingURL=all-roots-certified-simplified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/all-roots-certified.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/all-roots-certified.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allRootsCertified: () => (/* binding */ allRootsCertified)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../calculus/double-double/dd-differentiate-with-err.js */ \"./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js\");\n/* harmony import */ var _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../calculus/expansion/e-differentiate.js */ \"./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js\");\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/double/eval-certified.js */ \"./node_modules/flo-poly/node/evaluate/double/eval-certified.js\");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../evaluate/expansion/e-horner.js */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var _transpose_poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transpose-poly.js */ \"./node_modules/flo-poly/node/roots/certified/transpose-poly.js\");\n/* harmony import */ var _eval_adaptive_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./eval-adaptive.js */ \"./node_modules/flo-poly/node/roots/certified/eval-adaptive.js\");\n/* harmony import */ var _refine_certified_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./refine-certified.js */ \"./node_modules/flo-poly/node/roots/certified/refine-certified.js\");\n/* harmony import */ var _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../root-bounds/root-bounds-lmq.js */ \"./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js\");\n/* harmony import */ var _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../evaluate/double/horner-with-running-error.js */ \"./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js\");\n\n\n\n\n\n\n\n\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst ddDifferentiateWithError = _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_0__.ddDifferentiateWithError;\nconst evalCertified = _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_1__.evalCertified;\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_2__.eHorner;\nconst transposePoly = _transpose_poly_js__WEBPACK_IMPORTED_MODULE_3__.transposePoly;\nconst evalAdaptive = _eval_adaptive_js__WEBPACK_IMPORTED_MODULE_4__.evalAdaptive;\nconst refineCertified = _refine_certified_js__WEBPACK_IMPORTED_MODULE_5__.refineCertified;\nconst negativeRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_6__.negativeRootLowerBound_LMQ;\nconst positiveRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_6__.positiveRootUpperBound_LMQ;\nconst eDifferentiate = _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_7__.eDifferentiate;\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_8__.eEstimate;\nconst hornerWithRunningError = _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__.hornerWithRunningError;\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eSign;\nconst max = Math.max;\nconst min = Math.min;\nconst abs = Math.abs;\nconst eps = Number.EPSILON;\nconst onePlusEps = 1 + eps;\nfunction allRootsCertified(p, lb = 0, ub = 1, pE, getPExact, returnUndefinedForZeroPoly) {\n    // if `getPExact` is not specified then assume the given double-double \n    // precision coefficient polynomial is exact\n    if (!getPExact) {\n        getPExact = () => p;\n    }\n    //const δ = 2*Number.EPSILON * max(1, max(abs(lb), abs(ub)));\n    // if `pE` is not specified then assume there is no error\n    pE = pE || new Array(p.length).fill(0); // no error\n    // set `diffCount` to 0 so `getPolyExact` can be accurate\n    let diffCount = 0;\n    // lazy loaded array of the given polynomial and its derivatives\n    let psExact = undefined;\n    //----------------------------------------------------------------------\n    // Remove leading zero coefficients \n    // (the case of leading zero coefficients can now be handled)\n    // `p` and `getPExact()` *must* be of same length\n    //----------------------------------------------------------------------\n    let polyExact = undefined; // lazy loaded\n    // while the leading coefficient is smaller then the error bound \n    // i.e. possibly zero\t\n    while (p.length > 0 && abs(p[0][1]) <= pE[0]) {\n        polyExact = polyExact || getPExact();\n        // if leading coefficient really is zero\n        if (eSign(polyExact[0]) === 0) {\n            // shift the leading coefficient and error out without altering the \n            // given polynomial and error bound (shift is destructive, slice is not)\n            p = p.slice();\n            p.shift();\n            pE = pE.slice();\n            pE.shift();\n            // also shift out the exact polynomial's leading coefficient\n            polyExact.shift();\n            continue;\n        }\n        break;\n    }\n    if (p.length === 0) {\n        // return `undefined` for the zero polynomial?\n        return returnUndefinedForZeroPoly ? undefined : [];\n    }\n    else if (p.length === 1) {\n        // return `[]` for a degree 1 polynomial (a non-zero constant)\n        return [];\n    }\n    if (lb === Number.NEGATIVE_INFINITY || ub === Number.POSITIVE_INFINITY) {\n        const pDoubleCoeffs = p.map(c => c[1]);\n        if (lb === Number.NEGATIVE_INFINITY) {\n            lb = negativeRootUpperBound_LMQ(pDoubleCoeffs);\n        }\n        if (ub === Number.POSITIVE_INFINITY) {\n            ub = positiveRootUpperBound_LMQ(pDoubleCoeffs);\n        }\n    }\n    const p_ = transposePoly(p);\n    let bCount;\n    let exact;\n    const deg = p.length - 1;\n    bCount = 0;\n    exact = false;\n    let LB; // evaluation at lb\n    do {\n        LB = exact\n            ? eEstimate(eHorner(getPolyExact(), lb))\n            : evalCertified(p_, lb, pE);\n        if (LB === 0) {\n            bCount++;\n            // the max bCount is empirically selected for max performance\n            if (bCount >= 3 && !exact) {\n                exact = true;\n                continue;\n            }\n            lb -= 2 * Number.EPSILON * max(1, abs(lb));\n        }\n    } while (LB === 0);\n    bCount = 0;\n    exact = false;\n    let UB; // evaluation at ub\n    do {\n        UB = exact\n            ? eEstimate(eHorner(getPolyExact(), ub))\n            : evalCertified(p_, ub, pE);\n        if (UB === 0) {\n            bCount++;\n            if (bCount >= 3 && !exact) { // the max bCount is empirically selected for max performance\n                exact = true;\n                continue;\n            }\n            ub += 2 * Number.EPSILON * max(1, abs(ub));\n        }\n    } while (UB === 0);\n    // Get all derivatives with their coefficient-wise error bounds, i.e. \n    // ps === [p, dp, ddp, ..., constant]\n    //        [0,  1,   2, ..., deg     ]\n    const ps = [{ p, pE }];\n    const ps_ = [transposePoly(p)]; // the transposed versions\n    for (let i = 1; i <= deg; i++) {\n        const dP = ddDifferentiateWithError(ps[i - 1]);\n        ps.push(dP);\n        ps_.push(transposePoly(dP.p)); // the transposed versions\n    }\n    let is = [];\n    let curPE;\n    let curP_;\n    diffCount = deg - 1; // update diffcount\n    for (; diffCount >= 0; diffCount--) {\n        curPE = ps[diffCount].pE;\n        // on first iteration curP_ is linear, \n        // on second it is quadratic, etc. ...\n        curP_ = ps_[diffCount];\n        is = getRootsWithin();\n    }\n    // depends externally on `diffCount` and `psExact`\n    function getPolyExact() {\n        // cache\n        if (psExact !== undefined) {\n            return psExact[diffCount];\n        }\n        // keep TypeScript happy; `getPExact` cannot be `undefined` here\n        let poly = polyExact || getPExact();\n        psExact = [poly];\n        while (poly.length > 1) {\n            poly = eDifferentiate(poly);\n            psExact.push(poly);\n        }\n        return psExact[diffCount];\n    }\n    return is;\n    // All cases:\n    // ----------\n    // Note: [_a,a_] denotes a micro-interval, whereas [b_,_a], [a_,_b] denotes a\n    // normal interval.\n    // Note: In all iterations we check [_a,a_] and [a_,_b]. In the final\n    // iteration we check [_b,b_], then we've checked all intervals.\n    // \n    // ⇑ represents +pos (above x-axis) and ⇓ represents -neg\n    // (the symmetric cases also applies where + and - are interchanged)\n    // ? means does not matter\n    // -----------------------------------------------------------------\n    // CASE 1A:\n    // _A⇑ | A_⇑ | _B⇑\n    //  - [_a,a_] → \n    //    - _a === a_\n    //        ? no root \n    //        : A_/_A close enough to zero\n    //            ? close even root \n    //            : no roots\n    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)\n    // CASE 1B:\n    // _A⇑ | A_⇑ | _B⇓  \n    //  - [_a,a_] → \n    //    - _a === a_\n    //        ? no root \n    //        : A_/_A close enough to zero ? close even root : no roots\n    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)\n    // CASE 2A:\n    // _A⇑ | A_⇓ | _B⇑\n    //  - [_a,a_] → odd root(s)\n    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)\n    // CASE 2B:\n    // _A⇑ | A_⇓ | _B⇓\n    //  - [_a,a_] → odd root(s)\n    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)\n    // CASE 3A: \n    // A_0 | A_? | _B? | B_?  \n    // CASE 3B: \n    // A_? | A_0 | _B? | B_?  \n    /**\n     * Finds and returns all roots of the given polynomial within the given\n     * intervals, starting from the lower bound (lb) and ending at the upper\n     * bound (ub) as fetched from the closure.\n     *\n     * * **precondition** intervals should be disjoint, i.e endpoints are not allowed\n     * to be equal - it must be that a_ !== _b\n     * * **precondition** the curve must be monotone increasing or decreasing between\n     * b_ and _a AND a_ and _b\n     * * **precondition** the value at the lower bound (LB) and upper bound (UB)\n     * must !== 0\n     *\n     * @internal\n     *\n     * @param curP_ a polynomial given as an array with each consecutive element of\n     * the array having more accurate coefficients than the previous (by adding\n     * consecutive double precision coefficients to prior coefficients)\n     * @param is the micro-intervals\n     */\n    function getRootsWithin() {\n        const roots = [];\n        // If there are no micro-intervals then check the interval between lb and ub.\n        const LB = evalAdaptive(curP_, curPE, lb, getPolyExact);\n        if (!is.length) {\n            // close even root not possible\n            const UB = evalAdaptive(curP_, curPE, ub, getPolyExact);\n            if (LB * UB >= 0) {\n                return [];\n            }\n            const [tS, tE] = refineCertified(curP_, curPE, lb, ub, LB, UB, getPolyExact /*, δ*/);\n            return [{ tS, tE, multiplicity: 1 }];\n        }\n        //---- First check from lb to the left side of the first micro-interval.\n        let _a = is[0].tS;\n        let _A = evalAdaptive(curP_, curPE, _a, getPolyExact);\n        if (LB * _A > 0) {\n            // no roots possible (curve is monotone increasing or decreasing)\n        }\n        else if (LB * _A < 0) {\n            // recall LB must !== 0 as a precondition\n            const [tS, tE] = refineCertified(curP_, curPE, lb, _a, LB, _A, getPolyExact /*, δ*/);\n            roots.push({ tS, tE, multiplicity: 1 });\n        } //else {\n        // _A === 0\n        // no roots possible in [lb,_a]\n        //}\n        let a_ = lb;\n        let A_ = LB;\n        let _b = _a;\n        let _B = _A;\n        let a;\n        for (let i = 0; i < is.length; i++) {\n            const i_ = is[i + 1]; // right micro-interval\n            a = is[i];\n            _a = _b;\n            a_ = is[i].tE;\n            _b = i_ ? i_.tS : ub;\n            const B_ = A_;\n            _A = _B;\n            A_ = evalAdaptive(curP_, curPE, a_, getPolyExact);\n            _B = evalAdaptive(curP_, curPE, _b, getPolyExact);\n            if (_A * A_ > 0) {\n                //---- CASE 1: _A⇑ | A_⇑   OR   _A⇓ | A_⇓\n                if (A_ * _B > 0) {\n                    //---- CASE 1A: _A⇑ | A_⇑ | _B⇑   OR   _A⇓ | A_⇓ | _B⇓\n                    //console.log('CASE 1A');\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\n                        checkEvenAA();\n                    }\n                    // [a_,_b] → no root\n                }\n                else if (A_ * _B < 0) {\n                    //---- CASE 1B: _A⇑ | A_⇑ | _B⇓   OR   _A⇓ | A_⇓ | _B⇑\n                    //console.log('CASE 1B');\n                    // we cannot exclude this case as their may be even \n                    // multiplicity >= 4 roots; we would've been able if we\n                    // knew that a.multiplicity === 1 exactly and thus the code\n                    // could still be improved slightly\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\n                        checkEvenAA();\n                    }\n                    // [a_,_b] → single root (curve is monotone increasing or decreasing)\n                    const [tS, tE] = refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);\n                    roots.push({ tS, tE, multiplicity: 1 });\n                }\n                else { // _B === 0\n                    //---- CASE 1C: _A⇑ | A_⇑ | _B0   OR   _A⇓ | A_⇓ | _B0\n                    //console.log('CASE 1C');\n                    // we cannot exclude this case as their may be even \n                    // multiplicity >= 4 roots; we would've been able if we\n                    // knew that a.multiplicity === 1 exactly and thus the code\n                    // could still be improved slightly\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\n                        checkEvenAA();\n                    }\n                    // [a_,_b] → no root\n                }\n            }\n            else if (_A * A_ < 0) {\n                //---- CASE 2 _A⇑ | A_⇓   OR   _A⇓ | A_⇑\n                //console.log('CASE 2');\n                // - [_a,a_] → odd root(s)\n                roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });\n                if (A_ * _B < 0) {\n                    //---- CASE 2A: _A⇑ | A_⇓ | _B⇑   OR   _A⇓ | A_⇑ | _B⇓\n                    //console.log('CASE 2A');\n                    // [a_,_b] → single root\n                    const [tS, tE] = refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);\n                    roots.push({ tS, tE, multiplicity: 1 });\n                }\n                else if (A_ * _B > 0) {\n                    //---- CASE 2B: _A⇑ | A_⇓ | _B⇓   OR   _A⇓ | A_⇑ | _B⇑\n                    //console.log('CASE 2B');\n                    // [a_,_b] → no roots\n                }\n                else { // _B === 0\n                    //console.log('CASE 2C');\n                    // [a_,_b] → no roots\n                }\n            }\n            else if (A_ === 0) {\n                //---- CASE 3A A_0\n                //console.log('CASE 3A');\n                // [_a,a_] → rational root at a_\n                // There cannot be a root between a_ and _b since _B !== 0\n                if ( /*_a === a_ ||*/_A === 0) {\n                    // multiple rational root at a_ OR both _A and A_ is 0\n                    // so update multiplicity parity\n                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: a.multiplicity + 1 });\n                }\n                else {\n                    // now _A and _B are both !== 0\n                    if (_A * _B > 0) {\n                        roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });\n                    }\n                    else {\n                        roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });\n                    }\n                }\n            }\n            else { // _A === 0\n                //---- CASE 3B _A0\n                //console.log('CASE 3B');\n                // A_ !== 0 here and _a !== a_\n                // [_a,a_] → rational root at _a\n                if (A_ * _B < 0) {\n                    // [a_,_b] → single root\n                    const [tS, tE] = refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);\n                    roots.push({ tS, tE, multiplicity: 1 });\n                }\n                else if (A_ * _B > 0) {\n                    // [a_,_b] → no roots\n                }\n                // - [_a,a_] → \n                // B_ and A_ are both !== 0\n                if (B_ * A_ > 0) {\n                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });\n                }\n                else {\n                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });\n                }\n            }\n        }\n        // Combine the root intervals if they are adjacent (they are not \n        // allowed to overlap)\n        for (let i = 0; i < roots.length - 1; i++) {\n            const r = roots[i];\n            const r_ = roots[i + 1];\n            if (r.tE >= r_.tS) {\n                return joinRoots(roots);\n            }\n        }\n        return roots;\n        /**\n         * Calculates and returns max 2nd derivative - calculated using something\n         * akin to a Taylor expansion - could be improved by not taking absolute\n         * values, but rather minimum mins. and maximum max values of f(s)?.\n         * maxDdP = |f(s)| + δ|f'(s)| + δ^2|f''(s)| + ..., where δ = (a_ - _a),\n         * s = _a and f is the second derivative of the current polynomial. We can\n         * also potentially short circuit the maxDdP calculation after some terms,\n         * the point being there are very likely many optimizations that can still\n         * be done.\n         *\n         * @internal\n         */\n        function checkEvenAA() {\n            //This was the old method when the function only supported lb = 0, ub = 1\n            //-----------------------------------------------------------------------\n            //const ddP0 = diffCount+2 > deg ? undefined : ps_[diffCount+2][0];\n            //const maxDdP2 = 0;\n            //for (const j=0; j<ddP0.length; j++) {\n            //\t// evaluate at 1\n            //\tmaxDdP2 += abs(ddP0[j]);  // this is valid only if |lb| and |ub| <= 1\n            //}\n            const d = (a_ - _a) * onePlusEps;\n            let mult = 1;\n            let maxDdP = 0;\n            for (let ddDiffCount = diffCount + 2; ddDiffCount <= deg; ddDiffCount++) {\n                const p = ps_[ddDiffCount][0];\n                const h = hornerWithRunningError(p, _a);\n                const fs = abs(h[0]) + h[1];\n                maxDdP += fs * mult;\n                mult *= d * onePlusEps;\n            }\n            // maxDdP is now calculated\n            const AMinMax = A_ > 0 ? min(_A, A_) : max(_A, A_);\n            const δ = 2 * Number.EPSILON * max(1, abs(a_));\n            const dMax = maxDdP * (2 * δ); // since the first derivative === 0 somewhere in [_a,a_]\n            const yShift = A_ > 0 ? -dMax * 2 * δ : dMax * 2 * δ;\n            const y = AMinMax + yShift;\n            if (y * A_ < 0) {\n                // possible even multiplicity root\n                //console.log('A_, yShift', A_, yShift);\n                //console.log(toCasStr(ps_[0][0]));\n                //console.log('possible even multiplicty root: ', _a, a_);\n                // The below multiplicity can really be any non-negative \n                // multiple of 2\n                roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });\n            }\n        }\n    }\n}\nfunction joinRoots(rs) {\n    const newRs = [];\n    const r = rs[0];\n    // make a clone of the first interval\n    let curR = { tS: r.tS, tE: r.tE, multiplicity: r.multiplicity };\n    for (let i = 0; i < rs.length - 1; i++) {\n        const r = rs[i];\n        const r_ = rs[i + 1];\n        if (r.tE < r_.tS) {\n            // they don't stick together\n            newRs.push(curR);\n            // make a clone of the next interval\n            curR = { tS: r_.tS, tE: r_.tE, multiplicity: r_.multiplicity };\n        }\n        else {\n            // they stick together - expand\n            curR.tE = r_.tE;\n            curR.multiplicity = r.multiplicity + r_.multiplicity;\n        }\n    }\n    newRs.push(curR);\n    return newRs;\n}\n\n//# sourceMappingURL=all-roots-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/all-roots-certified.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/eval-adaptive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/eval-adaptive.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalAdaptive: () => (/* binding */ evalAdaptive)\n/* harmony export */ });\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../evaluate/double/eval-certified.js */ \"./node_modules/flo-poly/node/evaluate/double/eval-certified.js\");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/expansion/e-horner.js */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst evalCertified = _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__.evalCertified;\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__.eHorner;\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eEstimate;\n/**\n * Returns the result of evaluating the given polynomial (with double-double\n * precision coefficients) at the given value, where the coefficient-wise error\n * is also given.\n *\n * * **the sign of the returned result is guaranteed to be correct**\n * * the evaluation is done adaptively, i.e. if the evaluation cannot be done\n * accurately enough then an exact precision polynomial is requested\n *\n * @param p a polynomial given as an array with each consecutive element of\n * the array having more accurate coefficients than the previous (by adding\n * consecutive double precision coefficients to prior coefficients)\n * @param pE a coefficientwise error bound\n * @param x the point of evaluation\n * @param psExact an object holding the exact polynomial and all its exact\n * derivatives - this object may be modified!\n * @param getPsExact a function to retrieve the exact polynomial and all its\n * exact derivatives\n * @param diffCount the number of differentiations done up to this point\n *\n * @internal\n */\nfunction evalAdaptive(p, pE, x, getPolyExact) {\n    const r = evalCertified(p, x, pE, 4);\n    if (r !== 0) {\n        return r;\n    }\n    // condition number is too high - request higher precision\n    return eEstimate(eHorner(getPolyExact(), x));\n}\n\n//# sourceMappingURL=eval-adaptive.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/eval-adaptive.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/refine-certified.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/refine-certified.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refineCertified: () => (/* binding */ refineCertified)\n/* harmony export */ });\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../evaluate/double/eval-certified.js */ \"./node_modules/flo-poly/node/evaluate/double/eval-certified.js\");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/expansion/e-horner.js */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst evalCertified = _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__.evalCertified;\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__.eHorner;\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eEstimate;\nconst eps = Number.EPSILON;\nconst abs = Math.abs;\nconst max = Math.max;\n/**\n * Returns a refined root given a root bracketed in the interval (a,b) of the\n * given polynomial using Brent's Method - modified slightly to allow for\n * error certified bounds.\n *\n * * near exact implementation of the original Brent Dekker Method (also known\n * as Brent's Method), except that it is specialzed to polynomial evaluation\n *\n * * Brent's Method is an excellent root-refinement choice since:\n *  * guaranteed converge (unlike the Newton and other so-called single-point\n * methods),\n *  * converges in a reasonable number of iterations even for highly contrived\n * functions (unlike Dekker's Method) and\n *  * nearly always converges fast, i.e. super-linearly (unlike the Secant and\n * Regula-Falsi methods).\n * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)\n * works but is not precisely Brent's method and runs about 2x or more slower\n * due to it not implementing the critically important 'micro-step' (Aug 2020).\n *\n * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)\n * * [c++ implementation of Brent's Method](https://people.sc.fsu.edu/~jburkardt/cpp_src/brent/brent.cpp)\n *\n * @param p A polynomial with coefficients given densely as an array of double-double\n * floating point numbers from highest to lowest power, e.g. `[[0,5],[0,-3],[0,0]]`\n * represents the polynomial `5x^2 - 3x`. If `exact` is `true` then this is allowed\n * to be `undefined`.\n * @param pE An error polynomial that provides a coefficientwise error bound on\n * the input polynomial; all coefficients must be positive. If `exact` is `true`\n * then this is allowed to be `undefined`.\n * @param lb the lower limit of the search interval.\n * @param ub the upper limit of the search interval.\n * @param fa the result of evaluating the input polynomial at `a`\n * @param fb the result of evaluating the input polynomial at `b`\n * @param psExact\n * @param getPsExact\n * @param diffCount\n * @param exact set to true if you need to do exact evaluations from the start\n *\n * @internal\n */\nfunction refineCertified(p, pE, lb, ub, fa, fb, getPolyExact, exact) {\n    //---- Make local copies of a and b.\n    let a = lb;\n    let b = ub;\n    let c = a;\n    let fc = fa;\n    let e = b - a;\n    let d = e;\n    while (true) {\n        // update delta\n        if (abs(fc) < abs(fb)) {\n            a = b;\n            b = c;\n            c = a;\n            fa = fb;\n            fb = fc;\n            fc = fa;\n        }\n        // Original c++ code had the line below but with us t === 0 and b is \n        // taken as 1 and 2.0 * macheps is taken as 2*u === Number.EPSILON (eps)\n        // or can also be taken as 4*u === 2*Number.EPSILON (2*eps)\n        // adaptive tolerance\n        //let δ = 2 * eps * max(1,abs(b));\n        //let δ = 2 * u * max(1,abs(b));\n        let δ;\n        const mm = max(abs(a), abs(b));\n        if (mm <= 1) {\n            δ = eps;\n        }\n        else {\n            // keep δ = eps * a power of 2\n            //δ = eps * 2**Math.ceil(Math.log2(Math.ceil(mm)));  // may be faster to get log2 of an integer\n            δ = eps * 2 ** Math.ceil(Math.log2(mm));\n        }\n        //tol = 2.0 * macheps * abs ( b ) + t;\n        const m = 0.5 * (c - b);\n        //if (abs(m) <= δ || fb === 0) {\n        // modified from the original since we dont need the fb === 0 check here\n        if (abs(m) <= δ) {\n            // TODO - could potentially make b - c a power of 2 here δ\n            return b < c ? [b, c] : [c, b];\n        }\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\n            e = m;\n            d = e;\n        }\n        else {\n            let s = fb / fa;\n            let p;\n            let q;\n            if (a === c) {\n                p = 2 * m * s;\n                q = 1 - s;\n            }\n            else {\n                q = fa / fc;\n                const r = fb / fc;\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                q = (q - 1) * (r - 1) * (s - 1);\n            }\n            if (0 < p) {\n                q = -q;\n            }\n            else {\n                p = -p;\n            }\n            s = e;\n            e = d;\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\n                d = p / q;\n            }\n            else {\n                e = m;\n                d = e;\n            }\n        }\n        a = b;\n        fa = fb;\n        if (δ < abs(d)) {\n            b = b + d;\n        }\n        else if (0 < m) {\n            b = b + δ;\n        }\n        else {\n            //b = b - eps;\n            b = b - δ;\n        }\n        fb = exact\n            ? eEstimate(eHorner(getPolyExact(), b))\n            // keep TypeScript happy; neither `p` nor `pE` can be `undefined` \n            // here by a precondition\n            : evalCertified(p, b, pE);\n        if (fb === 0) {\n            // Since `evalCertified` returns zero if undecided the zero result\n            // cannot be fully trusted at this point.\n            // if we are already doing exact evaluations this is an exact root\n            if (exact) {\n                return [b, b];\n            }\n            // We need to calculate δ/2 to the left and right of b to get \n            // results that should usually be !== 0. \n            // It is a pre-filter. If the result === 0 we need to sharpen the\n            // ability of the evaluation by somehow reducing the error bound\n            const sL = Math.max(lb, b - δ); // dont overstep bounds\n            const sR = Math.min(ub, b + δ); // dont overstep bounds\n            // Note: sR - sL <= 2*δ provided lb, ub are in [-1..1] - usually \n            // (when sL === s - δ and sR === s + δ) sR - sL === 2*δ. Also δ > 0\n            // keep TypeScript happy; neither `p` nor `pE` can be `undefined` \n            // here by a precondition\n            const fsL = evalCertified(p, sL, pE);\n            const fsR = evalCertified(p, sR, pE);\n            // if the evaluation method is strong enough return the result\n            if (fsL * fsR !== 0) {\n                return [sL, sR];\n            }\n            // At this point either fsL or fsR === 0 so we need to sharpen the\n            // evaluation method\n            exact = true;\n            // get and cache the exact polynomial (we cache this since getting\n            // an exact polynomial takes about 15 times more time than getting\n            // a double-double polynomial and we very rarely expect to get to \n            // this point)\n            fb = eEstimate(eHorner(getPolyExact(), b));\n            // if the exact evaluation returns 0 we have an exact root\n            if (fb === 0) {\n                return [b, b];\n            }\n            // else we've got a new value for fb and from here on we use exact\n            // evaluations\n        }\n        if ((0 < fb && 0 < fc) || (fb <= 0 && fc <= 0)) {\n            c = a;\n            fc = fa;\n            e = b - a;\n            d = e;\n        }\n    }\n}\n\n//# sourceMappingURL=refine-certified.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/refine-certified.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/refine-k1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/refine-k1.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refineK1: () => (/* binding */ refineK1)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n/* harmony import */ var _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../change-variables/expansion/e-change-variables-linear.js */ \"./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js\");\n/* harmony import */ var _all_roots_certified_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./all-roots-certified.js */ \"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js\");\n\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst eChangeVariablesLinear = _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_0__.eChangeVariablesLinear;\nconst allRootsCertified = _all_roots_certified_js__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified;\nconst eToDd = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eToDd;\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoSum;\nconst eps = Number.EPSILON;\n/**\n * Returns once compensated root(s) (bar underflow / overflow) given a root\n * interval previously calculated using [[allRootsCertified]].\n *\n * * 'once-compensated' here means that the typical root interval, `W`,\n * (`= Number.EPSILON` at `1`) is reduced to `W**2`; if multiple roots were\n * present in the original interval they may be resolved to individual\n * intervals\n *\n * @param ri a root interval previously calculated\n * @param p the exact polynomial with coefficients given densely as an array of\n * Shewchuk floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\n *\n * @doc\n */\nfunction refineK1(ri, p) {\n    const tS = ri.tS;\n    // scale is exact by the precondition put on `RootInterval`\n    const δ = ri.tE - tS;\n    if (δ === 0) {\n        return [{\n                tS: [0, tS],\n                tE: [0, tS],\n                multiplicity: ri.multiplicity\n            }];\n    }\n    // Translate the polynomial such that the root is within δ from 0, then\n    // scale it such that the roots stay <= 1, i.e. is in [0,1]\n    const pExactK1 = eChangeVariablesLinear(p, δ, tS);\n    // reduce the polynomial to double-double precision for faster root finding\n    const pDdK1 = pExactK1.map(eToDd);\n    // update the double-double precision error bound - it is simply the error \n    // in rounding the exact coefficients to double-double precision\n    const errBoundK1 = pDdK1.map(c => eps * eps * c[1]);\n    const getPExactK1 = () => pExactK1;\n    // keep TypeScript happy; `allRootsCertified` can safely be assumed not to\n    // return `undefined`\n    const risLo = allRootsCertified(pDdK1, 0, 1, errBoundK1, getPExactK1);\n    const ris = [];\n    for (const riLo of risLo) {\n        ris.push({\n            tS: twoSum(tS, riLo.tS * δ),\n            tE: twoSum(tS, riLo.tE * δ),\n            multiplicity: riLo.multiplicity\n        });\n    }\n    return ris;\n}\n\n//# sourceMappingURL=refine-k1.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/refine-k1.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rootIntervalToExp: () => (/* binding */ rootIntervalToExp)\n/* harmony export */ });\n/**\n * Returns the result of converting a double precision root interval to a\n * double-double precision one\n *\n * @param ri a root interval\n *\n * @doc\n */\nfunction rootIntervalToExp(ri) {\n    return {\n        tS: [0, ri.tS],\n        tE: [0, ri.tE],\n        multiplicity: ri.multiplicity\n    };\n}\n\n//# sourceMappingURL=root-interval-to-exp.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/root-interval.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/root-interval.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRootExact: () => (/* binding */ createRootExact),\n/* harmony export */   mid: () => (/* binding */ mid)\n/* harmony export */ });\n/**\n * Simple function that creates and returns an exact root (with a bracketing\n * interval width of 0 and multiplicity 1)\n *\n * @param t\n *\n * @doc\n */\nfunction createRootExact(t) {\n    return { tS: t, tE: t, multiplicity: 1 };\n}\n/**\n * Simple function that returns the middle of the root bracketing interval - can\n * be used to estimate the root\n *\n * @param ri a root interval\n *\n * @doc\n */\nfunction mid(ri) {\n    return (ri.tS + ri.tE) / 2;\n}\n\n//# sourceMappingURL=root-interval.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/root-interval.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/certified/transpose-poly.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/certified/transpose-poly.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transposePoly: () => (/* binding */ transposePoly)\n/* harmony export */ });\n/**\n * Transposes the given polynomial (given with multi-precision coefficients)\n * into multiple polynomials with each consecutive polynomial 'adjusting'\n * the prior one to higher precision.\n *\n * @param p\n *\n * @internal\n */\nfunction transposePoly(p) {\n    // transpose the polynomial coefficients into multiple polynomials\n    const len = p[0].length;\n    const p_ = [];\n    for (let i = 0; i < len; i++) {\n        const _p = [];\n        for (let j = 0; j < p.length; j++) {\n            _p.push(p[j][len - (i + 1)]); // from highest to lowest\n        }\n        p_.push(_p);\n    }\n    return p_;\n}\n\n//# sourceMappingURL=transpose-poly.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/certified/transpose-poly.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRoots: () => (/* binding */ fromRoots)\n/* harmony export */ });\n/* harmony import */ var _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../basic/double/multiply.js */ \"./node_modules/flo-poly/node/basic/double/multiply.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst multiply = _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_0__.multiply;\n/**\n * Constructs a polynomial from the given roots by multiplying out the\n * factors (x - root1)(x - root2) in double precision\n *\n * * the resulting polynomial may have complex roots close to zero due to\n * round-off caused by working in double precision.\n *\n * * mostly for testing purposes.\n *\n * * the real roots of the constructed polynomial is unlikely to be exactly\n * the same as the roots that the polynomial has been constructed from due to\n * floating-point round-off.\n *\n * @param roots an array of roots\n *\n * @example\n * ```typescript\n * fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\n * allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\n *\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed.\n * allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\n * allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\n * ```\n *\n * @doc\n */\nfunction fromRoots(roots) {\n    let p = [1];\n    for (let i = 0; i < roots.length; i++) {\n        p = multiply(p, [1, -roots[i]]);\n    }\n    return p;\n}\n\n//# sourceMappingURL=from-roots.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/naive/all-roots.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/naive/all-roots.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allRoots: () => (/* binding */ allRoots)\n/* harmony export */ });\n/* harmony import */ var _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../calculus/double/differentiate.js */ \"./node_modules/flo-poly/node/calculus/double/differentiate.js\");\n/* harmony import */ var _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/double/horner.js */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n/* harmony import */ var _brent_poly_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./brent-poly.js */ \"./node_modules/flo-poly/node/roots/naive/brent-poly.js\");\n/* harmony import */ var _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../root-bounds/root-bounds-lmq.js */ \"./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js\");\n/* harmony import */ var _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../basic/double/remove-leading-zeros.js */ \"./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js\");\n\n\n\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst differentiate = _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_0__.differentiate;\nconst Horner = _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_1__.Horner;\nconst brentPoly = _brent_poly_js__WEBPACK_IMPORTED_MODULE_2__.brentPoly;\nconst negativeRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_3__.negativeRootLowerBound_LMQ;\nconst positiveRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_3__.positiveRootUpperBound_LMQ;\nconst removeLeadingZeros = _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_4__.removeLeadingZeros;\n/**\n * Find and return all roots of the given polynomial in the given interval.\n *\n * * an empty array is returned for a constant or the zero polynomial\n *\n * * **non-exact:** roots are found 'naively' using double-precision arithmetic\n * and accuracy will thus depend on the condition number around the root - use\n * [[allRootsCertifiedSimplified]] or [[allRootsCertified]] instead if certified\n * root bounds are required (it is about 3x slower, but still very fast!)\n *\n * * close (where the definition of closeness depends on the condition\n * number) or multiple *even* roots can be returned as 0, 1 or more close\n * roots, whereas close or multiple *odd* roots are guaranteed to return *at\n * least 1 root*\n *\n * * optimized for polynomials of degree 1 to about 30\n *\n * * roots are refined using the celebrated Brent's Method (and evaluated using\n * Horner's Method) until a root interval is found with\n * width `<= eps * max(1, 2^⌈log₂r⌉)`, where `eps = Number.EPSILON` and\n * `r` is a root\n *\n * * **ordered:** the returned roots are ordered from lowest to highest\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param lb defaults to `Number.NEGATIVE_INFINITY`; lower bound of roots to be\n * returned\n * @param ub defaults to `Number.POSITIVE_INFINITY`; upper bound of roots to be\n * returned\n *\n * @doc\n */\nfunction allRoots(p, lb = Number.NEGATIVE_INFINITY, ub = Number.POSITIVE_INFINITY) {\n    p = removeLeadingZeros(p);\n    //---- count and remove roots at zero\n    let numZerosAtZero = 0;\n    while (p[p.length - 1] === 0) {\n        p = p.slice(0, -1);\n        numZerosAtZero++;\n    }\n    //------------------------\n    // return an empty array for a constant or the zero polynomial\n    if (p.length <= 1) {\n        const roots = [];\n        for (let j = 0; j < numZerosAtZero; j++) {\n            roots.push(0);\n        }\n        return roots;\n    }\n    if (lb === Number.NEGATIVE_INFINITY) {\n        lb = negativeRootUpperBound_LMQ(p);\n    }\n    if (ub === Number.POSITIVE_INFINITY) {\n        ub = positiveRootUpperBound_LMQ(p);\n    }\n    // Get all derivatives, i.e. \n    // ps === [p, dp, ddp, ..., constant]\n    //        [0,  1,   2, ..., deg     ]\n    const ps = [p];\n    for (let i = 1; i <= p.length - 1; i++) {\n        ps.push(differentiate(ps[i - 1]));\n    }\n    //const δ = Math.max(2*eps, 2*eps * Math.max(Math.abs(lb), Math.abs(ub)));\n    /** root intervals */\n    let is = [];\n    // loop: ps[diffCount] === [linear, quadratic, ..., deg]\n    for (let diffCount = p.length - 2; diffCount >= 0; diffCount--) {\n        // Get roots within intervals:\n        // ---------------------------\n        // Finds and returns all roots of the given polynomial within the given \n        // intervals, starting from the lower bound (lb) and ending at the upper\n        // bound (ub)\n        const p = ps[diffCount];\n        const roots = [];\n        let _a_ = lb;\n        let _A_ = Horner(p, _a_);\n        // if lower bound value is zero and this is the last iteration with \n        // p === the original polynomial then push the root at the lower bound\n        if (_A_ === 0 && diffCount === 0) {\n            roots.push(lb);\n        }\n        for (let i = 0; i < is.length; i++) {\n            const _b_ = is[i];\n            const _B_ = Horner(p, _b_);\n            // if there is a root at the right interval then add it\n            if (_B_ === 0) {\n                roots.push(_b_);\n            }\n            else if (_A_ * _B_ < 0) {\n                roots.push(brentPoly(p, _a_, _b_, _A_, _B_));\n            }\n            _a_ = _b_;\n            _A_ = _B_;\n        }\n        const _B_ = Horner(p, ub);\n        if (_A_ * _B_ < 0) {\n            roots.push(brentPoly(p, _a_, ub, _A_, _B_));\n        }\n        // if upper bound value is zero and this is the last iteration with \n        // p === the original polynomial then push the root at the upper bound\n        if (_B_ === 0 && diffCount === 0) {\n            roots.push(ub);\n        }\n        is = roots;\n    }\n    if (numZerosAtZero > 0 && lb <= 0 && ub >= 0) {\n        // at this point the existing intervals, `is`, are sorted\n        // find the insertion spot and insert the zero roots to keep the roots\n        // sorted\n        const isWithZeroRoots = [];\n        let zerosInserted = false;\n        for (let i = 0; i < is.length; i++) {\n            if (!zerosInserted && is[i] >= 0) {\n                // push the zero roots\n                for (let j = 0; j < numZerosAtZero; j++) {\n                    isWithZeroRoots.push(0);\n                }\n                zerosInserted = true;\n            }\n            isWithZeroRoots.push(is[i]);\n        }\n        return isWithZeroRoots;\n    }\n    return is;\n}\n\n//# sourceMappingURL=all-roots.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/naive/all-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/naive/brent-poly.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/naive/brent-poly.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   brentPoly: () => (/* binding */ brentPoly)\n/* harmony export */ });\n/* harmony import */ var _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../evaluate/double/horner.js */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\nconst Horner = _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_0__.Horner;\nconst eps = Number.EPSILON;\nconst u = eps / 2;\nconst abs = Math.abs;\nconst max = Math.max;\n/**\n * Returns a refined root given a root bracketed in the interval (a,b) of the\n * given polynomial using Brent's Method.\n *\n * * near exact implementation of the original Brent Dekker Method (also known\n * as Brent's Method), except that it is specialzed to polynomial evaluation\n *\n * * the algorithm stops once the interval width becomes equal or less than\n * `2 * Number.EPSILON/2 * max(1,abs(a),abs(b))` where `a` and `b` are the current\n * lower and upper interval limits\n *\n * * Brent's Method is an excellent root-refinement choice since:\n *  * guaranteed converge (unlike the Newton and other so-called single-point\n * methods),\n *  * converges in a reasonable number of iterations even for highly contrived\n * functions (unlike Dekker's Method) and\n *  * nearly always converges fast, i.e. super-linearly (unlike the Secant and\n * Regula-Falsi methods).\n * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)\n * works but is not precisely Brent's method and runs about 2x or more slower\n * due to it not implementing the critically important 'micro-step' (Aug 2020).\n *\n * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n * @param lb the lower limit of the search interval.\n * @param ub the upper limit of the search interval.\n * @param fa (may be left out - will be calculated automatically) the result of\n * evaluating the input polynomial at `a`\n * @param fb (may be left out - will be calculated automatically) the result of\n * evaluating the input polynomial at `b`\n *\n * @example\n * ```typescript\n * const p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * const a = 2.2;\n * const b = 3.8;\n * brent(p,a,b); //=> 3.000000000000003\n * b = 3.1;\n * brent(p,a,b); //=> 3.000000000000001\n * ```\n *\n * @doc\n */\nfunction brentPoly(p, lb, ub, fa = Horner(p, lb), fb = Horner(p, ub)) {\n    // Precondition: fa, fb !== 0\n    //---- Make local copies of a and b.\n    let a = lb;\n    let b = ub;\n    let c = a;\n    let fc = fa;\n    let e = b - a;\n    let d = e;\n    while (true) {\n        if (abs(fc) < abs(fb)) {\n            a = b;\n            b = c;\n            c = a;\n            fa = fb;\n            fb = fc;\n            fc = fa;\n        }\n        const δ = 2 * u * max(1, abs(a), abs(b));\n        const m = 0.5 * (c - b);\n        //if (abs(m) <= δ || fb === 0) {\n        if (abs(m) <= δ) {\n            // uncomment below if range to be returned\n            //return b < c ? [b,c] : [c,b];\n            // uncomment below if leftmost guess to be returned\n            //return b < c ? b : c;\n            // uncomment below if rightmost guess to be returned\n            //return b < c ? b : c;\n            // uncomment below if any guess to be returned\n            return b;\n        }\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\n            e = m;\n            d = e;\n        }\n        else {\n            let s = fb / fa;\n            let p;\n            let q;\n            if (a === c) {\n                p = 2 * m * s;\n                q = 1 - s;\n            }\n            else {\n                q = fa / fc;\n                const r = fb / fc;\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                q = (q - 1) * (r - 1) * (s - 1);\n            }\n            if (0 < p) {\n                q = -q;\n            }\n            else {\n                p = -p;\n            }\n            s = e;\n            e = d;\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\n                d = p / q;\n            }\n            else {\n                e = m;\n                d = e;\n            }\n        }\n        a = b;\n        fa = fb;\n        if (δ < abs(d)) {\n            b = b + d;\n        }\n        else if (0 < m) {\n            b = b + δ;\n        }\n        else {\n            //b = b - eps;\n            b = b - δ;\n        }\n        fb = Horner(p, b);\n        // inlined above line:\n        //fb = p[0]; for (let i=1; i<p.length; i++) { fb = fb*b + p[i]; }\n        if (fb === 0) {\n            return b;\n        }\n        if (fb * fc > 0) {\n            c = a;\n            fc = fa;\n            e = b - a;\n            d = e;\n        }\n    }\n}\n\n//# sourceMappingURL=brent-poly.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/naive/brent-poly.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/naive/brent.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/naive/brent.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   brent: () => (/* binding */ brent)\n/* harmony export */ });\nconst eps = Number.EPSILON;\nconst abs = Math.abs;\nconst max = Math.max;\n/**\n * Returns a refined root given a root bracketed in the interval (a,b) of the\n * given function using Brent's Method. Any function can be supplied (it\n * does not even have to be continuous) as long as the root is bracketed.\n *\n * * near exact implementation of the original Brent Dekker Method (also known\n * as Brent's Method)\n *\n * * Brent's Method is an excellent root-refinement choice since:\n *   * guaranteed converge (unlike the Newton and other so-called single-point\n * methods),\n *   * converges in a reasonable number of iterations even for highly contrived\n * functions (unlike Dekker's Method) and\n *   * nearly always converges fast, i.e. super-linearly (unlike the Secant and\n * Regula-Falsi methods).\n * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)\n * works but is not precisely Brent's method and runs about 2x or more slower\n * due to it not implementing the critically important 'micro-step' (Aug 2020).\n *\n * * the algorithm stops once the interval width becomes equal or less than\n * `2 * Number.EPSILON * max(1,abs(a),abs(b))` where `a` and `b` are the current\n * lower and upper interval limits\n *\n * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)\n *\n * @param f the function for which the root is sought.\n * @param lb the lower limit of the search interval.\n * @param ub the upper limit of the search interval.\n *\n * @example\n * ```typescript\n * let p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = t => Horner(p,t);\n * brent(f,2.2,3.8); //=> 3.000000000000003\n * brent(f,2.2,3.1); //=> 3.000000000000001\n * ```\n *\n * @doc\n */\nfunction brent(f, lb, ub) {\n    // Precondition: fa, fb !== 0\n    //---- Make local copies of a and b.\n    let a = lb;\n    let b = ub;\n    let fa = f(a);\n    let fb = f(b);\n    let c = a;\n    let fc = fa;\n    let e = b - a;\n    let d = e;\n    while (true) {\n        if (abs(fc) < abs(fb)) {\n            a = b;\n            b = c;\n            c = a;\n            fa = fb;\n            fb = fc;\n            fc = fa;\n        }\n        const δ = 2 * eps * max(1, abs(a), abs(b));\n        const m = 0.5 * (c - b);\n        //if (abs(m) <= δ || fb === 0) {\n        if (abs(m) <= δ) {\n            // uncomment below if range to be returned\n            //return b < c ? [b,c] : [c,b];\n            // uncomment below if leftmost guess to be returned\n            //return b < c ? b : c;\n            // uncomment below if rightmost guess to be returned\n            //return b < c ? b : c;\n            // uncomment below if any guess to be returned\n            return b;\n        }\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\n            e = m;\n            d = e;\n        }\n        else {\n            let s = fb / fa;\n            let p;\n            let q;\n            if (a === c) {\n                p = 2 * m * s;\n                q = 1 - s;\n            }\n            else {\n                q = fa / fc;\n                const r = fb / fc;\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                q = (q - 1) * (r - 1) * (s - 1);\n            }\n            if (0 < p) {\n                q = -q;\n            }\n            else {\n                p = -p;\n            }\n            s = e;\n            e = d;\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\n                d = p / q;\n            }\n            else {\n                e = m;\n                d = e;\n            }\n        }\n        a = b;\n        fa = fb;\n        if (δ < abs(d)) {\n            b = b + d;\n        }\n        else if (0 < m) {\n            b = b + δ;\n        }\n        else {\n            //b = b - eps;\n            b = b - δ;\n        }\n        fb = f(b);\n        // inlined above line:\n        //fb = p[0]; for (let i=1; i<p.length; i++) { fb = fb*b + p[i]; }\n        if (fb === 0) {\n            return b;\n        }\n        if (fb * fc > 0) {\n            c = a;\n            fc = fa;\n            e = b - a;\n            d = e;\n        }\n    }\n}\n\n//# sourceMappingURL=brent.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/naive/brent.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/naive/e-deflate.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/naive/e-deflate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eDeflate: () => (/* binding */ eDeflate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst emd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultDouble2;\nconst eae = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\n/**\n * Deflates the given polynomial exactly by removing a factor (x - r).\n *\n * @param p a polynomial with coefficients given densely as an array of\n * floating point expansions from highest to lowest power,\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\n * @param t an evaluation point of the polynomial (typically a root).\n *\n * @doc\n */\nfunction eDeflate(p, t) {\n    const d = p.length - 1;\n    const bs = [p[0]];\n    for (let i = 1; i < d; i++) {\n        bs.push(\n        // p[i] + root*bs[i-1]\n        eae(p[i], emd(t, bs[i - 1])));\n    }\n    return bs;\n}\n\n//# sourceMappingURL=e-deflate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/naive/e-deflate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   positiveToNegativeBound: () => (/* binding */ positiveToNegativeBound)\n/* harmony export */ });\n/* harmony import */ var _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../change-variables/double/reflect-about-y-axis.js */ \"./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst reflectAboutYAxis = _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_0__.reflectAboutYAxis;\n/**\n * Returns a function that returns a negative root bound given a function that\n * returns a positive root bound.\n *\n * @param positiveBoundFunction\n *\n * @internal\n */\nfunction positiveToNegativeBound(positiveBoundFunction) {\n    return (p) => {\n        return -positiveBoundFunction(reflectAboutYAxis(p));\n    };\n}\n\n//# sourceMappingURL=positive-to-negative-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   negativeRootLowerBound_LMQ: () => (/* binding */ negativeRootLowerBound_LMQ),\n/* harmony export */   negativeRootUpperBound_LMQ: () => (/* binding */ negativeRootUpperBound_LMQ),\n/* harmony export */   positiveRootLowerBound_LMQ: () => (/* binding */ positiveRootLowerBound_LMQ),\n/* harmony export */   positiveRootUpperBound_LMQ: () => (/* binding */ positiveRootUpperBound_LMQ)\n/* harmony export */ });\n/* harmony import */ var _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/double/negate.js */ \"./node_modules/flo-poly/node/basic/double/negate.js\");\n/* harmony import */ var _upper_to_lower_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./upper-to-lower-bound.js */ \"./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js\");\n/* harmony import */ var _positive_to_negative_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./positive-to-negative-bound.js */ \"./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js\");\n\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst negate = _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_0__.negate;\nconst upperToLowerBound = _upper_to_lower_bound_js__WEBPACK_IMPORTED_MODULE_1__.upperToLowerBound;\nconst positiveToNegativeBound = _positive_to_negative_bound_js__WEBPACK_IMPORTED_MODULE_2__.positiveToNegativeBound;\n/**\n * Returns an upper bound for the positive real roots of the given polynomial.\n *\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @example\n * ```typescript\n * positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\n * positiveRootUpperBound_LMQ([2,3]);           //=> 0\n * positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\n * ```\n *\n * @doc\n */\nfunction positiveRootUpperBound_LMQ(p) {\n    const deg = p.length - 1;\n    if (deg < 1) {\n        return 0;\n    }\n    if (p[0] < 0) {\n        p = negate(p);\n    }\n    const timesUsed = [];\n    for (let i = 0; i < deg; i++) {\n        timesUsed.push(1);\n    }\n    let ub = 0;\n    for (let m = 0; m <= deg; m++) {\n        if (p[m] >= 0) {\n            continue;\n        }\n        let tempub = Number.POSITIVE_INFINITY;\n        let any = false;\n        for (let k = 0; k < m; k++) {\n            if (p[k] <= 0) {\n                continue;\n            }\n            const temp = (-p[m] / (p[k] / 2 ** timesUsed[k])) ** (1 / (m - k));\n            timesUsed[k]++;\n            if (tempub > temp) {\n                tempub = temp;\n            }\n            any = true;\n        }\n        if (any && ub < tempub)\n            ub = tempub;\n    }\n    return ub;\n}\n/**\n * Returns a positive lower bound of the real roots of the given polynomial\n *\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @doc\n */\nconst positiveRootLowerBound_LMQ = upperToLowerBound(positiveRootUpperBound_LMQ);\n/**\n * Returns a negative lower (further from zero) bound of the real roots of the\n * given polynomial.\n *\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @doc\n */\nconst negativeRootLowerBound_LMQ = positiveToNegativeBound(positiveRootUpperBound_LMQ);\n/**\n * Returns a negative upper (closer to zero) bound of the real roots of the\n * given polynomial.\n *\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n *\n * @param p a polynomial with coefficients given densely as an array of double\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\n * represents the polynomial `5x^2 - 3x`\n *\n * @doc\n */\nconst negativeRootUpperBound_LMQ = upperToLowerBound(negativeRootLowerBound_LMQ);\n\n//# sourceMappingURL=root-bounds-lmq.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   upperToLowerBound: () => (/* binding */ upperToLowerBound)\n/* harmony export */ });\n/* harmony import */ var _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/double/invert.js */ \"./node_modules/flo-poly/node/basic/double/invert.js\");\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst invert = _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_0__.invert;\n/**\n * Returns a function that returns a positive lower root bound given a function\n * that returns a positive upper root bound.\n *\n * @param positiveUpperBoundFunction\n *\n * @internal\n */\nfunction upperToLowerBound(positiveUpperBoundFunction) {\n    return (p) => {\n        return 1 / positiveUpperBoundFunction(invert(p));\n    };\n}\n\n//# sourceMappingURL=upper-to-lower-bound.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scaleFloatssToBigintss: () => (/* binding */ scaleFloatssToBigintss)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-representation/exponent.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-representation/bit-length.js\");\n\n\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.bitLength;\nconst b0 = 0n; // so tests are not tripped up - awaiting better support\n/**\n * Returns the result of scaling the given array of array of floats by the\n * *same* power of two such that all floats become bigints.\n *\n * * can be used to scale polynomials (with coefficients given as Shewchuk\n * expansions)\n *\n * @param ass an array of an array of double precision floating point numbers\n *\n * @doc\n */\nfunction scaleFloatssToBigintss(ass) {\n    let e = -1024;\n    for (let i = 0; i < ass.length; i++) {\n        const c = ass[i];\n        for (let j = 0; j < c.length; j++) {\n            const a = c[j];\n            if (a === 0) {\n                continue;\n            }\n            const scaleFactor = -exponent(a) + bitLength(a) - 1;\n            if (scaleFactor > e) {\n                e = scaleFactor;\n            }\n        }\n    }\n    // check for the trivial case\n    if (e === 0) {\n        return ass.map(as => as.map(a => BigInt(a)));\n    }\n    if (e > 0) {\n        return ass.map(as => as.map(a => {\n            if (a === 0) {\n                return b0;\n            }\n            const scalePower = -exponent(a) + bitLength(a) - 1;\n            // we first scale `a` to an integer without overflow and then\n            // convert it to a bigint before multiplying\n            return BigInt(a * 2 ** scalePower) * 2n ** BigInt(e - scalePower);\n        }));\n    }\n    // overflow / underflow cannot occur\n    return ass.map(as => as.map(a => BigInt(a * 2 ** e)));\n}\n\n//# sourceMappingURL=scale-floatss-to-bigintss.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reverseRotate: () => (/* binding */ reverseRotate)\n/* harmony export */ });\n/**\r\n * Returns a rotated (clockwise) version of the given 2-vector given the\r\n * sine and cosine of the angle.\r\n * @param p a 2d vector\r\n * @param sinθ\r\n * @param cosθ\r\n */\r\nfunction reverseRotate(sinθ, cosθ, p) {\r\n    return [\r\n        +p[0] * cosθ + p[1] * sinθ,\r\n        -p[0] * sinθ + p[1] * cosθ\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=reverse-rotate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reverse: () => (/* binding */ reverse)\n/* harmony export */ });\n/**\r\n * Returns the given 2-vector reversed (i.e. scaled by -1).\r\n * @param p a vector\r\n */\r\nfunction reverse(p) {\r\n    return [-p[0], -p[1]];\r\n}\r\n\r\n//# sourceMappingURL=reverse.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rotate90Degrees: () => (/* binding */ rotate90Degrees)\n/* harmony export */ });\n/**\r\n * Returns a 90 degrees rotated version of the given 2-vector.\r\n * @param p a 2d vector\r\n */\r\nfunction rotate90Degrees(p) {\r\n    return [-p[1], p[0]];\r\n}\r\n\r\n//# sourceMappingURL=rotate-90-degrees.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rotateNeg90Degrees: () => (/* binding */ rotateNeg90Degrees)\n/* harmony export */ });\n/**\r\n* Returns a negative 90 degrees rotated version of the given 2-vector.\r\n* @param p a 2d vector\r\n*/\r\nfunction rotateNeg90Degrees(p) {\r\n    return [p[1], -p[0]];\r\n}\r\n\r\n//# sourceMappingURL=rotate-neg-90-degrees.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rotate: () => (/* binding */ rotate)\n/* harmony export */ });\nfunction rotate(sinθ, cosθ, p) {\r\n    function rotateByθ(p) {\r\n        return [\r\n            p[0] * cosθ - p[1] * sinθ,\r\n            p[0] * sinθ + p[1] * cosθ\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? rotateByθ : rotateByθ(p);\r\n}\r\n\r\n//# sourceMappingURL=rotate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scale: () => (/* binding */ scale)\n/* harmony export */ });\n/**\r\n * Returns a scaled version of the given 2-vector.\r\n * @param p a vector\r\n * @param c a scale factor\r\n */\r\nfunction scale(p, c) {\r\n    return [c * p[0], c * p[1]];\r\n}\r\n\r\n//# sourceMappingURL=scale.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transformLinear: () => (/* binding */ transformLinear)\n/* harmony export */ });\nfunction transformLinear([[a, b], [c, d]], p) {\r\n    function transform([x, y]) {\r\n        return [\r\n            a * x + b * y,\r\n            c * x + d * y\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? transform : transform(p);\r\n}\r\n\r\n//# sourceMappingURL=transform-linear.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transformAffine: () => (/* binding */ transformAffine)\n/* harmony export */ });\nfunction transformAffine([[a, b], [c, d]], [r, s], p) {\r\n    function transform([x, y]) {\r\n        return [\r\n            a * x + b * y + r,\r\n            c * x + d * y + s\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? transform : transform(p);\r\n}\r\n\r\n//# sourceMappingURL=transform-affine.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   translate: () => (/* binding */ translate)\n/* harmony export */ });\n// From: https://en.wikipedia.org/wiki/Affine_transformation\r\n// \"If X is the point set of an affine space, then every affine transformation \r\n// on X can be represented as the composition of a linear transformation on X \r\n// and a translation of X\"\r\nfunction translate(a, b) {\r\n    function f(b) {\r\n        return [a[0] + b[0], a[1] + b[1]];\r\n    }\r\n    // Curry the function\r\n    return b === undefined ? f : f(b);\r\n}\r\n\r\n//# sourceMappingURL=translate.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/cross.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-vector2d/node/cross.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cross: () => (/* binding */ cross)\n/* harmony export */ });\n/**\r\n * Returns the cross product signed magnitude between two 2-vectors.\r\n * @param a the first vector\r\n * @param b the second vector\r\n */\r\nfunction cross(a, b) {\r\n    return a[0] * b[1] - a[1] * b[0];\r\n}\r\n\r\n//# sourceMappingURL=cross.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/cross.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   distanceBetweenPointAndLine: () => (/* binding */ distanceBetweenPointAndLine)\n/* harmony export */ });\n/**\r\n * Returns the distance between the given point and line.\r\n * * see https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\r\n * @param p a point\r\n * @param l a line\r\n */\r\nfunction distanceBetweenPointAndLine(p, l) {\r\n    const [x0, y0] = p;\r\n    const [[x1, y1], [x2, y2]] = l;\r\n    const y = y2 - y1;\r\n    const x = x2 - x1;\r\n    const a = (y * x0 - x * y0 + x2 * y1 - y2 * x1);\r\n    const b = Math.sqrt(x * x + y * y);\r\n    return Math.abs(a / b);\r\n}\r\n\r\n//# sourceMappingURL=distance-between-point-and-line.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/distance-between.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/distance-between.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   distanceBetween: () => (/* binding */ distanceBetween)\n/* harmony export */ });\n/**\r\n * Returns the distance between two 2d points.\r\n * @param p a point\r\n * @param q another point\r\n */\r\nfunction distanceBetween(p, q) {\r\n    const x = q[0] - p[0];\r\n    const y = q[1] - p[1];\r\n    return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n//# sourceMappingURL=distance-between.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/distance-between.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/len.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/len.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   len: () => (/* binding */ len)\n/* harmony export */ });\n/**\r\n * Returns the length of the given 2-vector.\r\n * @param p a 2d vector\r\n */\r\nfunction len(p) {\r\n    return Math.sqrt(p[0] * p[0] + p[1] * p[1]);\r\n}\r\n\r\n//# sourceMappingURL=len.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/len.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/length-squared.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/length-squared.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lengthSquared: () => (/* binding */ lengthSquared)\n/* harmony export */ });\n/**\r\n * Returns the squared length of the given 2-vector.\r\n * @param p a vector\r\n */\r\nfunction lengthSquared(v) {\r\n    return v[0] * v[0] + v[1] * v[1];\r\n}\r\n\r\n//# sourceMappingURL=length-squared.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/length-squared.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattanDistanceBetween: () => (/* binding */ manhattanDistanceBetween)\n/* harmony export */ });\n/**\r\n * Returns the Manhattan distance between two 2d points.\r\n * @param p a point.\r\n * @param q another point.\r\n */\r\nfunction manhattanDistanceBetween(p, q) {\r\n    return Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1]);\r\n}\r\n\r\n//# sourceMappingURL=manhattan-distance-between.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattanLength: () => (/* binding */ manhattanLength)\n/* harmony export */ });\n/**\r\n * Returns the Manhattan length of the given 2-vector.\r\n * @param p a vector\r\n */\r\nfunction manhattanLength(p) {\r\n    return Math.abs(p[0]) + Math.abs(p[1]);\r\n}\r\n\r\n//# sourceMappingURL=manhattan-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squaredDistanceBetweenPointAndLineSegment: () => (/* binding */ squaredDistanceBetweenPointAndLineSegment)\n/* harmony export */ });\n/* harmony import */ var _squared_distance_between_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squared-distance-between.js */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n\r\n/**\r\n * Returns the squared distance between the given point and line segment.\r\n * @param p a point\r\n * @param l a line\r\n */\r\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\r\n    const sqDst = _squared_distance_between_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween;\r\n    const v = l[0];\r\n    const w = l[1];\r\n    const l2 = sqDst(v, w);\r\n    if (l2 == 0) {\r\n        return sqDst(p, v);\r\n    }\r\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\r\n    t = Math.max(0, Math.min(1, t));\r\n    const d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\r\n    return d2;\r\n}\r\n\r\n//# sourceMappingURL=squared-distance-between-point-and-line-segment.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squaredDistanceBetween: () => (/* binding */ squaredDistanceBetween)\n/* harmony export */ });\n/**\r\n * Returns the squared distance between two 2d points.\r\n * @param p a point\r\n * @param q another point\r\n */\r\nfunction squaredDistanceBetween(p, q) {\r\n    const x = q[0] - p[0];\r\n    const y = q[1] - p[1];\r\n    return x * x + y * y;\r\n}\r\n\r\n//# sourceMappingURL=squared-distance-between.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/to-length.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/to-length.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toLength: () => (/* binding */ toLength)\n/* harmony export */ });\n/**\r\n * Returns the given 2-vector scaled to the given length.\r\n * @param p a vector\r\n * @param length the length to scale to\r\n */\r\nfunction toLength(p, length) {\r\n    const c = length / Math.sqrt(p[0] * p[0] + p[1] * p[1]);\r\n    return [c * p[0], c * p[1]];\r\n}\r\n\r\n//# sourceMappingURL=to-length.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/to-length.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toUnitVector: () => (/* binding */ toUnitVector)\n/* harmony export */ });\n/**\r\n * Returns the given 2-vector scaled to a length of one.\r\n * @param p a vector\r\n */\r\nfunction toUnitVector(p) {\r\n    const scaleFactor = 1 / (Math.sqrt(p[0] * p[0] + p[1] * p[1]));\r\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\r\n}\r\n\r\n//# sourceMappingURL=to-unit-vector.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/dot.js":
/*!***********************************************!*\
  !*** ./node_modules/flo-vector2d/node/dot.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dot: () => (/* binding */ dot)\n/* harmony export */ });\n/**\r\n * Returns the dot (inner) product between two 2-vectors.\r\n * @param a the first vector\r\n * @param b the second vector\r\n */\r\nfunction dot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/dot.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/index.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-vector2d/node/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ccw: () => (/* binding */ ccw),\n/* harmony export */   centroid: () => (/* reexport safe */ _triangle_centers_centroid_js__WEBPACK_IMPORTED_MODULE_22__.centroid),\n/* harmony export */   circumCenter: () => (/* reexport safe */ _triangle_centers_circum_center_js__WEBPACK_IMPORTED_MODULE_20__.circumCenter),\n/* harmony export */   cross: () => (/* reexport safe */ _cross_js__WEBPACK_IMPORTED_MODULE_3__.cross),\n/* harmony export */   det3: () => (/* reexport safe */ _matrix_det_js__WEBPACK_IMPORTED_MODULE_23__.det3),\n/* harmony export */   distanceBetween: () => (/* reexport safe */ _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_13__.distanceBetween),\n/* harmony export */   distanceBetweenPointAndLine: () => (/* reexport safe */ _distance_and_length_distance_between_point_and_line_js__WEBPACK_IMPORTED_MODULE_18__.distanceBetweenPointAndLine),\n/* harmony export */   doesSegSegIntersect: () => (/* reexport safe */ _lines_and_segments_does_seg_seg_intersect_js__WEBPACK_IMPORTED_MODULE_8__.doesSegSegIntersect),\n/* harmony export */   dot: () => (/* reexport safe */ _dot_js__WEBPACK_IMPORTED_MODULE_2__.dot),\n/* harmony export */   equal: () => (/* binding */ equal),\n/* harmony export */   fromTo: () => (/* binding */ fromTo),\n/* harmony export */   getClosestTo: () => (/* binding */ getClosestTo),\n/* harmony export */   getObjClosestTo: () => (/* binding */ getObjClosestTo),\n/* harmony export */   inCenter: () => (/* reexport safe */ _triangle_centers_in_center_js__WEBPACK_IMPORTED_MODULE_21__.inCenter),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   len: () => (/* reexport safe */ _distance_and_length_len_js__WEBPACK_IMPORTED_MODULE_14__.len),\n/* harmony export */   lengthSquared: () => (/* reexport safe */ _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_15__.lengthSquared),\n/* harmony export */   lineLineIntersection: () => (/* reexport safe */ _lines_and_segments_line_line_intersection_js__WEBPACK_IMPORTED_MODULE_6__.lineLineIntersection),\n/* harmony export */   manhattanDistanceBetween: () => (/* reexport safe */ _distance_and_length_manhattan_distance_between_js__WEBPACK_IMPORTED_MODULE_16__.manhattanDistanceBetween),\n/* harmony export */   manhattanLength: () => (/* reexport safe */ _distance_and_length_manhattan_length_js__WEBPACK_IMPORTED_MODULE_17__.manhattanLength),\n/* harmony export */   mean: () => (/* binding */ mean),\n/* harmony export */   reverse: () => (/* reexport safe */ _affine_transformations_linear_reverse_js__WEBPACK_IMPORTED_MODULE_10__.reverse),\n/* harmony export */   reverseRotate: () => (/* reexport safe */ _affine_transformations_linear_reverse_rotate_js__WEBPACK_IMPORTED_MODULE_24__.reverseRotate),\n/* harmony export */   rotate: () => (/* reexport safe */ _affine_transformations_linear_rotate_js__WEBPACK_IMPORTED_MODULE_5__.rotate),\n/* harmony export */   rotate90Degrees: () => (/* reexport safe */ _affine_transformations_linear_rotate_90_degrees_js__WEBPACK_IMPORTED_MODULE_25__.rotate90Degrees),\n/* harmony export */   rotateNeg90Degrees: () => (/* reexport safe */ _affine_transformations_linear_rotate_neg_90_degrees_js__WEBPACK_IMPORTED_MODULE_26__.rotateNeg90Degrees),\n/* harmony export */   scale: () => (/* reexport safe */ _affine_transformations_linear_scale_js__WEBPACK_IMPORTED_MODULE_9__.scale),\n/* harmony export */   segSegIntersection: () => (/* reexport safe */ _lines_and_segments_seg_seg_intersection_js__WEBPACK_IMPORTED_MODULE_7__.segSegIntersection),\n/* harmony export */   squaredDistanceBetween: () => (/* reexport safe */ _distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween),\n/* harmony export */   squaredDistanceBetweenPointAndLineSegment: () => (/* reexport safe */ _distance_and_length_squared_distance_between_point_and_line_segment_js__WEBPACK_IMPORTED_MODULE_19__.squaredDistanceBetweenPointAndLineSegment),\n/* harmony export */   toLength: () => (/* reexport safe */ _distance_and_length_to_length_js__WEBPACK_IMPORTED_MODULE_12__.toLength),\n/* harmony export */   toUnitVector: () => (/* reexport safe */ _distance_and_length_to_unit_vector_js__WEBPACK_IMPORTED_MODULE_11__.toUnitVector),\n/* harmony export */   transformAffine: () => (/* reexport safe */ _affine_transformations_transform_affine_js__WEBPACK_IMPORTED_MODULE_28__.transformAffine),\n/* harmony export */   transformLinear: () => (/* reexport safe */ _affine_transformations_linear_transform_linear_js__WEBPACK_IMPORTED_MODULE_27__.transformLinear),\n/* harmony export */   translate: () => (/* reexport safe */ _affine_transformations_translate_translate_js__WEBPACK_IMPORTED_MODULE_4__.translate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js\");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dot.js */ \"./node_modules/flo-vector2d/node/dot.js\");\n/* harmony import */ var _cross_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross.js */ \"./node_modules/flo-vector2d/node/cross.js\");\n/* harmony import */ var _lines_and_segments_seg_seg_intersection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lines-and-segments/seg-seg-intersection.js */ \"./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js\");\n/* harmony import */ var _lines_and_segments_does_seg_seg_intersect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lines-and-segments/does-seg-seg-intersect.js */ \"./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js\");\n/* harmony import */ var _lines_and_segments_line_line_intersection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lines-and-segments/line-line-intersection.js */ \"./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js\");\n/* harmony import */ var _affine_transformations_translate_translate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./affine-transformations/translate/translate.js */ \"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js\");\n/* harmony import */ var _affine_transformations_linear_rotate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./affine-transformations/linear/rotate.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js\");\n/* harmony import */ var _affine_transformations_linear_scale_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./affine-transformations/linear/scale.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js\");\n/* harmony import */ var _affine_transformations_linear_reverse_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./affine-transformations/linear/reverse.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js\");\n/* harmony import */ var _affine_transformations_linear_reverse_rotate_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./affine-transformations/linear/reverse-rotate.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js\");\n/* harmony import */ var _affine_transformations_linear_rotate_90_degrees_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./affine-transformations/linear/rotate-90-degrees.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js\");\n/* harmony import */ var _affine_transformations_linear_rotate_neg_90_degrees_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./affine-transformations/linear/rotate-neg-90-degrees.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js\");\n/* harmony import */ var _affine_transformations_linear_transform_linear_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./affine-transformations/linear/transform-linear.js */ \"./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js\");\n/* harmony import */ var _affine_transformations_transform_affine_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./affine-transformations/transform-affine.js */ \"./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js\");\n/* harmony import */ var _distance_and_length_to_unit_vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./distance-and-length/to-unit-vector.js */ \"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js\");\n/* harmony import */ var _distance_and_length_to_length_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./distance-and-length/to-length.js */ \"./node_modules/flo-vector2d/node/distance-and-length/to-length.js\");\n/* harmony import */ var _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./distance-and-length/distance-between.js */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n/* harmony import */ var _distance_and_length_len_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./distance-and-length/len.js */ \"./node_modules/flo-vector2d/node/distance-and-length/len.js\");\n/* harmony import */ var _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./distance-and-length/length-squared.js */ \"./node_modules/flo-vector2d/node/distance-and-length/length-squared.js\");\n/* harmony import */ var _distance_and_length_manhattan_distance_between_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./distance-and-length/manhattan-distance-between.js */ \"./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js\");\n/* harmony import */ var _distance_and_length_manhattan_length_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./distance-and-length/manhattan-length.js */ \"./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js\");\n/* harmony import */ var _distance_and_length_distance_between_point_and_line_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./distance-and-length/distance-between-point-and-line.js */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js\");\n/* harmony import */ var _distance_and_length_squared_distance_between_point_and_line_segment_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./distance-and-length/squared-distance-between-point-and-line-segment.js */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js\");\n/* harmony import */ var _distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance-and-length/squared-distance-between.js */ \"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js\");\n/* harmony import */ var _triangle_centers_circum_center_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./triangle-centers/circum-center.js */ \"./node_modules/flo-vector2d/node/triangle-centers/circum-center.js\");\n/* harmony import */ var _triangle_centers_in_center_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./triangle-centers/in-center.js */ \"./node_modules/flo-vector2d/node/triangle-centers/in-center.js\");\n/* harmony import */ var _triangle_centers_centroid_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./triangle-centers/centroid.js */ \"./node_modules/flo-vector2d/node/triangle-centers/centroid.js\");\n/* harmony import */ var _matrix_det_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./matrix/det.js */ \"./node_modules/flo-vector2d/node/matrix/det.js\");\n//==================================\r\n// 2d vector pure functions library\r\n//==================================\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\r\n * ccw < 0, and colinear if ccw === 0 because ccw is a determinant that gives\r\n * twice the signed area of the triangle formed by the points a, b and c.\r\n * * **certified**\r\n * @param A The first point\r\n * @param B The second point\r\n * @param C The third point\r\n */\r\nconst ccw = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d;\r\n/**\r\n * Returns the second 2-vector minus the first.\r\n * @param p the first vector\r\n * @param q the second vector\r\n  */\r\nfunction fromTo(p, q) {\r\n    return [q[0] - p[0], q[1] - p[1]];\r\n}\r\n/**\r\n * Performs linear interpolation between two 2d points and returns the\r\n * resulting point.\r\n * @param p the first point.\r\n * @param q the second point.\r\n * @param t the interpolation fraction (often in [0,1]).\r\n */\r\nfunction interpolate(p, q, t) {\r\n    return [\r\n        p[0] + (q[0] - p[0]) * t,\r\n        p[1] + (q[1] - p[1]) * t\r\n    ];\r\n}\r\n/**\r\n * Returns the mean of two 2d points.\r\n * @param ps the two points\r\n */\r\nfunction mean(ps) {\r\n    const p = ps[0];\r\n    const q = ps[1];\r\n    return [(p[0] + q[0]) / 2, (p[1] + q[1]) / 2];\r\n}\r\n/**\r\n* Returns true if two 2-vectors are identical (by value), false otherwise.\r\n* @param a a 2d vector\r\n* @param b another 2d vector\r\n*/\r\nfunction equal(a, b) {\r\n    return (a[0] === b[0] && a[1] === b[1]);\r\n}\r\n/**\r\n * Returns the closest point to the array of 2d points or if the array is empty\r\n * returns undefined.\r\n * @param p\r\n * @param ps\r\n */\r\nfunction getClosestTo(p, ps) {\r\n    let closestPoint = undefined;\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        const q = ps[i];\r\n        const d = (0,_distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, q);\r\n        if (d < closestDistance) {\r\n            closestPoint = q;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestPoint;\r\n}\r\n/**\r\n * Returns the closest point to the array of 2d points by providing a distance\r\n * function. If the given array is empty, returns undefined.\r\n * @param p\r\n * @param ps\r\n * @param f a function that takes the object and returns a point in order to\r\n * apply the Euclidian distance.\r\n */\r\nfunction getObjClosestTo(p, ps, f) {\r\n    let closestObj = undefined; // Closest Point\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        const o = ps[i];\r\n        const d = (0,_distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, f(o));\r\n        if (d < closestDistance) {\r\n            closestObj = o;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestObj;\r\n}\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doesSegSegIntersect: () => (/* binding */ doesSegSegIntersect)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js\");\n\r\n/**\r\n * Returns true if the two given 2d line segments intersect, false otherwise.\r\n * * **robust** uses exact adaptive floating point arithmetic.\r\n * @param a a line segment\r\n * @param b another line segment\r\n */\r\nfunction doesSegSegIntersect(a, b) {\r\n    if (((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(a[0], a[1], b[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(a[0], a[1], b[1])) > 0) {\r\n        return false;\r\n    }\r\n    if (((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(b[0], b[1], a[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(b[0], b[1], a[1])) > 0) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=does-seg-seg-intersect.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lineLineIntersection: () => (/* binding */ lineLineIntersection)\n/* harmony export */ });\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or undefined if they don't intersect or are the same line.\r\n * see Wikipedia https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\r\n * @param l1 A line\r\n * @param l2 Another line\r\n */\r\nfunction lineLineIntersection(l1, l2) {\r\n    const [[x1, y1], [x2, y2]] = l1;\r\n    const [[x3, y3], [x4, y4]] = l2;\r\n    const x1_ = x2 - x1;\r\n    const y1_ = y2 - y1;\r\n    const x2_ = x4 - x3;\r\n    const y2_ = y4 - y3;\r\n    const denom = x2_ * y1_ - y2_ * x1_;\r\n    if (denom === 0) {\r\n        // parallel\r\n        return undefined;\r\n    }\r\n    const b = ((y3 - y1) * x1_ - (x3 - x1) * y1_) / denom;\r\n    return [\r\n        x3 + b * x2_,\r\n        y3 + b * y2_\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=line-line-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   segSegIntersection: () => (/* binding */ segSegIntersection)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/expansion-product.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-diff.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-sign.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-compare.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-abs.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/double-expansion/e-estimate.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/basic/two-sum.js\");\n\r\n\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\r\n/**\r\n* Returns the point where two line segments intersect or undefined if they\r\n* don't intersect or if they intersect at infinitely many points.\r\n* * see Geometric primitves http://algs4.cs.princeton.edu/91primitives\r\n* * **certified**\r\n* @param ab The first line\r\n* @param cd The second line\r\n*/\r\nfunction segSegIntersection(ab, cd) {\r\n    const [a, b] = ab;\r\n    const [c, d] = cd;\r\n    const [a0, a1] = a;\r\n    const [b0, b1] = b;\r\n    const [c0, c1] = c;\r\n    const [d0, d1] = d;\r\n    //const denom  = (b[0] - a[0])*(d[1] - c[1]) - (b[1] - a[1])*(d[0] - c[0]);\r\n    const denom = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)(epr(td(b0, a0), td(d1, c1)), epr(td(b1, a1), td(d0, c0)));\r\n    //const rNumer = (a[1] - c[1])*(d[0] - c[0]) - (a[0] - c[0])*(d[1] - c[1]);\r\n    const rNumer = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)(epr(td(a1, c1), td(d0, c0)), epr(td(a0, c0), td(d1, c1)));\r\n    //const sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]); \r\n    const sNumer = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff)(epr(td(a1, c1), td(b0, a0)), epr(td(a0, c0), td(b1, a1)));\r\n    if (denom[denom.length - 1] === 0) {\r\n        // parallel\r\n        if (rNumer[rNumer.length - 1] === 0) {\r\n            // collinear\r\n            // TODO Check if x-projections and y-projections intersect\r\n            // and return the line of intersection if they do.\r\n            return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n    //let r = rNumer / denom;\r\n    //let s = sNumer / denom;\r\n    // if (0 <= r && r <= 1 && 0 <= s && s <= 1)\r\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign)(rNumer) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign)(denom) >= 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eAbs)(denom), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eAbs)(rNumer)) >= 0 &&\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign)(sNumer) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign)(denom) >= 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_4__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eAbs)(denom), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eAbs)(sNumer)) >= 0) {\r\n        const r = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)(rNumer) / (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)(denom);\r\n        //return [a0 + r*(b0 - a0), a1 + r*(b1 - a1)];\r\n        return [\r\n            (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_7__.twoSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)(epr(td(b0, a0), rNumer)) / (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)(denom), a0)),\r\n            (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_7__.twoSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)(epr(td(b1, a1), rNumer)) / (0,big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate)(denom), a1))\r\n        ];\r\n    }\r\n    return undefined;\r\n}\r\n\r\n//# sourceMappingURL=seg-seg-intersection.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/matrix/det.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-vector2d/node/matrix/det.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   det3: () => (/* binding */ det3)\n/* harmony export */ });\n/**\r\n * Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\r\n * @param x a 2d vector\r\n * @param y another 2d vector\r\n * @param z another 2d vector\r\n */\r\nfunction det3(x, y, z) {\r\n    return (x[0] * (y[1] * z[2] - y[2] * z[1])) -\r\n        (x[1] * (y[0] * z[2] - y[2] * z[0])) +\r\n        (x[2] * (y[0] * z[1] - y[1] * z[0]));\r\n}\r\n\r\n//# sourceMappingURL=det.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/matrix/det.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/triangle-centers/centroid.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/triangle-centers/centroid.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   centroid: () => (/* binding */ centroid)\n/* harmony export */ });\n/**\r\n* Returns the centroid of the given polygon, e.g. triangle. The polygon\r\n* must be simple, i.e. not self-intersecting.\r\n* @param polygon_\r\n*/\r\nfunction centroid(polygon) {\r\n    const polygon_ = [];\r\n    if (polygon.length === 1) {\r\n        return polygon[0];\r\n    }\r\n    // remove duplicate points\r\n    let prevP = polygon[polygon.length - 1];\r\n    for (let i = 0; i < polygon.length; i++) {\r\n        const [_x, _y] = prevP;\r\n        const [x, y] = polygon[i];\r\n        prevP = [x, y];\r\n        if (x !== _x || y !== _y) {\r\n            polygon_.push([x, y]);\r\n        }\r\n    }\r\n    if (polygon_.length === 2) {\r\n        const p1 = polygon_[0];\r\n        const p2 = polygon_[1];\r\n        const x = p1[0] + p2[0];\r\n        const y = p1[1] + p2[1];\r\n        return [x / 2, y / 2];\r\n    }\r\n    if (polygon_.length === 3) {\r\n        const p1 = polygon_[0];\r\n        const p2 = polygon_[1];\r\n        const p3 = polygon_[2];\r\n        const x = p1[0] + p2[0] + p3[0];\r\n        const y = p1[1] + p2[1] + p3[1];\r\n        return [x / 3, y / 3];\r\n    }\r\n    // polygon.length assumed > 3 and assumed to be non-self-intersecting\r\n    // See wikipedia\r\n    // First calculate the area, A, of the polygon\r\n    let A = 0;\r\n    for (let i = 0; i < polygon_.length; i++) {\r\n        const p0 = polygon_[i];\r\n        const p1 = (i === polygon_.length - 1)\r\n            ? polygon_[0]\r\n            : polygon_[i + 1];\r\n        A = A + (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    A = A / 2;\r\n    const C = [0, 0];\r\n    for (let i = 0; i < polygon_.length; i++) {\r\n        const p0 = polygon_[i];\r\n        const p1 = (i === polygon_.length - 1)\r\n            ? polygon_[0]\r\n            : polygon_[i + 1];\r\n        C[0] = C[0] + (p0[0] + p1[0]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n        C[1] = C[1] + (p0[1] + p1[1]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    return [C[0] / (6 * A), C[1] / (6 * A)];\r\n}\r\n\r\n//# sourceMappingURL=centroid.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/triangle-centers/centroid.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/triangle-centers/circum-center.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/triangle-centers/circum-center.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circumCenter: () => (/* binding */ circumCenter)\n/* harmony export */ });\n/* harmony import */ var _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../distance-and-length/length-squared.js */ \"./node_modules/flo-vector2d/node/distance-and-length/length-squared.js\");\n/* harmony import */ var _matrix_det_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matrix/det.js */ \"./node_modules/flo-vector2d/node/matrix/det.js\");\n\r\n\r\n/**\r\n* Returns the circumcenter of the given 2d triangle.\r\n* @param triangle\r\n*/\r\nfunction circumCenter(triangle) {\r\n    // See wikipedia\r\n    const p1 = triangle[0];\r\n    const p2 = triangle[1];\r\n    const p3 = triangle[2];\r\n    const sqLen = _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_0__.lengthSquared;\r\n    const Sx = 0.5 * (0,_matrix_det_js__WEBPACK_IMPORTED_MODULE_1__.det3)([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\r\n    const Sy = 0.5 * (0,_matrix_det_js__WEBPACK_IMPORTED_MODULE_1__.det3)([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\r\n    const a = (0,_matrix_det_js__WEBPACK_IMPORTED_MODULE_1__.det3)([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\r\n    return [Sx / a, Sy / a];\r\n}\r\n\r\n//# sourceMappingURL=circum-center.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/triangle-centers/circum-center.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/triangle-centers/in-center.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/triangle-centers/in-center.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inCenter: () => (/* binding */ inCenter)\n/* harmony export */ });\n/* harmony import */ var _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../distance-and-length/distance-between.js */ \"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js\");\n\r\n/**\r\n * Returns the incenter of the given triangle.\r\n * * see Wikipedia - https://en.wikipedia.org/wiki/Incenter\r\n * @param triangle\r\n */\r\nfunction inCenter(triangle) {\r\n    const dst = _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_0__.distanceBetween;\r\n    const p = triangle[0];\r\n    const q = triangle[1];\r\n    const r = triangle[2];\r\n    const a = dst(q, r);\r\n    const b = dst(p, r);\r\n    const c = dst(p, q);\r\n    const lengthSum = a + b + c;\r\n    return [\r\n        (a * p[0] + b * q[0] + c * r[0]) / lengthSum,\r\n        (a * p[1] + b * q[1] + c * r[1]) / lengthSum\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=in-center.js.map\n\n//# sourceURL=webpack://thinning-ts/./node_modules/flo-vector2d/node/triangle-centers/in-center.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;