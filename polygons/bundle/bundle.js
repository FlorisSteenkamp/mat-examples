/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_mat_1 = __webpack_require__(/*! flo-mat */ \"./node_modules/flo-mat/node/index.js\");\r\nconst NS = 'http://www.w3.org/2000/svg'; // Svg namespace\r\n/**\r\n * Creates and returns an SVG DOM element.\r\n * @param id The dom id to assign to the SVG element, e.g. 1 -> 'svg-1'\r\n */\r\nfunction createSvg(id) {\r\n    let $e = document.createElementNS(NS, 'svg');\r\n    $e.setAttributeNS(null, 'id', 'svg' + id);\r\n    $e.setAttributeNS(null, 'style', 'width: 33.3%; display: inline-block');\r\n    $e.setAttributeNS(null, 'viewBox', '-100 -100 200 200');\r\n    return $e;\r\n}\r\n/**\r\n * Returns an SVG path string of a 'stretched' polygon with n sides.\r\n * @param n The number of sides.\r\n * @param c The center.\r\n * @param r The radius.\r\n */\r\nfunction getPolygonPathStr(n, c, r) {\r\n    let vertices = [];\r\n    for (let i = 0; i < n; i++) {\r\n        let θ = i * 2 * Math.PI / n;\r\n        let x = c[0] + r * Math.sin(θ);\r\n        let y = c[1] + r * Math.cos(θ);\r\n        //if (x < 0 && Math.abs(x) > 0.1) { x -= stretch }\r\n        //if (x > 0 && Math.abs(x) > 0.1) { x += stretch }\r\n        vertices.push([x, y]);\r\n    }\r\n    let pathStr = '';\r\n    let prefix = 'M';\r\n    for (let vertex of vertices) {\r\n        pathStr += `${prefix}${vertex[0]} ${vertex[1]} \\n`;\r\n        prefix = 'L';\r\n    }\r\n    pathStr += 'z';\r\n    return pathStr;\r\n}\r\n/**\r\n * Returns an SVG path string of a line.\r\n * @param ps The line endpoints.\r\n */\r\nfunction getLinePathStr(ps) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    return `M${x0} ${y0} L${x1} ${y1}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a quadratic bezier curve.\r\n * @param ps The quadratic bezier control points.\r\n */\r\nfunction getQuadBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`;\r\n}\r\n/**\r\n * Returns an SVG path string of a cubic bezier curve.\r\n * @param ps The cubic bezier control points.\r\n */\r\nfunction getCubicBezierPathStr(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`;\r\n}\r\n/**\r\n * Returns a function that draws an array of MAT curves on an SVG element.\r\n * @param mats An array of MATs to draw.\r\n * @param svg The SVG element on which to draw.\r\n * @param type The type of MAT to draw. This simply affects the class on the\r\n * path element.\r\n  */\r\nfunction drawMats(mats, svg, type = 'mat') {\r\n    mats.forEach(f);\r\n    /**\r\n     * Draws a MAT curve on an SVG element.\r\n     */\r\n    function f(mat) {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return;\r\n        }\r\n        let fs = [, , getLinePathStr, getQuadBezierPathStr, getCubicBezierPathStr];\r\n        flo_mat_1.traverseEdges(cpNode, function (cpNode) {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            let bezier = flo_mat_1.getCurveToNext(cpNode);\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            let $path = document.createElementNS(NS, 'path');\r\n            $path.setAttributeNS(null, \"d\", fs[bezier.length](bezier));\r\n            $path.setAttributeNS(null, \"class\", type);\r\n            svg.appendChild($path);\r\n        });\r\n    }\r\n}\r\nfor (let i = 3; i < 12; i++) {\r\n    let $svg = createSvg(1); // Create SVG element.\r\n    let $path = document.createElementNS(NS, 'path'); // Create SVG path elem.\r\n    $path.setAttribute('class', 'shape-path');\r\n    $svg.appendChild($path); // Add the path element to the SVG.\r\n    document.body.appendChild($svg); // Add the SVG to the document body.\r\n    // Create polygon path with i vertices.\r\n    let $d = getPolygonPathStr(i, [0, 0], 75);\r\n    // Assign the path to the path element.\r\n    $path.setAttributeNS(null, \"d\", $d);\r\n    // Get loops (representing the shape) from the path.\r\n    let loops = flo_mat_1.getPathsFromStr($d);\r\n    /*\r\n    let loops = [\r\n        [\r\n            [[50.000, 95.000],[92.797, 63.905]],\r\n            [[92.797, 63.905],[76.450, 13.594]],\r\n            [[76.450, 13.594],[23.549, 13.594]],\r\n            [[23.549, 13.594],[7.202,  63.90]],\r\n            [[7.202,  63.900],[50.000, 95.000]]\r\n        ]\r\n    ];\r\n    */\r\n    // Get MATs from the loops.\r\n    let mats = flo_mat_1.findMats(loops, 1);\r\n    // Draw the MATs.\r\n    drawMats(mats, $svg);\r\n}\r\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/create/cubic-through-point.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/create/cubic-through-point.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Generates a cubic going through a specific point given control points 0,1\r\n * and 3.\r\n */\r\nfunction cubicThroughPointGiven013(ps, p, t) {\r\n    let [[x0, y0], [x1, y1], [,], [x3, y3]] = ps;\r\n    let [x, y] = p;\r\n    let x2 = (Math.pow(t, 3) * (-x0 + 3 * x1 + x3) + 3 * Math.pow(t, 2) * (x0 - 2 * x1) - 3 * t * (x0 - x1) - x + x0) / (3 * Math.pow(t, 2) * (t - 1));\r\n    let y2 = (Math.pow(t, 3) * (-y0 + 3 * y1 + y3) + 3 * Math.pow(t, 2) * (y0 - 2 * y1) - 3 * t * (y0 - y1) - y + y0) / (3 * Math.pow(t, 2) * (t - 1));\r\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\r\n}\r\nexports.cubicThroughPointGiven013 = cubicThroughPointGiven013;\r\n//# sourceMappingURL=cubic-through-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/create/cubic-through-point.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns a cubic bezier curve of the given order with a zero tangent (as a\r\n * vector) at t = 0.5 (i.e. a 'cusp').\r\n * @param p0 the bezier start point\r\n * @param pz the point at which the vanishing tangent should occur\r\n * @param pE the bezier end point\r\n */\r\nfunction generateCuspAtHalf3(p0, pz, pE) {\r\n    // x3 - 3x2 + 3x1 - x0, // := a = coefficent of t^3\r\n    // 3x2 - 6x1 + 3x0,     // := b = coefficent of t^2\r\n    // 3x1 - 3x0,           // := c = coefficent of t^1\r\n    // x0,                  // := d = coefficent of t^0\r\n    // y3 - 3y2 + 3y1 - y0, // := e = coefficent of t^3\r\n    // 3y2 - 6y1 + 3y0,     // := f = coefficent of t^2\r\n    // 3y1 - 3y0,           // := g = coefficent of t^1\r\n    // y0,                  // := h = coefficent of t^0\r\n    // let x = at^3 + bt^2 + ct + d\r\n    // let y = et^3 + ft^2 + gt + h\r\n    // x` = 3at^2 + 2bt + c\r\n    // y` = 3et^2 + 2ft + g\r\n    // d = x0 and h = y0\r\n    let [x0, y0] = p0;\r\n    let [xz, yz] = pz;\r\n    let [xE, yE] = pE;\r\n    // We must have x` = y` = 0 at t = 1/2:\r\n    // 3a/4 + b + c = 0            =>  3a  + 4b  + 4c  =  0       (1)\r\n    // 3e/4 + f + g = 0            =>  3e  + 4f  + 4g  =  0       (2)\r\n    // Also, x(1/2) === pz[0]:\r\n    // a/8 + b/4 + c/2 + d = pz[0] => a + 2b + 4c + 8d = 8xz      (3)\r\n    // and y(1/2) === pz[1]:\r\n    // e/8 + f/4 + g/2 + h = pz[1] => e + 2f + 4g + 8h = 8yz      (4)\r\n    // and by definitition:\r\n    // a = x3 - 3x2 + 3x1 - x0     => -3x2 + 3x1 - a   =  x0 - x3 (5)\r\n    // b = 3x2 - 6x1 + 3x0         =>  3x2 - 6x1 - b   = -3x0     (6)\r\n    // c = 3x1 - 3x0               =>  3x1       - c   =  3x0     (7)\r\n    // e = y3 - 3y2 + 3y1 - y0     => -3y2 + 3y1 - e   =  y0 - y3 (8)\r\n    // f = 3y2 - 6y1 + 3y0         =>  3y2 - 6y1 - f   = -3y0     (9) \r\n    // g = 3y1 - 3y0               =>  3y1       - g   =  3y0     (10)\r\n    // Solving the above linear system gives:\r\n    //let a = 4*xE-4*x0;\r\n    //let b = 4*x0-4*xz-4*xE+4*x0;\r\n    //let c = -4*x0+4*xz+xE-x0;\r\n    //let e = 4*yE-4*y0;\r\n    //let f = 4*y0-4*yz-4*yE+4*y0;\r\n    //let g = -4*y0+4*yz+yE-y0;\r\n    let x1 = -(4 * x0 - 4 * xz - xE - 2 * x0) / 3;\r\n    let y1 = -(4 * y0 - 4 * yz - yE - 2 * y0) / 3;\r\n    let x2 = -(4 * x0 - 4 * xz + 2 * xE - 5 * x0) / 3;\r\n    let y2 = -(4 * y0 - 4 * yz + 2 * yE - 5 * y0) / 3;\r\n    return [p0, [x1, y1], [x2, y2], pE];\r\n}\r\nexports.generateCuspAtHalf3 = generateCuspAtHalf3;\r\n/*\r\n3*a  + 4*b  + 4*c   = 0\r\n3*e  + 4*f  + 4*g   = 0\r\na + 2*b + 4*c + 8*d = 8*xz\r\ne + 2*f + 4*g + 8*h = 8*yz\r\n-3*x2 + 3*x1 - a =  x0 - x3\r\n3*x2 - 6*x1 - b = -3*x0\r\n3*x1 - c = 3*x0\r\n-3*y2 + 3*y1 - e = y0 - y3\r\n3*y2 - 6*y1  - f = -3*y0\r\n3*y1 - g = 3*y0\r\n*/\r\n//# sourceMappingURL=generate-cusp-at-half-t.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/debug/debug.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-bezier3/node/debug/debug.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_elem_1 = __webpack_require__(/*! ./draw-elem/draw-elem */ \"./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js\");\r\nclass BezDebug {\r\n    /**\r\n     * @param config - configuration settings.\r\n     * @param fs - some useful functions.\r\n     * @private\r\n     */\r\n    constructor(g) {\r\n        //(this as any).Bezier3 = Bezier3; // Included only for quick debugging from console\r\n        //(this as any).Vector2d = Vector; // ...\r\n        this.g = g;\r\n        //-----------------------------------------------\r\n        // Generated by debug object for later inspection\r\n        //-----------------------------------------------\r\n        this.generated = {\r\n            elems: {\r\n                beziers: [],\r\n                fatLine: [],\r\n                looseBoundingBox: [],\r\n                tightBoundingBox: [],\r\n                extreme: [],\r\n                boundingHull: [],\r\n                intersection: [],\r\n            }\r\n        };\r\n        this.fs = {\r\n            drawElem: draw_elem_1.drawElemFunctions,\r\n        };\r\n    }\r\n}\r\nexports.BezDebug = BezDebug;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction fatLine(g, fatLine) {\r\n    let { l, minD, maxD } = fatLine;\r\n    let [lp1, lp2] = l;\r\n    const E = 1024;\r\n    let lv = flo_vector2d_1.fromTo(lp1, lp2);\r\n    let lvTimes10 = [+E * lv[0], +E * lv[1]];\r\n    let reverseLvTimes10 = [-E * lv[0], -E * lv[1]];\r\n    let norm = [-lv[1], lv[0]]; // Rotate by -90 degrees\r\n    let normMin = flo_vector2d_1.toLength(norm, minD);\r\n    let normMax = flo_vector2d_1.toLength(norm, maxD);\r\n    let extLp1 = flo_vector2d_1.translate(lp1, reverseLvTimes10);\r\n    let extLp2 = flo_vector2d_1.translate(lp2, lvTimes10);\r\n    let nl11 = flo_vector2d_1.translate(extLp1, normMin);\r\n    let nl12 = flo_vector2d_1.translate(extLp2, normMin);\r\n    let nl21 = flo_vector2d_1.translate(extLp1, normMax);\r\n    let nl22 = flo_vector2d_1.translate(extLp2, normMax);\r\n    let nl1 = [nl11, nl12];\r\n    let nl2 = [nl21, nl22];\r\n    let $line1 = flo_draw_1.drawFs.line(g, nl1);\r\n    let $line2 = flo_draw_1.drawFs.line(g, nl2);\r\n    return [...$line1, ...$line2];\r\n}\r\nfunction beziers(g, beziers) {\r\n    let $bezier1 = flo_draw_1.drawFs.bezier(g, beziers[0], 'blue thin5 nofill');\r\n    let $bezier2 = flo_draw_1.drawFs.bezier(g, beziers[1], 'green thin5 nofill');\r\n    let size = getSize([...beziers[0], ...beziers[1]]) / 400;\r\n    let $dots = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let bezier = beziers[i];\r\n        for (let j = 0; j < bezier.length; j++) {\r\n            let p = bezier[j];\r\n            $dots.push(...flo_draw_1.drawFs.dot(g, p, size, i === 0 ? 'blue' : 'green'));\r\n        }\r\n    }\r\n    /*\r\n    let $dots = [\r\n        ...drawFs.dot(g, beziers[0][0], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[0][1], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[0][2], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[0][3], size, 'blue'),\r\n        ...drawFs.dot(g, beziers[1][0], size, 'green'),\r\n        ...drawFs.dot(g, beziers[1][1], size, 'green'),\r\n        ...drawFs.dot(g, beziers[1][2], size, 'green'),\r\n        ...drawFs.dot(g, beziers[1][3], size, 'green'),\r\n    ]\r\n    */\r\n    return [...$bezier1, ...$bezier2, ...$dots];\r\n}\r\nfunction getSize(ps) {\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    for (let p of ps) {\r\n        if (p[0] < minX) {\r\n            minX = p[0];\r\n        }\r\n        if (p[1] < minY) {\r\n            minY = p[1];\r\n        }\r\n        if (p[0] > maxX) {\r\n            maxX = p[0];\r\n        }\r\n        if (p[1] > maxY) {\r\n            maxY = p[1];\r\n        }\r\n    }\r\n    let width = maxX - minX;\r\n    let height = maxY - minY;\r\n    return Math.max(width, height);\r\n}\r\nfunction intersection(g, p) {\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, p, 'red thin5 nofill', 0.1);\r\n    return $elems;\r\n}\r\nfunction extreme(g, extreme) {\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, extreme.p, 'red thin10 nofill', 0.05);\r\n    return $elems;\r\n}\r\nfunction boundingHull(g, hull) {\r\n    let $polygon = flo_draw_1.drawFs.polygon(g, hull, 'thin5 black nofill');\r\n    return $polygon;\r\n}\r\nfunction looseBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.rect(g, box, 'thin5 brown nofill');\r\n    return $box;\r\n}\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, 'thin5 black nofill');\r\n    return $box;\r\n}\r\nlet drawElemFunctions = {\r\n    beziers,\r\n    intersection,\r\n    extreme,\r\n    boundingHull,\r\n    looseBoundingBox,\r\n    tightBoundingBox,\r\n    fatLine\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/debug/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/error-analysis/error-analysis.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst u = Number.EPSILON / 2;\r\nconst uu = Math.pow((Number.EPSILON / 2), 2);\r\nfunction γ(n) {\r\n    let nu = n * u;\r\n    return nu / (1 - nu);\r\n}\r\nexports.γ = γ;\r\nfunction γγ(n) {\r\n    let nuu = n * uu;\r\n    return nuu / (1 - nuu);\r\n}\r\nexports.γγ = γγ;\r\nconst γ1 = γ(1);\r\nexports.γ1 = γ1;\r\nconst γ2 = γ(2);\r\nexports.γ2 = γ2;\r\nconst γ3 = γ(3);\r\nexports.γ3 = γ3;\r\nconst γ4 = γ(4);\r\nexports.γ4 = γ4;\r\nconst γ5 = γ(5);\r\nexports.γ5 = γ5;\r\nconst γ6 = γ(6);\r\nexports.γ6 = γ6;\r\nconst γ7 = γ(7);\r\nexports.γ7 = γ7;\r\nconst γ8 = γ(8);\r\nexports.γ8 = γ8;\r\nconst γ9 = γ(9);\r\nexports.γ9 = γ9;\r\nconst γ10 = γ(10);\r\nexports.γ10 = γ10;\r\nconst γ11 = γ(11);\r\nexports.γ11 = γ11;\r\nconst γ12 = γ(12);\r\nexports.γ12 = γ12;\r\nconst γ13 = γ(13);\r\nexports.γ13 = γ13;\r\nconst γ14 = γ(14);\r\nexports.γ14 = γ14;\r\nconst γγ1 = γγ(1);\r\nexports.γγ1 = γγ1;\r\nconst γγ2 = γγ(2);\r\nexports.γγ2 = γγ2;\r\nconst γγ3 = γγ(3);\r\nexports.γγ3 = γγ3;\r\nconst γγ4 = γγ(4);\r\nexports.γγ4 = γγ4;\r\nconst γγ5 = γγ(5);\r\nexports.γγ5 = γγ5;\r\nconst γγ6 = γγ(6);\r\nexports.γγ6 = γγ6;\r\nconst γγ7 = γγ(7);\r\nexports.γγ7 = γγ7;\r\nconst γγ8 = γγ(8);\r\nexports.γγ8 = γγ8;\r\nconst γγ9 = γγ(9);\r\nexports.γγ9 = γγ9;\r\nconst γγ10 = γγ(10);\r\nexports.γγ10 = γγ10;\r\nconst γγ11 = γγ(11);\r\nexports.γγ11 = γγ11;\r\nconst γγ12 = γγ(12);\r\nexports.γγ12 = γγ12;\r\nconst γγ13 = γγ(13);\r\nexports.γγ13 = γγ13;\r\nconst γγ14 = γγ(14);\r\nexports.γγ14 = γγ14;\r\n//# sourceMappingURL=error-analysis.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/error-analysis/error-analysis.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/from-power-basis/from-power-bases.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/from-power-basis/from-power-bases.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the approximate Bernstein basis representation of a line, quadratic\r\n * or cubic bezier's power bases.\r\n *\r\n * @param cs An order 1, 2 or 3 parametric curve in power bases with the\r\n * x-coordinate coefficients given first as an array representing the polynomial\r\n * in the parameter from highest to lowest order, e.g. [[1,2,3,4], [5,6,7,8]]\r\n * represents a cubic parametric curve.\r\n */\r\nfunction fromPowerBases(cs) {\r\n    if (cs[0].length === 4) {\r\n        let [[a3, a2, a1, a0], [b3, b2, b1, b0]] = cs;\r\n        return [\r\n            [a0 + a1 + a2 + a3,\r\n                b0 + b1 + b2 + b3],\r\n            [a0 + 2 * a1 / 3 + a2 / 3,\r\n                b0 + 2 * b1 / 3 + b2 / 3],\r\n            [a0 + a1 / 3,\r\n                b0 + b1 / 3],\r\n            [a0,\r\n                b0]\r\n        ];\r\n    }\r\n    else if (cs.length === 3) {\r\n        let [[a2, a1, a0], [b2, b1, b0]] = cs;\r\n        return [\r\n            [a0 + a1 + a2,\r\n                b0 + b1 + b2,],\r\n            [a0 + a1 / 2,\r\n                b0 + b1 / 2],\r\n            [a0,\r\n                b0]\r\n        ];\r\n    }\r\n    else if (cs.length === 2) {\r\n        let [[a1, a0], [b1, b0]] = cs;\r\n        return [\r\n            [a0 + a1,\r\n                b0 + b1],\r\n            [a0,\r\n                b0]\r\n        ];\r\n    }\r\n}\r\nexports.fromPowerBases = fromPowerBases;\r\n//# sourceMappingURL=from-power-bases.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/from-power-basis/from-power-bases.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/geometry/intersect-boxes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/geometry/intersect-boxes.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst min = Math.min;\r\nconst max = Math.max;\r\n/**\r\n * Returns the intersection of 2 given axis-aligned rectangular boxes.\r\n * @param a An axis-aligned rectangular box\r\n * @param a Another axis-aligned rectangular box\r\n * * **closed**:  interpret boxes as being closed (i.e. they contain their border).\r\n */\r\nfunction intersectBoxes(a, b) {\r\n    let [[ax0, ay0], [ax1, ay1]] = a;\r\n    let [[bx0, by0], [bx1, by1]] = b;\r\n    // Swap so smaller coordinate comes first\r\n    if (ax0 > ax1) {\r\n        [ax0, ax1] = [ax1, ax0];\r\n    }\r\n    ;\r\n    if (bx0 > bx1) {\r\n        [bx0, bx1] = [bx1, bx0];\r\n    }\r\n    ;\r\n    if (ay0 > ay1) {\r\n        [ay0, ay1] = [ay1, ay0];\r\n    }\r\n    ;\r\n    if (by0 > by1) {\r\n        [by0, by1] = [by1, by0];\r\n    }\r\n    ;\r\n    if (!(ax0 <= bx1 && ax1 >= bx0 &&\r\n        by0 <= ay1 && by1 >= ay0)) {\r\n        // they don't intersect\r\n        return undefined;\r\n    }\r\n    return [\r\n        [max(ax0, bx0), max(ay0, by0)],\r\n        [min(ax1, bx1), min(ay1, by1)]\r\n    ];\r\n}\r\nexports.intersectBoxes = intersectBoxes;\r\n//# sourceMappingURL=intersect-boxes.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/geometry/intersect-boxes.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DELTA = 1e-6;\r\n/**\r\n * Calculates the curvature extrema brackets of the given cubic bezier.\r\n * See the paper at http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * Note that naming conventions is roughly as in the paper above.\r\n * @param ps\r\n */\r\nfunction getCurvatureExtremaBrackets(ps) {\r\n    let none = { brackets: [], inflections: [] };\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // Bezier points translated to origin;\r\n    let P_1x = x1 - x0;\r\n    let P_1y = y1 - y0;\r\n    let P_2x = x2 - x0;\r\n    let P_2y = y2 - y0;\r\n    let P_3x = x3 - x0;\r\n    let P_3y = y3 - y0;\r\n    // Distance to consecutive points\r\n    let W_0x = P_1x;\r\n    let W_1x = P_2x - P_1x;\r\n    let W_2x = P_3x - P_2x;\r\n    let W_0y = P_1y;\r\n    let W_1y = P_2y - P_1y;\r\n    let W_2y = P_3y - P_2y;\r\n    // Check for degenerate case in which cubic curve becomes quadratic. \r\n    if ((Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA) &&\r\n        (Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA)) {\r\n        // TODO - This case is simpler due to being quadratic - still needs to\r\n        // be implemented!. \r\n    }\r\n    // See http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n    // Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\r\n    let atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\r\n    let atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\r\n    let atan_numer_squared = atan_numer * atan_numer;\r\n    let atan_denom_squared = atan_denom * atan_denom;\r\n    let rad = Math.sqrt((atan_numer_squared / atan_denom_squared) + 1);\r\n    let cos_theta = 1 / rad;\r\n    let sin_theta;\r\n    if (cos_theta === 0) { // edge case\r\n        sin_theta = 1;\r\n    }\r\n    else {\r\n        sin_theta = atan_numer / (atan_denom * rad);\r\n    }\r\n    // Here we skip expensive trig evaluations\r\n    let R_1x = P_1x * cos_theta - P_1y * sin_theta;\r\n    let R_1y = P_1x * sin_theta + P_1y * cos_theta;\r\n    let R_2x = P_2x * cos_theta - P_2y * sin_theta;\r\n    let R_2y = P_2x * sin_theta + P_2y * cos_theta;\r\n    let R_3x = P_3x * cos_theta - P_3y * sin_theta;\r\n    let R_3y = P_3x * sin_theta + P_3y * cos_theta;\r\n    // Modify W_0x, etc. to be correct for new rotated curve \r\n    W_0x = R_1x;\r\n    W_1x = R_2x - R_1x;\r\n    W_2x = R_3x - R_2x;\r\n    W_0y = R_1y;\r\n    W_1y = R_2y - R_1y;\r\n    W_2y = R_3y - R_2y;\r\n    let a = 3 * (W_0y - 2 * W_1y + W_2y);\r\n    let dif = W_1x - W_0x; // === R_2x - 2*R_1x;\r\n    if (dif === 0) {\r\n        // Case 1 (special) - W_1x - W_0x === 0\r\n        // Degenerate to a cubic function (as opposed to parametric cubic)\r\n        if (W_0x === 0) {\r\n            // We have a straight line x=0!\r\n            return none;\r\n        }\r\n        if (W_0x < 0) {\r\n            // Reflect curve accross y-axis to make dif > 0\r\n            R_1x = -R_1x;\r\n            R_2x = -R_2x;\r\n            R_3x = -R_3x;\r\n            // Modify W_0x, etc. to be correct for new reflected \r\n            W_0x = -W_0x;\r\n            W_1x = -W_1x;\r\n            W_2x = -W_2x;\r\n        }\r\n        // TODO - finish\r\n        return none; // WRONG!\r\n    }\r\n    else {\r\n        // Case 2 (usual) - W_1x - W_0x !== 0\r\n        if (dif < 0) {\r\n            // Reflect curve accross y-axis to make dif > 0\r\n            R_1x = -R_1x;\r\n            R_2x = -R_2x;\r\n            R_3x = -R_3x;\r\n            // Modify W_0x, etc. to be correct for new reflected \r\n            W_0x = -W_0x;\r\n            W_1x = -W_1x;\r\n            W_2x = -W_2x;\r\n            dif = -dif;\r\n        }\r\n        // From the paper:\r\n        // ---------------\r\n        // All curves has exactly one of 4 cases:\r\n        //\r\n        // 1. It has a single inflection point and exactly 2 curvature maxima \r\n        //    (symmetrically positioned about inflection point). This is the \r\n        //    case if dif === 0 in above code.\r\n        // 2. TODO - It has a single cusp - ignored for now!\r\n        // 3. It has a point of self-intersection - occurs if d < 0 in paper.\r\n        // 4. It has 2 inflection points, no cusps, no self-intersections.\r\n        //    It can have either 3 or 5 curvature extrema\r\n        //    a. The case of 5 curvature extrema is ignored for now - in the \r\n        //       paper it is mentioned to even find such a curve is difficult \r\n        //       and it seems such curves have very sharp curvature at one point \r\n        //       which does not usually occur in an SVG shape. But this case \r\n        //       should later be included or we'll miss some points.\r\n        //    b. There are 3 curvature extrema:\r\n        //       Extrema occur in the range (-inf, -sqrt(d)), \r\n        //       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \r\n        //       Since we dont know how to select -inf and inf we will just \r\n        //       choose them to be -10 and 11 (remember bezier runs from t=0 to \r\n        //       t=1). If Brent's method runs out of the (0,1) interval we stop \r\n        //       and use 0 or 1 as the extremum? Remember extrema can also occur \r\n        //       at t=0 and t=1!\r\n        //\r\n        // TODO - At the moment we only test for case 1 and 4b, but in future \r\n        // we must test and eliminate the other cases.\r\n        let μ = 6 * dif;\r\n        let λ = (3 * a * W_0x) / (μ * μ);\r\n        let γ1 = (3 * a * W_0y) / (μ * μ);\r\n        let γ2 = (3 * (W_1y - W_0y)) / (μ);\r\n        let d = λ * λ - 2 * γ2 * λ + γ1;\r\n        let b = 2 * (γ2 - λ);\r\n        let deParamBoundary = deParameterizeBoundary(λ, μ, a);\r\n        let deParam = deParameterize(λ, μ, a);\r\n        if (d > 0) {\r\n            let ssigd_ = Math.sqrt(d);\r\n            // de-reparametize\r\n            // Note: the sda and sdb here are the inflection points forcase iv! \r\n            // there are easier ways to calculate these\r\n            let sda = -ssigd_;\r\n            let sdb = ssigd_;\r\n            let brackets = [\r\n                [Number.NEGATIVE_INFINITY, sda],\r\n                [sda, sdb],\r\n                [sdb, Number.POSITIVE_INFINITY]\r\n            ]\r\n                .map(deParamBoundary)\r\n                .map(clipBoundary);\r\n            let inflections = [deParam(sda), deParam(sdb)].filter(v => v > 0 && v < 1);\r\n            //console.log(inflections)\r\n            return { brackets, inflections };\r\n        }\r\n        else if (d < 0) {\r\n            // It is a loop \r\n            // Note: The loop intersection may be outside t=[0,1] but curvature \r\n            // maxima may still occur inside t=[0,1] of course.\r\n            // There can be 1 or 3 maxima of curvature.\r\n            let ξ1_ = 2 * b * b - 8 * d - 3;\r\n            if (ξ1_ < 0) {\r\n                let brackets = [[0, Math.sqrt(-3 * d)]]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n                return { brackets, inflections: [] };\r\n            }\r\n            else {\r\n                let ξ2_ = Math.sqrt(5 * ξ1_);\r\n                let ξ1 = (-5 * b - ξ2_) / 10;\r\n                let ξ2 = (-5 * b + ξ2_) / 10;\r\n                let brackets = [\r\n                    [Number.NEGATIVE_INFINITY, ξ1],\r\n                    [ξ1, Math.min(0, ξ2)],\r\n                    [Math.max(0, ξ2), Math.sqrt(-3 * d)]\r\n                ]\r\n                    .map(deParamBoundary)\r\n                    .map(clipBoundary);\r\n                return { brackets, inflections: [] };\r\n            }\r\n        }\r\n        else if (d === 0) {\r\n            // TODO - It is a cusp - still to implement!\r\n            return none;\r\n        }\r\n        else {\r\n            return none; // NaN\r\n        }\r\n    }\r\n}\r\nexports.getCurvatureExtremaBrackets = getCurvatureExtremaBrackets;\r\n/**\r\n * Clips to [0,1] or returns undefined if not within [0,1].\r\n * @param range\r\n */\r\nfunction clipBoundary(range) {\r\n    let [a, b] = range;\r\n    if ((a < 0 && b < 0) || (a > 1 && b > 1)) {\r\n        return undefined;\r\n    }\r\n    if (a < 0) {\r\n        a = 0;\r\n    }\r\n    if (a > 1) {\r\n        a = 1;\r\n    }\r\n    if (b < 0) {\r\n        b = 0;\r\n    }\r\n    if (b > 1) {\r\n        b = 1;\r\n    }\r\n    return [a, b];\r\n}\r\n/**\r\n *\r\n * @param λ\r\n * @param μ\r\n * @param a\r\n */\r\nfunction deParameterize(λ, μ, a) {\r\n    return (σ) => (σ - λ) * (μ / a);\r\n}\r\n/**\r\n *\r\n * @param λ\r\n * @param μ\r\n * @param a\r\n */\r\nfunction deParameterizeBoundary(λ, μ, a) {\r\n    return (boundary) => boundary.map(deParameterize(λ, μ, a));\r\n}\r\n//# sourceMappingURL=get-curvature-extrema-brackets.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_curvature_extrema_brackets_1 = __webpack_require__(/*! ./get-curvature-extrema-brackets */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js\");\r\nconst curvature_1 = __webpack_require__(/*! ../local-properties-at-t/curvature */ \"./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js\");\r\n/**\r\n * Finds the osculating circles and inflection points for the given bezier.\r\n * @param ps\r\n */\r\nfunction getCurvatureExtrema(ps) {\r\n    if (ps.length === 2) {\r\n        return { maxCurvatureTs: [], maxNegativeCurvatureTs: [] };\r\n    }\r\n    else if (ps.length === 3) {\r\n        // See e.g. https://math.stackexchange.com/a/2971112\r\n        // TODO\r\n        return { maxCurvatureTs: [], maxNegativeCurvatureTs: [] };\r\n    }\r\n    let maxCurvatureTs = [];\r\n    let maxNegativeCurvatureTs = [];\r\n    let brackets = get_curvature_extrema_brackets_1.getCurvatureExtremaBrackets(ps).brackets;\r\n    let κPs = curvature_1.κ(ps); // The curvature function\r\n    let lenb = brackets.length;\r\n    for (let k = 0; k < lenb; k++) {\r\n        let bracket = brackets[k];\r\n        if (!bracket) {\r\n            continue;\r\n        }\r\n        let root = lookForRoot(ps, bracket);\r\n        if (!root) {\r\n            continue;\r\n        }\r\n        let κ_ = -κPs(root);\r\n        // Check if local extrema is a maximum or minimum.\r\n        let κAtMinsd = -κPs(bracket[0]);\r\n        let κAtMaxsd = -κPs(bracket[1]);\r\n        if (κ_ > κAtMinsd && κ_ > κAtMaxsd) {\r\n            // maximum\r\n            if (κ_ > 0) {\r\n                maxCurvatureTs.push(root);\r\n            }\r\n        }\r\n        else if (κ_ <= κAtMinsd && κ_ <= κAtMaxsd) {\r\n            // minimum\r\n            if (κ_ < 0) {\r\n                maxNegativeCurvatureTs.push(root);\r\n            }\r\n        }\r\n    }\r\n    return { maxCurvatureTs, maxNegativeCurvatureTs };\r\n}\r\nexports.getCurvatureExtrema = getCurvatureExtrema;\r\nfunction lookForRoot(ps, [minsd, maxsd]) {\r\n    // At this point there can be exactly 0 or 1 roots within \r\n    // [minsd, maxsd]\r\n    let dκMod_ = dκMod(ps);\r\n    let c0 = dκMod_(minsd);\r\n    let c1 = dκMod_(maxsd);\r\n    if (c0 * c1 >= 0) {\r\n        return;\r\n    }\r\n    // There is exactly one root in the interval.\r\n    let root = flo_poly_1.brent(dκMod_, minsd, maxsd);\r\n    return root;\r\n}\r\nfunction dκMod(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    function f(t) {\r\n        let ts = t * t;\r\n        let omt = 1 - t;\r\n        let a = ts * x3;\r\n        let b = ts * y3;\r\n        let c = 2 * t - 3 * ts;\r\n        let d = (3 * t - 1) * omt;\r\n        let e = omt * omt;\r\n        let f = 3 * (a + c * x2 - d * x1 - e * x0);\r\n        let g = 3 * (b + c * y2 - d * y1 - e * y0);\r\n        let h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\r\n        let i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\r\n        let j = Math.sqrt(f * f + g * g);\r\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) -\r\n            g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) -\r\n            (f * h - i * g) * (2 * h * g + 2 * i * f) * j;\r\n    }\r\n    return t === undefined ? f : f(t);\r\n}\r\n//# sourceMappingURL=get-curvature-extrema.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_bounding_box_1 = __webpack_require__(/*! ./get-bounding-box */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\r\nconst length_squared_upper_bound_1 = __webpack_require__(/*! ../length/length-squared-upper-bound */ \"./node_modules/flo-bezier3/node/global-properties/length/length-squared-upper-bound.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Returns a **non-certified**, **rotated**, **tight** bounding box of the given\r\n * order 1, 2 or 3 bezier curve as four ordered points of a rotated rectangle.\r\n */\r\nlet getBoundingBoxTight = flo_memoize_1.memoize(function (ps) {\r\n    let [xS, yS] = ps[0];\r\n    let [xE, yE] = ps[ps.length - 1];\r\n    let sinθ;\r\n    let cosθ;\r\n    // take care of the case the endpoints are close together\r\n    let len = length_squared_upper_bound_1.lengthSquaredUpperBound(ps);\r\n    if (flo_vector2d_1.squaredDistanceBetween(ps[0], ps[ps.length - 1]) * Math.pow(2, 8) < len) {\r\n        let [xE_, yE_] = eval_de_casteljau_1.evalDeCasteljau(ps, 0.5);\r\n        let hypotenuse = Math.sqrt((xE_ - xS) * (xE_ - xS) + (yE_ - yS) * (yE_ - yS));\r\n        sinθ = (yE_ - yS) / hypotenuse;\r\n        cosθ = (xE_ - xS) / hypotenuse;\r\n    }\r\n    else {\r\n        let hypotenuse = Math.sqrt((xE - xS) * (xE - xS) + (yE - yS) * (yE - yS));\r\n        sinθ = (yE - yS) / hypotenuse;\r\n        cosθ = (xE - xS) / hypotenuse;\r\n    }\r\n    let box = getNormalizedBoundingBox(ps, sinθ, cosθ);\r\n    let [[p0x, p0y], [p1x, p1y]] = box;\r\n    let axisAlignedBox = [\r\n        box[0], [p1x, p0y],\r\n        box[1], [p0x, p1y]\r\n    ];\r\n    let bb = flo_vector2d_1.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\r\n    return bb;\r\n});\r\nexports.getBoundingBoxTight = getBoundingBoxTight;\r\n/**\r\n * Helper function. Returns the bounding box of the normalized (i.e. first point\r\n * moved to origin and rotated so that last point lies on x-axis) given cubic\r\n * bezier.\r\n * @ignore\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param sinθ - Sine of angle made by line from first bezier point to\r\n * last with x-axis.\r\n * @param cosθ - Cosine of angle made by line from first bezier point\r\n * to last with x-axis.\r\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\r\n */\r\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\r\n    let vectorToOrigin = ps[0].map(x => -x);\r\n    let boundingPs = flo_vector2d_1.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\r\n    return get_bounding_box_1.getBoundingBox(boundingPs);\r\n}\r\n//# sourceMappingURL=get-bounding-box-tight.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_bounds_1 = __webpack_require__(/*! ./get-bounds */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js\");\r\n/**\r\n * Returns an axis-aligned bounding box of the given order 2,\r\n * 3 or 4 bezier.\r\n * * **certified**\r\n * @param ps A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns the axis-aligned bounding box in the form\r\n * [[minx, miny], [maxx,maxy]\r\n */\r\nlet getBoundingBox = flo_memoize_1.memoize(function (ps) {\r\n    let xBounds = get_bounds_1.getXBoundsTight(ps);\r\n    let yBounds = get_bounds_1.getYBoundsTight(ps);\r\n    return [\r\n        [xBounds.minX.box[0][0], yBounds.minY.box[0][1]],\r\n        [xBounds.maxX.box[1][0], yBounds.maxY.box[1][1]]\r\n    ];\r\n});\r\nexports.getBoundingBox = getBoundingBox;\r\n//# sourceMappingURL=get-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_dx_1 = __webpack_require__(/*! ../../to-power-basis/get-dx */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dx.js\");\r\nconst get_dy_1 = __webpack_require__(/*! ../../to-power-basis/get-dy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dy.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_interval_box_1 = __webpack_require__(/*! ./get-interval-box/get-interval-box */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\nconst abs = Math.abs;\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns a tight axis-aligned bounding box bound of the given bezier curve.\r\n * @param ps\r\n */\r\nlet getXBoundsTight = flo_memoize_1.memoize(function getXBoundsTight(ps) {\r\n    let pS = ps[0];\r\n    let pE = ps[ps.length - 1];\r\n    let minX;\r\n    let maxX;\r\n    if (pS[0] < pE[0]) {\r\n        minX = { ts: [0, 0], box: [pS, pS] };\r\n        maxX = { ts: [1, 1], box: [pE, pE] };\r\n    }\r\n    else {\r\n        minX = { ts: [1, 1], box: [pE, pE] };\r\n        maxX = { ts: [0, 0], box: [pS, pS] };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { minX, maxX };\r\n    }\r\n    let dx = get_dx_1.getDx(ps); // <= exact if 48-bit aligned\r\n    // Roots of derivative\r\n    let rootsX;\r\n    if (ps.length === 4) {\r\n        rootsX = quadRoots(dx);\r\n    }\r\n    else { // ps.length === 3\r\n        rootsX = getLinearRoots(dx);\r\n    }\r\n    // Test points\r\n    for (let i = 0; i < rootsX.length; i++) {\r\n        let r = rootsX[i];\r\n        let ts = [r.r - r.rE, r.r + r.rE];\r\n        let box = get_interval_box_1.getIntervalBox(ps, ts);\r\n        if (box[0][0] < minX.box[0][0]) {\r\n            minX = { ts, box };\r\n        }\r\n        if (box[1][0] > maxX.box[0][0]) {\r\n            maxX = { ts, box };\r\n        }\r\n    }\r\n    return { minX, maxX };\r\n});\r\nexports.getXBoundsTight = getXBoundsTight;\r\n// TODO - move this another library\r\nfunction getLinearRoots([a, b]) {\r\n    let r = -b / a;\r\n    let rE = u * abs(b / a);\r\n    if (r + rE > 0 && r - rE < 1) {\r\n        return [{ r, rE }];\r\n    }\r\n    return [];\r\n}\r\n/**\r\n * Returns a tight axis-aligned bounding box bound of the given bezier curve.\r\n * @param ps\r\n */\r\nlet getYBoundsTight = flo_memoize_1.memoize(function getYBoundsTight(ps) {\r\n    let pS = ps[0];\r\n    let pE = ps[ps.length - 1];\r\n    let minY;\r\n    let maxY;\r\n    if (pS[1] < pE[1]) {\r\n        minY = { ts: [0, 0], box: [pS, pS] };\r\n        maxY = { ts: [1, 1], box: [pE, pE] };\r\n    }\r\n    else {\r\n        minY = { ts: [1, 1], box: [pE, pE] };\r\n        maxY = { ts: [0, 0], box: [pS, pS] };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { minY, maxY };\r\n    }\r\n    let dy = get_dy_1.getDy(ps); // <= exact if 48-bit aligned\r\n    // Roots of derivative\r\n    let rootsY;\r\n    if (ps.length === 4) {\r\n        rootsY = quadRoots(dy);\r\n    }\r\n    else { // ps.length === 3\r\n        rootsY = getLinearRoots(dy);\r\n    }\r\n    // Test points\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        let r = rootsY[i];\r\n        let ts = [r.r - r.rE, r.r + r.rE];\r\n        let box = get_interval_box_1.getIntervalBox(ps, ts);\r\n        if (box[0][1] < minY.box[0][1]) {\r\n            minY = { ts, box };\r\n        }\r\n        if (box[1][1] > maxY.box[0][1]) {\r\n            maxY = { ts, box };\r\n        }\r\n    }\r\n    return { minY, maxY };\r\n});\r\nexports.getYBoundsTight = getYBoundsTight;\r\n/**\r\n * Return quad roots in range [0,1] with error assuming input coefficients\r\n * are exact.\r\n */\r\n// TODO - move this another library\r\nfunction quadRoots([a, b, c]) {\r\n    // first check a !== 0, else get root of the line 'bt + c = 0'\r\n    if (a === 0) {\r\n        return getLinearRoots([b, c]);\r\n    }\r\n    // DD = discriminant = b^2 - 4ac\r\n    // calculate DD and its absolute error DD_\r\n    let bb = b * b;\r\n    let bb_ = u * bb; // the error bound in b**2\r\n    let ac4 = 4 * a * c;\r\n    let ac4_ = 4 * u * abs(a * c);\r\n    let DD = bb - ac4;\r\n    let DD_ = bb_ + ac4_ + error_analysis_1.γ1 * abs(DD);\r\n    // If the discriminant is smaller than negative the error bound then\r\n    // certainly there are no roots.\r\n    if (DD <= -DD_) {\r\n        // discriminant is definitely negative\r\n        return [];\r\n    }\r\n    // discriminant is definitely positive\r\n    let { est: D, err: D_ } = flo_numerical_1.sqrtWithErr(DD, DD_);\r\n    let q1;\r\n    if (b >= 0) {\r\n        // let r1 = (-b - D) / 2*a;\r\n        // let r2 = (2*c) / (-b - D);\r\n        q1 = -b - D;\r\n    }\r\n    else {\r\n        // let r2 = (-b + D) / 2*a;\r\n        // let r1 = (2*c) / (-b + D);\r\n        q1 = -b + D;\r\n    }\r\n    let q1_ = D_ + error_analysis_1.γ1 * abs(q1);\r\n    let { est: r1, err: r1_ } = flo_numerical_1.divWithErr(q1, 2 * a, q1_, 0);\r\n    let { est: r2, err: r2_ } = flo_numerical_1.divWithErr(2 * c, q1, 0, q1_);\r\n    let res = [];\r\n    if (r1 + r1_ > 0 && r1 - r1_ < 1) {\r\n        res.push({ r: r1, rE: r1_ });\r\n    }\r\n    if (r2 + r2_ > 0 && r2 - r2_ < 1) {\r\n        res.push({ r: r2, rE: r2_ });\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Returns the approximate axis-aligned bounding box together with the t values\r\n * where the bounds on the bezier are reached.\r\n */\r\nlet getBounds = flo_memoize_1.memoize(function (ps) {\r\n    // Roots of derivative\r\n    let rootsX = flo_poly_1.allRoots(get_dx_1.getDx(ps), 0, 1);\r\n    let rootsY = flo_poly_1.allRoots(get_dy_1.getDy(ps), 0, 1);\r\n    // Endpoints\r\n    rootsX.push(0, 1);\r\n    rootsY.push(0, 1);\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    let tMinX;\r\n    let tMaxX;\r\n    let tMinY;\r\n    let tMaxY;\r\n    // Test points\r\n    for (let i = 0; i < rootsX.length; i++) {\r\n        let t = rootsX[i];\r\n        let x = eval_de_casteljau_1.evalDeCasteljauX(ps, t);\r\n        if (x < minX) {\r\n            minX = x;\r\n            tMinX = t;\r\n        }\r\n        if (x > maxX) {\r\n            maxX = x;\r\n            tMaxX = t;\r\n        }\r\n    }\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        let t = rootsY[i];\r\n        let y = eval_de_casteljau_1.evalDeCasteljauY(ps, t);\r\n        if (y < minY) {\r\n            minY = y;\r\n            tMinY = t;\r\n        }\r\n        if (y > maxY) {\r\n            maxY = y;\r\n            tMaxY = t;\r\n        }\r\n    }\r\n    let ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\r\n    let box = [[minX, minY], [maxX, maxY]];\r\n    return { ts, box };\r\n});\r\nexports.getBounds = getBounds;\r\n//# sourceMappingURL=get-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-quad.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-quad.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eval_de_casteljau_with_err_1 = __webpack_require__(/*! ../../../local-properties-at-t/t-to-xy/eval-de-casteljau-with-err */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau-with-err.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst u = Number.EPSILON / 2;\r\nconst abs = Math.abs;\r\nconst qdq = flo_numerical_1.qDiffQuad;\r\nconst qOne = [0, 1];\r\nconst qdivq = flo_numerical_1.qDivQuad;\r\nconst qad = flo_numerical_1.qAddDouble;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\n/**\r\n * Returns the approximate bezier curve that is the curve from t1 to t2 in such\r\n * a way that the control points axis-aligned-box of the newly returned curve is\r\n * guaranteed to engulf the true (numerically exact) curve control points\r\n * axis-aligned box.\r\n * * **precondition** t1 < t2\r\n * @param ps an order 1,2 or 3 bezier curve\r\n * @param t1 first parameter value as a quad precision floating point value\r\n * @param t2 second parameter value as a quad precision floating point value\r\n */\r\nfunction getIntervalBoxQuad(ps, ts) {\r\n    if (ts[0] !== ts[1]) {\r\n        if (ps.length === 4) {\r\n            return getIntervalBox3Quad(ps, ts);\r\n        }\r\n        if (ps.length === 3) {\r\n            return getIntervalBox2Quad(ps, ts);\r\n        }\r\n        return getIntervalBox1Quad(ps, ts);\r\n    }\r\n    else { // ts[0] === ts[1]\r\n        return getIntervalBoxExactTQuad(ps, ts[0]);\r\n    }\r\n}\r\nexports.getIntervalBoxQuad = getIntervalBoxQuad;\r\n// quad precision t1, t2\r\nfunction getIntervalBox3Quad([[x0, y0], [x1, y1], [x2, y2], [x3, y3]], [t1, t2]) {\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let tDel = qdq(t2, t1);\r\n    let tDel_ = 3 * u * u * abs(tDel[1]); // max absolute error in tDel\r\n    let oMt1 = qdq(qOne, t1);\r\n    let oMt1_ = 3 * u * u * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let $t2 = flo_numerical_1.qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    //let s1 = (1 - t1);  // <= exact by precondition - not anymore\r\n    let s1 = qdq(qOne, t1); // <1>s1\r\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\r\n    let tt1 = qmq(t1, t1); // <2>tt1  \r\n    let ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\r\n    let ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\r\n    let ttt1 = qmq(tt1, t1); // <4>(<2>tt1<0>t1)\r\n    let tts1 = qmq(tt1, s1); // <5>(<2>tt1<1>s1)\r\n    let tss1 = qmq(ss1, t1); // <6>(<4>ss1<0>t1)\r\n    let sss1 = qmq(ss1, s1); // <7>(<4>ss1<1>s1)\r\n    let s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    let tt2 = qmq(t2, t2); // <2>tt2\r\n    let ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\r\n    let ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\r\n    let ttt2 = qmq(tt2, t2); // <4>(<1>tt2<0>t2)\r\n    let tts2 = qmq(tt2, s2); // <5>(<1>tt2<1>s2)\r\n    let tss2 = qmq(ss2, t2); // <6>(<3>ss2<0>t2)\r\n    let sss2 = qmq(ss2, s2); // <7>(<3>ss2<1>s2)\r\n    let _t1 = abs(t1[1]);\r\n    let _s1 = abs(s1[1]);\r\n    let _tt1 = abs(tt1[1]);\r\n    let _ts1 = abs(ts1[1]);\r\n    let _ss1 = abs(ss1[1]);\r\n    let _ttt1 = abs(ttt1[1]);\r\n    let _tts1 = abs(tts1[1]);\r\n    let _tss1 = abs(tss1[1]);\r\n    let _sss1 = abs(sss1[1]);\r\n    let _t2 = abs(t2[1]);\r\n    let _s2 = abs(s2[1]);\r\n    let _tt2 = abs(tt2[1]);\r\n    let _ts2 = abs(ts2[1]);\r\n    let _ss2 = abs(ss2[1]);\r\n    let _ttt2 = abs(ttt2[1]);\r\n    let _tts2 = abs(tts2[1]);\r\n    let _tss2 = abs(tss2[1]);\r\n    let _sss2 = abs(sss2[1]);\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    let _x3 = abs(x3);\r\n    let _y3 = abs(y3);\r\n    //---- x - calculation\r\n    let q8 = qaq(qmd(x3, t1), qmd(x2, s1));\r\n    let q7 = qaq(qaq(qmd(x3, tt1), qmd(2 * x2, ts1)), qmd(x1, ss1));\r\n    let qx0 = qaq(qaq(qmd(x3, ttt1), qmd(x0, sss1)), qmd(3, (qaq(qmd(x2, tts1), qmd(x1, tss1)))));\r\n    let qx1 = qaq(qmq(q7, t2), qmq(qx0, s2));\r\n    let qx2 = qaq(qaq(qmq(q8, tt2), qmq(qx0, ss2)), qmq(qm2(q7), ts2));\r\n    let qx3 = qaq(qaq(qmd(x3, ttt2), qmq(qx0, sss2)), qmd(3, qaq(qmq(q8, tts2), qmq(q7, tss2))));\r\n    let _qx0 = abs(qx0[1]);\r\n    //---- error / abs value calculation\r\n    let _q8 = _x3 * _t1 + _x2 * _s1; // <= <3>\r\n    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))\r\n    let _q7 = _x3 * _tt1 + 2 * _x2 * _ts1 + _x1 * _ss1; // <= <6> \r\n    // q7: <6>(<5>(<3>(x3*<2>tt1) + <4>(2*x2*<3>ts1)) + <5>(x1*<4>ss1));\r\n    _x0 = (_x3 * _ttt1 + _x0 * _sss1) + 3 * (_x2 * _tts1 + _x1 * _tss1); // <= <11>\r\n    // x0: <11>(<9>(x3*<4>ttt1 + x0*<7>sss1) + <10>(3*<9>(<8>(<6>(x2*<5>tts1) + <7>(x1*<6>tss1)))));\r\n    _x1 = _q7 * _t2 + _qx0 * _s2; // <= <15>\r\n    // x1: <15>(<7>(<6>q7*t2) + <14>(<11>x0*<1>s2));\r\n    _x2 = _q8 * _tt2 + _qx0 * _ss2 + 2 * _q7 * _ts2; // <= <20>\r\n    // x2: <20>(<19>(<18>(<3>q8*<2>tt2) + <17>(<11>x0*<4>ss2)) + <11>(2*<6>q7*<3>ts2));\r\n    _x3 = _x3 * _ttt2 + _qx0 * _sss2 + 3 * (_q8 * _tts2 + _q7 * _tss2); // <= <22>\r\n    // x3: <22>(<21>(<5>(x3*<4>ttt2) + <20>(<11>x0*<7>sss2)) + <16>(3*<15>(<10>(<3>q8*<5>tts2) + <14>(<6>q7*<6>tss2)))));\r\n    // max errors: \r\n    _x0 = 11 * u * u * _x0;\r\n    _x1 = 15 * u * u * _x1;\r\n    _x2 = 20 * u * u * _x2;\r\n    _x3 = 22 * u * u * _x3;\r\n    //---- y - calculation\r\n    let r8 = qaq(qmd(y3, t1), qmd(y2, s1));\r\n    let r7 = qaq(qaq(qmd(y3, tt1), qmd(2 * y2, ts1)), qmd(y1, ss1));\r\n    let qy0 = qaq(qaq(qmd(y3, ttt1), qmd(y0, sss1)), qmd(3, (qaq(qmd(y2, tts1), qmd(y1, tss1)))));\r\n    let qy1 = qaq(qmq(r7, t2), qmq(qy0, s2));\r\n    let qy2 = qaq(qaq(qmq(r8, tt2), qmq(qy0, ss2)), qmq(qm2(r7), ts2));\r\n    let qy3 = qaq(qaq(qmd(y3, ttt2), qmq(qy0, sss2)), qmd(3, qaq(qmq(r8, tts2), qmq(r7, tss2))));\r\n    let _qy0 = abs(qy0[1]);\r\n    //---- error / abs value calculation\r\n    let _r8 = _y3 * _t1 + _y2 * _s1; // <= <3>\r\n    let _r7 = _y3 * _tt1 + 2 * _y2 * _ts1 + _y1 * _ss1; // <= <6> \r\n    _y0 = (_y3 * _ttt1 + _y0 * _sss1) + 3 * (_y2 * _tts1 + _y1 * _tss1); // <= <11>\r\n    _y1 = _r7 * _t2 + _qy0 * _s2; // <= <15>\r\n    _y2 = _r8 * _tt2 + _qy0 * _ss2 + 2 * _r7 * _ts2; // <= <20>\r\n    _y3 = _y3 * _ttt2 + _qy0 * _sss2 + 3 * (_r8 * _tts2 + _r7 * _tss2); // <= <22>\r\n    // max errors: \r\n    _y0 = 11 * u * u * _y0;\r\n    _y1 = 15 * u * u * _y1;\r\n    _y2 = 20 * u * u * _y2;\r\n    _y3 = 22 * u * u * _y3;\r\n    let minX = flo_numerical_1.qMin(flo_numerical_1.qMin(qad(qx0, -_x0), qad(qx1, -_x1)), flo_numerical_1.qMin(qad(qx2, -_x2), qad(qx3, -_x3)));\r\n    let maxX = flo_numerical_1.qMax(flo_numerical_1.qMax(qad(qx0, +_x0), qad(qx1, +_x1)), flo_numerical_1.qMax(qad(qx2, +_x2), qad(qx3, +_x3)));\r\n    let minY = flo_numerical_1.qMin(flo_numerical_1.qMin(qad(qy0, -_y0), qad(qy1, -_y1)), flo_numerical_1.qMin(qad(qy2, -_y2), qad(qy3, -_y3)));\r\n    let maxY = flo_numerical_1.qMax(flo_numerical_1.qMax(qad(qy0, +_y0), qad(qy1, +_y1)), flo_numerical_1.qMax(qad(qy2, +_y2), qad(qy3, +_y3)));\r\n    //return [[x0,y0],[x1,y1],[x2,y2],[x3,y3]];\r\n    //console.log(qx0, _x0, qx1, _x1, qx2, _x2, qx3, _x3);\r\n    //console.log(qy0, _y0, qy1, _y1, qy2, _y2, qy3, _y3);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\nexports.getIntervalBox3Quad = getIntervalBox3Quad;\r\nfunction getIntervalBox2Quad([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let tDel = qdq(t2, t1);\r\n    let tDel_ = 3 * u * u * abs(tDel[1]); // max absolute error in tDel\r\n    let oMt1 = qdq(qOne, t1);\r\n    let oMt1_ = 3 * u * u * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let $t2 = flo_numerical_1.qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    //let s1 = (1 - t1);  // <= exact by precondition - not anymore\r\n    let s1 = qdq(qOne, t1); // <1>s1\r\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\r\n    let tt1 = qmq(t1, t1); // <2>tt1  \r\n    let ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\r\n    let ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\r\n    let s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    let tt2 = qmq(t2, t2); // <2>tt2\r\n    let ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\r\n    let ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\r\n    let _t1 = abs(t1[1]);\r\n    let _s1 = abs(s1[1]);\r\n    let _tt1 = abs(tt1[1]);\r\n    let _ts1 = abs(ts1[1]);\r\n    let _ss1 = abs(ss1[1]);\r\n    let _t2 = abs(t2[1]);\r\n    let _s2 = abs(s2[1]);\r\n    let _tt2 = abs(tt2[1]);\r\n    let _ts2 = abs(ts2[1]);\r\n    let _ss2 = abs(ss2[1]);\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    //---- x - calculation\r\n    let q1 = qaq(qaq(qmd(x2, tt1), qmd(2 * x1, ts1)), qmd(x0, ss1));\r\n    let q2 = qaq(qmd(x2, t1), qmd(x1, s1));\r\n    let qx0 = q1;\r\n    let qx1 = qaq(qmq(t2, q2), qmq(s2, q1));\r\n    let qx2 = qaq(qaq(qmd(x2, tt2), qmq(qm2(ts2), q2)), qmq(ss2, q1));\r\n    let _q1 = _x2 * _tt1 + 2 * _x1 * _ts1 + _x0 * _ss1; // <= <7>\r\n    // q1: <7>(<6>(<5>(x2*<2>tt1) + <4>(2*x1*<3>ts1)) + <5>(x0*<4>ss1));\r\n    let _q2 = _x2 * _t1 + _x1 * _s1; // <= <3>\r\n    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));\r\n    _x0 = _q1; // <= <7>\r\n    // x0: <7>q1;\r\n    _x1 = _t2 * _q2 + _s2 * _q1; // <= <11>\r\n    // x1: <11>(<5>(t2*<3>q2) + <10>(<1>s2*<7>q1));\r\n    _x2 = (_tt2 * x2 + 2 * _ts2 * _q2) + _ss2 * _q1; // <= <14>\r\n    // x2: <14>(<9>(<3>(<2>tt2*x2) + <8>(2*<3>ts2*<3>q2)) + <13>(<4>ss2*<7>q1));\r\n    // max errors: \r\n    _x0 = 7 * u * u * _x0;\r\n    _x1 = 11 * u * u * _x1;\r\n    _x2 = 14 * u * u * _x2;\r\n    //---- y - calculation\r\n    let r1 = qaq(qaq(qmd(y2, tt1), qmd(2 * y1, ts1)), qmd(y0, ss1));\r\n    let r2 = qaq(qmd(y2, t1), qmd(y1, s1));\r\n    let qy0 = r1;\r\n    let qy1 = qaq(qmq(t2, r2), qmq(s2, r1));\r\n    let qy2 = qaq(qaq(qmd(y2, tt2), qmq(qm2(ts2), r2)), qmq(ss2, r1));\r\n    let _r1 = _y2 * _tt1 + 2 * _y1 * _ts1 + _y0 * _ss1; // <= <7>\r\n    // r1: <7>(<6>(<5>(y2*<2>tt1) + <4>(2*y1*<3>ts1)) + <5>(y0*<4>ss1));\r\n    let _r2 = _y2 * _t1 + _y1 * _s1; // <= <3>\r\n    // r2: <3>(<1>(y2*t1) + <2>(y1*<1>s1));\r\n    _y0 = _r1; // <= <7>\r\n    // y0: <7>r1;\r\n    _y1 = _t2 * _r2 + _s2 * _r1; // <= <11>\r\n    // y1: <11>(<5>(t2*<3>r2) + <10>(<1>s2*<7>r1));\r\n    _y2 = (_tt2 * y2 + 2 * _ts2 * _r2) + _ss2 * _r1; // <= <14>\r\n    // y2: <14>(<9>(<3>(<2>tt2*y2) + <8>(2*<3>ts2*<3>r2)) + <13>(<4>ss2*<7>r1));\r\n    // max errors: \r\n    _y0 = 7 * u * u * _y0;\r\n    _y1 = 11 * u * u * _y1;\r\n    _y2 = 14 * u * u * _y2;\r\n    let minX = flo_numerical_1.qMin(flo_numerical_1.qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qad(qx2, -_x2));\r\n    let maxX = flo_numerical_1.qMax(flo_numerical_1.qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qad(qx2, +_x2));\r\n    let minY = flo_numerical_1.qMin(flo_numerical_1.qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qad(qy2, -_y2));\r\n    let maxY = flo_numerical_1.qMax(flo_numerical_1.qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qad(qy2, +_y2));\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\nexports.getIntervalBox2Quad = getIntervalBox2Quad;\r\n/**\r\n * @param param0\r\n * @param param1\r\n */\r\nfunction getIntervalBox1Quad([[x0, y0], [x1, y1]], [t1, t2]) {\r\n    // Implementation for lines kept for symmetry - there are obviously much\r\n    // simpler ways to calculate the required box in the case of a line.\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let tDel = qdq(t2, t1);\r\n    let tDel_ = 3 * u * u * abs(tDel[1]); // max absolute error in tDel\r\n    let oMt1 = qdq(qOne, t1);\r\n    let oMt1_ = 3 * u * u * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let $t2 = flo_numerical_1.qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    let s1 = qdq(qOne, t1); // <1>s1\r\n    let s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    let _t1 = abs(t1[1]);\r\n    let _s1 = abs(s1[1]);\r\n    let _t2 = abs(t2[1]);\r\n    let _s2 = abs(s2[1]);\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    //---- x - calculation\r\n    let qx0 = qaq(qmd(x1, t1), qmd(x0, s1));\r\n    let qx1 = qaq(qmd(x1, t2), qmq(qx0, s2));\r\n    _x0 = _x1 * _t1 + _x0 * _s1; // <= <3>\r\n    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));\r\n    _x1 = _x1 * _t2 + _x0 * _s2; // <= <7>\r\n    // x1: <7>(<1>(x1*t2) + <6>(<3>x0*<1>s2));\r\n    // max errors: \r\n    _x0 = 3 * u * _x0;\r\n    _x1 = 7 * u * _x1;\r\n    //---- y - calculation\r\n    let qy0 = qaq(qmd(y1, t1), qmd(y0, s1));\r\n    let qy1 = qaq(qmd(y1, t2), qmq(qy0, s2));\r\n    _y0 = _y1 * _t1 + _y0 * _s1; // <= <3>\r\n    _y1 = _y1 * _t2 + _y0 * _s2; // <= <7>\r\n    // max errors: \r\n    _y0 = 3 * u * _y0;\r\n    _y1 = 7 * u * _y1;\r\n    let minX = flo_numerical_1.qMin(qad(qx0, -_x0), qad(qx1, -_x1));\r\n    let maxX = flo_numerical_1.qMax(qad(qx0, +_x0), qad(qx1, +_x1));\r\n    let minY = flo_numerical_1.qMin(qad(qy0, -_y0), qad(qy1, -_y1));\r\n    let maxY = flo_numerical_1.qMax(qad(qy0, +_y0), qad(qy1, +_y1));\r\n    //return [[x0,y0],[x1,y1]];\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\nexports.getIntervalBox1Quad = getIntervalBox1Quad;\r\nfunction getIntervalBoxExactTQuad(ps, t) {\r\n    let _pS = ps[0];\r\n    let _pE = ps[ps.length - 1];\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        let pSx = [0, _pS[0]];\r\n        let pSy = [0, _pS[1]];\r\n        return [\r\n            [pSx, pSy],\r\n            [pSx, pSy]\r\n        ];\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        let pEx = [0, _pE[0]];\r\n        let pEy = [0, _pE[1]];\r\n        return [\r\n            [pEx, pEy],\r\n            [pEx, pEy]\r\n        ];\r\n    }\r\n    let { p, pE } = eval_de_casteljau_with_err_1.evalDeCasteljauWithErrQuad(ps, t);\r\n    return [\r\n        [qad(p[0], -pE[0]), qad(p[1], -pE[1])],\r\n        [qad(p[0], +pE[0]), qad(p[1], +pE[1])]\r\n    ];\r\n}\r\nexports.getIntervalBoxExactTQuad = getIntervalBoxExactTQuad;\r\n//# sourceMappingURL=get-interval-box-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-quad.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eval_de_casteljau_with_err_1 = __webpack_require__(/*! ../../../local-properties-at-t/t-to-xy/eval-de-casteljau-with-err */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau-with-err.js\");\r\nconst u = Number.EPSILON / 2;\r\nconst abs = Math.abs;\r\n/**\r\n * Returns the approximate bezier curve that is the curve from t1 to t2 in such\r\n * a way that the control points axis-aligned-box of the newly returned curve is\r\n * guaranteed to engulf the true (numerically exact) curve control points\r\n * axis-aligned box.\r\n * * **precondition** t1 < t2\r\n * @param ps an order 1,2 or 3 bezier curve\r\n * @param t1 first parameter value\r\n * @param t2 second parameter value\r\n */\r\nfunction getIntervalBox(ps, ts) {\r\n    if (ts[0] !== ts[1]) {\r\n        if (ps.length === 4) {\r\n            return getIntervalBox3(ps, ts);\r\n        }\r\n        if (ps.length === 3) {\r\n            return getIntervalBox2(ps, ts);\r\n        }\r\n        return getIntervalBox1(ps, ts);\r\n    }\r\n    else { // ts[0] === ts[1]\r\n        return getIntervalBoxExactT(ps, ts[0]);\r\n    }\r\n}\r\nexports.getIntervalBox = getIntervalBox;\r\nfunction getIntervalBox3([[x0, y0], [x1, y1], [x2, y2], [x3, y3]], [t1, t2]) {\r\n    /* from split.py (Python - Sympy)\r\n    let t2 = (t2-t1)/(1-t1);\r\n    let x0_ = t1**3*x3 + 3*t1**2*x2*(1 - t1) + 3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3;\r\n    let x1_ = t2*(t1**2*x3 + 2*t1*x2*(1 - t1) + x1*(1 - t1)**2) + (1 - t2)*(t1**3*x3 +\r\n            3*t1**2*x2*(1 - t1) + 3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3);\r\n    let x2_ = t2**2*(t1*x3 + x2*(1 - t1)) + t2*(1 - t2)*(2*t1**2*x3 + 4*t1*x2*(1 - t1) + 2*x1*(1 - t1)**2) +\r\n        (1 - t2)**2*(t1**3*x3 + 3*t1**2*x2*(1 - t1) + 3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3);\r\n    let x3_ = t2**3*x3 + t2**2*(1 - t2)*(3*t1*x3 + 3*x2*(1 - t1)) + t2*(1 - t2)**2*(3*t1**2*x3 +\r\n            6*t1*x2*(1 - t1) + 3*x1*(1 - t1)**2) + (1 - t2)**3*(t1**3*x3 + 3*t1**2*x2*(1 - t1) +\r\n            3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3);\r\n\r\n    let y0_ = t1**3*y3 + 3*t1**2*y2*(1 - t1) + 3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3;\r\n    let y1_ = t2*(t1**2*y3 + 2*t1*y2*(1 - t1) + y1*(1 - t1)**2) + (1 - t2)*(t1**3*y3 +\r\n            3*t1**2*y2*(1 - t1) + 3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3);\r\n    let y2_ = t2**2*(t1*y3 + y2*(1 - t1)) + t2*(1 - t2)*(2*t1**2*y3 + 4*t1*y2*(1 - t1) + 2*y1*(1 - t1)**2) +\r\n        (1 - t2)**2*(t1**3*y3 + 3*t1**2*y2*(1 - t1) + 3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3);\r\n    let y3_ = t2**3*y3 + t2**2*(1 - t2)*(3*t1*y3 + 3*y2*(1 - t1)) + t2*(1 - t2)**2*(3*t1**2*y3 +\r\n            6*t1*y2*(1 - t1) + 3*y1*(1 - t1)**2) + (1 - t2)**3*(t1**3*y3 + 3*t1**2*y2*(1 - t1) +\r\n            3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3);\r\n        */\r\n    t2 = ((t2 - t1) / (1 - t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    //let s1 = (1 - t1);  // <= exact by precondition\r\n    let s1 = (1 - t1); // <1>s1\r\n    let tt1 = t1 * t1; // <1>tt1  <- error by counters\r\n    let ts1 = t1 * s1; // <2>(<0>t1<1>s1)\r\n    let ss1 = s1 * s1; // <3>(<1>s1<1>s1)\r\n    let ttt1 = tt1 * t1; // <2>(<1>tt1<0>t1)\r\n    let tts1 = tt1 * s1; // <3>(<1>tt1<1>s1)\r\n    let tss1 = ss1 * t1; // <4>(<3>ss1<0>t1)\r\n    let sss1 = ss1 * s1; // <5>(<3>ss1<1>s1)\r\n    let s2 = (1 - t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    let tt2 = t2 * t2; // <1>tt2\r\n    let ts2 = t2 * s2; // <2>(<0>t2<1>s2)\r\n    let ss2 = s2 * s2; // <3>(<1>s2<1>s2)\r\n    let ttt2 = tt2 * t2; // <2>(<1>tt2<0>t2)\r\n    let tts2 = tt2 * s2; // <3>(<1>tt2<1>s2)\r\n    let tss2 = ss2 * t2; // <4>(<3>ss2<0>t2)\r\n    let sss2 = ss2 * s2; // <5>(<3>ss2<1>s2)\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    let _x3 = abs(x3);\r\n    let _y3 = abs(y3);\r\n    //---- x - calculation\r\n    let q8 = x3 * t1 + x2 * s1;\r\n    let q7 = (x3 * tt1 + 2 * x2 * ts1) + x1 * ss1;\r\n    x0 = (x3 * ttt1 + x0 * sss1) + 3 * (x2 * tts1 + x1 * tss1);\r\n    x1 = q7 * t2 + x0 * s2;\r\n    x2 = (q8 * tt2 + x0 * ss2) + 2 * q7 * ts2;\r\n    x3 = (x3 * ttt2 + x0 * sss2) + 3 * (q8 * tts2 + q7 * tss2);\r\n    //---- error / abs value calculation\r\n    let _q8 = _x3 * t1 + _x2 * s1; // <= <3>\r\n    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))\r\n    let _q7 = _x3 * tt1 + 2 * _x2 * ts1 + _x1 * ss1; // <= <5> \r\n    // q7: <5>(<4>(<2>(x3*<1>tt1) + <3>(2*x2*<2>ts1)) + <4>(x1*<3>ss1));\r\n    _x0 = (_x3 * ttt1 + _x0 * sss1) + 3 * (_x2 * tts1 + _x1 * tss1); // <= <8>\r\n    // x0: <8>(<7>(x3*<2>ttt1 + x0*<5>sss1) + <7>(3*<6>(<4>(x2*<3>tts1) + <5>(x1*<4>tss1))));\r\n    _x1 = _q7 * t2 + _x0 * s2; // <= <7>\r\n    // x1: <11>(<6>(<5>q7*t2) + <10>(<8>x0*<1>s2));\r\n    _x2 = _q8 * tt2 + _x0 * ss2 + 2 * _q7 * ts2; // <= <9>\r\n    // x2: <14>(<13>(<5>(<3>q8*<1>tt2) + <12>(<8>x0*<3>ss2)) + <8>(2*<5>q7*<2>ts2));\r\n    _x3 = _x3 * ttt2 + _x0 * sss2 + 3 * (_q8 * tts2 + _q7 * tss2); // <= <13>\r\n    // x3: <16>(<15>(<3>(x3*<2>ttt2) + <14>(<8>x0*<5>sss2)) + <12>(3*<11>(<7>(<3>q8*<3>tts2 + <10>(<5>q7*<4>tss2)))));\r\n    // max errors: \r\n    _x0 = 8 * u * _x0;\r\n    _x1 = 11 * u * _x1;\r\n    _x2 = 14 * u * _x2;\r\n    _x3 = 16 * u * _x3;\r\n    //---- y - calculation\r\n    let r8 = y3 * t1 + y2 * s1;\r\n    let r7 = (y3 * tt1 + 2 * y2 * ts1) + y1 * ss1;\r\n    y0 = (y3 * ttt1 + y0 * sss1) + 3 * (y2 * tts1 + y1 * tss1);\r\n    y1 = r7 * t2 + y0 * s2;\r\n    y2 = (r8 * tt2 + y0 * ss2) + 2 * r7 * ts2;\r\n    y3 = (y3 * ttt2 + y0 * sss2) + 3 * (r8 * tts2 + r7 * tss2);\r\n    let _r8 = _y3 * t1 + _y2 * s1;\r\n    let _r7 = _y3 * tt1 + 2 * _y2 * ts1 + _y1 * ss1;\r\n    _y0 = _y3 * ttt1 + _y0 * sss1 + 3 * (_y2 * tts1 + _y1 * tss1);\r\n    _y1 = _r7 * t2 + _y0 * s2;\r\n    _y2 = _r8 * tt2 + _y0 * ss2 + 2 * _r7 * ts2;\r\n    _y3 = (_y3 * ttt2 + _y0 * sss2) + 3 * (_r8 * tts2 + _r7 * tss2);\r\n    // max errors: \r\n    _y0 = 8 * u * _y0;\r\n    _y1 = 11 * u * _y1;\r\n    _y2 = 14 * u * _y2;\r\n    _y3 = 16 * u * _y3;\r\n    let minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2, x3 - _x3);\r\n    let maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2, x3 + _x3);\r\n    let minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2, y3 - _y3);\r\n    let maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2, y3 + _y3);\r\n    //return [[x0,y0],[x1,y1],[x2,y2],[x3,y3]];\r\n    //console.log(x0, _x0, x1, _x1, x2, _x2, x3, _x3);\r\n    //console.log(x0, _x0, x1, _x1, x2, _x2, x3, _x3);\r\n    //console.log(y0, _y0, y1, _y1, y2, _y2, y3, _y3);\r\n    //console.log(y0, _y0, y1, _y1, y2, _y2, y3, _y3);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\nexports.getIntervalBox3 = getIntervalBox3;\r\nfunction getIntervalBox2([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {\r\n    /* from split.py (Python - Sympy)\r\n    let t2 = (t2-t1)/(1-t1);\r\n\r\n    let x0_ = t1**2*x2 + 2*t1*x1*(1 - t1) + x0*(1 - t1)**2;\r\n    let x1_ = t2*(t1*x2 + x1*(1 - t1)) + (1 - t2)*(t1**2*x2 + 2*t1*x1*(1 - t1) + x0*(1 - t1)**2);\r\n    let x2_ = t2**2*x2 + t2*(1 - t2)*(2*t1*x2 + 2*x1*(1 - t1)) + (1 - t2)**2*(t1**2*x2 + 2*t1*x1*(1 - t1) + x0*(1 - t1)**2);\r\n\r\n    let y0_ = t1**2*y2 + 2*t1*y1*(1 - t1) + y0*(1 - t1)**2;\r\n    let y1_ = t2*(t1*y2 + y1*(1 - t1)) + (1 - t2)*(t1**2*y2 + 2*t1*y1*(1 - t1) + y0*(1 - t1)**2);\r\n    let y2_ = t2**2*y2 + t2*(1 - t2)*(2*t1*y2 + 2*y1*(1 - t1)) + (1 - t2)**2*(t1**2*y2 + 2*t1*y1*(1 - t1) + y0*(1 - t1)**2);\r\n    */\r\n    t2 = ((t2 - t1) / (1 - t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    //let s1 = (1 - t1);  // <= exact by precondition\r\n    let s1 = (1 - t1); // <1>s1\r\n    let tt1 = t1 * t1; // <1>tt1  <- error by counters\r\n    let ts1 = t1 * s1; // <2>(<0>t1<1>s1)\r\n    let ss1 = s1 * s1; // <3>(<1>s1<1>s1)\r\n    let s2 = (1 - t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    let tt2 = t2 * t2; // <1>tt2\r\n    let ts2 = t2 * s2; // <2>(<0>t2<1>s2)\r\n    let ss2 = s2 * s2; // <3>(<1>s2<1>s2)\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    //---- x - calculation\r\n    let q1 = (x2 * tt1 + 2 * x1 * ts1) + x0 * ss1;\r\n    let q2 = x2 * t1 + x1 * s1;\r\n    x0 = q1;\r\n    x1 = t2 * q2 + s2 * q1;\r\n    x2 = (tt2 * x2 + 2 * ts2 * q2) + ss2 * q1;\r\n    let _q1 = _x2 * tt1 + 2 * _x1 * ts1 + _x0 * ss1; // <= <5>\r\n    // q1: <5>(<4>(<2>(x2*<1>tt1) + <3>(2*x1*<2>ts1)) + <4>(x0*<3>ss1));\r\n    let _q2 = _x2 * t1 + _x1 * s1; // <= <3>\r\n    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));\r\n    _x0 = _q1; // <= <5>\r\n    // x0: <5>q1;\r\n    _x1 = t2 * _q2 + s2 * _q1; // <= <8>\r\n    // x1: <8>(<4>(t2*<3>q2) + <7>(<1>s2*<5>q1));\r\n    _x2 = (tt2 * x2 + 2 * ts2 * _q2) + ss2 * _q1; // <= <10>\r\n    // x2: <10>(<9>(<2>(<1>tt2*x2) + <6>(2*<2>ts2*<3>q2)) + <9>(<3>ss2*<5>q1));\r\n    // max errors: \r\n    _x0 = 5 * u * _x0;\r\n    _x1 = 8 * u * _x1;\r\n    _x2 = 10 * u * _x2;\r\n    //---- y - calculation\r\n    let r1 = (y2 * tt1 + 2 * y1 * ts1) + y0 * ss1;\r\n    let r2 = y2 * t1 + y1 * s1;\r\n    y0 = r1;\r\n    y1 = t2 * r2 + s2 * r1;\r\n    y2 = (tt2 * y2 + 2 * ts2 * r2) + ss2 * r1;\r\n    let _r1 = _y2 * tt1 + 2 * _y1 * ts1 + _y0 * ss1; // <= <5>\r\n    let _r2 = _y2 * t1 + _y1 * s1; // <= <3>\r\n    _y0 = _r1; // <= <5>\r\n    _y1 = t2 * _r2 + s2 * _r1; // <= <8>\r\n    _y2 = (tt2 * y2 + 2 * ts2 * _r2) + ss2 * _r1; // <= <10>\r\n    // max errors: \r\n    _y0 = 5 * u * _y0;\r\n    _y1 = 8 * u * _y1;\r\n    _y2 = 10 * u * _y2;\r\n    let minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2);\r\n    let maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2);\r\n    let minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2);\r\n    let maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2);\r\n    //return [[x0,y0],[x1,y1],[x2,y2]];\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\nexports.getIntervalBox2 = getIntervalBox2;\r\n/**\r\n * @param param0\r\n * @param param1\r\n */\r\nfunction getIntervalBox1([[x0, y0], [x1, y1]], [t1, t2]) {\r\n    // Implementation for lines kept for symmetry - there are obviously much\r\n    // simpler ways to calculate the required box in the case of a line.\r\n    /* from split.py (Python - Sympy)\r\n    let t2 = (t2-t1)/(1-t1);\r\n\r\n    let x0_ = t1*x1 + x0*(1 - t1)\r\n    let x1_ = t2*x1 + (1 - t2)*(t1*x1 + x0*(1 - t1))\r\n\r\n    let y0_ = t1*y1 + y0*(1 - t1)\r\n    let y1_ = t2*y1 + (1 - t2)*(t1*y1 + y0*(1 - t1))\r\n    */\r\n    t2 = ((t2 - t1) / (1 - t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    let s1 = (1 - t1); // <1>s1\r\n    let s2 = (1 - t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    // use a relative error bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    //---- x - calculation\r\n    x0 = x1 * t1 + x0 * s1;\r\n    x1 = x1 * t2 + x0 * s2;\r\n    _x0 = _x1 * t1 + _x0 * s1; // <= <3>\r\n    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));\r\n    _x1 = _x1 * t2 + _x0 * s2; // <= <3>\r\n    // x1: <6>(<1>(x1*t2) + <5>(<3>x0*<1>s2));\r\n    // max errors: \r\n    _x0 = 3 * u * _x0;\r\n    _x1 = 6 * u * _x1;\r\n    //---- y - calculation\r\n    y0 = y1 * t1 + y0 * s1;\r\n    y1 = y1 * t2 + y0 * s2;\r\n    _y0 = _y1 * t1 + _y0 * s1; // <= <3>\r\n    _y1 = _y1 * t2 + _y0 * s2; // <= <6>\r\n    // max errors: \r\n    _y0 = 3 * u * _y0;\r\n    _y1 = 6 * u * _y1;\r\n    let minX = Math.min(x0 - _x0, x1 - _x1);\r\n    let maxX = Math.max(x0 + _x0, x1 + _x1);\r\n    let minY = Math.min(y0 - _y0, y1 - _y1);\r\n    let maxY = Math.max(y0 + _y0, y1 + _y1);\r\n    //return [[x0,y0],[x1,y1]];\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\nexports.getIntervalBox1 = getIntervalBox1;\r\nfunction getIntervalBoxExactT(ps, t) {\r\n    let _pS = ps[0];\r\n    let _pE = ps[ps.length - 1];\r\n    if (t === 0) {\r\n        return [_pS, _pS];\r\n    }\r\n    else if (t === 1) {\r\n        return [_pE, _pE];\r\n    }\r\n    let { p, pE } = eval_de_casteljau_with_err_1.evalDeCasteljauWithErr(ps, t);\r\n    return [\r\n        [p[0] - pE[0], p[1] - pE[1]],\r\n        [p[0] + pE[0], p[1] + pE[1]]\r\n    ];\r\n}\r\nexports.getIntervalBoxExactT = getIntervalBoxExactT;\r\n//# sourceMappingURL=get-interval-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/flatness.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/flatness.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst length_upper_bound_1 = __webpack_require__(/*! ./length/length-upper-bound */ \"./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns a flatness measure of the given curve - calculated as the total\r\n * distance between consecutive control points divided by the distance between\r\n * the endpoints.\r\n * @param ps An order 1,2 or 3 bezier curve.\r\n */\r\nfunction flatness(ps) {\r\n    return length_upper_bound_1.lengthUpperBound(ps) / flo_vector2d_1.distanceBetween(ps[0], ps[ps.length - 1]);\r\n}\r\nexports.flatness = flatness;\r\n//# sourceMappingURL=flatness.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/flatness.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/get-inflection-points.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/get-inflection-points.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Returns the given bezier's approximate inflection points.\r\n **/\r\nfunction getInflectionPoints(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\r\n    let ax = x1 - x0;\r\n    let ay = y1 - y0;\r\n    let bx = x2 - x1 - ax;\r\n    let by = y2 - y1 - ay;\r\n    let cx = x3 - x2 - ax - (2 * bx);\r\n    let cy = y3 - y2 - ay - (2 * by);\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\r\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\r\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\r\n    let a = bx * cy - by * cx;\r\n    let b = ax * cy - ay * cx;\r\n    let c = ax * by - ay * bx;\r\n    let inflectionTs = flo_poly_1.allRoots([a, b, c], 0, 1);\r\n    return inflectionTs.map(t => eval_de_casteljau_1.evalDeCasteljau(ps, t));\r\n}\r\nexports.getInflectionPoints = getInflectionPoints;\r\n//# sourceMappingURL=get-inflection-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/get-inflection-points.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length-squared-upper-bound.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length-squared-upper-bound.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns an upper bound for the length of the given order 1, 2 or 3 bezier\r\n * curve.\r\n *\r\n * The curve has lenhth 0 iff this bound is zero.\r\n *\r\n * This bound is a bit loose as it uses the sum of the straight-line distances\r\n * between control points as a measure.\r\n * @param ps\r\n */\r\nfunction lengthSquaredUpperBound(ps) {\r\n    let totalLength = 0;\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        totalLength += flo_vector2d_1.squaredDistanceBetween(ps[i], ps[i + 1]);\r\n    }\r\n    return totalLength;\r\n}\r\nexports.lengthSquaredUpperBound = lengthSquaredUpperBound;\r\n//# sourceMappingURL=length-squared-upper-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/length/length-squared-upper-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns an upper bound for the length of the given bezier curve - this bound\r\n * is not very strict as it uses the sum of the straight-line distances between\r\n * control points as a measure.\r\n * @param ps\r\n */\r\nfunction lengthUpperBound(ps) {\r\n    let totalLength = 0;\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        totalLength += flo_vector2d_1.distanceBetween(ps[i], ps[i + 1]);\r\n    }\r\n    return totalLength;\r\n}\r\nexports.lengthUpperBound = lengthUpperBound;\r\n//# sourceMappingURL=length-upper-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/length/length.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/length/length.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ds_1 = __webpack_require__(/*! ../../local-properties-at-t/ds */ \"./node_modules/flo-bezier3/node/local-properties-at-t/ds.js\");\r\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nfunction length(interval, ps) {\r\n    let fs = [, , length1, length2, length3];\r\n    function f(ps) {\r\n        return fs[ps.length](interval, ps);\r\n    }\r\n    // Curry\r\n    return ps === undefined ? f : f(ps);\r\n}\r\nexports.length = length;\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\nfunction length3(interval, ps) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && x2 === x3 &&\r\n        y0 === y1 && y1 === y2 && y2 === y3) {\r\n        return 0;\r\n    }\r\n    const evDs = ds_1.ds(ps);\r\n    return flo_gauss_quadrature_1.gaussQuadrature(evDs, interval);\r\n}\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * Unused because it is not numerically stable in its current form.\r\n * See https://gist.github.com/tunght13488/6744e77c242cc7a94859\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\n/*\r\nfunction length2(interval: number[], ps: number[][]) {\r\n    if (interval[0] === interval[1]) { return 0; }\r\n\r\n    let [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {\r\n        return 0;\r\n    }\r\n\r\n    let [[x0, y0], [x1, y1], [x2, y2]] =\r\n            fromTo(ps)(interval[0], interval[1]);\r\n\r\n    let ax = x0 - 2*x1 + x2;\r\n    let ay = y0 - 2*y1 + y2;\r\n    let bx = 2*x1 - 2*x0;\r\n    let by = 2*y1 - 2*y0;\r\n\r\n    let A = 4 * (ax*ax + ay*ay);\r\n    let B = 4 * (ax*bx + ay*by);\r\n    let C = bx*bx + by*by;\r\n\r\n    let Sabc = 2*Math.sqrt(A+B+C);\r\n    let A_2 = Math.sqrt(A);\r\n    let A_32 = 2*A*A_2;\r\n    let C_2 = 2*Math.sqrt(C);\r\n    let BA = B/A_2;\r\n\r\n    return (\r\n        A_32*Sabc + A_2*B*(Sabc - C_2) +\r\n        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))\r\n    ) / (4*A_32);\r\n}\r\n*/\r\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * @param ps A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @param interval The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\nfunction length2(interval, ps) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // Ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {\r\n        return 0;\r\n    }\r\n    const evDs = ds_1.ds(ps);\r\n    return flo_gauss_quadrature_1.gaussQuadrature(evDs, interval);\r\n}\r\nfunction length1(interval, ps) {\r\n    let [t1, t2] = interval;\r\n    if (t1 === t2) {\r\n        return 0;\r\n    }\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && y0 === y1) {\r\n        return 0;\r\n    }\r\n    let p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];\r\n    let p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];\r\n    return flo_vector2d_1.distanceBetween(p1, p2);\r\n}\r\n//# sourceMappingURL=length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/length/length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/total-curvature.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/total-curvature.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\r\nconst evaluate_dx_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-dxy/evaluate-dx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-dxy/evaluate-dy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js\");\r\nconst evaluate_ddx_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-ddxy/evaluate-ddx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddx.js\");\r\nconst evaluate_ddy_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-ddxy/evaluate-ddy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddy.js\");\r\nfunction totalAbsoluteCurvature(ps, interval) {\r\n    function f(interval = [0, 1]) {\r\n        // Numerically integrate the absolute curvature\r\n        let result = flo_gauss_quadrature_1.gaussQuadrature(t => Math.abs(κds(ps)(t)), interval);\r\n        return result;\r\n    }\r\n    // Curry\r\n    return interval === undefined ? f : f(interval);\r\n}\r\nexports.totalAbsoluteCurvature = totalAbsoluteCurvature;\r\nfunction totalCurvature(ps, interval) {\r\n    //const tanPs = tangent(ps);\r\n    function f(interval) {\r\n        return flo_gauss_quadrature_1.gaussQuadrature(κds(ps), interval);\r\n        // TODO\r\n        /*\r\n        let [a,b] = interval;\r\n        let tangentA = tanPs(a);\r\n        let tangentB = tanPs(b);\r\n        let sinθ = Vector.cross(tanA, tanB)\r\n        */\r\n    }\r\n    // Curry\r\n    return interval === undefined ? f : f(interval);\r\n}\r\nexports.totalCurvature = totalCurvature;\r\nfunction κds(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    const evDdx = evaluate_ddx_1.evaluateDdx(ps);\r\n    const evDdy = evaluate_ddy_1.evaluateDdy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let ddx = evDdx(t);\r\n        let ddy = evDdy(t);\r\n        let a = dx * ddy - dy * ddx;\r\n        let b = dx * dx + dy * dy;\r\n        return a / b;\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\n//# sourceMappingURL=total-curvature.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/total-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/type/is-cubic-really-quad.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/type/is-cubic-really-quad.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst u = Number.EPSILON / 2;\r\nconst abs = Math.abs;\r\n/**\r\n * Returns true if the given bezier curve is really a quadratic curve.\r\n * * there is no limit on the bitlength of the coefficients\r\n * @param ps a cubic bezier curve\r\n */\r\nfunction isCubicReallyQuad(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // the if in the line below is unrolled\r\n    //if ((x3 + 3*x1) - (x0 + 3*x2) === 0 && \r\n    //    (y3 + 3*y1) - (y0 + 3*y2) === 0) {\r\n    // Calculate an approximation of the above with error bounds and use it as\r\n    // a fast filter.\r\n    let u1 = 3 * x1;\r\n    let u1_ = abs(3 * x1); // the absolute error in u1\r\n    let u2 = x3 + u1;\r\n    let u2_ = u1_ + abs(u2); // the absolute error in u2\r\n    let v1 = 3 * x2;\r\n    let v1_ = abs(3 * x2); // the absolute error in v1\r\n    let v2 = x0 + v1;\r\n    let v2_ = v1_ + abs(v2); // the absolute error in v2\r\n    let w = u2 - v2;\r\n    let w_ = u * (u2_ + v2_ + abs(w)); // the absolute error in w\r\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\r\n    if (abs(w) - w_ > 0) {\r\n        //console.log('fast filtered 1');\r\n        return false;\r\n    }\r\n    let q1 = 3 * y1;\r\n    let q1_ = abs(3 * y1); // the absolute error in q1\r\n    let q2 = y3 + q1;\r\n    let q2_ = q1_ + abs(q2); // the absolute error in q2\r\n    let r1 = 3 * y2;\r\n    let r1_ = abs(3 * y2); // the absolute error in r1\r\n    let r2 = y0 + r1;\r\n    let r2_ = r1_ + abs(r2); // the absolute error in r2\r\n    let s = q2 - r2;\r\n    let s_ = u * (q2_ + r2_ + abs(s)); // the absolute error in s\r\n    if (abs(s) - s_ > 0) {\r\n        //console.log('fast filtered 2');\r\n        return false;\r\n    }\r\n    //console.log('unable to filter - go slow and exact')\r\n    return (flo_numerical_1.sign(flo_numerical_1.expansionDiff(flo_numerical_1.fastExpansionSum([x3], flo_numerical_1.twoProduct(3, x1)), flo_numerical_1.fastExpansionSum([x0], flo_numerical_1.twoProduct(3, x2)))) === 0 &&\r\n        flo_numerical_1.sign(flo_numerical_1.expansionDiff(flo_numerical_1.fastExpansionSum([y3], flo_numerical_1.twoProduct(3, y1)), flo_numerical_1.fastExpansionSum([y0], flo_numerical_1.twoProduct(3, y2)))) === 0);\r\n}\r\nexports.isCubicReallyQuad = isCubicReallyQuad;\r\n//# sourceMappingURL=is-cubic-really-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/type/is-cubic-really-quad.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/type/is-line.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/type/is-line.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns true if the given bezier is a line or a line in diguise, i.e. if all\r\n * control points are collinear.\r\n *\r\n * Robust: Robust for any bitlength of the given coordinates.\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction isLine(ps) {\r\n    if (ps.length === 2) {\r\n        // Line\r\n        return true;\r\n    }\r\n    if (ps.length === 3) {\r\n        // Quadratic bezier\r\n        return flo_numerical_1.orient2d(ps[0], ps[1], ps[2]) === 0;\r\n    }\r\n    if (ps.length === 4) {\r\n        // Cubic bezier\r\n        return (flo_numerical_1.orient2d(ps[0], ps[1], ps[2]) === 0 &&\r\n            flo_numerical_1.orient2d(ps[1], ps[2], ps[3]) === 0 &&\r\n            // The below check is necessary for if ps[1] === ps[2]\r\n            flo_numerical_1.orient2d(ps[0], ps[2], ps[3]) === 0);\r\n    }\r\n}\r\nexports.isLine = isLine;\r\n/**\r\n * Returns true if the given bezier degenerates to a horizontal line (possibly\r\n * self-overlapping)\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction isHorizontalLine(ps) {\r\n    let y = ps[0][1];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][1] !== y) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isHorizontalLine = isHorizontalLine;\r\n/**\r\n * Returns true if the given bezier degenerates to a vertical line (possibly\r\n * self-overlapping)\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction isVerticalLine(ps) {\r\n    let x = ps[0][0];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][0] !== x) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isVerticalLine = isVerticalLine;\r\n//# sourceMappingURL=is-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/type/is-line.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/type/is-quad-flat.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/type/is-quad-flat.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vector = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst is_quad_obtuse_1 = __webpack_require__(/*! ./is-quad-obtuse */ \"./node_modules/flo-bezier3/node/global-properties/type/is-quad-obtuse.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Returns true if the given quadratic bezier curve is acute (see isQuadObtuse)\r\n * and can be approximated with a line segment with maximum Hausdorff distance\r\n * <= the given tolerance.\r\n * @param ps A quadratic bezier curve.\r\n */\r\nfunction isQuadFlat(ps, tolerance) {\r\n    if (is_quad_obtuse_1.isQuadObtuse(ps)) {\r\n        return false;\r\n    }\r\n    let [[x1, y1], , [x2, y2]] = ps;\r\n    if (x1 === x2 && y1 === y2) {\r\n        return true;\r\n    }\r\n    let [x0, y0] = eval_de_casteljau_1.evalDeCasteljau(ps, 0.5);\r\n    let numerator = Math.pow(((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1), 2);\r\n    let denominator = vector.squaredDistanceBetween(ps[0], ps[2]);\r\n    let dSquared = Math.abs(numerator / denominator);\r\n    return dSquared < Math.pow(tolerance, 2);\r\n}\r\nexports.isQuadFlat = isQuadFlat;\r\n//# sourceMappingURL=is-quad-flat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/type/is-quad-flat.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/type/is-quad-obtuse.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/type/is-quad-obtuse.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns true if the given quadratic bezier is obtuse, false otherwise (i.e.\r\n * false if acute).\r\n * Obtuse here is defined as follows: Let the quad form a triangle through its\r\n * control points P0, P1, P2 where P0 and P2 are the endpoints. If both interior\r\n * angles ∠P0 and ∠P2 are <= 90 degrees then the quad is considered acute,\r\n * otherwise it is considered obtuse.\r\n */\r\nfunction isQuadObtuse(ps) {\r\n    let v0 = flo_vector2d_1.fromTo(ps[0], ps[1]);\r\n    let v1 = flo_vector2d_1.fromTo(ps[1], ps[2]);\r\n    let v2 = flo_vector2d_1.fromTo(ps[2], ps[0]);\r\n    let angleP0Obtuse = flo_vector2d_1.dot(v2, v0) > 0;\r\n    let angleP2Obtuse = flo_vector2d_1.dot(v1, v2) > 0;\r\n    return angleP0Obtuse || angleP2Obtuse;\r\n}\r\nexports.isQuadObtuse = isQuadObtuse;\r\n//# sourceMappingURL=is-quad-obtuse.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/type/is-quad-obtuse.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/global-properties/type/is-self-overlapping.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/global-properties/type/is-self-overlapping.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_line_1 = __webpack_require__(/*! ./is-line */ \"./node_modules/flo-bezier3/node/global-properties/type/is-line.js\");\r\n/**\r\n * Returns true if the given bezier is a line and self-overlapping, i.e. if it\r\n * intersects itself at an infinite number of points.\r\n *\r\n * Note: A bezier curve can only intersect itself at an infinite number of\r\n * points if is a self-overlapping line.\r\n *\r\n * Robust: This function is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n */\r\nfunction isSelfOverlapping(ps) {\r\n    if (!is_line_1.isLine(ps)) {\r\n        return false;\r\n    }\r\n    // Check if control points are non-strict monotone\r\n    let xs = ps.map(p => p[0]);\r\n    let ys = ps.map(p => p[1]);\r\n    return !(isMonotone(xs) && isMonotone(ys));\r\n}\r\nexports.isSelfOverlapping = isSelfOverlapping;\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone increasing.\r\n * @param xs An array of numbers\r\n */\r\nfunction isMonotoneIncreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] > xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone decreasing.\r\n * @param xs An array of numbers\r\n */\r\nfunction isMonotoneDecreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] < xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isMonotone(xs) {\r\n    return isMonotoneIncreasing(xs) || isMonotoneDecreasing(xs);\r\n}\r\n//# sourceMappingURL=is-self-overlapping.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/global-properties/type/is-self-overlapping.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qdq = flo_numerical_1.qDiffQuad;\r\n/**\r\n * Returns the exact implicit form of the given linear bezier.\r\n * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm1Exact_(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    let [[a1, a0], [b1, b0]] = get_xy_1.getXY(ps);\r\n    let vₓ = -b1;\r\n    let vᵧ = a1;\r\n    let v = qdq(tp(a0, b1), tp(a1, b0));\r\n    return { vₓ, vᵧ, v };\r\n}\r\nexports.getImplicitForm1Exact_ = getImplicitForm1Exact_;\r\n//# sourceMappingURL=get-implicit-form1-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the exact implicit form of the given linear bezier.\r\n * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm1Exact(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    let [a1, a0] = get_x_1.getXExact(ps);\r\n    let [b1, b0] = get_y_1.getYExact(ps);\r\n    let vₓ = b1;\r\n    let vᵧ = flo_numerical_1.negativeOf(a1);\r\n    let v = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(a1, b0), flo_numerical_1.expansionProduct(a0, b1));\r\n    return { vₓ, vᵧ, v };\r\n}\r\nexports.getImplicitForm1Exact = getImplicitForm1Exact;\r\n//# sourceMappingURL=get-implicit-form1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct; // error -> 0\r\nconst qno = flo_numerical_1.qNegativeOf; // error -> 0\r\nconst qm2 = flo_numerical_1.qMultBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst qdq = flo_numerical_1.qDiffQuad; // error -> 3*γ²\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nconst edif = flo_numerical_1.expansionDiff;\r\nconst epr = flo_numerical_1.expansionProduct;\r\n// TODO - document better\r\n/**\r\n * * required: max 47 coefficient bitlength\r\n * Returns the exact implicit form of the given quadratic bezier.\r\n * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm2Exact_(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let [[a2, a1, a0], [b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    let a2b1 = tp(a2, b1); // error free\r\n    let a1b2 = tp(a1, b2); // error free\r\n    let a2b0 = tp(a2, b0); // error free\r\n    let a0b2 = tp(a0, b2); // error free\r\n    let a1b0 = tp(a1, b0); // error free\r\n    let a0b1 = tp(a0, b1); // error free\r\n    let a2a2 = tp(a2, a2); // error free\r\n    let a2b2 = tp(a2, b2); // error free\r\n    let b2b2 = tp(b2, b2); // error free\r\n    let q1 = qdq(a2b1, a1b2); // 48-bit aligned => error free\r\n    let q2 = qdq(a2b0, a0b2); // 48-bit aligned => error free\r\n    let q3 = qdq(a1b0, a0b1); // 48-bit aligned => error free\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // b2**2*x**2\r\n    // -b2**2 *x**2\r\n    let vₓₓ = qno(b2b2);\r\n    // -2*a2*b2*x*y\r\n    // 2*a2*b2 *x*y\r\n    let vₓᵧ = qm2(a2b2);\r\n    // a2**2*y**2\r\n    // -a2**2 *y**2 \r\n    let vᵧᵧ = qno(a2a2);\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //let vₓ = b1*q1 - 2*b2*q2;\r\n    let w1 = sce(b1, q1);\r\n    let w2 = em2(sce(b2, q2));\r\n    let vₓ = edif(w1, w2);\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    let w3 = em2(sce(a2, q2));\r\n    let w4 = sce(a1, q1);\r\n    let vᵧ = edif(w3, w4);\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    let w5 = epr(q1, q3);\r\n    let w6 = epr(q2, q2);\r\n    let v = edif(w5, w6);\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\nexports.getImplicitForm2Exact_ = getImplicitForm2Exact_;\r\n//# sourceMappingURL=get-implicit-form2-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the exact implicit form of the given quadratic bezier.\r\n * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm2Exact(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let [a2, a1, a0] = get_x_1.getXExact(ps);\r\n    let [b2, b1, b0] = get_y_1.getYExact(ps);\r\n    // b2**2*x**2\r\n    let vₓₓ = flo_numerical_1.expansionProduct(b2, b2);\r\n    // -2*a2*b2*x*y\r\n    let vₓᵧ = flo_numerical_1.calculateProduct([[-2], a2, b2]);\r\n    // a2**2*y**2\r\n    let vᵧᵧ = flo_numerical_1.expansionProduct(a2, a2);\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    let vₓ = flo_numerical_1.calculate([\r\n        [[-2], a0, b2, b2], [a1, b1, b2],\r\n        [[2], a2, b0, b2], [[-1], a2, b1, b1]\r\n    ]);\r\n    // 2*a0*a2*b2 - a1**2*b2 + \r\n    // a1*a2*b1 - 2*a2**2*b0\r\n    let vᵧ = flo_numerical_1.calculate([\r\n        [[2], a0, a2, b2], [[-1], a1, a1, b2],\r\n        [a1, a2, b1], [[-2], a2, a2, b0]\r\n    ]);\r\n    // a0**2*b2**2 - a0*a1*b1*b2 \r\n    // - 2*a0*a2*b0*b2 + a0*a2*b1**2 + \r\n    // a1**2*b0*b2 - a1*a2*b0*b1 + \r\n    // a2**2*b0**2\r\n    let v = flo_numerical_1.calculate([\r\n        [a0, a0, b2, b2], [[-1], a0, a1, b1, b2],\r\n        [[-2], a0, a2, b0, b2], [a0, a2, b1, b1],\r\n        [a1, a1, b0, b2], [[-1], a1, a2, b0, b1],\r\n        [a2, a2, b0, b0],\r\n    ]);\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\nexports.getImplicitForm2Exact = getImplicitForm2Exact;\r\n//# sourceMappingURL=get-implicit-form2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct; // error -> 0\r\nconst qm2 = flo_numerical_1.qMultBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qdq = flo_numerical_1.qDiffQuad; // error -> 3*γ²\r\nconst qaq = flo_numerical_1.qAddQuad; // error -> 3*γ²\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst edif = flo_numerical_1.expansionDiff;\r\nconst eno = flo_numerical_1.negativeOf;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nconst ed2 = flo_numerical_1.eDivBy2;\r\n// TODO - document better\r\n/**\r\n * * precondition: max 47 coefficient bitlength\r\n * Returns an approximate implicit form of the given cubic bezier and an\r\n * implicit form coefficientwise error bound of the given cubic bezier.\r\n * * takes about 155 micro-seconds on a 1st gen i7 and Chrome 79\r\n * @param coeffsX\r\n * @param coeffsY\r\n */\r\nfunction getImplicitForm3Exact_(ps) {\r\n    let [[a3, a2, a1, a0], [b3, b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let a3b1 = tp(a3, b1); // error free\r\n    let a1b3 = tp(a1, b3); // error free\r\n    let a3b2 = tp(a3, b2); // error free\r\n    let a2b2 = tp(a2, b2); // error free\r\n    let a2b3 = tp(a2, b3); // error free\r\n    let a3a3 = tp(a3, a3); // error free\r\n    let b2b2 = tp(b2, b2); // error free\r\n    let b3b3 = tp(b3, b3); // error free\r\n    let a1a3 = tp(a1, a3); // error free\r\n    let a2a2 = tp(a2, a2); // error free\r\n    let b1b3 = tp(b1, b3); // error free\r\n    let b2b3 = tp(b2, b3); // error free\r\n    let a2a3 = tp(a2, a3); // error free\r\n    let a3b3 = tp(a3, b3); // error free\r\n    let a3b0 = tp(a3, b0); // error free\r\n    let a0b3 = tp(a0, b3); // error free\r\n    let a2b0 = tp(a2, b0); // error free\r\n    let a0b2 = tp(a0, b2); // error free\r\n    let a2b1 = tp(a2, b1); // error free\r\n    let a1b2 = tp(a1, b2); // error free\r\n    let a1b0 = tp(a1, b0); // error free\r\n    let a0b1 = tp(a0, b1); // error free\r\n    let q1 = qdq(a3b0, a0b3); // 48-bit aligned => error free\r\n    let q2 = qdq(a3b1, a1b3); // 48-bit aligned => error free\r\n    let q3 = qdq(a3b2, a2b3); // 48-bit aligned => error free\r\n    let q4 = qdq(a2b0, a0b2); // 48-bit aligned => error free\r\n    let q5 = qdq(a2b1, a1b2); // 48-bit aligned => error free\r\n    let q6 = qdq(a1b0, a0b1); // 48-bit aligned => error free\r\n    let t1 = qdq(b1b3, b2b2); // 48-bit aligned => error free\r\n    let t2 = qdq(a1a3, a2a2); // 48-bit aligned => error free\r\n    let p1 = qaq(a2b3, a3b2); // 48-bit aligned => error free\r\n    let p2 = qaq(a1b3, a3b1); // 48-bit aligned => error free\r\n    let tq2 = qm2(q2); // error free\r\n    let q1q1 = epr(q1, q1);\r\n    let q1q2 = epr(q1, q2);\r\n    let q1q3 = epr(q1, q3);\r\n    let q1q5 = epr(q1, q5);\r\n    let q2q2 = epr(q2, q2);\r\n    let tq2q4 = epr(tq2, q4);\r\n    let q3q4 = epr(q3, q4);\r\n    let q3q5 = epr(q3, q5);\r\n    let q3q6 = epr(q3, q6);\r\n    let vₓₓₓ = sce(-b3, b3b3);\r\n    let vₓₓᵧ = sce(3 * a3, b3b3); // 47-bit aligned => 3*a0,... -> error free\r\n    let vₓᵧᵧ = sce(-3 * b3, a3a3); // 47-bit aligned => 3*b0,... -> error free \r\n    let vᵧᵧᵧ = sce(a3, a3a3);\r\n    // 46-bit aligned => qmd(3*q1 - q5,...) -> error free\r\n    let u1 = edif(sce(-3, q1), q5); // 47-bit aligned => qmd(3*q1 - q5) -> error free\r\n    //let vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    let w1 = epr(u1, b3b3);\r\n    let w2 = epr(q3, t1);\r\n    let w3 = fes(w1, w2);\r\n    let w4 = epr(tq2, b2b3);\r\n    let vₓₓ = fes(w3, w4);\r\n    //let vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    let w5 = epr(u1, a3a3);\r\n    let w6 = epr(q3, t2);\r\n    let w7 = fes(w5, w6);\r\n    let w8 = epr(tq2, a2a3);\r\n    let vᵧᵧ = fes(w7, w8);\r\n    //let vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    let wa = edif(a2b2, ed2(p2)); // 47-bit aligned => wa = a2b2 - p2/2 -> error free\r\n    let wb = epr(u1, a3b3);\r\n    let wc = epr(q2, p1);\r\n    let wd = fes(wb, wc);\r\n    let wq = epr(q3, wa);\r\n    let vₓᵧ = em2(edif(wq, wd));\r\n    //let s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    let wr = sce(-3, q1q1);\r\n    let we = edif(wr, em2(q1q5));\r\n    let wf = fes(tq2q4, q3q6);\r\n    let s1 = fes(we, wf);\r\n    //let s2 = 2*(q1q2 - q3q4);\r\n    let s2 = em2(edif(q1q2, q3q4));\r\n    //let s3 = q1q3 - q2q2 + q3q5;\r\n    let wl = edif(q1q3, q2q2);\r\n    let s3 = fes(wl, q3q5);\r\n    //let vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    let wm = sce(b3, s1);\r\n    let ws = sce(b2, s2);\r\n    let wt = sce(b1, s3);\r\n    let wn = fes(ws, wt);\r\n    let vₓ = fes(wm, wn);\r\n    //let vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    let wo = sce(a3, s1);\r\n    let wu = sce(a2, s2);\r\n    let wv = sce(a1, s3);\r\n    let wp = fes(wu, wv);\r\n    let vᵧ = eno(fes(wo, wp));\r\n    let v3 = edif(tq2q4, q1q1);\r\n    let v1 = edif(v3, q1q5);\r\n    let v4 = epr(s3, q6);\r\n    let v5 = epr(q3q4, q4);\r\n    let v2 = edif(v4, v5);\r\n    let v6 = epr(q1, v1);\r\n    //let v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    let v = fes(v6, v2);\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\nexports.getImplicitForm3Exact_ = getImplicitForm3Exact_;\r\n//# sourceMappingURL=get-implicit-form3-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the exact implicit form of the given cubic bezier.\r\n * Taken from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm3Exact(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let [a3, a2, a1, a0] = get_x_1.getXExact(ps);\r\n    let [b3, b2, b1, b0] = get_y_1.getYExact(ps);\r\n    // let vₓₓₓ = b3*b3*b3;\r\n    let vₓₓₓ = flo_numerical_1.calculateProduct([b3, b3, b3]);\r\n    // let vₓₓᵧ = -3*a3*b3*b3;\r\n    let vₓₓᵧ = flo_numerical_1.calculateProduct([[-3], a3, b3, b3]);\r\n    // let vₓᵧᵧ = 3*b3*a3*a3;\r\n    let vₓᵧᵧ = flo_numerical_1.calculateProduct([[3], b3, a3, a3]);\r\n    // let vᵧᵧᵧ = -a3*a3*a3;\r\n    let vᵧᵧᵧ = flo_numerical_1.negativeOf(flo_numerical_1.calculateProduct([a3, a3, a3]));\r\n    // let vₓₓ = -3*a3*b1*b2*b3 + a1*b2*b3*b3 - a2*b3*b2*b2 + 2*a2*b1*b3*b3 + \r\n    //           3*a3*b0*b3*b3 + a3*b2*b2*b2 - 3*a0*b3*b3*b3;\r\n    let vₓₓ = flo_numerical_1.calculate([\r\n        [[-3], a3, b1, b2, b3], [a1, b2, b3, b3], [[-1], a2, b3, b2, b2],\r\n        [[2], a2, b1, b3, b3], [[3], a3, b0, b3, b3], [a3, b2, b2, b2],\r\n        [[-3], a0, b3, b3, b3]\r\n    ]);\r\n    // let vₓᵧ = a1*a3*b2*b3 - a2*a3*b1*b3 - 6*b0*b3*a3*a3 - 3*a1*a2*b3*b3 - \r\n    //           2*a2*a3*b2*b2 + 2*b2*b3*a2*a2 + 3*b1*b2*a3*a3 + 6*a0*a3*b3*b3;\r\n    let vₓᵧ = flo_numerical_1.calculate([\r\n        [a1, a3, b2, b3], [[-1], a2, a3, b1, b3], [[-6], b0, b3, a3, a3],\r\n        [[-3], a1, a2, b3, b3], [[-2], a2, a3, b2, b2], [[2], b2, b3, a2, a2],\r\n        [[3], b1, b2, a3, a3], [[6], a0, a3, b3, b3]\r\n    ]);\r\n    // let vᵧᵧ = 3*a1*a2*a3*b3 + a3*b2*a2*a2 - a2*b1*a3*a3 - 3*a0*b3*a3*a3 - \r\n    //           2*a1*b2*a3*a3 - b3*a2*a2*a2 + 3*b0*a3*a3*a3;\r\n    let vᵧᵧ = flo_numerical_1.calculate([\r\n        [[3], a1, a2, a3, b3], [a3, b2, a2, a2], [[-1], a2, b1, a3, a3],\r\n        [[-3], a0, b3, a3, a3], [[-2], a1, b2, a3, a3], [[-1], b3, a2, a2, a2],\r\n        [[3], b0, a3, a3, a3]\r\n    ]);\r\n    // let vₓ = a2*a3*b0*b1*b3 - a1*a2*b1*b2*b3 - a1*a3*b0*b2*b3 + \r\n    //          6*a0*a3*b1*b2*b3 + b1*a1*a1*b3*b3 + b3*a2*a2*b1*b1 + \r\n    //          3*b3*a3*a3*b0*b0 + a1*a3*b1*b2*b2 - a2*a3*b2*b1*b1 - \r\n    //          6*a0*a3*b0*b3*b3 - 4*a0*a2*b1*b3*b3 - 3*b0*b1*b2*a3*a3 -\r\n    //          2*a0*a1*b2*b3*b3 - 2*a1*a3*b3*b1*b1 - 2*b0*b2*b3*a2*a2 + \r\n    //          2*a0*a2*b3*b2*b2 + 2*a2*a3*b0*b2*b2 + 3*a1*a2*b0*b3*b3 + \r\n    //          a3*a3*b1*b1*b1 + 3*a0*a0*b3*b3*b3 - 2*a0*a3*b2*b2*b2;\r\n    let vₓ = flo_numerical_1.calculate([\r\n        [a2, a3, b0, b1, b3], [[-1], a1, a2, b1, b2, b3], [[-1], a1, a3, b0, b2, b3],\r\n        [[6], a0, a3, b1, b2, b3], [b1, a1, a1, b3, b3], [b3, a2, a2, b1, b1],\r\n        [[3], b3, a3, a3, b0, b0], [a1, a3, b1, b2, b2], [[-1], a2, a3, b2, b1, b1],\r\n        [[-6], a0, a3, b0, b3, b3], [[-4], a0, a2, b1, b3, b3], [[-3], b0, b1, b2, a3, a3],\r\n        [[-2], a0, a1, b2, b3, b3], [[-2], a1, a3, b3, b1, b1], [[-2], b0, b2, b3, a2, a2],\r\n        [[2], a0, a2, b3, b2, b2], [[2], a2, a3, b0, b2, b2], [[3], a1, a2, b0, b3, b3],\r\n        [a3, a3, b1, b1, b1], [[3], a0, a0, b3, b3, b3], [[-2], a0, a3, b2, b2, b2]\r\n    ]);\r\n    // let vᵧ = a0*a2*a3*b1*b3 + a1*a2*a3*b1*b2 - a0*a1*a3*b2*b3 - \r\n    //          6*a1*a2*a3*b0*b3 - a1*a1*a1*b3*b3 - 3*a3*a3*a3*b0*b0 - \r\n    //          a1*a3*a3*b1*b1 - a3*a1*a1*b2*b2 - 3*a3*a0*a0*b3*b3 + \r\n    //          a2*b2*b3*a1*a1 - a1*b1*b3*a2*a2 - 3*a0*b1*b2*a3*a3 - \r\n    //          2*a0*b2*b3*a2*a2 - 2*a3*b0*b2*a2*a2 + 2*a0*a2*a3*b2*b2 + \r\n    //          2*a2*b0*b1*a3*a3 + 2*a3*b1*b3*a1*a1 + 3*a0*a1*a2*b3*b3 + \r\n    //          4*a1*b0*b2*a3*a3 + 6*a0*b0*b3*a3*a3 + 2*b0*b3*a2*a2*a2;\r\n    let vᵧ = flo_numerical_1.calculate([\r\n        [a0, a2, a3, b1, b3], [a1, a2, a3, b1, b2], [[-1], a0, a1, a3, b2, b3],\r\n        [[-6], a1, a2, a3, b0, b3], [[-1], a1, a1, a1, b3, b3], [[-3], a3, a3, a3, b0, b0],\r\n        [[-1], a1, a3, a3, b1, b1], [[-1], a3, a1, a1, b2, b2], [[-3], a3, a0, a0, b3, b3],\r\n        [a2, b2, b3, a1, a1], [[-1], a1, b1, b3, a2, a2], [[-3], a0, b1, b2, a3, a3],\r\n        [[-2], a0, b2, b3, a2, a2], [[-2], a3, b0, b2, a2, a2], [[2], a0, a2, a3, b2, b2],\r\n        [[2], a2, b0, b1, a3, a3], [[2], a3, b1, b3, a1, a1], [[3], a0, a1, a2, b3, b3],\r\n        [[4], a1, b0, b2, a3, a3], [[6], a0, b0, b3, a3, a3], [[2], b0, b3, a2, a2, a2]\r\n    ]);\r\n    // let v = a0*a1*a2*b1*b2*b3 + a0*a1*a3*b0*b2*b3 - a0*a2*a3*b0*b1*b3 - \r\n    //          a1*a2*a3*b0*b1*b2 + b0*a1*a1*a1*b3*b3 - b3*a2*a2*a2*b0*b0 + \r\n    //          a1*b0*a3*a3*b1*b1 + a1*b2*a0*a0*b3*b3 + a3*b0*a1*a1*b2*b2 + \r\n    //          a3*b2*a2*a2*b0*b0 - a0*b1*a1*a1*b3*b3 - a0*b3*a2*a2*b1*b1 - \r\n    //          a2*b1*a3*a3*b0*b0 - a2*b3*a0*a0*b2*b2 - 3*a0*b3*a3*a3*b0*b0 - \r\n    //          2*a1*b2*a3*a3*b0*b0 + 2*a2*b1*a0*a0*b3*b3 + 3*a3*b0*a0*a0*b3*b3 + \r\n    //          a0*a2*a3*b2*b1*b1 + a1*b0*b1*b3*a2*a2 - a0*a1*a3*b1*b2*b2 - \r\n    //          a2*b0*b2*b3*a1*a1 - 3*a0*a1*a2*b0*b3*b3 - 3*a3*b1*b2*b3*a0*a0 - \r\n    //          2*a0*a2*a3*b0*b2*b2 - 2*a3*b0*b1*b3*a1*a1 + 2*a0*a1*a3*b3*b1*b1 + \r\n    //          2*a0*b0*b2*b3*a2*a2 + 3*a0*b0*b1*b2*a3*a3 + 3*a1*a2*a3*b3*b0*b0 + \r\n    //          a3*a3*a3*b0*b0*b0 - a0*a0*a0*b3*b3*b3 + a3*a0*a0*b2*b2*b2 - \r\n    //          a0*a3*a3*b1*b1*b1;\r\n    let v = flo_numerical_1.calculate([\r\n        [a0, a1, a2, b1, b2, b3], [a0, a1, a3, b0, b2, b3], [[-1], a0, a2, a3, b0, b1, b3],\r\n        [[-1], a1, a2, a3, b0, b1, b2], [b0, a1, a1, a1, b3, b3], [[-1], b3, a2, a2, a2, b0, b0],\r\n        [a1, b0, a3, a3, b1, b1], [a1, b2, a0, a0, b3, b3], [a3, b0, a1, a1, b2, b2],\r\n        [a3, b2, a2, a2, b0, b0], [[-1], a0, b1, a1, a1, b3, b3], [[-1], a0, b3, a2, a2, b1, b1],\r\n        [[-1], a2, b1, a3, a3, b0, b0], [[-1], a2, b3, a0, a0, b2, b2], [[-3], a0, b3, a3, a3, b0, b0],\r\n        [[-2], a1, b2, a3, a3, b0, b0], [[2], a2, b1, a0, a0, b3, b3], [[3], a3, b0, a0, a0, b3, b3],\r\n        [a0, a2, a3, b2, b1, b1], [a1, b0, b1, b3, a2, a2], [[-1], a0, a1, a3, b1, b2, b2],\r\n        [[-1], a2, b0, b2, b3, a1, a1], [[-3], a0, a1, a2, b0, b3, b3], [[-3], a3, b1, b2, b3, a0, a0],\r\n        [[-2], a0, a2, a3, b0, b2, b2], [[-2], a3, b0, b1, b3, a1, a1], [[2], a0, a1, a3, b3, b1, b1],\r\n        [[2], a0, b0, b2, b3, a2, a2], [[3], a0, b0, b1, b2, a3, a3], [[3], a1, a2, a3, b3, b0, b0],\r\n        [a3, a3, a3, b0, b0, b0], [[-1], a0, a0, a0, b3, b3, b3], [a3, a0, a0, b2, b2, b2],\r\n        [[-1], a0, a3, a3, b1, b1, b1]\r\n    ]);\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\nexports.getImplicitForm3Exact = getImplicitForm3Exact;\r\n//# sourceMappingURL=get-implicit-form3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\n/**\r\n * Returns an approximate implicit form of the given linear bezier and a\r\n * coefficientwise error bound.\r\n * * the error bound needs to be multiplied by γ === nu/(1-nu), where\r\n * u === Number.EPSILON / 2\r\n * * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm1(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    let [[a1, a0], [b1, b0]] = get_xy_1.getXY(ps);\r\n    let vₓ = -b1;\r\n    let vᵧ = a1;\r\n    //let v = a1*b0 - a0*b1;\r\n    let w1 = a1 * b0;\r\n    let w1_ = Math.abs(a1 * b0);\r\n    let w2 = a0 * b1;\r\n    let w2_ = Math.abs(a0 * b1);\r\n    let v = w2 - w1;\r\n    let v_ = w1_ + w2_ + Math.abs(v);\r\n    return {\r\n        coeffs: { vₓ, vᵧ, v },\r\n        errorBound: { v_ } // vₓ_, vᵧ_, => zero\r\n    };\r\n}\r\nexports.getImplicitForm1 = getImplicitForm1;\r\n//# sourceMappingURL=get-implicit-form1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\n/**\r\n * Returns an approximate implicit form of the given quadratic bezier and a\r\n * coefficientwise error bound.\r\n * * the error bound needs to be multiplied by γ === nu/(1-nu), where\r\n * u === Number.EPSILON / 2\r\n * * the coordinates of the given bezier must be 47-bit aligned\r\n * * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm2(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let [[a2, a1, a0], [b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    let a2b1 = a2 * b1;\r\n    let a1b2 = a1 * b2;\r\n    let a2b0 = a2 * b0;\r\n    let a0b2 = a0 * b2;\r\n    let a1b0 = a1 * b0;\r\n    let a0b1 = a0 * b1;\r\n    let a2a2 = a2 * a2;\r\n    let a2b2 = a2 * b2;\r\n    let b2b2 = b2 * b2;\r\n    let q1 = a2b1 - a1b2;\r\n    let q2 = a2b0 - a0b2;\r\n    let q3 = a1b0 - a0b1;\r\n    let _q1 = abs(q1);\r\n    let _q2 = abs(q2);\r\n    let _q3 = abs(q3);\r\n    let q1_ = abs(a2b1) + abs(a1b2) + _q1;\r\n    let q2_ = abs(a2b0) + abs(a0b2) + _q2;\r\n    let q3_ = abs(a1b0) + abs(a0b1) + _q3;\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // b2**2*x**2\r\n    // -b2**2 *x**2\r\n    let vₓₓ = -b2b2;\r\n    let vₓₓ_ = abs(b2b2);\r\n    // -2*a2*b2*x*y\r\n    // 2*a2*b2 *x*y\r\n    let vₓᵧ = 2 * a2b2;\r\n    let vₓᵧ_ = 2 * abs(a2b2);\r\n    // a2**2*y**2\r\n    // -a2**2 *y**2 \r\n    let vᵧᵧ = -a2a2;\r\n    let vᵧᵧ_ = abs(a2a2);\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //let vₓ = b1*q1 - 2*b2*q2;\r\n    let w1 = b1 * q1;\r\n    let w1_ = abs(b1) * q1_ + abs(w1);\r\n    let w2 = 2 * b2 * q2;\r\n    let w2_ = 2 * (abs(b2) * q2_) + abs(w2);\r\n    let vₓ = w1 - w2;\r\n    let vₓ_ = w1_ + w2_ + abs(vₓ);\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    let w3 = 2 * a2 * q2;\r\n    let w3_ = 2 * (abs(a2) * q2_) + abs(w3);\r\n    let w4 = a1 * q1;\r\n    let w4_ = abs(a1) * q1_ + abs(w4);\r\n    let vᵧ = w3 - w4;\r\n    let vᵧ_ = w3_ + w4_ + abs(vᵧ);\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    let w5 = q1 * q3;\r\n    let w5_ = q1_ * _q3 + _q1 * q3_ + abs(w5);\r\n    let w6 = q2 * q2;\r\n    let w6_ = 2 * (_q2 * q2_) + abs(w6);\r\n    let v = w5 - w6;\r\n    let v_ = w5_ + w6_ + abs(v);\r\n    return {\r\n        coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\nexports.getImplicitForm2 = getImplicitForm2;\r\n//# sourceMappingURL=get-implicit-form2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\n/**\r\n * Returns an approximate implicit form of the given cubic bezier and a\r\n * coefficientwise error bound.\r\n * * the error bound needs to be multiplied by γ === nu/(1-nu), where\r\n * u === Number.EPSILON / 2\r\n * * the coordinates of the given bezier must be 47-bit aligned\r\n * * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * * takes about 1.2 micro-seconds on a 1st gen i7 and Chrome 79\r\n * @param ps\r\n */\r\nfunction getImplicitForm3(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let [[a3, a2, a1, a0], [b3, b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    let a3b1 = a3 * b1;\r\n    let a1b3 = a1 * b3;\r\n    let a3b2 = a3 * b2;\r\n    let a2b2 = a2 * b2;\r\n    let a2b3 = a2 * b3;\r\n    let a3a3 = a3 * a3;\r\n    let b2b2 = b2 * b2;\r\n    let b3b3 = b3 * b3;\r\n    let a1a3 = a1 * a3;\r\n    let a2a2 = a2 * a2;\r\n    let b1b3 = b1 * b3;\r\n    let b2b3 = b2 * b3;\r\n    let a2a3 = a2 * a3;\r\n    let a3b3 = a3 * b3;\r\n    let a3b0 = a3 * b0;\r\n    let a0b3 = a0 * b3;\r\n    let a2b0 = a2 * b0;\r\n    let a0b2 = a0 * b2;\r\n    let a2b1 = a2 * b1;\r\n    let a1b2 = a1 * b2;\r\n    let a1b0 = a1 * b0;\r\n    let a0b1 = a0 * b1;\r\n    let _a3b1 = abs(a3b1);\r\n    let _a1b3 = abs(a1b3);\r\n    let _a3b2 = abs(a3b2);\r\n    let _a2b2 = abs(a2b2);\r\n    let _a2b3 = abs(a2b3);\r\n    let _a3a3 = abs(a3a3);\r\n    let _b2b2 = abs(b2b2);\r\n    let _b3b3 = abs(b3b3);\r\n    let _a1a3 = abs(a1a3);\r\n    let _a2a2 = abs(a2a2);\r\n    let _b1b3 = abs(b1b3);\r\n    let _b2b3 = abs(b2b3);\r\n    let _a2a3 = abs(a2a3);\r\n    let _a3b3 = abs(a3b3);\r\n    let _a3b0 = abs(a3b0);\r\n    let _a0b3 = abs(a0b3);\r\n    let _a2b0 = abs(a2b0);\r\n    let _a0b2 = abs(a0b2);\r\n    let _a2b1 = abs(a2b1);\r\n    let _a1b2 = abs(a1b2);\r\n    let _a1b0 = abs(a1b0);\r\n    let _a0b1 = abs(a0b1);\r\n    let q1 = a3b0 - a0b3;\r\n    let q2 = a3b1 - a1b3;\r\n    let q3 = a3b2 - a2b3;\r\n    let q4 = a2b0 - a0b2;\r\n    let q5 = a2b1 - a1b2;\r\n    let q6 = a1b0 - a0b1;\r\n    let t1 = b1b3 - b2b2;\r\n    let t2 = a1a3 - a2a2;\r\n    let p1 = a2b3 + a3b2;\r\n    let p2 = a1b3 + a3b1;\r\n    let tq2 = 2 * q2;\r\n    let _q1 = abs(q1);\r\n    let _q2 = abs(q2);\r\n    let _q3 = abs(q3);\r\n    let _q4 = abs(q4);\r\n    let _q5 = abs(q5);\r\n    let _q6 = abs(q6);\r\n    let _p1 = abs(p1);\r\n    let _p2 = abs(p2);\r\n    let _tq2 = 2 * _q2;\r\n    let q1_ = _a3b0 + _a0b3 + _q1;\r\n    let q2_ = _a3b1 + _a1b3 + _q2;\r\n    let q3_ = _a3b2 + _a2b3 + _q3;\r\n    let q4_ = _a2b0 + _a0b2 + _q4;\r\n    let q5_ = _a2b1 + _a1b2 + _q5;\r\n    let q6_ = _a1b0 + _a0b1 + _q6;\r\n    let p1_ = _a2b3 + _a3b2 + _p1;\r\n    let p2_ = _a1b3 + _a3b1 + _p2;\r\n    let tq2_ = 2 * q2_;\r\n    let q1q1 = q1 * q1;\r\n    let q1q2 = q1 * q2;\r\n    let q1q3 = q1 * q3;\r\n    let q1q5 = q1 * q5;\r\n    let q2q2 = q2 * q2;\r\n    let tq2q4 = tq2 * q4;\r\n    let q3q4 = q3 * q4;\r\n    let q3q5 = q3 * q5;\r\n    let q3q6 = q3 * q6;\r\n    let q1q1_ = 2 * (q1_ * _q1) + abs(q1q1);\r\n    let q1q2_ = q1_ * _q2 + _q1 * q2_ + abs(q1q2);\r\n    let q1q3_ = q1_ * _q3 + _q1 * q3_ + abs(q1q3);\r\n    let q1q5_ = q1_ * _q5 + _q1 * q5_ + abs(q1q5);\r\n    let q2q2_ = 2 * (q2_ * _q2) + abs(q2q2);\r\n    let tq2q4_ = tq2_ * _q4 + _tq2 * q4_ + abs(tq2q4);\r\n    let q3q4_ = q3_ * _q4 + _q3 * q4_ + abs(q3q4);\r\n    let q3q5_ = q3_ * _q5 + _q3 * q5_ + abs(q3q5);\r\n    let q3q6_ = q3_ * _q6 + _q3 * q6_ + abs(q3q4);\r\n    let u1 = -3 * q1 - q5;\r\n    let _u1 = abs(u1);\r\n    let u1_ = 3 * (q1_ + _q1) + q5_ + _u1;\r\n    let vₓₓₓ = -b3 * b3b3;\r\n    let vₓₓᵧ = (3 * a3) * b3b3; // 3*a3: 47-bit aligned => error free\r\n    let vₓᵧᵧ = (-3 * b3) * a3a3; // 3*b3: 47-bit aligned => error free\r\n    let vᵧᵧᵧ = a3 * a3a3;\r\n    let vₓₓₓ_ = 2 * abs(vₓₓₓ);\r\n    //let vₓₓᵧ_ = 3*abs(3*a3*_b3b3);  \r\n    let vₓₓᵧ_ = 6 * _b3b3 * (abs(a3)); // 3*a3: 47-bit aligned => error free\r\n    //let vₓᵧᵧ_ = 3*abs(3*b3*_a3a3);\r\n    let vₓᵧᵧ_ = 6 * _a3a3 * (abs(b3)); // 3*b3: 47-bit aligned => error free\r\n    let vᵧᵧᵧ_ = 2 * abs(vᵧᵧᵧ);\r\n    let _t1 = abs(t1);\r\n    let t1_ = _b1b3 + _b2b2 + _t1;\r\n    let _t2 = abs(t2);\r\n    let t2_ = _a1a3 + _a2a2 + abs(t2);\r\n    let w1 = u1 * b3b3;\r\n    let w1_ = _b3b3 * (u1_ + _u1) + abs(w1);\r\n    let w2 = q3 * t1;\r\n    let w2_ = q3_ * _t1 + t1_ * _q3 + abs(w2);\r\n    let w3 = w1 + w2;\r\n    let w3_ = w1_ + w2_ + abs(w3);\r\n    let w4 = tq2 * b2b3;\r\n    let w4_ = _b2b3 * (tq2_ + _tq2) + abs(w4);\r\n    //let vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    let vₓₓ = w3 + w4;\r\n    let vₓₓ_ = w3_ + w4_ + abs(w3 + w4);\r\n    let w5 = u1 * a3a3;\r\n    let w5_ = _a3a3 * (u1_ + _u1) + abs(w5);\r\n    let w6 = q3 * t2;\r\n    let w6_ = t2_ * _q3 + q3_ * _t2 + abs(w6);\r\n    let w7 = w5 + w6;\r\n    let w7_ = w5_ + w6_ + abs(w7);\r\n    let w8 = tq2 * a2a3;\r\n    let w8_ = _a2a3 * (tq2_ + _tq2) + abs(w8);\r\n    //let vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    let vᵧᵧ = w7 + w8;\r\n    let vᵧᵧ_ = w7_ + w8_ + abs(vᵧᵧ);\r\n    let wa = a2b2 - p2 / 2;\r\n    let _wa = abs(wa);\r\n    let wa_ = _a2b2 + p2_ / 2 + _wa;\r\n    let wb = u1 * a3b3;\r\n    let wb_ = _a3b3 * (u1_ + _u1) + abs(wb);\r\n    let wc = q2 * p1;\r\n    let wc_ = q2_ * _p1 + _q2 * p1_ + abs(wc);\r\n    let wd = wb + wc;\r\n    let wd_ = wb_ + wc_ + abs(wd);\r\n    let wq = q3 * wa;\r\n    let wq_ = q3_ * _wa + _q3 * wa_ + abs(wq);\r\n    //let vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    let vₓᵧ = 2 * (wq - wd);\r\n    let vₓᵧ_ = 2 * (wq_ + wd_) + abs(vₓᵧ);\r\n    let wr = -3 * q1q1;\r\n    let wr_ = 3 * q1q1_ + abs(wr);\r\n    let we = wr - 2 * q1q5;\r\n    let we_ = wr_ + 2 * q1q5_ + abs(we);\r\n    let wf = tq2q4 + q3q6;\r\n    let wf_ = tq2q4_ + q3q6_ + abs(wf);\r\n    //let s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    let s1 = we + wf;\r\n    let s1_ = we_ + wf_ + abs(s1);\r\n    //let s2 = 2*(q1q2 - q3q4);\r\n    let s2 = 2 * (q1q2 - q3q4);\r\n    let s2_ = 2 * (q1q2_ + q3q4_) + abs(s2);\r\n    let wl = q1q3 - q2q2;\r\n    let wl_ = q1q3_ + q2q2_ + abs(wl);\r\n    //let s3 = q1q3 - q2q2 + q3q5;\r\n    let s3 = wl + q3q5;\r\n    let s3_ = wl_ + q3q5_ + abs(s3);\r\n    let wm = b3 * s1;\r\n    let wm_ = abs(b3) * s1_ + abs(wm);\r\n    let ws = b2 * s2;\r\n    let ws_ = abs(b2) * s2_ + abs(ws);\r\n    let wt = b1 * s3;\r\n    let wt_ = abs(b1) * s3_ + abs(wt);\r\n    let wn = ws + wt;\r\n    let wn_ = ws_ + wt_ + abs(wn);\r\n    //let vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    let vₓ = wm + wn;\r\n    let vₓ_ = wm_ + wn_ + abs(vₓ);\r\n    let wo = a3 * s1;\r\n    let wo_ = abs(a3) * s1_ + abs(wo);\r\n    let wu = a2 * s2;\r\n    let wu_ = abs(a2) * s2_ + abs(wu);\r\n    let wv = a1 * s3;\r\n    let wv_ = abs(a1) * s3_ + abs(wv);\r\n    let wp = wu + wv;\r\n    let wp_ = wu_ + wv_ + abs(wp);\r\n    //let vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    let vᵧ = -(wo + wp);\r\n    let vᵧ_ = wo_ + wp_ + abs(vᵧ);\r\n    let v3 = tq2q4 - q1q1;\r\n    let v3_ = tq2q4_ + q1q1_ + abs(v3);\r\n    let v1 = v3 - q1q5;\r\n    let _v1 = abs(v1);\r\n    let v1_ = v3_ + q1q5_ + _v1;\r\n    let v4 = s3 * q6;\r\n    let v4_ = s3_ * abs(q6) + abs(s3) * q6_ + abs(v4);\r\n    let v5 = q3q4 * q4;\r\n    let v5_ = q3q4_ * _q4 + abs(q3q4) * q4_ + abs(v5);\r\n    let v2 = v4 - v5;\r\n    let v2_ = v4_ + v5_ + abs(v2);\r\n    let v6 = q1 * v1;\r\n    let v6_ = q1_ * _v1 + _q1 * v1_ + abs(v6);\r\n    //let v = q1*(tq2q4 - q1q1 - q1q5) + s3q6 - q3q4*q4;\r\n    let v = v6 + v2;\r\n    let v_ = v6_ + v2_ + abs(v);\r\n    return {\r\n        coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\nexports.getImplicitForm3 = getImplicitForm3;\r\n//# sourceMappingURL=get-implicit-form3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct; // error -> 0\r\nconst qdq = flo_numerical_1.qDiffQuad; // error -> 3*γ²\r\n/**\r\n * Returns the quad precision implicit form of the given linear bezier.\r\n * * precondition: the input coefficients must be 48-bit-aligned\r\n * * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction getImplicitForm1Quad(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    let [[a1, a0], [b1, b0]] = get_xy_1.getXY(ps);\r\n    let vₓ = -b1;\r\n    let vᵧ = a1;\r\n    let v = qdq(tp(a0, b1), tp(a1, b0)); // 48-bit aligned => error free\r\n    return {\r\n        coeffs: { vₓ, vᵧ, v },\r\n        errorBound: {} // vₓ_, vᵧ_, v_ === 0\r\n    };\r\n}\r\nexports.getImplicitForm1Quad = getImplicitForm1Quad;\r\n//# sourceMappingURL=get-implicit-form1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct; // error -> 0\r\nconst qno = flo_numerical_1.qNegativeOf; // error -> 0\r\nconst qm2 = flo_numerical_1.qMultBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = flo_numerical_1.qMultDouble2; // error -> 3*γ²\r\nconst qmq = flo_numerical_1.qMultQuad; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²\r\nconst qdq = flo_numerical_1.qDiffQuad; // error -> 3*γ²\r\n/**\r\n * Returns an approximate (quad precision) implicit form of the given quadratic\r\n * bezier and a coefficientwise error bound.\r\n * * Adapted from http://www.mare.ee/indrek/misc/2d.pdf\r\n * * precondition: the input coefficients must be 47-bit-aligned\r\n * @param ps\r\n */\r\nfunction getImplicitForm2Quad(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    let [[a2, a1, a0], [b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    let a2b1 = tp(a2, b1); // error free\r\n    let a1b2 = tp(a1, b2); // error free\r\n    let a2b0 = tp(a2, b0); // error free\r\n    let a0b2 = tp(a0, b2); // error free\r\n    let a1b0 = tp(a1, b0); // error free\r\n    let a0b1 = tp(a0, b1); // error free\r\n    let a2a2 = tp(a2, a2); // error free\r\n    let a2b2 = tp(a2, b2); // error free\r\n    let b2b2 = tp(b2, b2); // error free\r\n    let $a2b1 = a2 * b1;\r\n    let $a1b2 = a1 * b2;\r\n    let $a2b0 = a2 * b0;\r\n    let $a0b2 = a0 * b2;\r\n    let $a1b0 = a1 * b0;\r\n    let $a0b1 = a0 * b1;\r\n    let q1 = qdq(a2b1, a1b2); // 48-bit aligned => error free\r\n    let q2 = qdq(a2b0, a0b2); // 48-bit aligned => error free\r\n    let q3 = qdq(a1b0, a0b1); // 48-bit aligned => error free\r\n    let $q1 = $a2b1 - $a1b2;\r\n    let $q2 = $a2b0 - $a0b2;\r\n    let $q3 = $a1b0 - $a0b1;\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // b2**2*x**2\r\n    // -b2**2 *x**2\r\n    let vₓₓ = qno(b2b2);\r\n    // -2*a2*b2*x*y\r\n    // 2*a2*b2 *x*y\r\n    let vₓᵧ = qm2(a2b2);\r\n    // a2**2*y**2\r\n    // -a2**2 *y**2 \r\n    let vᵧᵧ = qno(a2a2);\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //let vₓ = b1*q1 - 2*b2*q2;\r\n    let $w1 = b1 * $q1;\r\n    let w1 = qmd(b1, q1);\r\n    let w1_ = abs($w1);\r\n    let $w2 = 2 * b2 * $q2;\r\n    let w2 = qm2(qmd(b2, q2));\r\n    let w2_ = abs($w2);\r\n    let $vₓ = $w1 - $w2;\r\n    let vₓ = qdq(w1, w2);\r\n    let vₓ_ = w1_ + w2_ + abs($vₓ);\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    let $w3 = 2 * a2 * $q2;\r\n    let w3 = qm2(qmd(a2, q2));\r\n    let w3_ = abs($w3);\r\n    let $w4 = a1 * $q1;\r\n    let w4 = qmd(a1, q1);\r\n    let w4_ = abs($w4);\r\n    let $vᵧ = $w3 - $w4;\r\n    let vᵧ = qdq(w3, w4);\r\n    let vᵧ_ = w3_ + w4_ + abs($vᵧ);\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    let $w5 = $q1 * $q3;\r\n    let w5 = qmq(q1, q3);\r\n    let w5_ = 2 * abs($w5);\r\n    let $w6 = $q2 * $q2;\r\n    let w6 = qmq(q2, q2);\r\n    let w6_ = abs($w6);\r\n    let $v = $w5 - $w6;\r\n    let v = qdq(w5, w6);\r\n    let v_ = w5_ + w6_ + abs($v);\r\n    return {\r\n        coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓ_, vᵧ_, v_ } // vₓₓ_, vₓᵧ_, vᵧᵧ_ === 0\r\n    };\r\n}\r\nexports.getImplicitForm2Quad = getImplicitForm2Quad;\r\n//# sourceMappingURL=get-implicit-form2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct; // error -> 0\r\nconst qno = flo_numerical_1.qNegativeOf; // error -> 0\r\nconst qm2 = flo_numerical_1.qMultBy2; // error -> 0 \r\nconst qd2 = flo_numerical_1.qDivBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = flo_numerical_1.qMultDouble2; // error -> 3*γ²\r\nconst qmq = flo_numerical_1.qMultQuad; // error -> 5*γ² (theoretical), 7*γ² (worst found), we use 6*γ²\r\nconst qdq = flo_numerical_1.qDiffQuad; // error -> 3*γ²\r\nconst qaq = flo_numerical_1.qAddQuad; // error -> 3*γ²\r\n// TODO - document better\r\n/**\r\n * Returns an approximate (quad precision) implicit form of the given cubic\r\n * bezier and a coefficientwise error bound.\r\n * * **precondition**: the input coefficients must be 47-bit-aligned\r\n * * takes about 15 micro-seconds on a 1st gen i7 and Chrome 79\r\n * @param coeffsX\r\n * @param coeffsY\r\n */\r\nfunction getImplicitForm3Quad(ps) {\r\n    let [[a3, a2, a1, a0], [b3, b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    // var -> a variable\r\n    // _var -> the absolute value of $var\r\n    // var_ -> the error in var (but should still be multiplied by 3*γ²)\r\n    // recall: a*b, where both a and b have errors |a| and |b| we get for the\r\n    // error of (a*b) -> a_|b| + |a|b_ + abs(a*b)\r\n    // error of (a+b) -> a_ + b_ + abs(a+b)\r\n    // the returned errors need to be multiplied by 3γ² to represent the true\r\n    // error\r\n    let a3b1 = tp(a3, b1); // error free\r\n    let a1b3 = tp(a1, b3); // error free\r\n    let a3b2 = tp(a3, b2); // error free\r\n    let a2b2 = tp(a2, b2); // error free\r\n    let a2b3 = tp(a2, b3); // error free\r\n    let a3a3 = tp(a3, a3); // error free\r\n    let b2b2 = tp(b2, b2); // error free\r\n    let b3b3 = tp(b3, b3); // error free\r\n    let a1a3 = tp(a1, a3); // error free\r\n    let a2a2 = tp(a2, a2); // error free\r\n    let b1b3 = tp(b1, b3); // error free\r\n    let b2b3 = tp(b2, b3); // error free\r\n    let a2a3 = tp(a2, a3); // error free\r\n    let a3b3 = tp(a3, b3); // error free\r\n    let a3b0 = tp(a3, b0); // error free\r\n    let a0b3 = tp(a0, b3); // error free\r\n    let a2b0 = tp(a2, b0); // error free\r\n    let a0b2 = tp(a0, b2); // error free\r\n    let a2b1 = tp(a2, b1); // error free\r\n    let a1b2 = tp(a1, b2); // error free\r\n    let a1b0 = tp(a1, b0); // error free\r\n    let a0b1 = tp(a0, b1); // error free\r\n    let q1 = qdq(a3b0, a0b3); // 48-bit aligned => error free\r\n    let q2 = qdq(a3b1, a1b3); // 48-bit aligned => error free\r\n    let q3 = qdq(a3b2, a2b3); // 48-bit aligned => error free\r\n    let q4 = qdq(a2b0, a0b2); // 48-bit aligned => error free\r\n    let q5 = qdq(a2b1, a1b2); // 48-bit aligned => error free\r\n    let q6 = qdq(a1b0, a0b1); // 48-bit aligned => error free\r\n    let t1 = qdq(b1b3, b2b2); // 48-bit aligned => error free\r\n    let t2 = qdq(a1a3, a2a2); // 48-bit aligned => error free\r\n    let p1 = qaq(a2b3, a3b2); // 48-bit aligned => error free\r\n    let p2 = qaq(a1b3, a3b1); // 48-bit aligned => error free\r\n    let tq2 = qm2(q2); // error free\r\n    let q1q1 = qmq(q1, q1);\r\n    let q1q2 = qmq(q1, q2);\r\n    let q1q3 = qmq(q1, q3);\r\n    let q1q5 = qmq(q1, q5);\r\n    let q2q2 = qmq(q2, q2);\r\n    let tq2q4 = qmq(tq2, q4);\r\n    let q3q4 = qmq(q3, q4);\r\n    let q3q5 = qmq(q3, q5);\r\n    let q3q6 = qmq(q3, q6);\r\n    let q1q1_ = 2 * abs(q1q1[1]);\r\n    let q1q2_ = 2 * abs(q1q2[1]);\r\n    let q1q3_ = 2 * abs(q1q3[1]);\r\n    let q1q5_ = 2 * abs(q1q5[1]);\r\n    let q2q2_ = 2 * abs(q2q2[1]);\r\n    let tq2q4_ = 2 * abs(tq2q4[1]);\r\n    let q3q4_ = 2 * abs(q3q4[1]);\r\n    let q3q5_ = 2 * abs(q3q5[1]);\r\n    let q3q6_ = 2 * abs(q3q4[1]);\r\n    let vₓₓₓ = qmd(-b3, b3b3);\r\n    let vₓₓₓ_ = abs(vₓₓₓ[1]);\r\n    // recall: \r\n    // 49-bit aligned => 0 bits left in e.g. a3b2\r\n    // 48-bit aligned => 2 bits left in e.g. a3b2\r\n    // 47-bit aligned => 4 bits left in e.g. a3b2\r\n    // 46-bit aligned => 6 bits left in e.g. a3b2\r\n    // 47-bit aligned => 3*a0,...,b3 -> error free\r\n    let vₓₓᵧ = qmd(3 * a3, b3b3);\r\n    let vₓₓᵧ_ = abs(vₓₓᵧ[1]);\r\n    // 47-bit aligned => 3*a0,...,b3 -> error free\r\n    let vₓᵧᵧ = qmd(-3 * b3, a3a3);\r\n    let vₓᵧᵧ_ = abs(vₓᵧᵧ[1]);\r\n    let vᵧᵧᵧ = qmd(a3, a3a3);\r\n    let vᵧᵧᵧ_ = abs(vᵧᵧᵧ[1]);\r\n    // 47-bit aligned => qmd(3*q1 - q5,...) -> error free\r\n    let u1 = qdq(qmd(-3, q1), q5); // 47-bit aligned => qmd(3*q1 - q5) -> error free\r\n    //let u1_ = 3*_q1 + _u1;\r\n    // 48-bit aligned => t1, t2 -> error free\r\n    //let t1_ = _b1b3 + _b2b2 + _t1;\r\n    //let _t2 = abs(t2);\r\n    //let t2_ = _a1a3 + _a2a2 + abs(t2);\r\n    let w1 = qmq(u1, b3b3);\r\n    // recall: 2* below since error of qmq is double that of others\r\n    let w1_ = 2 * abs(w1[1]);\r\n    let w2 = qmq(q3, t1);\r\n    let w2_ = 2 * abs(w2[1]);\r\n    let w3 = qaq(w1, w2);\r\n    let w3_ = w1_ + w2_ + abs(w3[1]);\r\n    let w4 = qmq(tq2, b2b3);\r\n    let w4_ = 2 * abs(w4[1]);\r\n    //let vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    let vₓₓ = qaq(w3, w4);\r\n    let vₓₓ_ = w3_ + w4_ + abs(vₓₓ[1]);\r\n    let w5 = qmq(u1, a3a3);\r\n    let w5_ = 2 * abs(w5[1]);\r\n    let w6 = qmq(q3, t2);\r\n    let w6_ = 2 * abs(w6[1]);\r\n    let w7 = qaq(w5, w6);\r\n    let w7_ = w5_ + w6_ + abs(w7[1]);\r\n    let w8 = qmq(tq2, a2a3);\r\n    let w8_ = 2 * abs(w8[1]);\r\n    //let vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    let vᵧᵧ = qaq(w7, w8);\r\n    let vᵧᵧ_ = w7_ + w8_ + abs(vᵧᵧ[1]);\r\n    // 47-bit aligned => wa = a2b2 - p2/2 -> error free\r\n    let wa = qdq(a2b2, qd2(p2));\r\n    let wb = qmq(u1, a3b3);\r\n    let wb_ = 2 * abs(wb[1]);\r\n    let wc = qmq(q2, p1);\r\n    let wc_ = 2 * abs(wc[1]);\r\n    let wd = qaq(wb, wc);\r\n    let wd_ = wb_ + wc_ + abs(wd[1]);\r\n    let wq = qmq(q3, wa);\r\n    let wq_ = 2 * abs(wq[1]);\r\n    //let vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    let vₓᵧ = qm2(qdq(wq, wd));\r\n    let vₓᵧ_ = 2 * (wq_ + wd_) + abs(vₓᵧ[1]);\r\n    let wr = qmd(-3, q1q1);\r\n    let wr_ = 3 * q1q1_ + abs(wr[1]);\r\n    let we = qdq(wr, qm2(q1q5));\r\n    let we_ = wr_ + 2 * q1q5_ + abs(we[1]);\r\n    let wf = qaq(tq2q4, q3q6);\r\n    let wf_ = tq2q4_ + q3q6_ + abs(wf[1]);\r\n    //let s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    let s1 = qaq(we, wf);\r\n    let s1_ = we_ + wf_ + abs(s1[1]);\r\n    //let s2 = 2*(q1q2 - q3q4);\r\n    let s2 = qm2(qdq(q1q2, q3q4));\r\n    let s2_ = 2 * (q1q2_ + q3q4_) + abs(s2[1]);\r\n    let wl = qdq(q1q3, q2q2);\r\n    let wl_ = q1q3_ + q2q2_ + abs(wl[1]);\r\n    //let s3 = q1q3 - q2q2 + q3q5;\r\n    let s3 = qaq(wl, q3q5);\r\n    let s3_ = wl_ + q3q5_ + abs(s3[1]);\r\n    let wm = qmd(b3, s1);\r\n    let wm_ = abs(b3) * s1_ + abs(wm[1]);\r\n    let ws = qmd(b2, s2);\r\n    let ws_ = abs(b2) * s2_ + abs(ws[1]);\r\n    let wt = qmd(b1, s3);\r\n    let wt_ = abs(b1) * s3_ + abs(wt[1]);\r\n    let wn = qaq(ws, wt);\r\n    let wn_ = ws_ + wt_ + abs(wn[1]);\r\n    //let vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    let vₓ = qaq(wm, wn);\r\n    let vₓ_ = wm_ + wn_ + abs(vₓ[1]);\r\n    let wo = qmd(a3, s1);\r\n    let wo_ = abs(a3) * s1_ + abs(wo[1]);\r\n    let wu = qmd(a2, s2);\r\n    let wu_ = abs(a2) * s2_ + abs(wu[1]);\r\n    let wv = qmd(a1, s3);\r\n    let wv_ = abs(a1) * s3_ + abs(wv[1]);\r\n    let wp = qaq(wu, wv);\r\n    let wp_ = wu_ + wv_ + abs(wp[1]);\r\n    //let vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    let vᵧ = qno(qaq(wo, wp));\r\n    let vᵧ_ = wo_ + wp_ + abs(vᵧ[1]);\r\n    let v3 = qdq(tq2q4, q1q1);\r\n    let v3_ = tq2q4_ + q1q1_ + abs(v3[1]);\r\n    let v1 = qdq(v3, q1q5);\r\n    let _v1 = abs(v1[1]);\r\n    let v1_ = v3_ + q1q5_ + _v1;\r\n    let v4 = qmq(s3, q6);\r\n    let v4_ = s3_ * abs(q6[1]) + 2 * abs(v4[1]);\r\n    let v5 = qmq(q3q4, q4);\r\n    let v5_ = q3q4_ * abs(q4[1]) + 2 * abs(v5[1]);\r\n    let v2 = qdq(v4, v5);\r\n    let v2_ = v4_ + v5_ + abs(v2[1]);\r\n    let v6 = qmq(q1, v1);\r\n    let v6_ = abs(q1[1]) * v1_ + 2 * abs(v6[1]);\r\n    //let v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    let v = qaq(v6, v2);\r\n    let v_ = v6_ + v2_ + abs(v[1]);\r\n    return {\r\n        coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\nexports.getImplicitForm3Quad = getImplicitForm3Quad;\r\n//# sourceMappingURL=get-implicit-form3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-bezier3/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nexports.rotate = flo_vector2d_1.rotatePs;\r\nexports.translate = flo_vector2d_1.translatePs;\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_graham_scan_1 = __webpack_require__(/*! flo-graham-scan */ \"./node_modules/flo-graham-scan/node/index.js\");\r\nconst length_1 = __webpack_require__(/*! ./global-properties/length/length */ \"./node_modules/flo-bezier3/node/global-properties/length/length.js\");\r\nexports.length = length_1.length;\r\nconst clone_1 = __webpack_require__(/*! ./transformation/clone */ \"./node_modules/flo-bezier3/node/transformation/clone.js\");\r\nexports.clone = clone_1.clone;\r\nconst get_t_at_length_1 = __webpack_require__(/*! ./local-properties-to-t/get-t-at-length */ \"./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js\");\r\nexports.getTAtLength = get_t_at_length_1.getTAtLength;\r\nconst equal_1 = __webpack_require__(/*! ./simultaneous-properties/equal */ \"./node_modules/flo-bezier3/node/simultaneous-properties/equal.js\");\r\nexports.equal = equal_1.equal;\r\nconst cubic_to_quadratic_1 = __webpack_require__(/*! ./transformation/cubic-to-quadratic */ \"./node_modules/flo-bezier3/node/transformation/cubic-to-quadratic.js\");\r\nexports.cubicToQuadratic = cubic_to_quadratic_1.cubicToQuadratic;\r\nconst from_bezier_piece_1 = __webpack_require__(/*! ./transformation/from-bezier-piece */ \"./node_modules/flo-bezier3/node/transformation/from-bezier-piece.js\");\r\nexports.bezierFromBezierPiece = from_bezier_piece_1.bezierFromBezierPiece;\r\nconst evaluate_hybrid_quadratic_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/evaluate-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-hybrid-quadratic.js\");\r\nexports.evaluateHybridQuadratic = evaluate_hybrid_quadratic_1.evaluateHybridQuadratic;\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! ./simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js\");\r\nexports.closestPointOnBezier = closest_point_on_bezier_1.closestPointOnBezier;\r\nconst intersect_boxes_1 = __webpack_require__(/*! ./geometry/intersect-boxes */ \"./node_modules/flo-bezier3/node/geometry/intersect-boxes.js\");\r\nexports.intersectBoxes = intersect_boxes_1.intersectBoxes;\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\nexports.evalDeCasteljau = eval_de_casteljau_1.evalDeCasteljau;\r\nexports.evalDeCasteljauX = eval_de_casteljau_1.evalDeCasteljauX;\r\nexports.evalDeCasteljauY = eval_de_casteljau_1.evalDeCasteljauY;\r\nconst eval_de_casteljau_with_err_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/eval-de-casteljau-with-err */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau-with-err.js\");\r\nexports.evalDeCasteljauWithErr = eval_de_casteljau_with_err_1.evalDeCasteljauWithErr;\r\nexports.evalDeCasteljauWithErrQuad = eval_de_casteljau_with_err_1.evalDeCasteljauWithErrQuad;\r\nconst is_point_on_bezier_extension_1 = __webpack_require__(/*! ./simultaneous-properties/is-point-on-bezier-extension */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension.js\");\r\nexports.isPointOnBezierExtension = is_point_on_bezier_extension_1.isPointOnBezierExtension;\r\nconst total_curvature_1 = __webpack_require__(/*! ./global-properties/total-curvature */ \"./node_modules/flo-bezier3/node/global-properties/total-curvature.js\");\r\nexports.totalCurvature = total_curvature_1.totalCurvature;\r\nexports.totalAbsoluteCurvature = total_curvature_1.totalAbsoluteCurvature;\r\nconst reverse_1 = __webpack_require__(/*! ./transformation/reverse */ \"./node_modules/flo-bezier3/node/transformation/reverse.js\");\r\nexports.reverse = reverse_1.reverse;\r\nconst get_inflection_points_1 = __webpack_require__(/*! ./global-properties/get-inflection-points */ \"./node_modules/flo-bezier3/node/global-properties/get-inflection-points.js\");\r\nexports.getInflectionPoints = get_inflection_points_1.getInflectionPoints;\r\nconst bezier_bezier_intersection_implicit_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit.js\");\r\nexports.getIntersectionCoeffs = bezier_bezier_intersection_implicit_1.getIntersectionCoeffs;\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ./implicit-form/naive/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js\");\r\nexports.getImplicitForm3 = get_implicit_form3_1.getImplicitForm3;\r\nconst get_implicit_form3_2 = __webpack_require__(/*! ./implicit-form/quad/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js\");\r\nexports.getImplicitForm3Quad = get_implicit_form3_2.getImplicitForm3Quad;\r\nconst get_implicit_form3_3 = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js\");\r\nexports.getImplicitForm3Exact = get_implicit_form3_3.getImplicitForm3Exact;\r\nconst get_implicit_form3_4 = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form3- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js\");\r\nexports.getImplicitForm3Exact_ = get_implicit_form3_4.getImplicitForm3Exact_;\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ./implicit-form/naive/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js\");\r\nexports.getImplicitForm2 = get_implicit_form2_1.getImplicitForm2;\r\nconst get_implicit_form2_2 = __webpack_require__(/*! ./implicit-form/quad/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js\");\r\nexports.getImplicitForm2Quad = get_implicit_form2_2.getImplicitForm2Quad;\r\nconst get_implicit_form2_3 = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js\");\r\nexports.getImplicitForm2Exact = get_implicit_form2_3.getImplicitForm2Exact;\r\nconst get_implicit_form2_4 = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form2- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js\");\r\nexports.getImplicitForm2Exact_ = get_implicit_form2_4.getImplicitForm2Exact_;\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ./implicit-form/naive/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js\");\r\nexports.getImplicitForm1 = get_implicit_form1_1.getImplicitForm1;\r\nconst get_implicit_form1_2 = __webpack_require__(/*! ./implicit-form/quad/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js\");\r\nexports.getImplicitForm1Quad = get_implicit_form1_2.getImplicitForm1Quad;\r\nconst get_implicit_form1_3 = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js\");\r\nexports.getImplicitForm1Exact = get_implicit_form1_3.getImplicitForm1Exact;\r\nconst get_implicit_form1_4 = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form1- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js\");\r\nexports.getImplicitForm1Exact_ = get_implicit_form1_4.getImplicitForm1Exact_;\r\nconst get_coefficients_3x3_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-3x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x3.js\");\r\nexports.getCoeffs3x3 = get_coefficients_3x3_1.getCoeffs3x3;\r\nconst get_coefficients_3x3_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-3x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x3.js\");\r\nexports.getCoeffs3x3Quad = get_coefficients_3x3_2.getCoeffs3x3Quad;\r\nconst get_coefficients_3x3_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-3x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3.js\");\r\nexports.getCoeffs3x3Exact = get_coefficients_3x3_3.getCoeffs3x3Exact;\r\nconst get_coefficients_3x3_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-3x3- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3-.js\");\r\nexports.getCoeffs3x3Exact_ = get_coefficients_3x3_4.getCoeffs3x3Exact_;\r\nconst get_coefficients_3x2_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-3x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x2.js\");\r\nexports.getCoeffs3x2 = get_coefficients_3x2_1.getCoeffs3x2;\r\nconst get_coefficients_3x2_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-3x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x2.js\");\r\nexports.getCoeffs3x2Quad = get_coefficients_3x2_2.getCoeffs3x2Quad;\r\nconst get_coefficients_3x2_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-3x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2.js\");\r\nexports.getCoeffs3x2Exact = get_coefficients_3x2_3.getCoeffs3x2Exact;\r\nconst get_coefficients_3x2_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-3x2- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2-.js\");\r\nexports.getCoeffs3x2Exact_ = get_coefficients_3x2_4.getCoeffs3x2Exact_;\r\nconst get_coefficients_3x1_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-3x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x1.js\");\r\nexports.getCoeffs3x1 = get_coefficients_3x1_1.getCoeffs3x1;\r\nconst get_coefficients_3x1_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-3x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x1.js\");\r\nexports.getCoeffs3x1Quad = get_coefficients_3x1_2.getCoeffs3x1Quad;\r\nconst get_coefficients_3x1_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-3x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1.js\");\r\nexports.getCoeffs3x1Exact = get_coefficients_3x1_3.getCoeffs3x1Exact;\r\nconst get_coefficients_3x1_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-3x1- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1-.js\");\r\nexports.getCoeffs3x1Exact_ = get_coefficients_3x1_4.getCoeffs3x1Exact_;\r\nconst get_coefficients_2x3_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-2x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x3.js\");\r\nexports.getCoeffs2x3 = get_coefficients_2x3_1.getCoeffs2x3;\r\nconst get_coefficients_2x3_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-2x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x3.js\");\r\nexports.getCoeffs2x3Quad = get_coefficients_2x3_2.getCoeffs2x3Quad;\r\nconst get_coefficients_2x3_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-2x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3.js\");\r\nexports.getCoeffs2x3Exact = get_coefficients_2x3_3.getCoeffs2x3Exact;\r\nconst get_coefficients_2x3_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-2x3- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3-.js\");\r\nexports.getCoeffs2x3Exact_ = get_coefficients_2x3_4.getCoeffs2x3Exact_;\r\nconst get_coefficients_2x2_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-2x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x2.js\");\r\nexports.getCoeffs2x2 = get_coefficients_2x2_1.getCoeffs2x2;\r\nconst get_coefficients_2x2_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-2x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x2.js\");\r\nexports.getCoeffs2x2Quad = get_coefficients_2x2_2.getCoeffs2x2Quad;\r\nconst get_coefficients_2x2_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-2x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2.js\");\r\nexports.getCoeffs2x2Exact = get_coefficients_2x2_3.getCoeffs2x2Exact;\r\nconst get_coefficients_2x2_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-2x2- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2-.js\");\r\nexports.getCoeffs2x2Exact_ = get_coefficients_2x2_4.getCoeffs2x2Exact_;\r\nconst get_coefficients_2x1_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-2x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x1.js\");\r\nexports.getCoeffs2x1 = get_coefficients_2x1_1.getCoeffs2x1;\r\nconst get_coefficients_2x1_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-2x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x1.js\");\r\nexports.getCoeffs2x1Quad = get_coefficients_2x1_2.getCoeffs2x1Quad;\r\nconst get_coefficients_2x1_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-2x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1.js\");\r\nexports.getCoeffs2x1Exact = get_coefficients_2x1_3.getCoeffs2x1Exact;\r\nconst get_coefficients_2x1_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-2x1- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1-.js\");\r\nexports.getCoeffs2x1Exact_ = get_coefficients_2x1_4.getCoeffs2x1Exact_;\r\nconst get_coefficients_1x3_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-1x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x3.js\");\r\nexports.getCoeffs1x3 = get_coefficients_1x3_1.getCoeffs1x3;\r\nconst get_coefficients_1x3_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-1x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x3.js\");\r\nexports.getCoeffs1x3Quad = get_coefficients_1x3_2.getCoeffs1x3Quad;\r\nconst get_coefficients_1x3_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-1x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3.js\");\r\nexports.getCoeffs1x3Exact = get_coefficients_1x3_3.getCoeffs1x3Exact;\r\nconst get_coefficients_1x3_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-1x3- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3-.js\");\r\nexports.getCoeffs1x3Exact_ = get_coefficients_1x3_4.getCoeffs1x3Exact_;\r\nconst get_coefficients_1x2_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-1x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x2.js\");\r\nexports.getCoeffs1x2 = get_coefficients_1x2_1.getCoeffs1x2;\r\nconst get_coefficients_1x2_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-1x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x2.js\");\r\nexports.getCoeffs1x2Quad = get_coefficients_1x2_2.getCoeffs1x2Quad;\r\nconst get_coefficients_1x2_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-1x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2.js\");\r\nexports.getCoeffs1x2Exact = get_coefficients_1x2_3.getCoeffs1x2Exact;\r\nconst get_coefficients_1x2_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-1x2- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2-.js\");\r\nexports.getCoeffs1x2Exact_ = get_coefficients_1x2_4.getCoeffs1x2Exact_;\r\nconst get_coefficients_1x1_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/naive/get-coefficients-1x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x1.js\");\r\nexports.getCoeffs1x1 = get_coefficients_1x1_1.getCoeffs1x1;\r\nconst get_coefficients_1x1_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/quad/get-coefficients-1x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x1.js\");\r\nexports.getCoeffs1x1Quad = get_coefficients_1x1_2.getCoeffs1x1Quad;\r\nconst get_coefficients_1x1_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-1x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1.js\");\r\nexports.getCoeffs1x1Exact = get_coefficients_1x1_3.getCoeffs1x1Exact;\r\nconst get_coefficients_1x1_4 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/exact/get-coefficients-1x1- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1-.js\");\r\nexports.getCoeffs1x1Exact_ = get_coefficients_1x1_4.getCoeffs1x1Exact_;\r\nconst get_coeffs_3_1 = __webpack_require__(/*! ./intersection/self-intersection/naive/get-coeffs-3 */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/naive/get-coeffs-3.js\");\r\nexports.getCoeffs3 = get_coeffs_3_1.getCoeffs3;\r\nconst get_coeffs_3_2 = __webpack_require__(/*! ./intersection/self-intersection/quad/get-coeffs-3 */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/quad/get-coeffs-3.js\");\r\nexports.getCoeffs3Quad = get_coeffs_3_2.getCoeffs3Quad;\r\nconst get_coeffs_3_3 = __webpack_require__(/*! ./intersection/self-intersection/exact/get-coeffs-3 */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3.js\");\r\nexports.getCoeffs3Exact = get_coeffs_3_3.getCoeffs3Exact;\r\nconst to_expansion_1 = __webpack_require__(/*! ./transformation/to-expansion */ \"./node_modules/flo-bezier3/node/transformation/to-expansion.js\");\r\nexports.toExpansion = to_expansion_1.toExpansion;\r\nconst to_estimation_1 = __webpack_require__(/*! ./transformation/to-estimation */ \"./node_modules/flo-bezier3/node/transformation/to-estimation.js\");\r\nexports.toEstimation = to_estimation_1.toEstimation;\r\nconst from_power_bases_1 = __webpack_require__(/*! ./from-power-basis/from-power-bases */ \"./node_modules/flo-bezier3/node/from-power-basis/from-power-bases.js\");\r\nexports.fromPowerBases = from_power_bases_1.fromPowerBases;\r\nconst get_hodograph_1 = __webpack_require__(/*! ./transformation/get-hodograph */ \"./node_modules/flo-bezier3/node/transformation/get-hodograph.js\");\r\nexports.getHodograph = get_hodograph_1.getHodograph;\r\nconst generate_cusp_at_half_t_1 = __webpack_require__(/*! ./create/generate-cusp-at-half-t */ \"./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js\");\r\nexports.generateCuspAtHalf3 = generate_cusp_at_half_t_1.generateCuspAtHalf3;\r\nconst cubic_through_point_1 = __webpack_require__(/*! ./create/cubic-through-point */ \"./node_modules/flo-bezier3/node/create/cubic-through-point.js\");\r\nexports.cubicThroughPointGiven013 = cubic_through_point_1.cubicThroughPointGiven013;\r\nconst self_intersection_1 = __webpack_require__(/*! ./intersection/self-intersection/self-intersection */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/self-intersection.js\");\r\nexports.bezierSelfIntersection = self_intersection_1.bezierSelfIntersection;\r\nconst get_endpoint_intersections_1 = __webpack_require__(/*! ./intersection/get-endpoint-intersections */ \"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections.js\");\r\nexports.getEndpointIntersections = get_endpoint_intersections_1.getEndpointIntersections;\r\nconst inversion_01_1 = __webpack_require__(/*! ./intersection/inversion-01 */ \"./node_modules/flo-bezier3/node/intersection/inversion-01.js\");\r\nexports.inversion01Precise = inversion_01_1.inversion01Precise;\r\nconst inversion_old_1 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/inversion-old */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/inversion-old.js\");\r\nexports.inversion1_BL52_1ULP = inversion_old_1.inversion1_BL52_1ULP;\r\nconst get_xy_1 = __webpack_require__(/*! ./to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nexports.getXY = get_xy_1.getXY;\r\nconst get_dxy_1 = __webpack_require__(/*! ./to-power-basis/get-dxy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dxy.js\");\r\nexports.getDxy = get_dxy_1.getDxy;\r\nconst get_ddxy_1 = __webpack_require__(/*! ./to-power-basis/get-ddxy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-ddxy.js\");\r\nexports.getDdxy = get_ddxy_1.getDdxy;\r\nconst get_x_1 = __webpack_require__(/*! ./to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nexports.getX = get_x_1.getX;\r\nconst get_y_1 = __webpack_require__(/*! ./to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nexports.getY = get_y_1.getY;\r\nconst get_dx_1 = __webpack_require__(/*! ./to-power-basis/get-dx */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dx.js\");\r\nexports.getDx = get_dx_1.getDx;\r\nconst get_dy_1 = __webpack_require__(/*! ./to-power-basis/get-dy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dy.js\");\r\nexports.getDy = get_dy_1.getDy;\r\nconst get_ddx_1 = __webpack_require__(/*! ./to-power-basis/get-ddx */ \"./node_modules/flo-bezier3/node/to-power-basis/get-ddx.js\");\r\nexports.getDdx = get_ddx_1.getDdx;\r\nconst get_ddy_1 = __webpack_require__(/*! ./to-power-basis/get-ddy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-ddy.js\");\r\nexports.getDdy = get_ddy_1.getDdy;\r\nconst get_dxy_at_1_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-dxy/get-dxy-at-1 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-1.js\");\r\nexports.getDxyAt1 = get_dxy_at_1_1.getDxyAt1;\r\nconst get_ddxy_at_1_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-ddxy/get-ddxy-at-1 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-1.js\");\r\nexports.getDdxyAt1 = get_ddxy_at_1_1.getDdxyAt1;\r\nconst get_dxy_at_0_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-dxy/get-dxy-at-0 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-0.js\");\r\nexports.getDxyAt0 = get_dxy_at_0_1.getDxyAt0;\r\nconst get_ddxy_at_0_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-ddxy/get-ddxy-at-0 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-0.js\");\r\nexports.getDdxyAt0 = get_ddxy_at_0_1.getDdxyAt0;\r\nconst get_dddxy_1 = __webpack_require__(/*! ./to-power-basis/get-dddxy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dddxy.js\");\r\nexports.getDddxy = get_dddxy_1.getDddxy;\r\nconst evaluate_x_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/evaluate-x */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-x.js\");\r\nexports.evaluateX = evaluate_x_1.evaluateX;\r\nconst evaluate_y_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/evaluate-y */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-y.js\");\r\nexports.evaluateY = evaluate_y_1.evaluateY;\r\nconst evaluate_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/evaluate */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js\");\r\nexports.evaluate = evaluate_1.evaluate;\r\nconst evaluate_2 = __webpack_require__(/*! ./local-properties-at-t/t-to-xy/evaluate */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js\");\r\nexports.evaluateExact = evaluate_2.evaluateExact;\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-dxy/evaluate-dx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js\");\r\nexports.evaluateDx = evaluate_dx_1.evaluateDx;\r\nconst evaluate_ddx_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-ddxy/evaluate-ddx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddx.js\");\r\nexports.evaluateDdx = evaluate_ddx_1.evaluateDdx;\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-dxy/evaluate-dy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js\");\r\nexports.evaluateDy = evaluate_dy_1.evaluateDy;\r\nconst evaluate_ddy_1 = __webpack_require__(/*! ./local-properties-at-t/t-to-ddxy/evaluate-ddy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddy.js\");\r\nexports.evaluateDdy = evaluate_ddy_1.evaluateDdy;\r\nconst tangent_1 = __webpack_require__(/*! ./local-properties-at-t/tangent */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent.js\");\r\nexports.tangent = tangent_1.tangent;\r\nconst normal_1 = __webpack_require__(/*! ./local-properties-at-t/normal */ \"./node_modules/flo-bezier3/node/local-properties-at-t/normal.js\");\r\nexports.normal = normal_1.normal;\r\nconst from_0_to_T_1 = __webpack_require__(/*! ./transformation/split-merge-clone/from-0-to-T */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-0-to-T.js\");\r\nexports.from0ToT = from_0_to_T_1.from0ToT;\r\nconst from_T_to_1_1 = __webpack_require__(/*! ./transformation/split-merge-clone/from-T-to-1 */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-T-to-1.js\");\r\nexports.fromTTo1 = from_T_to_1_1.fromTTo1;\r\nconst from_to_1 = __webpack_require__(/*! ./transformation/split-merge-clone/from-to */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js\");\r\nexports.fromTo = from_to_1.fromTo;\r\nexports.fromToPrecise = from_to_1.fromToPrecise;\r\nconst bezier_bezier_intersection_implicit_2 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit.js\");\r\nexports.getOtherTs = bezier_bezier_intersection_implicit_2.getOtherTs;\r\nconst bezier_bezier_intersection_implicit_3 = __webpack_require__(/*! ./intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit.js\");\r\nexports.bezierBezierIntersectionImplicit = bezier_bezier_intersection_implicit_3.bezierBezierIntersectionImplicit;\r\nconst to_cubic_1 = __webpack_require__(/*! ./transformation/degree-or-type/to-cubic */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js\");\r\nexports.toCubic = to_cubic_1.toCubic;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-bezier3/node/debug/debug.js\");\r\nexports.BezDebug = debug_1.BezDebug;\r\nconst curvature_1 = __webpack_require__(/*! ./local-properties-at-t/curvature */ \"./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js\");\r\nexports.κ = curvature_1.κ;\r\nconst quad_to_polyline_1 = __webpack_require__(/*! ./transformation/quad-to-polyline */ \"./node_modules/flo-bezier3/node/transformation/quad-to-polyline.js\");\r\nexports.quadToPolyline = quad_to_polyline_1.quadToPolyline;\r\nconst is_quad_obtuse_1 = __webpack_require__(/*! ./global-properties/type/is-quad-obtuse */ \"./node_modules/flo-bezier3/node/global-properties/type/is-quad-obtuse.js\");\r\nexports.isQuadObtuse = is_quad_obtuse_1.isQuadObtuse;\r\nconst get_interval_box_1 = __webpack_require__(/*! ./global-properties/bounds/get-interval-box/get-interval-box */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\r\nexports.getIntervalBox = get_interval_box_1.getIntervalBox;\r\nexports.getIntervalBox1 = get_interval_box_1.getIntervalBox1;\r\nexports.getIntervalBox2 = get_interval_box_1.getIntervalBox2;\r\nexports.getIntervalBox3 = get_interval_box_1.getIntervalBox3;\r\nconst get_interval_box_quad_1 = __webpack_require__(/*! ./global-properties/bounds/get-interval-box/get-interval-box-quad */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-quad.js\");\r\nexports.getIntervalBoxQuad = get_interval_box_quad_1.getIntervalBoxQuad;\r\nexports.getIntervalBox1Quad = get_interval_box_quad_1.getIntervalBox1Quad;\r\nexports.getIntervalBox2Quad = get_interval_box_quad_1.getIntervalBox2Quad;\r\nexports.getIntervalBox3Quad = get_interval_box_quad_1.getIntervalBox3Quad;\r\nconst split_at_1 = __webpack_require__(/*! ./transformation/split-merge-clone/split-at */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js\");\r\nexports.splitAt = split_at_1.splitAt;\r\nexports.splitAtPrecise = split_at_1.splitAtPrecise;\r\nconst closest_point_on_bezier_2 = __webpack_require__(/*! ./simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js\");\r\nexports.closestPointOnBezierPrecise = closest_point_on_bezier_2.closestPointOnBezierPrecise;\r\nconst hausdorff_distance_1 = __webpack_require__(/*! ./simultaneous-properties/hausdorff-distance */ \"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance.js\");\r\nexports.hausdorffDistance = hausdorff_distance_1.hausdorffDistance;\r\nexports.hausdorffDistanceCandidates = hausdorff_distance_1.hausdorffDistanceCandidates;\r\nconst length_upper_bound_1 = __webpack_require__(/*! ./global-properties/length/length-upper-bound */ \"./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js\");\r\nexports.lengthUpperBound = length_upper_bound_1.lengthUpperBound;\r\nconst length_squared_upper_bound_1 = __webpack_require__(/*! ./global-properties/length/length-squared-upper-bound */ \"./node_modules/flo-bezier3/node/global-properties/length/length-squared-upper-bound.js\");\r\nexports.lengthSquaredUpperBound = length_squared_upper_bound_1.lengthSquaredUpperBound;\r\nconst split_by_max_curve_length_1 = __webpack_require__(/*! ./transformation/split-merge-clone/split-by-max-curve-length */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curve-length.js\");\r\nexports.splitByMaxCurveLength = split_by_max_curve_length_1.splitByMaxCurveLength;\r\nconst get_curvature_extrema_1 = __webpack_require__(/*! ./get-curvature-extrema/get-curvature-extrema */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js\");\r\nexports.getCurvatureExtrema = get_curvature_extrema_1.getCurvatureExtrema;\r\nconst get_inflections_1 = __webpack_require__(/*! ./local-properties-to-t/get-inflections */ \"./node_modules/flo-bezier3/node/local-properties-to-t/get-inflections.js\");\r\nexports.getInflections = get_inflections_1.getInflections;\r\nconst flatness_1 = __webpack_require__(/*! ./global-properties/flatness */ \"./node_modules/flo-bezier3/node/global-properties/flatness.js\");\r\nexports.flatness = flatness_1.flatness;\r\nconst split_by_max_curvature_1 = __webpack_require__(/*! ./transformation/split-merge-clone/split-by-max-curvature */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curvature.js\");\r\nexports.splitByMaxCurvature = split_by_max_curvature_1.splitByMaxCurvature;\r\nconst split_by_curvature_and_length_1 = __webpack_require__(/*! ./transformation/split-merge-clone/split-by-curvature-and-length */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-curvature-and-length.js\");\r\nexports.splitByCurvatureAndLength = split_by_curvature_and_length_1.splitByCurvatureAndLength;\r\nconst are_beziers_in_same_k_family_1 = __webpack_require__(/*! ./simultaneous-properties/are-beziers-in-same-k-family */ \"./node_modules/flo-bezier3/node/simultaneous-properties/are-beziers-in-same-k-family.js\");\r\nexports.areBeziersInSameKFamily = are_beziers_in_same_k_family_1.areBeziersInSameKFamily;\r\nconst get_interface_ccw_1 = __webpack_require__(/*! ./simultaneous-properties/get-interface-ccw */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-ccw.js\");\r\nexports.getInterfaceCcw = get_interface_ccw_1.getInterfaceCcw;\r\nconst is_line_1 = __webpack_require__(/*! ./global-properties/type/is-line */ \"./node_modules/flo-bezier3/node/global-properties/type/is-line.js\");\r\nexports.isLine = is_line_1.isLine;\r\nexports.isHorizontalLine = is_line_1.isHorizontalLine;\r\nexports.isVerticalLine = is_line_1.isVerticalLine;\r\nconst is_self_overlapping_1 = __webpack_require__(/*! ./global-properties/type/is-self-overlapping */ \"./node_modules/flo-bezier3/node/global-properties/type/is-self-overlapping.js\");\r\nexports.isSelfOverlapping = is_self_overlapping_1.isSelfOverlapping;\r\nconst get_tangent_poly_from_point_1 = __webpack_require__(/*! ./simultaneous-properties/get-tangent-poly-from-point/naive/get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/naive/get-tangent-poly-from-point.js\");\r\nexports.getTangentPolyFromPoint = get_tangent_poly_from_point_1.getTangentPolyFromPoint;\r\nconst get_tangent_poly_from_point_2 = __webpack_require__(/*! ./simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point.js\");\r\nexports.getTangentPolyFromPointExact = get_tangent_poly_from_point_2.getTangentPolyFromPointExact;\r\nconst get_bounds_1 = __webpack_require__(/*! ./global-properties/bounds/get-bounds */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js\");\r\nexports.getXBoundsTight = get_bounds_1.getXBoundsTight;\r\nexports.getYBoundsTight = get_bounds_1.getYBoundsTight;\r\nconst get_bounds_2 = __webpack_require__(/*! ./global-properties/bounds/get-bounds */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js\");\r\nexports.getBounds = get_bounds_2.getBounds;\r\nconst get_bounding_box_tight_1 = __webpack_require__(/*! ./global-properties/bounds/get-bounding-box-tight */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js\");\r\nexports.getBoundingBoxTight = get_bounding_box_tight_1.getBoundingBoxTight;\r\nconst get_bounding_box_1 = __webpack_require__(/*! ./global-properties/bounds/get-bounding-box */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js\");\r\nexports.getBoundingBox = get_bounding_box_1.getBoundingBox;\r\nconst to_hybrid_quadratic_1 = __webpack_require__(/*! ./transformation/degree-or-type/to-hybrid-quadratic */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-hybrid-quadratic.js\");\r\nexports.toHybridQuadratic = to_hybrid_quadratic_1.toHybridQuadratic;\r\nconst is_cubic_really_quad_1 = __webpack_require__(/*! ./global-properties/type/is-cubic-really-quad */ \"./node_modules/flo-bezier3/node/global-properties/type/is-cubic-really-quad.js\");\r\nexports.isCubicReallyQuad = is_cubic_really_quad_1.isCubicReallyQuad;\r\nconst to_quad_from_cubic_1 = __webpack_require__(/*! ./transformation/degree-or-type/to-quad-from-cubic */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-quad-from-cubic.js\");\r\nexports.toQuadraticFromCubic = to_quad_from_cubic_1.toQuadraticFromCubic;\r\nconst circle_bezier_intersection_1 = __webpack_require__(/*! ./intersection/circle-bezier-intersection/naive/circle-bezier-intersection */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/circle-bezier-intersection.js\");\r\nexports.circleBezierIntersection = circle_bezier_intersection_1.circleBezierIntersection;\r\nconst circle_bezier_intersection_precise_1 = __webpack_require__(/*! ./intersection/circle-bezier-intersection/circle-bezier-intersection-precise */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection-precise.js\");\r\nexports.circleBezierIntersectionPrecise = circle_bezier_intersection_precise_1.circleBezierIntersectionPrecise;\r\n/**\r\n * Returns the convex hull of a bezier's control points. This hull bounds the\r\n * bezier curve. This function is memoized.\r\n *\r\n * The tolerance at which the cross product of two nearly collinear lines of the\r\n * hull are considered collinear is 1e-12.\r\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns An ordered array of convex hull points.\r\n */\r\nlet getBoundingHull = flo_memoize_1.memoize(flo_graham_scan_1.grahamScan);\r\nexports.getBoundingHull = getBoundingHull;\r\n/** Alias of κ. */\r\nlet curvature = curvature_1.κ;\r\nexports.curvature = curvature;\r\n/**\r\n * Returns a human readable string representation of the given bezier.\r\n * @param ps - A bezier curve\r\n */\r\nfunction toString(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}],[${x3},${y3}]]`;\r\n}\r\nexports.toString = toString;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_coefficients_1x1_1 = __webpack_require__(/*! ./quad/get-coefficients-1x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x1.js\");\r\nconst get_coefficients_2x1_1 = __webpack_require__(/*! ./quad/get-coefficients-2x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x1.js\");\r\nconst get_coefficients_3x1_1 = __webpack_require__(/*! ./quad/get-coefficients-3x1 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x1.js\");\r\nconst get_coefficients_1x2_1 = __webpack_require__(/*! ./quad/get-coefficients-1x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x2.js\");\r\nconst get_coefficients_2x2_1 = __webpack_require__(/*! ./quad/get-coefficients-2x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x2.js\");\r\nconst get_coefficients_3x2_1 = __webpack_require__(/*! ./quad/get-coefficients-3x2 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x2.js\");\r\nconst get_coefficients_1x3_1 = __webpack_require__(/*! ./quad/get-coefficients-1x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x3.js\");\r\nconst get_coefficients_2x3_1 = __webpack_require__(/*! ./quad/get-coefficients-2x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x3.js\");\r\nconst get_coefficients_3x3_1 = __webpack_require__(/*! ./quad/get-coefficients-3x3 */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x3.js\");\r\nconst get_coefficients_1x1_2 = __webpack_require__(/*! ./exact/get-coefficients-1x1- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1-.js\");\r\nconst get_coefficients_2x1_2 = __webpack_require__(/*! ./exact/get-coefficients-2x1- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1-.js\");\r\nconst get_coefficients_3x1_2 = __webpack_require__(/*! ./exact/get-coefficients-3x1- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1-.js\");\r\nconst get_coefficients_1x2_2 = __webpack_require__(/*! ./exact/get-coefficients-1x2- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2-.js\");\r\nconst get_coefficients_2x2_2 = __webpack_require__(/*! ./exact/get-coefficients-2x2- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2-.js\");\r\nconst get_coefficients_3x2_2 = __webpack_require__(/*! ./exact/get-coefficients-3x2- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2-.js\");\r\nconst get_coefficients_1x3_2 = __webpack_require__(/*! ./exact/get-coefficients-1x3- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3-.js\");\r\nconst get_coefficients_2x3_2 = __webpack_require__(/*! ./exact/get-coefficients-2x3- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3-.js\");\r\nconst get_coefficients_3x3_2 = __webpack_require__(/*! ./exact/get-coefficients-3x3- */ \"./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3-.js\");\r\nconst differentiate_1 = __webpack_require__(/*! flo-poly/node/calculus/differentiate */ \"./node_modules/flo-poly/node/calculus/differentiate.js\");\r\nconst get_interval_box_1 = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box */ \"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js\");\r\nconst intersect_boxes_1 = __webpack_require__(/*! ../../geometry/intersect-boxes */ \"./node_modules/flo-bezier3/node/geometry/intersect-boxes.js\");\r\nconst abs = Math.abs;\r\nfunction getIntersectionCoeffs(ps1, ps2) {\r\n    let { coeffs, errBound } = [\r\n        [get_coefficients_1x1_1.getCoeffs1x1Quad, get_coefficients_1x2_1.getCoeffs1x2Quad, get_coefficients_1x3_1.getCoeffs1x3Quad],\r\n        [get_coefficients_2x1_1.getCoeffs2x1Quad, get_coefficients_2x2_1.getCoeffs2x2Quad, get_coefficients_2x3_1.getCoeffs2x3Quad],\r\n        [get_coefficients_3x1_1.getCoeffs3x1Quad, get_coefficients_3x2_1.getCoeffs3x2Quad, get_coefficients_3x3_1.getCoeffs3x3Quad]\r\n    ][ps1.length - 2][ps2.length - 2](ps1, ps2);\r\n    function getPExact() {\r\n        return [\r\n            [get_coefficients_1x1_2.getCoeffs1x1Exact_, get_coefficients_1x2_2.getCoeffs1x2Exact_, get_coefficients_1x3_2.getCoeffs1x3Exact_],\r\n            [get_coefficients_2x1_2.getCoeffs2x1Exact_, get_coefficients_2x2_2.getCoeffs2x2Exact_, get_coefficients_2x3_2.getCoeffs2x3Exact_],\r\n            [get_coefficients_3x1_2.getCoeffs3x1Exact_, get_coefficients_3x2_2.getCoeffs3x2Exact_, get_coefficients_3x3_2.getCoeffs3x3Exact_]\r\n        ][ps1.length - 2][ps2.length - 2](ps1, ps2);\r\n    }\r\n    function getPsExact() {\r\n        let poly = getPExact();\r\n        let psExact = [poly];\r\n        while (poly.length > 1) {\r\n            poly = differentiate_1.differentiateExact(psExact[psExact.length - 1]);\r\n            psExact.push(poly);\r\n        }\r\n        return psExact;\r\n    }\r\n    // check if all coefficients are zero, \r\n    // i.e. the two curves are possibly in the same k-family\r\n    let possiblySameKFamily = true;\r\n    for (let i = 0; i < coeffs.length; i++) {\r\n        if (abs(coeffs[i][1]) - errBound[i] > 0) {\r\n            possiblySameKFamily = false;\r\n            break;\r\n        }\r\n    }\r\n    let sameKFamily = false;\r\n    if (possiblySameKFamily) {\r\n        sameKFamily = true;\r\n        let poly = getPExact();\r\n        for (let i = 0; i < poly.length; i++) {\r\n            if (flo_numerical_1.sign(poly[i]) !== 0) {\r\n                sameKFamily = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (sameKFamily) {\r\n        return undefined;\r\n    }\r\n    //if (ps1.length === 4 && ps2.length === 2 &&\r\n    //    ps2[0][0] > 376 && ps2[0][0] < 377) {\r\n    //    console.log(ps1,ps2)\r\n    //    console.log(coeffs);\r\n    //    console.log(errBound);\r\n    //    console.log('------');\r\n    //}\r\n    return { coeffs, errBound, getPsExact };\r\n}\r\nexports.getIntersectionCoeffs = getIntersectionCoeffs;\r\n/**\r\n * Returns the intersection between two linear, quadratic or cubic bezier curves\r\n * in any combination.\r\n * * Returns **undefined** only in the case that the two beziers are in the same\r\n * k-family.\r\n * * The second bezier's t values are retuned. Call getOtherTs to get the first\r\n * bezier's t values.\r\n * * this algorithm is nearly always accurate to 1 u in the t values for the **second**\r\n * bezier (except if there are several extremely close intersections) and\r\n * a few u accurate for the second t values.\r\n * * Before calling this function, ensure the two given beziers are really cubic\r\n * or quadratic if given as such (check with isReallyQuadratic), else convert\r\n * them (cubics can be converted with toQuadraticFromCubic)\r\n * See http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps\r\n */\r\nfunction bezierBezierIntersectionImplicit(ps1, ps2) {\r\n    let _coeffs = getIntersectionCoeffs(ps1, ps2);\r\n    if (_coeffs === undefined) {\r\n        return undefined;\r\n    }\r\n    let { coeffs, errBound, getPsExact } = _coeffs;\r\n    return flo_poly_1.allRootsMultiWithErrBounds(coeffs, errBound, getPsExact);\r\n}\r\nexports.bezierBezierIntersectionImplicit = bezierBezierIntersectionImplicit;\r\n/**\r\n * Returns the ordered (first ps1, then ps2) intersection pairs given the two\r\n * curves that intersect and the t values of the **second** curve.\r\n * @param ps1 the first bezier\r\n * @param ps2 the second bezier\r\n * @param ts2 the t values of the second bezier\r\n */\r\nfunction getOtherTs(ps1, ps2, ts2) {\r\n    if (ts2 === undefined || ts2.length === 0) {\r\n        return [];\r\n    }\r\n    let ts1 = bezierBezierIntersectionImplicit(ps2, ps1);\r\n    if (ts1.length === 0) {\r\n        return [];\r\n    }\r\n    let is1 = ts1.map(ri => get_interval_box_1.getIntervalBox(ps1, [ri.tS, ri.tE]));\r\n    let is2 = ts2.map(ri => get_interval_box_1.getIntervalBox(ps2, [ri.tS, ri.tE]));\r\n    let xPairs = [];\r\n    for (let i = 0; i < ts1.length; i++) {\r\n        let box1 = is1[i];\r\n        for (let j = 0; j < ts2.length; j++) {\r\n            let box2 = is2[j];\r\n            let box = intersect_boxes_1.intersectBoxes(box1, box2);\r\n            if (box !== undefined) {\r\n                //console.log(box1)\r\n                //console.log(box2)\r\n                //console.log(box)\r\n                //console.log('---------')\r\n                // TODO important - combine boxes to make sense, i.e. combine better\r\n                // e.g. two odd multiplicity boxes should combine to a single even, etc. etc.\r\n                let x1 = { ri: ts1[i], box, kind: 1 };\r\n                let x2 = { ri: ts2[j], box, kind: 1 };\r\n                xPairs.push([x1, x2]);\r\n            }\r\n        }\r\n    }\r\n    return xPairs;\r\n}\r\nexports.getOtherTs = getOtherTs;\r\n//# sourceMappingURL=bezier-bezier-intersection-implicit.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/bezier-bezier-intersection-implicit.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form1- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nfunction getCoeffs1x1Exact_(ps1, ps2) {\r\n    let { vₓ, vᵧ, v } = get_implicit_form1_1.getImplicitForm1Exact_(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p1 = tp(c1, vₓ); // vₓ is a double => error free\r\n    let p2 = tp(d1, vᵧ); // vᵧ is a double => error free\r\n    let v1 = qaq(p1, p2); // 48-bit aligned => error free\r\n    //let v0 = c0*vₓ + d0*vᵧ + v_0;\r\n    let p3 = tp(c0, vₓ); // vₓ is a double => error free\r\n    let p4 = tp(d0, vᵧ); // vᵧ is a double => error free\r\n    let p5 = qaq(p3, p4); // 48-bit aligned => error free\r\n    let v0 = qaq(p5, v); // 48-bit aligned => error free \r\n    return [v1, v0];\r\n}\r\nexports.getCoeffs1x1Exact_ = getCoeffs1x1Exact_;\r\n//# sourceMappingURL=get-coefficients-1x1-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nfunction getCoeffs1x1Exact(ps1, ps2) {\r\n    let { vₓ, vᵧ, v } = get_implicit_form1_1.getImplicitForm1Exact(ps1);\r\n    let [c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d1, d0] = get_y_1.getYExact(ps2);\r\n    // a1*v_x + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [c1, vₓ], [d1, vᵧ]\r\n    ]);\r\n    // a0*v_x + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, vₓ], [d0, vᵧ], [v]\r\n    ]);\r\n    return [v1, v0];\r\n}\r\nexports.getCoeffs1x1Exact = getCoeffs1x1Exact;\r\n//# sourceMappingURL=get-coefficients-1x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form1- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nfunction getCoeffs1x2Exact_(ps1, ps2) {\r\n    let { vₓ, vᵧ, v } = get_implicit_form1_1.getImplicitForm1Exact_(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a2*v_x + b2*v_y\r\n    //let v2 = c2*vₓ + d2*vᵧ;\r\n    let p1 = flo_numerical_1.twoProduct(c2, vₓ); // vₓ is a double => error free\r\n    let p2 = flo_numerical_1.twoProduct(d2, vᵧ); // vᵧ is a double => error free\r\n    let v2 = flo_numerical_1.qAddQuad(p1, p2); // 48-bit aligned => error free\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p3 = flo_numerical_1.twoProduct(c1, vₓ); // vₓ is a double => error free\r\n    let p4 = flo_numerical_1.twoProduct(d1, vᵧ); // vᵧ is a double => error free\r\n    let v1 = flo_numerical_1.qAddQuad(p3, p4); // 48-bit aligned => error free\r\n    // a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p5 = flo_numerical_1.twoProduct(c0, vₓ); // vₓ is a double => error free\r\n    let p6 = flo_numerical_1.twoProduct(d0, vᵧ); // vᵧ is a double => error free\r\n    let p7 = flo_numerical_1.qAddQuad(p5, p6); // 48-bit aligned => error free\r\n    let v0 = flo_numerical_1.qAddQuad(p7, v); // 48-bit aligned => error free\r\n    return [v2, v1, v0];\r\n}\r\nexports.getCoeffs1x2Exact_ = getCoeffs1x2Exact_;\r\n//# sourceMappingURL=get-coefficients-1x2-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js\");\r\nfunction getCoeffs1x2Exact(ps1, ps2) {\r\n    let { vₓ, vᵧ, v } = get_implicit_form1_1.getImplicitForm1Exact(ps1);\r\n    let [c2, c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d2, d1, d0] = get_y_1.getYExact(ps2);\r\n    // a2*v_x + b2*v_y\r\n    let v2 = flo_numerical_1.calculate([\r\n        [c2, vₓ], [d2, vᵧ]\r\n    ]);\r\n    // a1*v_x + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [c1, vₓ], [d1, vᵧ]\r\n    ]);\r\n    // a0*v_x + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, vₓ], [d0, vᵧ], [v]\r\n    ]);\r\n    return [v2, v1, v0];\r\n}\r\nexports.getCoeffs1x2Exact = getCoeffs1x2Exact;\r\n//# sourceMappingURL=get-coefficients-1x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form1- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nfunction getCoeffs1x3Exact_(ps1, ps2) {\r\n    let { vₓ, vᵧ, v } = get_implicit_form1_1.getImplicitForm1Exact_(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a3*v_x + b3*v_y\r\n    //let v3 = c3*vₓ + d3*vᵧ;\r\n    let p1 = flo_numerical_1.twoProduct(c3, vₓ); // vₓ is a double => error free\r\n    let p2 = flo_numerical_1.twoProduct(d3, vᵧ); // vᵧ is a double => error free\r\n    let v3 = flo_numerical_1.qAddQuad(p1, p2); // 48-bit aligned => error free\r\n    // a2*v_x + b2*v_y\r\n    //let v2 = c2*vₓ + d2*vᵧ;\r\n    let p3 = flo_numerical_1.twoProduct(c2, vₓ); // vₓ is a double => error free\r\n    let p4 = flo_numerical_1.twoProduct(d2, vᵧ); // vᵧ is a double => error free\r\n    let v2 = flo_numerical_1.qAddQuad(p3, p4); // 48-bit aligned => error free\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p5 = flo_numerical_1.twoProduct(c1, vₓ); // vₓ is a double => error free\r\n    let p6 = flo_numerical_1.twoProduct(d1, vᵧ); // vᵧ is a double => error free\r\n    let v1 = flo_numerical_1.qAddQuad(p5, p6); // 48-bit aligned => error free\r\n    // a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p7 = flo_numerical_1.twoProduct(c0, vₓ); // vₓ is a double => error free\r\n    let p8 = flo_numerical_1.twoProduct(d0, vᵧ); // vᵧ is a double => error free\r\n    let p9 = flo_numerical_1.qAddQuad(p7, p8); // 48-bit aligned => error free\r\n    let v0 = flo_numerical_1.qAddQuad(p9, v); // 48-bit aligned => error free\r\n    return [v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs1x3Exact_ = getCoeffs1x3Exact_;\r\n//# sourceMappingURL=get-coefficients-1x3-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1.js\");\r\nfunction getCoeffs1x3Exact(ps1, ps2) {\r\n    let { vₓ, vᵧ, v } = get_implicit_form1_1.getImplicitForm1Exact(ps1);\r\n    let [c3, c2, c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d3, d2, d1, d0] = get_y_1.getYExact(ps2);\r\n    // a3*v_x + b3*v_y\r\n    let v3 = flo_numerical_1.calculate([\r\n        [c3, vₓ], [d3, vᵧ]\r\n    ]);\r\n    // a2*v_x + b2*v_y\r\n    let v2 = flo_numerical_1.calculate([\r\n        [c2, vₓ], [d2, vᵧ]\r\n    ]);\r\n    // a1*v_x + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [c1, vₓ], [d1, vᵧ]\r\n    ]);\r\n    // a0*v_x + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, vₓ], [d0, vᵧ], [v]\r\n    ]);\r\n    return [v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs1x3Exact = getCoeffs1x3Exact;\r\n//# sourceMappingURL=get-coefficients-1x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-1x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form2- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nfunction getCoeffs2x1Exact_(ps1, ps2) {\r\n    let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_1.getImplicitForm2Exact_(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    let c0c0 = flo_numerical_1.twoProduct(c0, c0);\r\n    let c0c1 = flo_numerical_1.twoProduct(c0, c1);\r\n    let c0d0 = flo_numerical_1.twoProduct(c0, d0);\r\n    let c0d1 = flo_numerical_1.twoProduct(c0, d1);\r\n    let c1c1 = flo_numerical_1.twoProduct(c1, c1);\r\n    let c1d0 = flo_numerical_1.twoProduct(c1, d0);\r\n    let c1d1 = flo_numerical_1.twoProduct(c1, d1);\r\n    let d0d0 = flo_numerical_1.twoProduct(d0, d0);\r\n    let d0d1 = flo_numerical_1.twoProduct(d0, d1);\r\n    let d1d1 = flo_numerical_1.twoProduct(d1, d1);\r\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\r\n    let p1 = epr(c1c1, vₓₓ);\r\n    let p2 = epr(d1d1, vᵧᵧ);\r\n    let p3 = epr(c1d1, vₓᵧ);\r\n    let p4 = fes(p1, p2);\r\n    let v2 = fes(p4, p3);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\r\n    let p5 = epr(c0c1, vₓₓ);\r\n    let p6 = epr(d0d1, vᵧᵧ);\r\n    let p7 = qaq(c0d1, c1d0); // 48-bit aligned => error free\r\n    let pn = epr(p7, vₓᵧ);\r\n    let p8 = em2(fes(p5, p6));\r\n    let p9 = fes(p8, pn);\r\n    let pa = sce(c1, vₓ);\r\n    let pb = sce(d1, vᵧ);\r\n    let pc = fes(pa, pb);\r\n    let v1 = fes(p9, pc);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\r\n    let pe = epr(c0c0, vₓₓ);\r\n    let pf = epr(c0d0, vₓᵧ);\r\n    let pg = epr(d0d0, vᵧᵧ);\r\n    let ph = fes(pe, pf);\r\n    let pi = fes(ph, pg);\r\n    let pj = sce(c0, vₓ);\r\n    let pk = sce(d0, vᵧ);\r\n    let pl = fes(pj, pk);\r\n    let pm = fes(pi, pl);\r\n    let v0 = fes(pm, v);\r\n    return [v2, v1, v0];\r\n}\r\nexports.getCoeffs2x1Exact_ = getCoeffs2x1Exact_;\r\n//# sourceMappingURL=get-coefficients-2x1-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js\");\r\nfunction getCoeffs2x1Exact(ps1, ps2) {\r\n    let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_1.getImplicitForm2Exact(ps1);\r\n    let [c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d1, d0] = get_y_1.getYExact(ps2);\r\n    // a1**2*v_xx + a1*b1*v_xy + b1**2*v_yy\r\n    let v2 = flo_numerical_1.calculate([\r\n        [c1, c1, vₓₓ], [c1, d1, vₓᵧ], [d1, d1, vᵧᵧ]\r\n    ]);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, vₓₓ], [c0, d1, vₓᵧ], [c1, d0, vₓᵧ],\r\n        [c1, vₓ], [[2], d0, d1, vᵧᵧ], [d1, vᵧ]\r\n    ]);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + b0**2*v_yy + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, c0, vₓₓ], [c0, d0, vₓᵧ], [c0, vₓ],\r\n        [d0, d0, vᵧᵧ], [d0, vᵧ], [v]\r\n    ]);\r\n    return [v2, v1, v0];\r\n}\r\nexports.getCoeffs2x1Exact = getCoeffs2x1Exact;\r\n//# sourceMappingURL=get-coefficients-2x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form2- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nconst tp = flo_numerical_1.twoProduct;\r\nfunction getCoeffs2x2Exact_(ps1, ps2) {\r\n    let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_1.getImplicitForm2Exact_(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d2d2 = tp(d2, d2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //let v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    let p1 = epr(c2c2, vₓₓ);\r\n    let p2 = epr(c2d2, vₓᵧ);\r\n    let p3 = epr(d2d2, vᵧᵧ);\r\n    let p4 = fes(p1, p2);\r\n    let v4 = fes(p4, p3);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //let v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    let p5 = epr(c1c2, vₓₓ);\r\n    let p6 = epr(d1d2, vᵧᵧ);\r\n    let p7 = qaq(c1d2, c2d1); // 48-bit aligned => error free\r\n    let p8 = epr(p7, vₓᵧ);\r\n    let p9 = em2(fes(p5, p6));\r\n    let v3 = fes(p9, p8);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //let v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    let pa = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let pb = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let pc = qaq(c0d2, c1d1); // 48-bit aligned => error free\r\n    let pd = qaq(pc, c2d0); // 48-bit aligned => error free\r\n    let pe = epr(pa, vₓₓ);\r\n    let pf = epr(pb, vᵧᵧ);\r\n    let pg = epr(pd, vₓᵧ);\r\n    let ph = sce(c2, vₓ);\r\n    let pi = sce(d2, vᵧ);\r\n    let pj = fes(pe, pf);\r\n    let pk = fes(pj, pg);\r\n    let pl = fes(ph, pi);\r\n    let v2 = fes(pk, pl);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    let pm = epr(c0c1, vₓₓ);\r\n    let pn = epr(d0d1, vᵧᵧ);\r\n    let po = qaq(c0d1, c1d0); // 48-bit aligned => error free\r\n    let pp = epr(po, vₓᵧ);\r\n    let pq = em2(fes(pm, pn));\r\n    let pr = sce(c1, vₓ);\r\n    let ps = sce(d1, vᵧ);\r\n    let pt = fes(pq, pp);\r\n    let pu = fes(pr, ps);\r\n    let v1 = fes(pt, pu);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    let pv = epr(c0c0, vₓₓ);\r\n    let pw = epr(c0d0, vₓᵧ);\r\n    let px = epr(d0d0, vᵧᵧ);\r\n    let py = sce(c0, vₓ);\r\n    let pz = sce(d0, vᵧ);\r\n    let q1 = fes(pv, pw);\r\n    let q2 = fes(q1, px);\r\n    let q3 = fes(py, pz);\r\n    let q4 = fes(q2, q3);\r\n    let v0 = fes(q4, v);\r\n    return [v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs2x2Exact_ = getCoeffs2x2Exact_;\r\n//# sourceMappingURL=get-coefficients-2x2-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js\");\r\nfunction getCoeffs2x2Exact(ps1, ps2) {\r\n    let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_1.getImplicitForm2Exact(ps1);\r\n    let [c2, c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d2, d1, d0] = get_y_1.getYExact(ps2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    let v4 = flo_numerical_1.calculate([\r\n        [c2, c2, vₓₓ], [c2, d2, vₓᵧ], [d2, d2, vᵧᵧ]\r\n    ]);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    let v3 = flo_numerical_1.calculate([\r\n        [[2], c1, c2, vₓₓ], [c1, d2, vₓᵧ],\r\n        [c2, d1, vₓᵧ], [[2], d1, d2, vᵧᵧ]\r\n    ]);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    let v2 = flo_numerical_1.calculate([\r\n        [[2], c0, c2, vₓₓ], [c0, d2, vₓᵧ], [c1, c1, vₓₓ],\r\n        [c1, d1, vₓᵧ], [c2, d0, vₓᵧ], [c2, vₓ],\r\n        [[2], d0, d2, vᵧᵧ], [d1, d1, vᵧᵧ], [d2, vᵧ]\r\n    ]);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, vₓₓ], [c0, d1, vₓᵧ], [c1, d0, vₓᵧ],\r\n        [c1, vₓ], [[2], d0, d1, vᵧᵧ], [d1, vᵧ]\r\n    ]);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, c0, vₓₓ], [c0, d0, vₓᵧ], [c0, vₓ],\r\n        [d0, d0, vᵧᵧ], [d0, vᵧ], [v]\r\n    ]);\r\n    return [v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs2x2Exact = getCoeffs2x2Exact;\r\n//# sourceMappingURL=get-coefficients-2x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form2- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nfunction getCoeffs2x3Exact_(ps1, ps2) {\r\n    let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_1.getImplicitForm2Exact_(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let c0c0 = flo_numerical_1.twoProduct(c0, c0);\r\n    let c0c1 = flo_numerical_1.twoProduct(c0, c1);\r\n    let c0c2 = flo_numerical_1.twoProduct(c0, c2);\r\n    let c0c3 = flo_numerical_1.twoProduct(c0, c3);\r\n    let c0d0 = flo_numerical_1.twoProduct(c0, d0);\r\n    let c0d1 = flo_numerical_1.twoProduct(c0, d1);\r\n    let c0d2 = flo_numerical_1.twoProduct(c0, d2);\r\n    let c0d3 = flo_numerical_1.twoProduct(c0, d3);\r\n    let c1c1 = flo_numerical_1.twoProduct(c1, c1);\r\n    let c1c2 = flo_numerical_1.twoProduct(c1, c2);\r\n    let c1c3 = flo_numerical_1.twoProduct(c1, c3);\r\n    let c1d0 = flo_numerical_1.twoProduct(c1, d0);\r\n    let c1d1 = flo_numerical_1.twoProduct(c1, d1);\r\n    let c1d2 = flo_numerical_1.twoProduct(c1, d2);\r\n    let c1d3 = flo_numerical_1.twoProduct(c1, d3);\r\n    let c2d1 = flo_numerical_1.twoProduct(c2, d1);\r\n    let c2c2 = flo_numerical_1.twoProduct(c2, c2);\r\n    let c2c3 = flo_numerical_1.twoProduct(c2, c3);\r\n    let c2d0 = flo_numerical_1.twoProduct(c2, d0);\r\n    let c2d2 = flo_numerical_1.twoProduct(c2, d2);\r\n    let c2d3 = flo_numerical_1.twoProduct(c2, d3);\r\n    let c3c3 = flo_numerical_1.twoProduct(c3, c3);\r\n    let c3d0 = flo_numerical_1.twoProduct(c3, d0);\r\n    let c3d1 = flo_numerical_1.twoProduct(c3, d1);\r\n    let c3d2 = flo_numerical_1.twoProduct(c3, d2);\r\n    let c3d3 = flo_numerical_1.twoProduct(c3, d3);\r\n    let d0d0 = flo_numerical_1.twoProduct(d0, d0);\r\n    let d0d1 = flo_numerical_1.twoProduct(d0, d1);\r\n    let d0d2 = flo_numerical_1.twoProduct(d0, d2);\r\n    let d0d3 = flo_numerical_1.twoProduct(d0, d3);\r\n    let d1d1 = flo_numerical_1.twoProduct(d1, d1);\r\n    let d1d2 = flo_numerical_1.twoProduct(d1, d2);\r\n    let d3d3 = flo_numerical_1.twoProduct(d3, d3);\r\n    let d2d2 = flo_numerical_1.twoProduct(d2, d2);\r\n    let d2d3 = flo_numerical_1.twoProduct(d2, d3);\r\n    let d1d3 = flo_numerical_1.twoProduct(d1, d3);\r\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\r\n    //let v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    let p1 = epr(c3c3, vₓₓ);\r\n    let p2 = epr(c3d3, vₓᵧ);\r\n    let p3 = epr(d3d3, vᵧᵧ);\r\n    let p4 = fes(p1, p2);\r\n    let v6 = fes(p4, p3);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //let v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    vₓᵧ*(c2d3 + c3d2);\r\n    let p5 = epr(c2c3, vₓₓ);\r\n    let p6 = epr(d2d3, vᵧᵧ);\r\n    let p7 = fes(p5, p6);\r\n    let p8 = qaq(c2d3, c3d2); // 48-bit aligned => error free\r\n    let p9 = epr(p8, vₓᵧ);\r\n    let v5 = fes(em2(p7), p9);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //let v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    let pa = qaq(qm2(c1c3), c2c2); // 48-bit aligned => error free\r\n    let pb = qaq(qm2(d1d3), d2d2); // 48-bit aligned => error free\r\n    let pc = qaq(c1d3, c2d2); // 48-bit aligned => error free\r\n    let pd = qaq(pc, c3d1); // 48-bit aligned => error free\r\n    let pe = epr(pa, vₓₓ);\r\n    let pf = epr(pb, vᵧᵧ);\r\n    let pg = fes(pe, pf);\r\n    let rp = epr(pd, vₓᵧ);\r\n    let v4 = fes(pg, rp);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //let v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    let ph = qaq(c0c3, c1c2); // 48-bit aligned => error free\r\n    let pi = qaq(d0d3, d1d2); // 48-bit aligned => error free\r\n    let pj = qaq(c0d3, c1d2); // 48-bit aligned => error free\r\n    let pk = qaq(c2d1, c3d0); // 48-bit aligned => error free\r\n    let pl = qaq(pj, pk); // 48-bit aligned => error free\r\n    let pm = epr(ph, vₓₓ);\r\n    let pn = epr(pi, vᵧᵧ);\r\n    let po = em2(fes(pm, pn));\r\n    let pp = epr(pl, vₓᵧ);\r\n    let rn = sce(c3, vₓ);\r\n    let ro = sce(d3, vᵧ);\r\n    let pq = fes(rn, ro);\r\n    let pr = fes(po, pp);\r\n    let v3 = fes(pr, pq);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //let v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    let ps = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let pt = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let pu = qaq(c0d2, c1d1); // 48-bit aligned => error free\r\n    let pv = qaq(pu, c2d0); // 48-bit aligned => error free\r\n    let pw = epr(ps, vₓₓ);\r\n    let px = epr(pt, vᵧᵧ);\r\n    let py = epr(pv, vₓᵧ);\r\n    let pz = fes(pw, px);\r\n    let r1 = fes(pz, py);\r\n    let r2 = sce(c2, vₓ);\r\n    let r3 = sce(d2, vᵧ);\r\n    let r4 = fes(r2, r3);\r\n    let v2 = fes(r1, r4);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //let v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    let r5 = epr(c0c1, vₓₓ);\r\n    let r6 = epr(d0d1, vᵧᵧ);\r\n    let r7 = qaq(c0d1, c1d0); // 48-bit aligned => error free\r\n    let r8 = epr(r7, vₓᵧ);\r\n    let r9 = em2(fes(r5, r6));\r\n    let ra = fes(r9, r8);\r\n    let rb = sce(c1, vₓ);\r\n    let rc = sce(d1, vᵧ);\r\n    let rd = fes(rb, rc);\r\n    let v1 = fes(ra, rd);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    let re = epr(c0c0, vₓₓ);\r\n    let rf = epr(c0d0, vₓᵧ);\r\n    let rg = epr(d0d0, vᵧᵧ);\r\n    let rh = sce(c0, vₓ);\r\n    let ri = sce(d0, vᵧ);\r\n    let rj = fes(re, rf);\r\n    let rk = fes(rj, rg);\r\n    let rl = fes(rh, ri);\r\n    let rm = fes(rk, rl);\r\n    let v0 = fes(rm, v);\r\n    return [v6, v5, v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs2x3Exact_ = getCoeffs2x3Exact_;\r\n//# sourceMappingURL=get-coefficients-2x3-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2.js\");\r\nfunction getCoeffs2x3Exact(ps1, ps2) {\r\n    let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_1.getImplicitForm2Exact(ps1);\r\n    let [c3, c2, c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d3, d2, d1, d0] = get_y_1.getYExact(ps2);\r\n    // a3**2*v_xx + a3*b3*v_xy + b3**2*v_yy\r\n    let v6 = flo_numerical_1.calculate([\r\n        [c3, c3, vₓₓ], [c3, d3, vₓᵧ], [d3, d3, vᵧᵧ]\r\n    ]);\r\n    // 2*a2*a3*v_xx + a2*b3*v_xy + a3*b2*v_xy + 2*b2*b3*v_yy\r\n    let v5 = flo_numerical_1.calculate([\r\n        [[2], c2, c3, vₓₓ], [c2, d3, vₓᵧ],\r\n        [c3, d2, vₓᵧ], [[2], d2, d3, vᵧᵧ]\r\n    ]);\r\n    // 2*a1*a3*v_xx + a1*b3*v_xy + a2**2*v_xx + a2*b2*v_xy + a3*b1*v_xy + 2*b1*b3*v_yy + b2**2*v_yy\r\n    let v4 = flo_numerical_1.calculate([\r\n        [[2], c1, c3, vₓₓ], [c1, d3, vₓᵧ], [c2, c2, vₓₓ],\r\n        [c2, d2, vₓᵧ], [c3, d1, vₓᵧ], [[2], d1, d3, vᵧᵧ],\r\n        [d2, d2, vᵧᵧ]\r\n    ]);\r\n    // 2*a0*a3*v_xx + a0*b3*v_xy + 2*a1*a2*v_xx + \r\n    // a1*b2*v_xy + a2*b1*v_xy + a3*b0*v_xy + \r\n    // a3*v_x + 2*b0*b3*v_yy + 2*b1*b2*v_yy + b3*v_y\r\n    let v3 = flo_numerical_1.calculate([\r\n        [[2], c0, c3, vₓₓ], [c0, d3, vₓᵧ], [[2], c1, c2, vₓₓ],\r\n        [c1, d2, vₓᵧ], [c2, d1, vₓᵧ], [c3, d0, vₓᵧ],\r\n        [c3, vₓ], [[2], d0, d3, vᵧᵧ], [[2], d1, d2, vᵧᵧ],\r\n        [d3, vᵧ]\r\n    ]);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    let v2 = flo_numerical_1.calculate([\r\n        [[2], c0, c2, vₓₓ], [c0, d2, vₓᵧ], [c1, c1, vₓₓ],\r\n        [c1, d1, vₓᵧ], [c2, d0, vₓᵧ], [c2, vₓ],\r\n        [[2], d0, d2, vᵧᵧ], [d1, d1, vᵧᵧ], [d2, vᵧ]\r\n    ]);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, vₓₓ], [c0, d1, vₓᵧ], [c1, d0, vₓᵧ],\r\n        [c1, vₓ], [[2], d0, d1, vᵧᵧ], [d1, vᵧ]\r\n    ]);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + b0**2*v_yy + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, c0, vₓₓ], [c0, d0, vₓᵧ], [c0, vₓ],\r\n        [d0, d0, vᵧᵧ], [d0, vᵧ], [v]\r\n    ]);\r\n    return [v6, v5, v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs2x3Exact = getCoeffs2x3Exact;\r\n//# sourceMappingURL=get-coefficients-2x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-2x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form3- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nfunction getCoeffs3x1Exact_(ps1, ps2) {\r\n    let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_1.getImplicitForm3Exact_(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    let c0c0 = flo_numerical_1.twoProduct(c0, c0);\r\n    let c0c1 = flo_numerical_1.twoProduct(c0, c1);\r\n    let c0d0 = flo_numerical_1.twoProduct(c0, d0);\r\n    let c0d1 = flo_numerical_1.twoProduct(c0, d1);\r\n    let c1c1 = flo_numerical_1.twoProduct(c1, c1);\r\n    let c1d0 = flo_numerical_1.twoProduct(c1, d0);\r\n    let c1d1 = flo_numerical_1.twoProduct(c1, d1);\r\n    let d0d0 = flo_numerical_1.twoProduct(d0, d0);\r\n    let d0d1 = flo_numerical_1.twoProduct(d0, d1);\r\n    let d1d1 = flo_numerical_1.twoProduct(d1, d1);\r\n    let z1 = sce(c0, vₓₓₓ);\r\n    let z7 = sce(3 * c0, vₓₓₓ); // 3*c0: 47-bit aligned => error free \r\n    let z2 = sce(c0, vₓₓᵧ);\r\n    let z3 = sce(d0, vₓₓᵧ);\r\n    let z4 = sce(c0, vₓᵧᵧ);\r\n    let z5 = sce(d0, vₓᵧᵧ);\r\n    let z6 = sce(d0, vᵧᵧᵧ);\r\n    let z8 = sce(3 * d0, vᵧᵧᵧ);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //let v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    let u1 = sce(c1, vₓₓₓ);\r\n    let u2 = sce(c1, vₓᵧᵧ);\r\n    let u3 = sce(d1, vₓₓᵧ);\r\n    let u4 = sce(d1, vᵧᵧᵧ);\r\n    let u5 = fes(u1, u3);\r\n    let u6 = fes(u2, u4);\r\n    let u7 = epr(c1c1, u5);\r\n    let u8 = epr(d1d1, u6);\r\n    let v3 = fes(u7, u8);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //let v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //let v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    let u9 = fes(z7, z3);\r\n    let ua = em2(fes(z2, z5));\r\n    let ub = fes(z4, z8);\r\n    let uc = fes(u9, vₓₓ);\r\n    let ud = fes(ua, vₓᵧ);\r\n    let ue = fes(ub, vᵧᵧ);\r\n    let uf = epr(c1c1, uc);\r\n    let ug = epr(c1d1, ud);\r\n    let uh = epr(d1d1, ue);\r\n    let ui = fes(uf, ug);\r\n    let v2 = fes(ui, uh);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    let uj = em2(fes(z3, vₓₓ));\r\n    let uk = em2(fes(z4, vᵧᵧ));\r\n    let un = fes(z7, uj);\r\n    let uo = fes(z8, uk);\r\n    let up = fes(z2, vₓᵧ);\r\n    let uq = fes(z5, vₓᵧ);\r\n    let ur = epr(c0c1, un);\r\n    let us = epr(d0d1, uo);\r\n    let ut = epr(c0d1, up);\r\n    let uu = epr(c1d0, uq);\r\n    let uv = sce(c1, vₓ);\r\n    let uw = sce(d1, vᵧ);\r\n    let ux = fes(ur, us);\r\n    let uy = fes(ut, uu);\r\n    let uz = fes(ux, uy);\r\n    let u0 = fes(uv, uw);\r\n    let v1 = fes(uz, u0);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //let v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    let f1 = fes(z1, z3);\r\n    let f2 = fes(z6, z4);\r\n    let f3 = fes(f1, vₓₓ);\r\n    let f4 = fes(f2, vᵧᵧ);\r\n    let f5 = epr(c0c0, f3);\r\n    let f6 = epr(d0d0, f4);\r\n    let f7 = epr(c0d0, vₓᵧ);\r\n    let f8 = fes(f5, f6);\r\n    let f9 = fes(f8, f7);\r\n    let fa = sce(c0, vₓ);\r\n    let fb = sce(d0, vᵧ);\r\n    let fc = fes(fa, fb);\r\n    let fd = fes(f9, fc);\r\n    let v0 = fes(fd, v);\r\n    return [v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs3x1Exact_ = getCoeffs3x1Exact_;\r\n//# sourceMappingURL=get-coefficients-3x1-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js\");\r\nfunction getCoeffs3x1Exact(ps1, ps2) {\r\n    let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_1.getImplicitForm3Exact(ps1);\r\n    let [c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d1, d0] = get_y_1.getYExact(ps2);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    let v3 = flo_numerical_1.calculate([\r\n        [c1, c1, c1, vₓₓₓ], [c1, c1, d1, vₓₓᵧ],\r\n        [c1, d1, d1, vₓᵧᵧ], [d1, d1, d1, vᵧᵧᵧ]\r\n    ]);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    let v2 = flo_numerical_1.calculate([\r\n        [[3], c0, c1, c1, vₓₓₓ], [[2], c0, c1, d1, vₓₓᵧ], [c0, d1, d1, vₓᵧᵧ],\r\n        [c1, c1, d0, vₓₓᵧ], [c1, c1, vₓₓ], [[2], c1, d0, d1, vₓᵧᵧ],\r\n        [c1, d1, vₓᵧ], [[3], d0, d1, d1, vᵧᵧᵧ], [d1, d1, vᵧᵧ]\r\n    ]);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [[3], c0, c0, c1, vₓₓₓ], [c0, c0, d1, vₓₓᵧ], [[2], c0, c1, d0, vₓₓᵧ],\r\n        [[2], c0, c1, vₓₓ], [[2], c0, d0, d1, vₓᵧᵧ], [c0, d1, vₓᵧ],\r\n        [c1, d0, d0, vₓᵧᵧ], [c1, d0, vₓᵧ], [c1, vₓ],\r\n        [[3], d0, d0, d1, vᵧᵧᵧ], [[2], d0, d1, vᵧᵧ], [d1, vᵧ]\r\n    ]);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, c0, c0, vₓₓₓ],\r\n        [d0, d0, d0, vᵧᵧᵧ],\r\n        [c0, c0, d0, vₓₓᵧ],\r\n        [c0, d0, d0, vₓᵧᵧ],\r\n        [c0, c0, vₓₓ],\r\n        [d0, d0, vᵧᵧ],\r\n        [c0, d0, vₓᵧ],\r\n        [c0, vₓ],\r\n        [d0, vᵧ],\r\n        [v],\r\n    ]);\r\n    return [v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs3x1Exact = getCoeffs3x1Exact;\r\n//# sourceMappingURL=get-coefficients-3x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form3- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\nconst tp = flo_numerical_1.twoProduct;\r\nfunction getCoeffs3x2Exact_(ps1, ps2) {\r\n    let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_1.getImplicitForm3Exact_(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d2d2 = tp(d2, d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //let v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    let e1 = sce(c2, vₓₓₓ);\r\n    let e2 = sce(c2, vₓᵧᵧ);\r\n    let e3 = sce(d2, vₓₓᵧ);\r\n    let e4 = sce(d2, vᵧᵧᵧ);\r\n    let e5 = fes(e1, e3);\r\n    let e6 = fes(e2, e4);\r\n    let e7 = epr(c2c2, e5);\r\n    let e8 = epr(d2d2, e6);\r\n    let v6 = fes(e7, e8);\r\n    let z1 = qaq(c0c2, c1c1); // 48-bit aligned => error free\r\n    let z2 = qaq(d0d2, d1d1); // 48-bit aligned => error free\r\n    let z3 = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let z4 = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let z5 = qaq(qm2(c1d1), c2d0); // 48-bit aligned => error free\r\n    let z6 = qaq(qm2(c1d1), c0d2); // 48-bit aligned => error free\r\n    let z7 = qaq(qm2(c2d0), c1d1); // 48-bit aligned => error free\r\n    let z8 = qaq(qmd(6, c0c2), c1c1); // 47-bit aligned => error free\r\n    let z9 = qaq(qmd(6, d0d2), d1d1); // 47-bit aligned => error free\r\n    let za = qaq(c1d2, c2d1); // 48-bit aligned => error free\r\n    let zb = qaq(c0d2, c2d0); // 48-bit aligned => error free\r\n    let zc = qaq(qm2(c1d0), c0d1); // 48-bit aligned => error free\r\n    let zd = qaq(qm2(c0d1), c1d0); // 48-bit aligned => error free\r\n    let zf = qaq(c0d2, c1d1); // 48-bit aligned => error free\r\n    let ze = qaq(zf, c2d0); // 48-bit aligned => error free\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //let v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    let s0 = qmd(3, c2c2); // 48-bit aligned => error free\r\n    let t1 = qmd(3, d2d2); // 48-bit aligned => error free\r\n    let s1 = epr(s0, vₓₓₓ);\r\n    let s2 = epr(c2c2, vₓₓᵧ);\r\n    let s3 = em2(epr(c2d2, vₓₓᵧ));\r\n    let s4 = em2(epr(c2d2, vₓᵧᵧ));\r\n    let s5 = epr(d2d2, vₓᵧᵧ);\r\n    let s6 = epr(t1, vᵧᵧᵧ);\r\n    let s7 = fes(s1, s3);\r\n    let s8 = fes(s2, s4);\r\n    let s9 = fes(s7, s5);\r\n    let sa = fes(s8, s6);\r\n    let sb = sce(c1, s9);\r\n    let sc = sce(d1, sa);\r\n    let v5 = fes(sb, sc);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //let v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //let v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    let sd = sce(d2, z3);\r\n    let se = sce(d2, z6);\r\n    let sf = sce(c2, z5);\r\n    let sg = sce(c2, z4);\r\n    let sh = sce(3 * c2, z1); // 3*c2: 47-bit aligned => error free\r\n    let si = sce(3 * d2, z2); // 3*d2: 47-bit aligned => error free\r\n    let sj = fes(sd, sf);\r\n    let sk = fes(se, sg);\r\n    let sl = epr(sh, vₓₓₓ);\r\n    let sm = epr(si, vᵧᵧᵧ);\r\n    let sn = epr(sj, vₓₓᵧ);\r\n    let so = epr(sk, vₓᵧᵧ);\r\n    let sp = fes(sl, sm);\r\n    let sq = fes(sn, so);\r\n    let sr = epr(c2c2, vₓₓ);\r\n    let ss = epr(d2d2, vᵧᵧ);\r\n    let st = epr(c2d2, vₓᵧ);\r\n    let su = fes(sr, ss);\r\n    let sv = fes(sp, sq);\r\n    let sw = fes(su, st);\r\n    let v4 = fes(sv, sw);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //let v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //let v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    let sx = sce(c1, z8);\r\n    let sy = sce(d1, z9);\r\n    let sz = sce(2 * c0, za);\r\n    let o1 = sce(2 * d1, zb);\r\n    let o2 = sce(c1, z7);\r\n    let o3 = sce(c1, z4);\r\n    let o4 = fes(sz, o2);\r\n    let o5 = fes(o1, o3);\r\n    let o6 = epr(d1d2, vᵧᵧ);\r\n    let o7 = epr(c1c2, vₓₓ);\r\n    let o8 = epr(za, vₓᵧ);\r\n    let o9 = fes(o6, o7);\r\n    let oa = epr(sx, vₓₓₓ);\r\n    let ob = epr(o4, vₓₓᵧ);\r\n    let oc = epr(sy, vᵧᵧᵧ);\r\n    let od = epr(o5, vₓᵧᵧ);\r\n    let oe = fes(oa, oc);\r\n    let og = fes(ob, od);\r\n    let oh = fes(oe, og);\r\n    let oi = fes(em2(o9), o8);\r\n    let v3 = fes(oh, oi);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //let v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    //let v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    let oj = sce(3 * c0, z1);\r\n    let ok = sce(3 * d0, z2);\r\n    let ol = sce(c0, z6);\r\n    let om = sce(c0, z4);\r\n    let on = sce(d0, z3);\r\n    let oo = sce(d0, z5);\r\n    let op = fes(ol, on);\r\n    let oq = fes(om, oo);\r\n    let or = epr(oj, vₓₓₓ);\r\n    let os = epr(ok, vᵧᵧᵧ);\r\n    let ot = epr(op, vₓₓᵧ);\r\n    let ou = epr(oq, vₓᵧᵧ);\r\n    let ov = epr(z3, vₓₓ);\r\n    let ow = epr(z4, vᵧᵧ);\r\n    let ox = epr(ze, vₓᵧ);\r\n    let oy = sce(c2, vₓ);\r\n    let oz = sce(d2, vᵧ);\r\n    let p1 = fes(or, os);\r\n    let p2 = fes(ot, ou);\r\n    let p3 = fes(ov, ow);\r\n    let p4 = fes(p1, p2);\r\n    let p5 = fes(p3, ox);\r\n    let p6 = fes(oy, oz);\r\n    let p7 = fes(p4, p5);\r\n    let v2 = fes(p7, p6);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //let v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    let p8 = sce(3 * c0, c0c1);\r\n    let p9 = sce(3 * d0, d0d1);\r\n    let pa = sce(c0, zc);\r\n    let pb = sce(d0, zd);\r\n    let pc = epr(c0c1, vₓₓ);\r\n    let pd = epr(d0d1, vᵧᵧ);\r\n    let pe = epr(c0d1, vₓᵧ);\r\n    let pf = epr(c1d0, vₓᵧ);\r\n    let pg = em2(fes(pc, pd));\r\n    let ph = fes(pe, pf);\r\n    let pi = sce(c1, vₓ);\r\n    let pj = sce(d1, vᵧ);\r\n    let pk = epr(p8, vₓₓₓ);\r\n    let pl = epr(p9, vᵧᵧᵧ);\r\n    let pm = epr(pa, vₓₓᵧ);\r\n    let pn = epr(pb, vₓᵧᵧ);\r\n    let po = fes(pk, pl);\r\n    let pp = fes(pm, pn);\r\n    let pq = fes(po, pp);\r\n    let pr = fes(pg, ph);\r\n    let ps = fes(pi, pj);\r\n    let pt = fes(pq, pr);\r\n    let v1 = fes(pt, ps);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    let pu = sce(c0, vₓₓₓ);\r\n    let pv = sce(c0, vₓᵧᵧ);\r\n    let pw = sce(d0, vₓₓᵧ);\r\n    let px = sce(d0, vᵧᵧᵧ);\r\n    let py = fes(pu, pw);\r\n    let pz = fes(pv, px);\r\n    let u1 = fes(py, vₓₓ);\r\n    let u2 = fes(pz, vᵧᵧ);\r\n    let u3 = epr(c0c0, u1);\r\n    let u4 = epr(d0d0, u2);\r\n    let u5 = epr(c0d0, vₓᵧ);\r\n    let u6 = sce(c0, vₓ);\r\n    let u7 = sce(d0, vᵧ);\r\n    let u8 = fes(u3, u4);\r\n    let u9 = fes(u8, u5);\r\n    let ua = fes(u6, u7);\r\n    let ub = fes(u9, ua);\r\n    let v0 = fes(ub, v);\r\n    return [v6, v5, v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs3x2Exact_ = getCoeffs3x2Exact_;\r\n//# sourceMappingURL=get-coefficients-3x2-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js\");\r\nfunction getCoeffs3x2Exact(ps1, ps2) {\r\n    let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_1.getImplicitForm3Exact(ps1);\r\n    let [c2, c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d2, d1, d0] = get_y_1.getYExact(ps2);\r\n    // max bitlengths (assuming coefficients is at 14 bitlength):\r\n    // a2, b2: 16\r\n    // a1, b1: 16\r\n    // a0, b0: 14\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    let v6 = flo_numerical_1.calculate([\r\n        [c2, c2, c2, vₓₓₓ], [c2, c2, d2, vₓₓᵧ],\r\n        [c2, d2, d2, vₓᵧᵧ], [d2, d2, d2, vᵧᵧᵧ]\r\n    ]);\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    let v5 = flo_numerical_1.calculate([\r\n        [[3], c1, c2, c2, vₓₓₓ], [[2], c1, c2, d2, vₓₓᵧ],\r\n        [c1, d2, d2, vₓᵧᵧ], [c2, c2, d1, vₓₓᵧ],\r\n        [[2], c2, d1, d2, vₓᵧᵧ], [[3], d1, d2, d2, vᵧᵧᵧ]\r\n    ]);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    let v4 = flo_numerical_1.calculate([\r\n        [[3], c0, c2, c2, vₓₓₓ], [[2], c0, c2, d2, vₓₓᵧ], [c0, d2, d2, vₓᵧᵧ],\r\n        [[3], c1, c1, c2, vₓₓₓ], [c1, c1, d2, vₓₓᵧ], [[2], c1, c2, d1, vₓₓᵧ],\r\n        [[2], c1, d1, d2, vₓᵧᵧ], [c2, c2, d0, vₓₓᵧ], [c2, c2, vₓₓ],\r\n        [[2], c2, d0, d2, vₓᵧᵧ], [c2, d1, d1, vₓᵧᵧ], [c2, d2, vₓᵧ],\r\n        [[3], d0, d2, d2, vᵧᵧᵧ], [[3], d1, d1, d2, vᵧᵧᵧ], [d2, d2, vᵧᵧ]\r\n    ]);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    let v3 = flo_numerical_1.calculate([\r\n        [[6], c0, c1, c2, vₓₓₓ], [[2], c0, c1, d2, vₓₓᵧ], [[2], c0, c2, d1, vₓₓᵧ],\r\n        [[2], c0, d1, d2, vₓᵧᵧ], [c1, c1, c1, vₓₓₓ], [c1, c1, d1, vₓₓᵧ],\r\n        [[2], c1, c2, d0, vₓₓᵧ], [[2], c1, c2, vₓₓ], [[2], c1, d0, d2, vₓᵧᵧ],\r\n        [c1, d1, d1, vₓᵧᵧ], [c1, d2, vₓᵧ], [[2], c2, d0, d1, vₓᵧᵧ],\r\n        [c2, d1, vₓᵧ], [[6], d0, d1, d2, vᵧᵧᵧ], [d1, d1, d1, vᵧᵧᵧ],\r\n        [[2], d1, d2, vᵧᵧ]\r\n    ]);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    let v2 = flo_numerical_1.calculate([\r\n        [[3], c0, c0, c2, vₓₓₓ], [c0, c0, d2, vₓₓᵧ], [[3], c0, c1, c1, vₓₓₓ],\r\n        [[2], c0, c1, d1, vₓₓᵧ], [[2], c0, c2, d0, vₓₓᵧ], [[2], c0, c2, vₓₓ],\r\n        [[2], c0, d0, d2, vₓᵧᵧ], [c0, d1, d1, vₓᵧᵧ], [c0, d2, vₓᵧ],\r\n        [c1, c1, d0, vₓₓᵧ], [c1, c1, vₓₓ], [[2], c1, d0, d1, vₓᵧᵧ],\r\n        [c1, d1, vₓᵧ], [c2, d0, d0, vₓᵧᵧ], [c2, d0, vₓᵧ],\r\n        [c2, vₓ], [[3], d0, d0, d2, vᵧᵧᵧ], [[3], d0, d1, d1, vᵧᵧᵧ],\r\n        [[2], d0, d2, vᵧᵧ], [d1, d1, vᵧᵧ], [d2, vᵧ]\r\n    ]);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    let v1 = flo_numerical_1.calculate([\r\n        [[3], c0, c0, c1, vₓₓₓ], [c0, c0, d1, vₓₓᵧ], [[2], c0, c1, d0, vₓₓᵧ],\r\n        [[2], c0, c1, vₓₓ], [[2], c0, d0, d1, vₓᵧᵧ], [c0, d1, vₓᵧ],\r\n        [c1, d0, d0, vₓᵧᵧ], [c1, d0, vₓᵧ], [c1, vₓ],\r\n        [[3], d0, d0, d1, vᵧᵧᵧ], [[2], d0, d1, vᵧᵧ], [d1, vᵧ]\r\n    ]);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, c0, c0, vₓₓₓ], [c0, c0, d0, vₓₓᵧ], [c0, c0, vₓₓ],\r\n        [c0, d0, d0, vₓᵧᵧ], [c0, d0, vₓᵧ], [c0, vₓ],\r\n        [d0, d0, d0, vᵧᵧᵧ], [d0, d0, vᵧᵧ], [d0, vᵧ],\r\n        [v]\r\n    ]);\r\n    return [v6, v5, v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs3x2Exact = getCoeffs3x2Exact;\r\n//# sourceMappingURL=get-coefficients-3x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3-.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3-.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form3- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\nconst em2 = flo_numerical_1.eMultBy2;\r\n// TODO - better docs\r\n/**\r\n * * **precondition**: 47-bit bit-aligned coefficient bitlength (this is to\r\n * improve speed considerably)\r\n * @param ps1\r\n * @param ps2\r\n */\r\nfunction getCoeffs3x3Exact_(ps1, ps2) {\r\n    let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_1.getImplicitForm3Exact_(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0c3 = tp(c0, c3);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c0d3 = tp(c0, d3);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1c3 = tp(c1, c3);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c1d3 = tp(c1, d3);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2c3 = tp(c2, c3);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let c2d3 = tp(c2, d3);\r\n    let c3c3 = tp(c3, c3);\r\n    let c3d0 = tp(c3, d0);\r\n    let c3d1 = tp(c3, d1);\r\n    let c3d2 = tp(c3, d2);\r\n    let c3d3 = tp(c3, d3);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d0d3 = tp(d0, d3);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d3d3 = tp(d3, d3);\r\n    let d2d2 = tp(d2, d2);\r\n    let d2d3 = tp(d2, d3);\r\n    let d1d3 = tp(d1, d3);\r\n    //let v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;  \r\n    let g1 = sce(c3, c3c3); // c3*c3c3\r\n    let g2 = sce(c3, d3d3); // c3*d3d3\r\n    let g3 = sce(d3, c3c3); // d3*c3c3\r\n    let g4 = sce(d3, d3d3); // d3*d3d3\r\n    let g5 = epr(g1, vₓₓₓ); // g1*vₓₓₓ\r\n    let g6 = epr(g2, vₓᵧᵧ); // g2*vₓᵧᵧ\r\n    let g7 = epr(g3, vₓₓᵧ); // g3*vₓₓᵧ \r\n    let g8 = epr(g4, vᵧᵧᵧ); // g4*vᵧᵧᵧ\r\n    let g9 = fes(g5, g6); // g5 + g6\r\n    let ga = fes(g7, g8); // g7 + g8\r\n    let v9 = fes(g9, ga); // g9 + ga\r\n    //let v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    let w1 = qaq(qm2(c2d3), c3d2); // 47-bit aligned => error free\r\n    let w2 = qaq(qm2(c3d2), c2d3); // 47-bit aligned => error free\r\n    let w3 = sce(c3, w1);\r\n    let w4 = sce(d3, w2);\r\n    let w5 = sce(c2, c3c3);\r\n    let w6 = sce(d2, d3d3);\r\n    let w7 = epr(vₓₓₓ, w5);\r\n    let u1 = epr(vᵧᵧᵧ, w6);\r\n    let u2 = epr(vₓₓᵧ, w3);\r\n    let u3 = epr(vₓᵧᵧ, w4);\r\n    let u4 = fes(u2, u3);\r\n    let u5 = sce(3, fes(w7, u1));\r\n    let v8 = fes(u4, u5);\r\n    //let v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    let o1 = sce(c1, c3d3);\r\n    let o2 = sce(d1, c3c3);\r\n    let o3 = sce(c2, d2d3);\r\n    let o4 = sce(c1, d3d3);\r\n    let o5 = sce(c2, c3d2);\r\n    let o6 = sce(d3, c2c2);\r\n    let o7 = sce(c3, d1d3);\r\n    let o8 = sce(d2, c3d2);\r\n    let w8 = fes(o1, o5);\r\n    let w9 = fes(o2, o6);\r\n    let wa = fes(o3, o7);\r\n    let wb = fes(o4, o8);\r\n    let wc = qaq(c1c3, c2c2); // 48-bit aligned => error free\r\n    let wd = qaq(d1d3, d2d2); // 48-bit aligned => error free\r\n    let we = fes(em2(w8), w9);\r\n    let wf = fes(em2(wa), wb);\r\n    let wg = epr(vₓₓᵧ, we);\r\n    let wh = epr(vₓᵧᵧ, wf);\r\n    let wi = sce(c3, wc);\r\n    let wj = sce(d3, wd);\r\n    let wk = epr(vₓₓₓ, wi);\r\n    let wl = epr(vᵧᵧᵧ, wj);\r\n    let wm = fes(wg, wh);\r\n    let wn = sce(3, fes(wk, wl));\r\n    let v7 = fes(wm, wn);\r\n    //let v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    let wo = qaq(c2d3, c3d2); // 48-bit aligned => error free\r\n    let zc = sce(d2, c2c2);\r\n    let zd = em2(sce(c1, wo));\r\n    let wp = fes(zc, zd);\r\n    let wq = qm2(qaq(c0d3, c2d1)); // 48-bit aligned => error free\r\n    let wr = qaq(wq, c3d0); // 47-bit aligned => error free\r\n    let ze = sce(c3, wr);\r\n    let ws = fes(wp, ze);\r\n    let zf = sce(c2, d2d2);\r\n    let zg = em2(sce(d1, wo));\r\n    let wt = fes(zf, zg);\r\n    let wu = qm2(qaq(c1d2, c3d0)); // 48-bit aligned => error free\r\n    let wv = qaq(wu, c0d3); // 47-bit aligned => error free\r\n    let zh = sce(d3, wv);\r\n    let ww = fes(wt, zh);\r\n    let wx = sce(c2, c2c2);\r\n    let wy = qaq(qm2(c1c2), c0c3); // 48-bit aligned => error free\r\n    let wz = sce(3 * c3, wy); // 3*c3: 47-bit aligned => error free\r\n    let z1 = fes(wx, wz);\r\n    let z2 = sce(d2, d2d2);\r\n    let z3 = qaq(qm2(d1d2), d0d3); // 47-bit aligned => error free\r\n    let z4 = sce(3 * d3, z3); // 3*d3: 47-bit aligned => error free\r\n    let z5 = fes(z2, z4);\r\n    let zi = epr(vₓₓᵧ, ws);\r\n    let zj = epr(vₓᵧᵧ, ww);\r\n    let z6 = fes(zi, zj);\r\n    let zk = epr(vₓₓₓ, z1);\r\n    let zl = epr(vᵧᵧᵧ, z5);\r\n    let z7 = fes(zk, zl);\r\n    let zm = epr(c3c3, vₓₓ);\r\n    let zn = epr(d3d3, vᵧᵧ);\r\n    let z8 = fes(zm, zn);\r\n    let z9 = epr(c3d3, vₓᵧ);\r\n    let za = fes(z6, z7);\r\n    let zb = fes(z8, z9);\r\n    let v6 = fes(za, zb);\r\n    //let r4 = c2d2 + c3d1;\r\n    //let r5 = c1d3 + c2d2;\r\n    //let v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    let r4 = qaq(c2d2, c3d1); // 48-bit aligned => error free\r\n    let r5 = qaq(c1d3, c2d2); // 48-bit aligned => error free\r\n    let k1 = sce(c0, wo); // wo: 48-bit aligned => error free\r\n    let k2 = sce(d0, wo);\r\n    let k3 = sce(c1, r4);\r\n    let k4 = sce(d1, r5);\r\n    let k5 = qaq(qm2(c3d0), c2d1); // 48-bit aligned => error free\r\n    let k6 = qaq(qm2(c0d3), c1d2); // 48-bit aligned => error free\r\n    let k7 = sce(d3, c1c1);\r\n    let k8 = sce(c3, d1d1);\r\n    let k9 = sce(c2, k5);\r\n    let ka = sce(d2, k6);\r\n    let kb = em2(fes(k1, k3));\r\n    let kc = em2(fes(k2, k4));\r\n    let kd = em2(sce(c0, c2c3));\r\n    let ke = em2(sce(d0, d2d3));\r\n    let kf = sce(c1, wc);\r\n    let kg = sce(d1, wd);\r\n    let kh = epr(c2c3, vₓₓ);\r\n    let ki = epr(d2d3, vᵧᵧ);\r\n    let kj = fes(kb, k7);\r\n    let kk = fes(kc, k8);\r\n    let kl = fes(kj, k9);\r\n    let km = fes(kk, ka);\r\n    let kn = fes(kd, kf);\r\n    let ko = fes(ke, kg);\r\n    let kp = em2(fes(kh, ki));\r\n    let kq = epr(vₓₓᵧ, kl);\r\n    let kr = epr(vₓᵧᵧ, km);\r\n    let ks = epr(vₓₓₓ, kn);\r\n    let kt = epr(vᵧᵧᵧ, ko);\r\n    let ku = fes(kq, kr);\r\n    let kv = sce(3, fes(ks, kt));\r\n    let kw = epr(vₓᵧ, wo);\r\n    let kx = fes(ku, kv);\r\n    let ky = fes(kw, kp);\r\n    let v5 = fes(kx, ky);\r\n    //let r1 = c1d3 + r4;\r\n    //let r2 = 2*c1c3 + c2c2;\r\n    //let r3 = 2*d1d3 + d2d2;\r\n    //let v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    let r1 = qaq(c1d3, r4); // 48-bit aligned => error free\r\n    let r2 = qaq(qm2(c1c3), c2c2); // 48-bit aligned => error free\r\n    let r3 = qaq(qm2(d1d3), d2d2); // 48-bit aligned => error free\r\n    let s1 = sce((2 * c0), r1);\r\n    let s2 = sce((2 * d0), r1);\r\n    let s5 = qaq(c1d2, qm2(c2d1)); // 48-bit aligned => error free\r\n    let s6 = qaq(c2d1, qm2(c1d2)); // 48-bit aligned => error free\r\n    let s3 = sce(d0, r2);\r\n    let s4 = sce(c0, r3);\r\n    let s7 = sce(c1, s5);\r\n    let s8 = sce(d1, s6);\r\n    let s9 = sce(c0, r2);\r\n    let sa = sce(d0, r3);\r\n    let sb = sce(c2, c1c1);\r\n    let sc = sce(d2, d1d1);\r\n    let sd = fes(s1, s3);\r\n    let se = fes(s2, s4);\r\n    let sf = fes(sd, s7);\r\n    let sg = fes(se, s8);\r\n    let sh = fes(s9, sb);\r\n    let si = fes(sa, sc);\r\n    let sj = epr(vₓₓᵧ, sf);\r\n    let sk = epr(vₓᵧᵧ, sg);\r\n    let sl = epr(vₓₓₓ, sh);\r\n    let sm = epr(vᵧᵧᵧ, si);\r\n    let sn = fes(sl, sm);\r\n    let so = fes(sj, sk);\r\n    let sp = fes(so, sce(3, sn));\r\n    let ss = epr(vₓᵧ, r1);\r\n    let st = epr(vₓₓ, r2);\r\n    let sq = fes(ss, st);\r\n    let su = epr(vᵧᵧ, r3);\r\n    let sr = fes(sq, su);\r\n    let v4 = fes(sp, sr);\r\n    //let r6 = c1d2 + c2d1;\r\n    //let r7 = c3d0 + c0d3;\r\n    //let r8 = c1c2 + c0c3;\r\n    //let r9 = d1d2 + d0d3;\r\n    //let v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    // 48-bit aligned => error free\r\n    let r6 = qaq(c1d2, c2d1); // 48-bit aligned => error free\r\n    let r7 = qaq(c3d0, c0d3); // 48-bit aligned => error free\r\n    let r8 = qaq(c1c2, c0c3); // 48-bit aligned => error free\r\n    let r9 = qaq(d1d2, d0d3); // 48-bit aligned => error free\r\n    let m1 = qaq(qm2(r6), c3d0); // 47-bit aligned => error free\r\n    let m2 = qaq(qm2(r6), c0d3); // 47-bit aligned => error free\r\n    let m3 = qaq(qm2(c2d0), c1d1); // 48-bit aligned => error free\r\n    let m4 = qaq(qm2(c0d2), c1d1); // 48-bit aligned => error free\r\n    let m5 = qaq(r8, c1c2); // 48-bit aligned => error free\r\n    let m6 = qaq(r9, d1d2); // 48-bit aligned => error free\r\n    let m7 = sce(3 * c0, m5); // 3*c0: 47-bit aligned => error free\r\n    let m8 = sce(3 * d0, m6); // 3*c0: 47-bit aligned => error free\r\n    let m9 = sce(c1, c1c1);\r\n    let ma = sce(d1, d1d1);\r\n    let mb = epr(vₓₓ, r8);\r\n    let mc = epr(vᵧᵧ, r9);\r\n    let md = fes(m1, r7);\r\n    let me = fes(m2, r7);\r\n    let mf = sce(c0, md);\r\n    let mg = sce(d0, me);\r\n    let mh = sce(c1, m3);\r\n    let mi = sce(d1, m4);\r\n    let mj = sce(c3, vₓ);\r\n    let mk = sce(d3, vᵧ);\r\n    let ml = fes(mf, mh);\r\n    let mm = fes(mg, mi);\r\n    let mn = fes(m7, m9);\r\n    let mo = fes(m8, ma);\r\n    let mp = qaq(r7, r6); // 47-bit aligned => error free\r\n    let mq = em2(fes(mb, mc));\r\n    let mr = epr(vₓₓᵧ, ml);\r\n    let ms = epr(vₓᵧᵧ, mm);\r\n    let mt = epr(vₓₓₓ, mn);\r\n    let mu = epr(vᵧᵧᵧ, mo);\r\n    let mv = epr(vₓᵧ, mp);\r\n    let mw = fes(mr, ms);\r\n    let mx = fes(mt, mu);\r\n    let my = fes(mv, mq);\r\n    let mz = fes(mj, mk);\r\n    let n1 = fes(mw, mx);\r\n    let n2 = fes(my, mz);\r\n    let v3 = fes(n1, n2);\r\n    //let ra = c1d1 + c2d0;\r\n    //let rb = c1d1 + c0d2;\r\n    //let v2 =\r\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //    vₓᵧ*(ra + c0d2) +\r\n    //    vₓₓ*(2*c0c2 + c1c1) + \r\n    //    vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //    c2*vₓ + d2*vᵧ;\r\n    let ra = qaq(c1d1, c2d0); // 48-bit aligned => error free\r\n    let rb = qaq(c1d1, c0d2); // 48-bit aligned => error free\r\n    let l1 = qaq(qm2(ra), c0d2); // 47-bit aligned => error free\r\n    let l2 = qaq(qm2(rb), c2d0); // 47-bit aligned => error free\r\n    let l3 = sce(c0, l1);\r\n    let l4 = sce(d0, c1c1);\r\n    let l5 = sce(d0, l2);\r\n    let l6 = sce(c0, d1d1);\r\n    let l7 = sce(c0, c1c1);\r\n    let l8 = sce(c2, c0c0);\r\n    let l9 = sce(d0, d1d1);\r\n    let la = sce(d2, d0d0);\r\n    let lb = fes(l3, l4);\r\n    let lc = fes(l5, l6);\r\n    let ld = fes(l7, l8);\r\n    let le = fes(l9, la);\r\n    let lf = epr(vₓₓₓ, ld);\r\n    let lg = epr(vᵧᵧᵧ, le);\r\n    let lh = sce(3, fes(lf, lg));\r\n    let li = qaq(ra, c0d2); // 48-bit aligned => error free\r\n    let lj = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let lk = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let ll = epr(vₓₓᵧ, lb);\r\n    let lm = epr(vₓᵧᵧ, lc);\r\n    let ln = epr(vₓᵧ, li);\r\n    let lo = epr(vₓₓ, lj);\r\n    let lp = epr(vᵧᵧ, lk);\r\n    let lq = sce(c2, vₓ);\r\n    let lr = sce(d2, vᵧ);\r\n    let ls = fes(lq, lr);\r\n    let lt = fes(ll, lm);\r\n    let lu = fes(lh, ln);\r\n    let lv = fes(lo, lp);\r\n    let lw = fes(lt, lu);\r\n    let lx = fes(lv, ls);\r\n    let v2 = fes(lw, lx);\r\n    //let rc = c1d0 + c0d1;\r\n    //let v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    let rc = qaq(c1d0, c0d1); // 48-bit aligned => error free\r\n    let rd = sce(c0, vₓₓᵧ);\r\n    let re = sce(d0, vₓᵧᵧ);\r\n    let rf = qaq(rc, c1d0); // 48-bit aligned => error free\r\n    let rg = qaq(rc, c0d1); // 48-bit aligned => error free\r\n    let rx = sce(c1, c0c0);\r\n    let rh = epr(rx, vₓₓₓ);\r\n    let ry = sce(d1, d0d0);\r\n    let ri = epr(ry, vᵧᵧᵧ);\r\n    let rj = epr(vₓᵧ, rc);\r\n    let rk = epr(c0c1, vₓₓ);\r\n    let rl = epr(d0d1, vᵧᵧ);\r\n    let rm = fes(rk, rl);\r\n    let rn = sce(c1, vₓ);\r\n    let ro = sce(d1, vᵧ);\r\n    let rp = fes(rn, ro);\r\n    let rq = epr(rd, rf);\r\n    let rr = epr(re, rg);\r\n    let rs = fes(rq, rr);\r\n    let rt = sce(3, fes(rh, ri));\r\n    let ru = fes(rj, em2(rm));\r\n    let rv = fes(rs, rt);\r\n    let rw = fes(ru, rp);\r\n    let v1 = fes(rv, rw);\r\n    // v0\r\n    let t1 = sce(c0, vₓₓₓ);\r\n    let t2 = sce(d0, vₓₓᵧ);\r\n    let p4 = fes(t1, t2);\r\n    let t3 = sce(c0, vₓᵧᵧ);\r\n    let t4 = sce(d0, vᵧᵧᵧ);\r\n    let p5 = fes(t3, t4);\r\n    let p7 = fes(p4, vₓₓ);\r\n    let p8 = fes(p5, vᵧᵧ);\r\n    let pc = epr(c0c0, p7);\r\n    let pd = epr(d0d0, p8);\r\n    let p6 = fes(pc, pd);\r\n    let pe = epr(c0d0, vₓᵧ);\r\n    let p9 = fes(p6, pe);\r\n    let pf = sce(c0, vₓ);\r\n    let pg = sce(d0, vᵧ);\r\n    let pa = fes(pf, pg);\r\n    let pb = fes(p9, pa);\r\n    let v0 = fes(pb, v);\r\n    return [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs3x3Exact_ = getCoeffs3x3Exact_;\r\n//# sourceMappingURL=get-coefficients-3x3-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/exact/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3.js\");\r\n/**\r\n * @param ps1\r\n * @param ps2\r\n */\r\nfunction getCoeffs3x3Exact(ps1, ps2) {\r\n    let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_1.getImplicitForm3Exact(ps1);\r\n    let [c3, c2, c1, c0] = get_x_1.getXExact(ps2);\r\n    let [d3, d2, d1, d0] = get_y_1.getYExact(ps2);\r\n    let v9 = flo_numerical_1.calculate([\r\n        [c3, d3, d3, vₓᵧᵧ],\r\n        [d3, c3, c3, vₓₓᵧ],\r\n        [c3, c3, c3, vₓₓₓ],\r\n        [d3, d3, d3, vᵧᵧᵧ]\r\n    ]);\r\n    let v8 = flo_numerical_1.calculate([\r\n        [[2], c2, c3, d3, vₓₓᵧ],\r\n        [[2], c3, d2, d3, vₓᵧᵧ],\r\n        [c2, d3, d3, vₓᵧᵧ],\r\n        [d2, c3, c3, vₓₓᵧ],\r\n        [[3], c2, c3, c3, vₓₓₓ],\r\n        [[3], d2, d3, d3, vᵧᵧᵧ]\r\n    ]);\r\n    let v7 = flo_numerical_1.calculate([\r\n        [[2], c1, c3, d3, vₓₓᵧ],\r\n        [[2], c2, c3, d2, vₓₓᵧ],\r\n        [[2], c2, d2, d3, vₓᵧᵧ],\r\n        [[2], c3, d1, d3, vₓᵧᵧ],\r\n        [d3, d3, c1, vₓᵧᵧ],\r\n        [d2, d2, c3, vₓᵧᵧ],\r\n        [c3, c3, d1, vₓₓᵧ],\r\n        [c2, c2, d3, vₓₓᵧ],\r\n        [[3], c1, c3, c3, vₓₓₓ],\r\n        [[3], c3, c2, c2, vₓₓₓ],\r\n        [[3], d1, d3, d3, vᵧᵧᵧ],\r\n        [[3], d3, d2, d2, vᵧᵧᵧ]\r\n    ]);\r\n    let v6 = flo_numerical_1.calculate([\r\n        [[2], c0, c3, d3, vₓₓᵧ],\r\n        [[2], c1, c2, d3, vₓₓᵧ],\r\n        [[2], c1, c3, d2, vₓₓᵧ],\r\n        [[2], c1, d2, d3, vₓᵧᵧ],\r\n        [[2], c2, c3, d1, vₓₓᵧ],\r\n        [[2], c2, d1, d3, vₓᵧᵧ],\r\n        [[2], c3, d0, d3, vₓᵧᵧ],\r\n        [[2], c3, d1, d2, vₓᵧᵧ],\r\n        [[6], c1, c2, c3, vₓₓₓ],\r\n        [[6], d1, d2, d3, vᵧᵧᵧ],\r\n        [c0, d3, d3, vₓᵧᵧ],\r\n        [c2, d2, d2, vₓᵧᵧ],\r\n        [d0, c3, c3, vₓₓᵧ],\r\n        [d2, c2, c2, vₓₓᵧ],\r\n        [[3], c0, c3, c3, vₓₓₓ],\r\n        [[3], d0, d3, d3, vᵧᵧᵧ],\r\n        [c2, c2, c2, vₓₓₓ],\r\n        [d2, d2, d2, vᵧᵧᵧ],\r\n        [c3, c3, vₓₓ],\r\n        [d3, d3, vᵧᵧ],\r\n        [c3, d3, vₓᵧ]\r\n    ]);\r\n    let v5 = flo_numerical_1.calculate([\r\n        [[2], c0, c2, d3, vₓₓᵧ],\r\n        [[2], c0, c3, d2, vₓₓᵧ],\r\n        [[2], c0, d2, d3, vₓᵧᵧ],\r\n        [[2], c1, c2, d2, vₓₓᵧ],\r\n        [[2], c1, c3, d1, vₓₓᵧ],\r\n        [[2], c1, d1, d3, vₓᵧᵧ],\r\n        [[2], c2, c3, d0, vₓₓᵧ],\r\n        [[2], c2, d0, d3, vₓᵧᵧ],\r\n        [[2], c2, d1, d2, vₓᵧᵧ],\r\n        [[2], c3, d0, d2, vₓᵧᵧ],\r\n        [[6], c0, c2, c3, vₓₓₓ],\r\n        [[6], d0, d2, d3, vᵧᵧᵧ],\r\n        [c1, d2, d2, vₓᵧᵧ],\r\n        [c3, d1, d1, vₓᵧᵧ],\r\n        [d1, c2, c2, vₓₓᵧ],\r\n        [d3, c1, c1, vₓₓᵧ],\r\n        [[3], c1, c2, c2, vₓₓₓ],\r\n        [[3], c3, c1, c1, vₓₓₓ],\r\n        [[3], d1, d2, d2, vᵧᵧᵧ],\r\n        [[3], d3, d1, d1, vᵧᵧᵧ],\r\n        [c2, d3, vₓᵧ],\r\n        [c3, d2, vₓᵧ],\r\n        [[2], c2, c3, vₓₓ],\r\n        [[2], d2, d3, vᵧᵧ]\r\n    ]);\r\n    let v4 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, d3, vₓₓᵧ],\r\n        [[2], c0, c2, d2, vₓₓᵧ],\r\n        [[2], c0, c3, d1, vₓₓᵧ],\r\n        [[2], c0, d1, d3, vₓᵧᵧ],\r\n        [[2], c1, c2, d1, vₓₓᵧ],\r\n        [[2], c1, c3, d0, vₓₓᵧ],\r\n        [[2], c1, d0, d3, vₓᵧᵧ],\r\n        [[2], c1, d1, d2, vₓᵧᵧ],\r\n        [[2], c2, d0, d2, vₓᵧᵧ],\r\n        [[2], c3, d0, d1, vₓᵧᵧ],\r\n        [[6], c0, c1, c3, vₓₓₓ],\r\n        [[6], d0, d1, d3, vᵧᵧᵧ],\r\n        [c0, d2, d2, vₓᵧᵧ],\r\n        [c2, d1, d1, vₓᵧᵧ],\r\n        [d0, c2, c2, vₓₓᵧ],\r\n        [d2, c1, c1, vₓₓᵧ],\r\n        [[3], c0, c2, c2, vₓₓₓ],\r\n        [[3], c2, c1, c1, vₓₓₓ],\r\n        [[3], d0, d2, d2, vᵧᵧᵧ],\r\n        [[3], d2, d1, d1, vᵧᵧᵧ],\r\n        [c2, c2, vₓₓ],\r\n        [d2, d2, vᵧᵧ],\r\n        [c1, d3, vₓᵧ],\r\n        [c2, d2, vₓᵧ],\r\n        [c3, d1, vₓᵧ],\r\n        [[2], c1, c3, vₓₓ],\r\n        [[2], d1, d3, vᵧᵧ]\r\n    ]);\r\n    let v3 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, d2, vₓₓᵧ],\r\n        [[2], c0, c2, d1, vₓₓᵧ],\r\n        [[2], c0, c3, d0, vₓₓᵧ],\r\n        [[2], c0, d0, d3, vₓᵧᵧ],\r\n        [[2], c0, d1, d2, vₓᵧᵧ],\r\n        [[2], c1, c2, d0, vₓₓᵧ],\r\n        [[2], c1, d0, d2, vₓᵧᵧ],\r\n        [[2], c2, d0, d1, vₓᵧᵧ],\r\n        [[6], c0, c1, c2, vₓₓₓ],\r\n        [[6], d0, d1, d2, vᵧᵧᵧ],\r\n        [c1, d1, d1, vₓᵧᵧ],\r\n        [c3, d0, d0, vₓᵧᵧ],\r\n        [d1, c1, c1, vₓₓᵧ],\r\n        [d3, c0, c0, vₓₓᵧ],\r\n        [[3], c3, c0, c0, vₓₓₓ],\r\n        [[3], d3, d0, d0, vᵧᵧᵧ],\r\n        [c1, c1, c1, vₓₓₓ],\r\n        [d1, d1, d1, vᵧᵧᵧ],\r\n        [c0, d3, vₓᵧ],\r\n        [c1, d2, vₓᵧ],\r\n        [c2, d1, vₓᵧ],\r\n        [c3, d0, vₓᵧ],\r\n        [[2], c0, c3, vₓₓ],\r\n        [[2], c1, c2, vₓₓ],\r\n        [[2], d0, d3, vᵧᵧ],\r\n        [[2], d1, d2, vᵧᵧ],\r\n        [c3, vₓ],\r\n        [d3, vᵧ],\r\n    ]);\r\n    let v2 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, d1, vₓₓᵧ],\r\n        [[2], c0, c2, d0, vₓₓᵧ],\r\n        [[2], c0, d0, d2, vₓᵧᵧ],\r\n        [[2], c1, d0, d1, vₓᵧᵧ],\r\n        [c0, d1, d1, vₓᵧᵧ],\r\n        [c2, d0, d0, vₓᵧᵧ],\r\n        [d0, c1, c1, vₓₓᵧ],\r\n        [d2, c0, c0, vₓₓᵧ],\r\n        [[3], c0, c1, c1, vₓₓₓ],\r\n        [[3], c2, c0, c0, vₓₓₓ],\r\n        [[3], d0, d1, d1, vᵧᵧᵧ],\r\n        [[3], d2, d0, d0, vᵧᵧᵧ],\r\n        [c0, d2, vₓᵧ],\r\n        [c1, d1, vₓᵧ],\r\n        [c2, d0, vₓᵧ],\r\n        [[2], c0, c2, vₓₓ],\r\n        [[2], d0, d2, vᵧᵧ],\r\n        [c1, c1, vₓₓ],\r\n        [d1, d1, vᵧᵧ],\r\n        [c2, vₓ],\r\n        [d2, vᵧ]\r\n    ]);\r\n    let v1 = flo_numerical_1.calculate([\r\n        [[2], c0, c1, d0, vₓₓᵧ],\r\n        [[2], c0, d0, d1, vₓᵧᵧ],\r\n        [c1, d0, d0, vₓᵧᵧ],\r\n        [d1, c0, c0, vₓₓᵧ],\r\n        [[3], c1, c0, c0, vₓₓₓ],\r\n        [[3], d1, d0, d0, vᵧᵧᵧ],\r\n        [c0, d1, vₓᵧ],\r\n        [c1, d0, vₓᵧ],\r\n        [[2], c0, c1, vₓₓ],\r\n        [[2], d0, d1, vᵧᵧ],\r\n        [c1, vₓ],\r\n        [d1, vᵧ],\r\n    ]);\r\n    let v0 = flo_numerical_1.calculate([\r\n        [c0, d0, d0, vₓᵧᵧ],\r\n        [d0, c0, c0, vₓₓᵧ],\r\n        [c0, c0, c0, vₓₓₓ],\r\n        [d0, d0, d0, vᵧᵧᵧ],\r\n        [c0, d0, vₓᵧ],\r\n        [c0, c0, vₓₓ],\r\n        [d0, d0, vᵧᵧ],\r\n        [c0, vₓ],\r\n        [d0, vᵧ],\r\n        [v]\r\n    ]);\r\n    return [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0];\r\n}\r\nexports.getCoeffs3x3Exact = getCoeffs3x3Exact;\r\n//# sourceMappingURL=get-coefficients-3x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/exact/get-coefficients-3x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/inversion-old.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/inversion-old.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the t parameter value of the point closest to the given point of the\r\n * given bezier curve.\r\n * * **don't use**: This function has numeric stability issues when the cubic is very close to\r\n * a line, e.g. 0 0 1 1 2 2 3 3.00000000000001. The same problem would occur by\r\n * following the example by Tom Sederberg, to quote: \"If P1, P2, and P3 are\r\n * not collinear\", and it turns out sometimes they *are* collinear. Use closestPointOnBezierPrecise\r\n * or closestPointOnBezier instead\r\n * @param ps\r\n * @param p\r\n */\r\nfunction inversion(ps, p) {\r\n    if (ps.length === 4) {\r\n        return inversion3(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return inversion2(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return inversion1(ps, p);\r\n    }\r\n}\r\nexports.inversion = inversion;\r\n/**\r\n * Returns the t parameter value of the point closest to the given point of the\r\n * given cubic bezier curve.\r\n * * **don't use**: This function has numeric stability issues when the cubic is very close to\r\n * a line, e.g. 0 0 1 1 2 2 3 3.00000000000001. The same problem would occur by\r\n * following the example by Tom Sederberg, to quote: \"If P1, P2, and P3 are\r\n * not collinear\", and it turns out sometimes they *are* collinear.\r\n * * The bitlength of the control point coordinates of the bezier must <= 49\r\n * @param ps an order 3 bezier curve\r\n * @param p a point\r\n */\r\nfunction inversion3(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let [x, y] = p;\r\n    // The formulas below was generated by the Python Sympy script.\r\n    // Each matrix row below is an inversion formula, but only one of the roots\r\n    // of the polynomials in t is correct. Also, only 2 of the rows are linearly\r\n    // independent.\r\n    //---- Matrix top row\r\n    //let t12 = \r\n    // -x*y0 + 3*x*y1 - 3*x*y2 + x*y3 + x0*y - x0*y3 - 3*x1*y + 3*x1*y3 + \r\n    // 3*x2*y - 3*x2*y3 - x3*y + x3*y0 - 3*x3*y1 + 3*x3*y2;\r\n    let t12 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -y0),\r\n        flo_numerical_1.scaleExpansion(x, 3 * y1),\r\n        flo_numerical_1.scaleExpansion(x, -3 * y2),\r\n        flo_numerical_1.scaleExpansion(x, y3),\r\n        flo_numerical_1.scaleExpansion(y, x0),\r\n        flo_numerical_1.twoProduct(-x0, y3),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x1),\r\n        flo_numerical_1.twoProduct(3 * x1, y3),\r\n        flo_numerical_1.scaleExpansion(y, 3 * x2),\r\n        flo_numerical_1.twoProduct(-3 * x2, y3),\r\n        flo_numerical_1.scaleExpansion(y, -x3),\r\n        flo_numerical_1.twoProduct(x3, y0),\r\n        flo_numerical_1.twoProduct(-3 * x3, y1),\r\n        flo_numerical_1.twoProduct(3 * x3, y2)\r\n    ]);\r\n    //let t11 = \r\n    // 2*x*y0 - 3*x*y1 + x*y3 - 2*x0*y + 2*x0*y3 + 3*x1*y - \r\n    // 3*x1*y3 - x3*y - 2*x3*y0 + 3*x3*y1;\r\n    let t11 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, 2 * y0),\r\n        flo_numerical_1.scaleExpansion(x, -3 * y1),\r\n        flo_numerical_1.scaleExpansion(x, y3),\r\n        flo_numerical_1.scaleExpansion(y, -2 * x0),\r\n        flo_numerical_1.twoProduct(2 * x0, y3),\r\n        flo_numerical_1.scaleExpansion(y, 3 * x1),\r\n        flo_numerical_1.twoProduct(-3 * x1, y3),\r\n        flo_numerical_1.scaleExpansion(y, -x3),\r\n        flo_numerical_1.twoProduct(-2 * x3, y0),\r\n        flo_numerical_1.twoProduct(+3 * x3, y1)\r\n    ]);\r\n    //let t10 = -x*y0 + x*y3 + x0*y - x0*y3 - x3*y + x3*y0;\r\n    let t10 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -y0),\r\n        flo_numerical_1.scaleExpansion(x, y3),\r\n        flo_numerical_1.scaleExpansion(y, x0),\r\n        flo_numerical_1.twoProduct(-x0, y3),\r\n        flo_numerical_1.scaleExpansion(y, -x3),\r\n        flo_numerical_1.twoProduct(x3, y0)\r\n    ]);\r\n    //---- Matrix middle row\r\n    //let t22 = \r\n    // -2*x*y0 + 6*x*y1 - 6*x*y2 + 2*x*y3 + 2*x0*y - 3*x0*y2 + \r\n    // x0*y3 - 6*x1*y + 9*x1*y2 - 3*x1*y3 + 6*x2*y + 3*x2*y0 - 9*x2*y1\r\n    // -2*x3*y - x3*y0 + 3*x3*y1;\r\n    let t22 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -2 * y0),\r\n        flo_numerical_1.scaleExpansion(x, 6 * y1),\r\n        flo_numerical_1.scaleExpansion(x, -6 * y2),\r\n        flo_numerical_1.scaleExpansion(x, 2 * y3),\r\n        flo_numerical_1.scaleExpansion(y, 2 * x0),\r\n        flo_numerical_1.twoProduct(-3 * x0, y2),\r\n        flo_numerical_1.twoProduct(x0, y3),\r\n        flo_numerical_1.scaleExpansion(y, -6 * x1),\r\n        flo_numerical_1.twoProduct(9 * x1, y2),\r\n        flo_numerical_1.twoProduct(-3 * x1, y3),\r\n        flo_numerical_1.scaleExpansion(y, 6 * x2),\r\n        flo_numerical_1.twoProduct(3 * x2, y0),\r\n        flo_numerical_1.twoProduct(-9 * x2, y1),\r\n        flo_numerical_1.scaleExpansion(y, -2 * x3),\r\n        flo_numerical_1.twoProduct(-x3, y0),\r\n        flo_numerical_1.twoProduct(3 * x3, y1)\r\n    ]);\r\n    //let t21 = \r\n    // 5*x*y0 - 9*x*y1 + 3*x*y2 + x*y3 - 5*x0*y + 6*x0*y2 - x0*y3 + \r\n    // 9*x1*y - 9*x1*y2 - 3*x2*y - 6*x2*y0 + 9*x2*y1 - x3*y + x3*y0;\r\n    let t21 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, 5 * y0),\r\n        flo_numerical_1.scaleExpansion(x, -9 * y1),\r\n        flo_numerical_1.scaleExpansion(x, 3 * y2),\r\n        flo_numerical_1.scaleExpansion(x, y3),\r\n        flo_numerical_1.scaleExpansion(y, -5 * x0),\r\n        flo_numerical_1.twoProduct(6 * x0, y2),\r\n        flo_numerical_1.twoProduct(-x0, y3),\r\n        flo_numerical_1.scaleExpansion(y, 9 * x1),\r\n        flo_numerical_1.twoProduct(-9 * x1, y2),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x2),\r\n        flo_numerical_1.twoProduct(-6 * x2, y0),\r\n        flo_numerical_1.twoProduct(9 * x2, y1),\r\n        flo_numerical_1.scaleExpansion(y, -x3),\r\n        flo_numerical_1.twoProduct(x3, y0)\r\n    ]);\r\n    //let t20 = -3*x*y0 + 3*x*y2 + 3*x0*y - 3*x0*y2 - 3*x2*y + 3*x2*y0;\r\n    let t20 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -3 * y0),\r\n        flo_numerical_1.scaleExpansion(x, 3 * y2),\r\n        flo_numerical_1.scaleExpansion(y, 3 * x0),\r\n        flo_numerical_1.twoProduct(-3 * x0, y2),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x2),\r\n        flo_numerical_1.twoProduct(3 * x2, y0)\r\n    ]);\r\n    //---- Matrix bottom row\r\n    //let t32 = \r\n    // -x*y0 + 3*x*y1 - 3*x*y2 + x*y3 + x0*y - 3*x0*y1 + 3*x0*y2 - \r\n    // x0*y3 - 3*x1*y + 3*x1*y0 + 3*x2*y - 3*x2*y0 - x3*y + x3*y0;\r\n    let t32 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -y0),\r\n        flo_numerical_1.scaleExpansion(x, 3 * y1),\r\n        flo_numerical_1.scaleExpansion(x, -3 * y2),\r\n        flo_numerical_1.scaleExpansion(x, y3),\r\n        flo_numerical_1.scaleExpansion(y, x0),\r\n        flo_numerical_1.twoProduct(-3 * x0, y1),\r\n        flo_numerical_1.twoProduct(3 * x0, y2),\r\n        flo_numerical_1.twoProduct(-x0, y3),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x1),\r\n        flo_numerical_1.twoProduct(3 * x1, y0),\r\n        flo_numerical_1.scaleExpansion(y, 3 * x2),\r\n        flo_numerical_1.twoProduct(-3 * x2, y0),\r\n        flo_numerical_1.scaleExpansion(y, -x3),\r\n        flo_numerical_1.twoProduct(x3, y0)\r\n    ]);\r\n    //let t31 = \r\n    // 3*x*y0 - 6*x*y1 + 3*x*y2 - 3*x0*y + 6*x0*y1 - 3*x0*y2 + \r\n    // 6*x1*y - 6*x1*y0 - 3*x2*y + 3*x2*y0;\r\n    let t31 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, 3 * y0),\r\n        flo_numerical_1.scaleExpansion(x, -6 * y1),\r\n        flo_numerical_1.scaleExpansion(x, 3 * y2),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x0),\r\n        flo_numerical_1.twoProduct(6 * x0, y1),\r\n        flo_numerical_1.twoProduct(-3 * x0, y2),\r\n        flo_numerical_1.scaleExpansion(y, 6 * x1),\r\n        flo_numerical_1.twoProduct(-6 * x1, y0),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x2),\r\n        flo_numerical_1.twoProduct(3 * x2, y0)\r\n    ]);\r\n    //let t30 = \r\n    // -3*x*y0 + 3*x*y1 + 3*x0*y - 3*x0*y1 - 3*x1*y + 3*x1*y0;\r\n    let t30 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -3 * y0),\r\n        flo_numerical_1.scaleExpansion(x, 3 * y1),\r\n        flo_numerical_1.scaleExpansion(y, 3 * x0),\r\n        flo_numerical_1.twoProduct(-3 * x0, y1),\r\n        flo_numerical_1.scaleExpansion(y, -3 * x1),\r\n        flo_numerical_1.twoProduct(3 * x1, y0)\r\n    ]);\r\n    // Inversion formulae are in the form f(x,y) / g(x,y).\r\n    // These formulae come from the rows of a 3x3 matrix with each row an\r\n    // equation of the form at^2 + bt + c and where at least one row is\r\n    // linearly dependent on the other two.\r\n    // Here we have f(x,y) === t0 and g(x,y) === t1\r\n    // So a solution is -t0/t1.\r\n    // But, we should strive for the biggest t1 as this will increase numerical\r\n    // stability and/or decrease the 'difficulty' of the problem.\r\n    // We may end up in each case with 0/0 in which case the t value is at the\r\n    // double point of the cubic bezier - we should then proceed to find this\r\n    // double point and return both relevant t values.\r\n    // subtract t12/t22 times the second row from first\r\n    let a1;\r\n    let b1;\r\n    let a2;\r\n    let b2;\r\n    let a3;\r\n    let b3;\r\n    if (flo_numerical_1.sign(t12) === 0) {\r\n        // the top row equation is already linear\r\n        if (flo_numerical_1.sign(t11) !== 0) {\r\n            a1 = t11;\r\n            b1 = t10;\r\n        } // else the top row reads 0t^2 + 0t + 0 = 0, i.e. the row is already\r\n        // eliminated\r\n    }\r\n    if (flo_numerical_1.sign(t22) === 0) {\r\n        // the middle row equation is already linear\r\n        if (flo_numerical_1.sign(t21) !== 0) {\r\n            a2 = t21;\r\n            b2 = t20;\r\n        } // else the middle row reads 0t^2 + 0t + 0 = 0, i.e. the row is already\r\n        // eliminated\r\n    }\r\n    if (flo_numerical_1.sign(t32) === 0) {\r\n        // the bottom row equation is already linear\r\n        if (flo_numerical_1.sign(t31) !== 0) {\r\n            a3 = t31;\r\n            b3 = t30;\r\n        } // else the bottom row reads 0t^2 + 0t + 0 = 0, i.e. the row is already\r\n        // eliminated\r\n    }\r\n    // eliminate the coefficient of t^2 from the first row (using the second)\r\n    if (flo_numerical_1.sign(t22) !== 0 && flo_numerical_1.sign(t12) !== 0) {\r\n        let d = flo_numerical_1.expansionDiv(t12, t22, 4);\r\n        a1 = flo_numerical_1.expansionDiff(t11, flo_numerical_1.expansionProduct(d, t21));\r\n        b1 = flo_numerical_1.expansionDiff(t10, flo_numerical_1.expansionProduct(d, t20));\r\n    }\r\n    // eliminate the coefficient of t^2 from the second row (using the 3rd)\r\n    if (flo_numerical_1.sign(t32) !== 0 && flo_numerical_1.sign(t22) !== 0) {\r\n        let d = flo_numerical_1.expansionDiv(t22, t32, 4);\r\n        a2 = flo_numerical_1.expansionDiff(t21, flo_numerical_1.expansionProduct(d, t31));\r\n        b2 = flo_numerical_1.expansionDiff(t20, flo_numerical_1.expansionProduct(d, t30));\r\n    }\r\n    // eliminate the coefficient of t^2 from the third row (using the 1st)\r\n    if (flo_numerical_1.sign(t12) !== 0 && flo_numerical_1.sign(t32) !== 0) {\r\n        let d = flo_numerical_1.expansionDiv(t32, t12, 4);\r\n        a3 = flo_numerical_1.expansionDiff(t31, flo_numerical_1.expansionProduct(d, t11));\r\n        b3 = flo_numerical_1.expansionDiff(t30, flo_numerical_1.expansionProduct(d, t10));\r\n    }\r\n    let useRow;\r\n    a1 = a1 || [0];\r\n    a2 = a2 || [0];\r\n    a3 = a3 || [0];\r\n    if (flo_numerical_1.compare(flo_numerical_1.abs(a1), flo_numerical_1.abs(a2)) > 0) {\r\n        if (flo_numerical_1.compare(flo_numerical_1.abs(a1), flo_numerical_1.abs(a3)) > 0) {\r\n            useRow = 1;\r\n        }\r\n        else {\r\n            useRow = 3;\r\n        }\r\n    }\r\n    else {\r\n        if (flo_numerical_1.compare(flo_numerical_1.abs(a2), flo_numerical_1.abs(a3)) > 0) {\r\n            useRow = 2;\r\n        }\r\n        else {\r\n            useRow = 3;\r\n        }\r\n    }\r\n    let a = useRow === 1 ? a1 : useRow === 2 ? a2 : a3;\r\n    let b = useRow === 1 ? b1 : useRow === 2 ? b2 : b3;\r\n    let t = flo_numerical_1.expansionDiv(flo_numerical_1.negativeOf(b), a, 4);\r\n    return flo_numerical_1.estimate(t);\r\n}\r\n/**\r\n * Returns the t parameter value of the point closest to the given point of the\r\n * given quadratic bezier curve.\r\n * * The bitlength of the control point coordinates of the bezier must <= 49\r\n * @param ps an order 2 bezier curve\r\n * @param p a point\r\n */\r\nfunction inversion2(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let [x, y] = p;\r\n    // The formulas below was generated by the Python Sympy script.\r\n    // Each matrix row below is an inversion formula.\r\n    //---- Matrix top row\r\n    //let t11 = x*y0 - 2*x*y1 + x*y2 - x0*y + x0*y2 + 2*x1*y - 2*x1*y2 - x2*y - x2*y0 + 2*x2*y1\r\n    let t11 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, y0),\r\n        flo_numerical_1.scaleExpansion(x, -2 * y1),\r\n        flo_numerical_1.scaleExpansion(x, y2),\r\n        flo_numerical_1.scaleExpansion(y, -x0),\r\n        flo_numerical_1.twoProduct(x0, y2),\r\n        flo_numerical_1.scaleExpansion(y, 2 * x1),\r\n        flo_numerical_1.twoProduct(-2 * x1, y2),\r\n        flo_numerical_1.scaleExpansion(y, -x2),\r\n        flo_numerical_1.twoProduct(-x2, y0),\r\n        flo_numerical_1.twoProduct(2 * x2, y1)\r\n    ]);\r\n    //let t10 = - x*y0 + x*y2 + x0*y - x0*y2 - x2*y + x2*y0\r\n    let t10 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -y0),\r\n        flo_numerical_1.scaleExpansion(x, y2),\r\n        flo_numerical_1.scaleExpansion(y, x0),\r\n        flo_numerical_1.twoProduct(-x0, y2),\r\n        flo_numerical_1.scaleExpansion(y, -x2),\r\n        flo_numerical_1.twoProduct(x2, y0)\r\n    ]);\r\n    let t = flo_numerical_1.expansionDiv(flo_numerical_1.negativeOf(t10), t11, 4);\r\n    return flo_numerical_1.estimate(t);\r\n    //---- Matrix bottom row\r\n    //let t22 = \r\n    let t21 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, y0),\r\n        flo_numerical_1.scaleExpansion(x, -2 * y1),\r\n        flo_numerical_1.scaleExpansion(x, y2),\r\n        flo_numerical_1.scaleExpansion(y, -x0),\r\n        flo_numerical_1.twoProduct(2 * x0, y1),\r\n        flo_numerical_1.twoProduct(-x0, y2),\r\n        flo_numerical_1.scaleExpansion(y, 2 * x1),\r\n        flo_numerical_1.twoProduct(-2 * x1, y0),\r\n        flo_numerical_1.scaleExpansion(y, -x2),\r\n        flo_numerical_1.twoProduct(x2, y0)\r\n    ]);\r\n    //let t21 = \r\n    let t20 = flo_numerical_1.calculateSum([\r\n        flo_numerical_1.scaleExpansion(x, -2 * y0),\r\n        flo_numerical_1.scaleExpansion(x, 2 * y1),\r\n        flo_numerical_1.scaleExpansion(y, 2 * x0),\r\n        flo_numerical_1.twoProduct(-2 * x0, y1),\r\n        flo_numerical_1.scaleExpansion(y, -2 * x1),\r\n        flo_numerical_1.twoProduct(2 * x1, y0)\r\n    ]);\r\n}\r\n/**\r\n * Returns the t parameter value of the point closest to the given point of the\r\n * given line.\r\n * * The bitlength of the control point coordinates of the bezier must <= 49\r\n * @param ps an order 1 bezier curve\r\n * @param p a point\r\n */\r\nfunction inversion1(ps, p) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let [x, y] = p;\r\n    let x1_x0 = flo_numerical_1.twoDiff(x1, x0);\r\n    let y1_y0 = flo_numerical_1.twoDiff(y1, y0);\r\n    // the compare below ensures numerical stability\r\n    if (flo_numerical_1.compare(x1_x0, y1_y0) > 0) {\r\n        let t = flo_numerical_1.expansionDiv(flo_numerical_1.fastExpansionSum(x, [-x0]), x1_x0, 4);\r\n        return flo_numerical_1.estimate(t);\r\n    }\r\n    let t = flo_numerical_1.expansionDiv(flo_numerical_1.fastExpansionSum(y, [-y0]), flo_numerical_1.twoDiff(y1, y0), 4);\r\n    return flo_numerical_1.estimate(t);\r\n}\r\n/**\r\n * Returns the t parameter value of the point closest to the given point of the\r\n * given line.\r\n * * The bit-aligned bitlength of the control point coordinates of the line and\r\n * the given point must <= 52\r\n * * the result is accurate to within 1 ULP\r\n * @param ps an order 1 bezier curve\r\n * @param p a point\r\n */\r\nfunction inversion1_BL52_1ULP(ps, p) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let [x, y] = p;\r\n    let x1_x0 = x1 - x0;\r\n    let y1_y0 = y1 - y0;\r\n    // the compare below ensures numerical stability\r\n    return Math.abs(x1_x0) > Math.abs(y1_y0)\r\n        ? (x - x0) / x1_x0\r\n        : (y - y0) / y1_y0;\r\n}\r\nexports.inversion1_BL52_1ULP = inversion1_BL52_1ULP;\r\n//# sourceMappingURL=inversion-old.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/inversion-old.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x1.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x1.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nfunction getCoeffs1x1(ps1, ps2) {\r\n    let { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } // vₓ_, vᵧ_ === 0\r\n     } = get_implicit_form1_1.getImplicitForm1(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p1 = c1 * vₓ;\r\n    let p1_ = abs(p1); // vₓ_ === 0\r\n    let p2 = d1 * vᵧ;\r\n    let p2_ = abs(p2); // vᵧ_ === 0\r\n    let v1 = p1 + p2;\r\n    let v1_ = p1_ + p2_ + abs(v1);\r\n    // v0 = a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p3 = c0 * vₓ;\r\n    let p3_ = abs(p3); // vₓ_ === 0\r\n    let p4 = d0 * vᵧ;\r\n    let p4_ = abs(p4); // vᵧ_ === 0\r\n    let p5 = p3 + p4;\r\n    let p5_ = p3_ + p4_ + abs(p5);\r\n    let v0 = p5 + v;\r\n    let v0_ = p5_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v1, v0],\r\n        errBound: [v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs1x1 = getCoeffs1x1;\r\n//# sourceMappingURL=get-coefficients-1x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x2.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x2.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nfunction getCoeffs1x2(ps1, ps2) {\r\n    let { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } // vₓ_, vᵧ_ === 0\r\n     } = get_implicit_form1_1.getImplicitForm1(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a2*v_x + b2*v_y\r\n    //let v2 = c2*vₓ + d2*vᵧ;\r\n    let p1 = c2 * vₓ;\r\n    let p1_ = abs(p1); // vₓ_ === 0\r\n    let p2 = d2 * vᵧ;\r\n    let p2_ = abs(p2); // vᵧ_ === 0\r\n    let v2 = p1 + p2;\r\n    let v2_ = p1_ + p2_ + abs(v2);\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p3 = c1 * vₓ;\r\n    let p3_ = abs(p3); // vₓ_ === 0\r\n    let p4 = d1 * vᵧ;\r\n    let p4_ = abs(p4); // vᵧ_ === 0\r\n    let v1 = p3 + p4;\r\n    let v1_ = p3_ + p4_ + abs(v1);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p5 = c0 * vₓ;\r\n    let p5_ = abs(p5); // vₓ_ === 0\r\n    let p6 = d0 * vᵧ;\r\n    let p6_ = abs(p6); // vᵧ_ === 0\r\n    let p7 = p5 + p6;\r\n    let p7_ = p5_ + p6_ + abs(p7);\r\n    let v0 = p7 + v;\r\n    let v0_ = p7_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs1x2 = getCoeffs1x2;\r\n//# sourceMappingURL=get-coefficients-1x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x3.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x3.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form1.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nfunction getCoeffs1x3(ps1, ps2) {\r\n    let { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } // vₓ_, vᵧ_ === 0\r\n     } = get_implicit_form1_1.getImplicitForm1(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a3*v_x + b3*v_y\r\n    //let v3 = c3*vₓ + d3*vᵧ;\r\n    let p1 = c3 * vₓ; // vₓ_ === 0\r\n    let p1_ = abs(p1);\r\n    let p2 = d3 * vᵧ; // vᵧ_ === 0\r\n    let p2_ = abs(p2);\r\n    let v3 = p1 + p2;\r\n    let v3_ = p1_ + p2_ + abs(v3);\r\n    // a2*v_x + b2*v_y\r\n    //let v2 = c2*vₓ + d2*vᵧ;\r\n    let p3 = c2 * vₓ;\r\n    let p3_ = abs(p3); // vₓ_ === 0\r\n    let p4 = d2 * vᵧ;\r\n    let p4_ = abs(p4); // vᵧ_ === 0\r\n    let v2 = p3 + p4;\r\n    let v2_ = p3_ + p4_ + abs(v2);\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p5 = c1 * vₓ;\r\n    let p5_ = abs(p5); // vₓ_ === 0\r\n    let p6 = d1 * vᵧ;\r\n    let p6_ = abs(p6); // vᵧ_ === 0\r\n    let v1 = p5 + p6;\r\n    let v1_ = p5_ + p6_ + abs(v1);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p7 = c0 * vₓ;\r\n    let p7_ = abs(p7); // vₓ_ === 0\r\n    let p8 = d0 * vᵧ;\r\n    let p8_ = abs(p8); // vᵧ_ === 0\r\n    let p9 = p7 + p8;\r\n    let p9_ = p7_ + p8_ + abs(p9);\r\n    let v0 = p9 + v;\r\n    let v0_ = p9_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [v3_, v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs1x3 = getCoeffs1x3;\r\n//# sourceMappingURL=get-coefficients-1x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-1x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x1.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x1.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nfunction getCoeffs2x1(ps1, ps2) {\r\n    let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form2_1.getImplicitForm2(ps1);\r\n    let _vₓₓ = abs(vₓₓ);\r\n    let _vₓᵧ = abs(vₓᵧ);\r\n    let _vᵧᵧ = abs(vᵧᵧ);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    let _c0 = abs(c0);\r\n    let _d0 = abs(d0);\r\n    let _c1 = abs(c1);\r\n    let _d1 = abs(d1);\r\n    let c0d1 = c0 * d1;\r\n    let c1c1 = c1 * c1;\r\n    let d1d1 = d1 * d1;\r\n    let c1d1 = c1 * d1;\r\n    let c0c1 = c0 * c1;\r\n    let d0d1 = d0 * d1;\r\n    let c1d0 = c1 * d0;\r\n    let c0c0 = c0 * c0;\r\n    let c0d0 = c0 * d0;\r\n    let d0d0 = d0 * d0;\r\n    let _c0d1 = abs(c0d1);\r\n    let _c1c1 = abs(c1c1);\r\n    let _d1d1 = abs(d1d1);\r\n    let _c1d1 = abs(c1d1);\r\n    let _c0c1 = abs(c0c1);\r\n    let _d0d1 = abs(d0d1);\r\n    let _c1d0 = abs(c1d0);\r\n    let _c0c0 = abs(c0c0);\r\n    let _c0d0 = abs(c0d0);\r\n    let _d0d0 = abs(d0d0);\r\n    // c1c1*vₓₓ + c1d1*vₓᵧ + d1d1*vᵧᵧ\r\n    let p1 = c1c1 * vₓₓ;\r\n    let p1_ = _c1c1 * (_vₓₓ + vₓₓ_) + abs(p1);\r\n    let p2 = d1d1 * vᵧᵧ;\r\n    let p2_ = _d1d1 * (_vᵧᵧ + vᵧᵧ_) + abs(p2);\r\n    let p3 = c1d1 * vₓᵧ;\r\n    let p3_ = _c1d1 * (_vₓᵧ + vₓᵧ_) + abs(p3);\r\n    let p4 = p1 + p2;\r\n    let p4_ = p1_ + p2_ + abs(p4);\r\n    let v2 = p4 + p3;\r\n    let v2_ = p4_ + p3_ + abs(v2);\r\n    // 2*c0c1*vₓₓ + c0d1*vₓᵧ + c1d0*vₓᵧ + c1*vₓ + 2*d0d1*vᵧᵧ + d1*vᵧ\r\n    //let v1 = \r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) + \r\n    //    (c0d1 + c1d0)*vₓᵧ + \r\n    //    c1*vₓ + \r\n    //    d1*vᵧ\r\n    let p5 = c0c1 * vₓₓ;\r\n    let p5_ = _c0c1 * (_vₓₓ + vₓₓ_) + abs(p5);\r\n    let p6 = d0d1 * vᵧᵧ;\r\n    let p6_ = _d0d1 * (_vᵧᵧ + vᵧᵧ_) + abs(p6);\r\n    let p7 = c0d1 + c1d0;\r\n    let _p7 = abs(p7);\r\n    let p7_ = _c0d1 + _c1d0 + _p7;\r\n    let pn = p7 * vₓᵧ;\r\n    let pn_ = p7_ * _vₓᵧ + _p7 * vₓᵧ_ + _p7;\r\n    let p8 = 2 * (p5 + p6);\r\n    let p8_ = 2 * (p5_ + p6_) + abs(p8);\r\n    let p9 = p8 + pn;\r\n    let p9_ = p8_ + pn_ + abs(p9);\r\n    let pa = c1 * vₓ;\r\n    let pa_ = _c1 * vₓ_ + abs(pa);\r\n    let pb = d1 * vᵧ;\r\n    let pb_ = _d1 * vᵧ_ + abs(pb);\r\n    let pc = pa + pb;\r\n    let pc_ = pa_ + pb_ + abs(pc);\r\n    let v1 = p9 + pc;\r\n    let v1_ = p9_ + pc_ + abs(v1);\r\n    // c0c0*vₓₓ + c0d0*vₓᵧ + c0*vₓ + d0d0*vᵧᵧ + d0*vᵧ + v_0\r\n    let pe = c0c0 * vₓₓ;\r\n    let pe_ = _c0c0 * (_vₓₓ + vₓₓ_) + abs(pe);\r\n    let pf = c0d0 * vₓᵧ;\r\n    let pf_ = _c0d0 * (_vₓᵧ + vₓᵧ_) + abs(pf);\r\n    let pg = d0d0 * vᵧᵧ;\r\n    let pg_ = _d0d0 * (_vᵧᵧ + vᵧᵧ_) + abs(pg);\r\n    let ph = pe + pf;\r\n    let ph_ = pe_ + pf_ + abs(ph);\r\n    let pi = ph + pg;\r\n    let pi_ = ph_ + pg_ + abs(pi);\r\n    let pj = c0 * vₓ;\r\n    let pj_ = _c0 * vₓ_ + abs(pj);\r\n    let pk = d0 * vᵧ;\r\n    let pk_ = _d0 * vᵧ_ + abs(pk);\r\n    let pl = pj + pk;\r\n    let pl_ = pj_ + pk_ + abs(pl);\r\n    let pm = pi + pl;\r\n    let pm_ = pi_ + pl_ + abs(pm);\r\n    let v0 = pm + v;\r\n    let v0_ = pm_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs2x1 = getCoeffs2x1;\r\n//# sourceMappingURL=get-coefficients-2x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x2.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x2.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nfunction getCoeffs2x2(ps1, ps2) {\r\n    let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form2_1.getImplicitForm2(ps1);\r\n    let _vₓₓ = abs(vₓₓ);\r\n    let _vₓᵧ = abs(vₓᵧ);\r\n    let _vᵧᵧ = abs(vᵧᵧ);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let _c0 = abs(c0);\r\n    let _d0 = abs(d0);\r\n    let _c1 = abs(c1);\r\n    let _d1 = abs(d1);\r\n    let _c2 = abs(c2);\r\n    let _d2 = abs(d2);\r\n    let c0c0 = c0 * c0;\r\n    let c0d0 = c0 * d0;\r\n    let d0d0 = d0 * d0;\r\n    let c0c1 = c0 * c1;\r\n    let c0d1 = c0 * d1;\r\n    let c1c2 = c1 * c2;\r\n    let c1d2 = c1 * d2;\r\n    let c1d0 = c1 * d0;\r\n    let c2c2 = c2 * c2;\r\n    let c2d1 = c2 * d1;\r\n    let c2d2 = c2 * d2;\r\n    let d0d1 = d0 * d1;\r\n    let d1d2 = d1 * d2;\r\n    let d2d2 = d2 * d2;\r\n    let c0c2 = c0 * c2;\r\n    let c1c1 = c1 * c1;\r\n    let d0d2 = d0 * d2;\r\n    let d1d1 = d1 * d1;\r\n    let c0d2 = c0 * d2;\r\n    let c1d1 = c1 * d1;\r\n    let c2d0 = c2 * d0;\r\n    let _c2c2 = abs(c2c2);\r\n    let _c2d2 = abs(c2d2);\r\n    let _d2d2 = abs(d2d2);\r\n    let _c1c2 = abs(c1c2);\r\n    let _d1d2 = abs(d1d2);\r\n    let _c1d2 = abs(c1d2);\r\n    let _c2d1 = abs(c2d1);\r\n    let _c0c2 = abs(c0c2);\r\n    let _c1c1 = abs(c1c1);\r\n    let _d0d2 = abs(d0d2);\r\n    let _d1d1 = abs(d1d1);\r\n    let _c0d2 = abs(c0d2);\r\n    let _c1d1 = abs(c1d1);\r\n    let _c2d0 = abs(c2d0);\r\n    let _c0c1 = abs(c0c1);\r\n    let _d0d1 = abs(d0d1);\r\n    let _c0d1 = abs(c0d1);\r\n    let _c1d0 = abs(c1d0);\r\n    let _c0c0 = abs(c0c0);\r\n    let _c0d0 = abs(c0d0);\r\n    let _d0d0 = abs(d0d0);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //let v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    let p1 = c2c2 * vₓₓ;\r\n    let p1_ = _c2c2 * (_vₓₓ + vₓₓ_) + abs(p1);\r\n    let p2 = c2d2 * vₓᵧ;\r\n    let p2_ = _c2d2 * (_vₓᵧ + vₓᵧ_) + abs(p2);\r\n    let p3 = d2d2 * vᵧᵧ;\r\n    let p3_ = _d2d2 * (_vᵧᵧ + vᵧᵧ_) + abs(p3);\r\n    let p4 = p1 + p2;\r\n    let p4_ = p1_ + p2_ + abs(p4);\r\n    let v4 = p4 + p3;\r\n    let v4_ = p4_ + p3_ + abs(v4);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //let v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    let p5 = c1c2 * vₓₓ;\r\n    let p5_ = _c1c2 * (_vₓₓ + vₓₓ_) + abs(p5);\r\n    let p6 = d1d2 * vᵧᵧ;\r\n    let p6_ = _d1d2 * (_vᵧᵧ + vᵧᵧ_) + abs(p6);\r\n    let p7 = c1d2 + c2d1;\r\n    let _p7 = abs(p7);\r\n    let p7_ = _c1d2 + _c2d1 + _p7;\r\n    let p8 = p7 * vₓᵧ;\r\n    let p8_ = p7_ * _vₓᵧ + _p7 * vₓᵧ_ + abs(p8);\r\n    let p9 = 2 * (p5 + p6);\r\n    let p9_ = 2 * (p5_ + p6_) + abs(p9);\r\n    let v3 = p9 + p8;\r\n    let v3_ = p9_ + p8_ + abs(v3);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //let v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    let pa = 2 * c0c2 + c1c1;\r\n    let _pa = abs(pa);\r\n    let pa_ = 2 * _c0c2 + _c1c1 + _pa;\r\n    let pb = 2 * d0d2 + d1d1;\r\n    let _pb = abs(pb);\r\n    let pb_ = 2 * _d0d2 + _d1d1 + _pb;\r\n    let pc = c0d2 + c1d1;\r\n    let _pc = abs(pc);\r\n    let pc_ = _c0d2 + _c1d1 + _pc;\r\n    let pd = pc + c2d0;\r\n    let _pd = abs(pd);\r\n    let pd_ = pc_ + _c2d0 + _pd;\r\n    let pe = pa * vₓₓ;\r\n    let pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + abs(pe);\r\n    let pf = pb * vᵧᵧ;\r\n    let pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + abs(pf);\r\n    let pg = pd * vₓᵧ;\r\n    let pg_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + abs(pg);\r\n    let ph = c2 * vₓ;\r\n    let ph_ = _c2 * vₓ_ + abs(ph);\r\n    let pi = d2 * vᵧ;\r\n    let pi_ = _d2 * vᵧ_ + abs(pi);\r\n    let pj = pe + pf;\r\n    let pj_ = pe_ + pf_ + abs(pj);\r\n    let pk = pj + pg;\r\n    let pk_ = pj_ + pg_ + abs(pk);\r\n    let pl = ph + pi;\r\n    let pl_ = ph_ + pi_ + abs(pl);\r\n    let v2 = pk + pl;\r\n    let v2_ = pk_ + pl_ + abs(v2);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    let pm = c0c1 * vₓₓ;\r\n    let pm_ = _c0c1 * (_vₓₓ + vₓₓ_) + abs(pm);\r\n    let pn = d0d1 * vᵧᵧ;\r\n    let pn_ = _d0d1 * (_vᵧᵧ + vᵧᵧ_) + abs(pn);\r\n    let po = c0d1 + c1d0;\r\n    let _po = abs(po);\r\n    let po_ = _c0d1 + _c1d0 + _po;\r\n    let pp = po * vₓᵧ;\r\n    let pp_ = po_ * _vₓᵧ + _po * vₓᵧ_ + abs(pp);\r\n    let pq = 2 * (pm + pn);\r\n    let pq_ = 2 * (pm_ + pn_) + abs(pq);\r\n    let pr = c1 * vₓ;\r\n    let pr_ = _c1 * vₓ_ + abs(pr);\r\n    let ps = d1 * vᵧ;\r\n    let ps_ = _d1 * vᵧ_ + abs(ps);\r\n    let pt = pq + pp;\r\n    let pt_ = pq_ + pp_ + abs(pt);\r\n    let pu = pr + ps;\r\n    let pu_ = pr_ + ps_ + abs(pu);\r\n    let v1 = pt + pu;\r\n    let v1_ = pt_ + pu_ + abs(v1);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    let pv = c0c0 * vₓₓ;\r\n    let pv_ = _c0c0 * (_vₓₓ + vₓₓ_) + abs(pv);\r\n    let pw = c0d0 * vₓᵧ;\r\n    let pw_ = _c0d0 * (_vₓᵧ + vₓᵧ_) + abs(pw);\r\n    let px = d0d0 * vᵧᵧ;\r\n    let px_ = _d0d0 * (_vᵧᵧ + vᵧᵧ_) + abs(px);\r\n    let py = c0 * vₓ;\r\n    let py_ = _c0 * vₓ_ + abs(py);\r\n    let pz = d0 * vᵧ;\r\n    let pz_ = _d0 * vᵧ_ + abs(pz);\r\n    let q1 = pv + pw;\r\n    let q1_ = pv_ + pw_ + abs(q1);\r\n    let q2 = q1 + px;\r\n    let q2_ = q1_ + px_ + abs(q2);\r\n    let q3 = py + pz;\r\n    let q3_ = py_ + pz_ + abs(q3);\r\n    let q4 = q2 + q3;\r\n    let q4_ = q2_ + q3_ + abs(q4);\r\n    let v0 = q4 + v;\r\n    let v0_ = q4_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v4, v3, v2, v1, v0],\r\n        errBound: [v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs2x2 = getCoeffs2x2;\r\n//# sourceMappingURL=get-coefficients-2x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x3.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x3.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nfunction getCoeffs2x3(ps1, ps2) {\r\n    let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form2_1.getImplicitForm2(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let _c0 = abs(c0);\r\n    let _d0 = abs(d0);\r\n    let _c1 = abs(c1);\r\n    let _d1 = abs(d1);\r\n    let _c2 = abs(c2);\r\n    let _d2 = abs(d2);\r\n    let _c3 = abs(c3);\r\n    let _d3 = abs(d3);\r\n    let _vₓₓ = abs(vₓₓ);\r\n    let _vₓᵧ = abs(vₓᵧ);\r\n    let _vᵧᵧ = abs(vᵧᵧ);\r\n    let c0c0 = c0 * c0;\r\n    let c0c1 = c0 * c1;\r\n    let c0c2 = c0 * c2;\r\n    let c0c3 = c0 * c3;\r\n    let c0d0 = c0 * d0;\r\n    let c0d1 = c0 * d1;\r\n    let c0d2 = c0 * d2;\r\n    let c0d3 = c0 * d3;\r\n    let c1c1 = c1 * c1;\r\n    let c1c2 = c1 * c2;\r\n    let c1c3 = c1 * c3;\r\n    let c1d0 = c1 * d0;\r\n    let c1d1 = c1 * d1;\r\n    let c1d2 = c1 * d2;\r\n    let c1d3 = c1 * d3;\r\n    let c2c2 = c2 * c2;\r\n    let c2c3 = c2 * c3;\r\n    let c2d0 = c2 * d0;\r\n    let c2d1 = c2 * d1;\r\n    let c2d2 = c2 * d2;\r\n    let c2d3 = c2 * d3;\r\n    let c3c3 = c3 * c3;\r\n    let c3d0 = c3 * d0;\r\n    let c3d1 = c3 * d1;\r\n    let c3d2 = c3 * d2;\r\n    let c3d3 = c3 * d3;\r\n    let d0d0 = d0 * d0;\r\n    let d0d1 = d0 * d1;\r\n    let d0d2 = d0 * d2;\r\n    let d0d3 = d0 * d3;\r\n    let d1d1 = d1 * d1;\r\n    let d1d2 = d1 * d2;\r\n    let d1d3 = d1 * d3;\r\n    let d2d2 = d2 * d2;\r\n    let d2d3 = d2 * d3;\r\n    let d3d3 = d3 * d3;\r\n    let _c1c3 = abs(c1c3);\r\n    let _c1d3 = abs(c1d3);\r\n    let _c2c2 = abs(c2c2);\r\n    let _c2c3 = abs(c2c3);\r\n    let _c2d2 = abs(c2d2);\r\n    let _c2d3 = abs(c2d3);\r\n    let _c3c3 = abs(c3c3);\r\n    let _c3d1 = abs(c3d1);\r\n    let _c3d2 = abs(c3d2);\r\n    let _c3d3 = abs(c3d3);\r\n    let _d1d3 = abs(d1d3);\r\n    let _d2d2 = abs(d2d2);\r\n    let _d2d3 = abs(d2d3);\r\n    let _d3d3 = abs(d3d3);\r\n    let _c0c3 = abs(c0c3);\r\n    let _c1c2 = abs(c1c2);\r\n    let _d0d3 = abs(d0d3);\r\n    let _d1d2 = abs(d1d2);\r\n    let _c0d3 = abs(c0d3);\r\n    let _c1d2 = abs(c1d2);\r\n    let _c2d1 = abs(c2d1);\r\n    let _c3d0 = abs(c3d0);\r\n    let _c0c2 = abs(c0c2);\r\n    let _c1c1 = abs(c1c1);\r\n    let _d0d2 = abs(d0d2);\r\n    let _d1d1 = abs(d1d1);\r\n    let _c0d2 = abs(c0d2);\r\n    let _c1d1 = abs(c1d1);\r\n    let _c2d0 = abs(c2d0);\r\n    let _c0c1 = abs(c0c1);\r\n    let _d0d1 = abs(d0d1);\r\n    let _c0d1 = abs(c0d1);\r\n    let _c1d0 = abs(c1d0);\r\n    let _c0c0 = abs(c0c0);\r\n    let _c0d0 = abs(c0d0);\r\n    let _d0d0 = abs(d0d0);\r\n    // c3**2*vₓₓ + c3*d3*vₓᵧ + d3**2*vᵧᵧ\r\n    //let v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    let p1 = c3c3 * vₓₓ;\r\n    let p1_ = _c3c3 * (_vₓₓ + vₓₓ_) + abs(p1);\r\n    let p2 = c3d3 * vₓᵧ;\r\n    let p2_ = _c3d3 * (_vₓᵧ + vₓᵧ_) + abs(p2);\r\n    let p3 = d3d3 * vᵧᵧ;\r\n    let p3_ = _d3d3 * (_vᵧᵧ + vᵧᵧ_) + abs(p3);\r\n    let p4 = p1 + p2;\r\n    let p4_ = p1_ + p2_ + abs(p4);\r\n    let v6 = p4 + p3;\r\n    let v6_ = p4_ + p3_ + abs(v6);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //let v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    (c2d3 + c3d2)*vₓᵧ;\r\n    let p5 = c2c3 * vₓₓ;\r\n    let p5_ = _c2c3 * (_vₓₓ + vₓₓ_) + abs(p5);\r\n    let p6 = d2d3 * vᵧᵧ;\r\n    let p6_ = _d2d3 * (_vᵧᵧ + vᵧᵧ_) + abs(p6);\r\n    let p7 = p5 + p6;\r\n    let p7_ = p5_ + p6_ + abs(p7);\r\n    let p8 = c2d3 + c3d2;\r\n    let _p8 = abs(p8);\r\n    let p8_ = _c2d3 + _c3d2 + _p8;\r\n    let p9 = p8 * vₓᵧ;\r\n    let p9_ = p8_ * _vₓᵧ + _p8 * vₓᵧ_ + abs(p9);\r\n    let v5 = 2 * p7 + p9;\r\n    let v5_ = 2 * p7_ + p9_ + abs(v5);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //let v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    let pa = 2 * c1c3 + c2c2;\r\n    let _pa = abs(pa);\r\n    let pa_ = 2 * _c1c3 + _c2c2 + _pa;\r\n    let pb = 2 * d1d3 + d2d2;\r\n    let _pb = abs(pb);\r\n    let pb_ = 2 * _d1d3 + _d2d2 + _pb;\r\n    let pc = c1d3 + c2d2;\r\n    let pc_ = _c1d3 + _c2d2 + abs(pc);\r\n    let pd = pc + c3d1;\r\n    let _pd = abs(pd);\r\n    let pd_ = pc_ + _c3d1 + _pd;\r\n    let pe = pa * vₓₓ;\r\n    let pe_ = pa_ * vₓₓ_ + _pa * vₓₓ_ + abs(pe);\r\n    let pf = pb * vᵧᵧ;\r\n    let pf_ = pb_ * vᵧᵧ_ + _pb * vᵧᵧ_ + abs(pf);\r\n    let pg = pe + pf;\r\n    let pg_ = pe_ + pf_ + abs(pg);\r\n    let rp = pd * vₓᵧ;\r\n    let rp_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + abs(rp);\r\n    let v4 = pg + rp;\r\n    let v4_ = pg_ + rp_ + abs(v4);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //let v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    let ph = c0c3 + c1c2;\r\n    let _ph = abs(ph);\r\n    let ph_ = _c0c3 + _c1c2 + _ph;\r\n    let pi = d0d3 + d1d2;\r\n    let _pi = abs(pi);\r\n    let pi_ = _d0d3 + _d1d2 + _pi;\r\n    let pj = c0d3 + c1d2;\r\n    let pj_ = _c0d3 + _c1d2 + abs(pj);\r\n    let pk = c2d1 + c3d0;\r\n    let pk_ = _c2d1 + _c3d0 + abs(pk);\r\n    let pl = pj + pk;\r\n    let _pl = abs(pl);\r\n    let pl_ = pj_ + pk_ + _pl;\r\n    let pm = ph * vₓₓ;\r\n    let pm_ = ph_ * _vₓₓ + _ph * vₓₓ_ + abs(pm);\r\n    let pn = pi * vᵧᵧ;\r\n    let pn_ = pi_ * _vᵧᵧ + _pi * vᵧᵧ_ + abs(pn);\r\n    let po = 2 * (pm + pn);\r\n    let po_ = 2 * (pm_ + pn_) + abs(po);\r\n    let pp = pl * vₓᵧ;\r\n    let pp_ = pl_ * _vₓᵧ + _pl * vₓᵧ_ + abs(pp);\r\n    let rn = c3 * vₓ;\r\n    let rn_ = _c3 * vₓ_ + abs(rn);\r\n    let ro = d3 * vᵧ;\r\n    let ro_ = _d3 * vᵧ_ + abs(ro);\r\n    let pq = rn + ro;\r\n    let pq_ = rn_ + ro_ + abs(pq);\r\n    let pr = po + pp;\r\n    let pr_ = po_ + pp_ + abs(pr);\r\n    let v3 = pr + pq;\r\n    let v3_ = pr_ + pq_ + abs(v3);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //let v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    let ps = 2 * c0c2 + c1c1;\r\n    let _ps = abs(ps);\r\n    let ps_ = 2 * _c0c2 + _c1c1 + _ps;\r\n    let pt = 2 * d0d2 + d1d1;\r\n    let _pt = abs(pt);\r\n    let pt_ = 2 * _d0d2 + _d1d1 + _pt;\r\n    let pu = c0d2 + c1d1;\r\n    let pu_ = _c0d2 + _c1d1 + abs(pu);\r\n    let pv = pu + c2d0;\r\n    let _pv = abs(pv);\r\n    let pv_ = pu_ + _c2d0 + _pv;\r\n    let pw = ps * vₓₓ;\r\n    let pw_ = ps_ * _vₓₓ + _ps * vₓₓ_ + abs(pw);\r\n    let px = pt * vᵧᵧ;\r\n    let px_ = pt_ * _vᵧᵧ + _pt * vᵧᵧ_ + abs(px);\r\n    let py = pv * vₓᵧ;\r\n    let py_ = pv_ * _vₓᵧ + _pv * vₓᵧ_ + abs(py);\r\n    let pz = pw + px;\r\n    let pz_ = pw_ + px_ + abs(pz);\r\n    let r1 = pz + py;\r\n    let r1_ = pz_ + py_ + abs(r1);\r\n    let r2 = c2 * vₓ;\r\n    let r2_ = _c2 * vₓ_ + abs(r2);\r\n    let r3 = d2 * vᵧ;\r\n    let r3_ = _d2 * vᵧ_ + abs(r3);\r\n    let r4 = r2 + r3;\r\n    let r4_ = r2_ + r3_ + abs(r4);\r\n    let v2 = r1 + r4;\r\n    let v2_ = r1_ + r4_ + abs(v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //let v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    let r5 = c0c1 * vₓₓ;\r\n    let r5_ = _c0c1 * (_vₓₓ + vₓₓ_) + abs(r5);\r\n    let r6 = d0d1 * vᵧᵧ;\r\n    let r6_ = _d0d1 * (_vᵧᵧ + vᵧᵧ_) + abs(r6);\r\n    let r7 = c0d1 + c1d0;\r\n    let _r7 = abs(r7);\r\n    let r7_ = _c0d1 + _c1d0 + _r7;\r\n    let r8 = r7 * vₓᵧ;\r\n    let r8_ = r7_ * _vₓᵧ + _r7 * vₓᵧ_ + abs(r8);\r\n    let r9 = 2 * (r5 + r6);\r\n    let r9_ = 2 * (r5_ + r6_) + abs(r9);\r\n    let ra = r9 + r8;\r\n    let ra_ = r9_ + r8_ + abs(ra);\r\n    let rb = c1 * vₓ;\r\n    let rb_ = _c1 * vₓ_ + abs(rb);\r\n    let rc = d1 * vᵧ;\r\n    let rc_ = _d1 * vᵧ_ + abs(rc);\r\n    let rd = rb + rc;\r\n    let rd_ = rb_ + rc_ + abs(rd);\r\n    let v1 = ra + rd;\r\n    let v1_ = ra_ + rd_ + abs(v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    let re = c0c0 * vₓₓ;\r\n    let re_ = _c0c0 * (_vₓₓ + vₓₓ_) + abs(re);\r\n    let rf = c0d0 * vₓᵧ;\r\n    let rf_ = _c0d0 * (_vₓᵧ + vₓᵧ_) + abs(rf);\r\n    let rg = d0d0 * vᵧᵧ;\r\n    let rg_ = _d0d0 * (_vᵧᵧ + vᵧᵧ_) + abs(rg);\r\n    let rh = c0 * vₓ;\r\n    let rh_ = _c0 * vₓ_ + abs(rh);\r\n    let ri = d0 * vᵧ;\r\n    let ri_ = _d0 * vᵧ_ + abs(ri);\r\n    let rj = re + rf;\r\n    let rj_ = re_ + rf_ + abs(rj);\r\n    let rk = rj + rg;\r\n    let rk_ = rj_ + rg_ + abs(rk);\r\n    let rl = rh + ri;\r\n    let rl_ = rh_ + ri_ + abs(rl);\r\n    let rm = rk + rl;\r\n    let rm_ = rk_ + rl_ + abs(rm);\r\n    let v0 = rm + v;\r\n    let v0_ = rm_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [v6_, v5_, v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs2x3 = getCoeffs2x3;\r\n//# sourceMappingURL=get-coefficients-2x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-2x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x1.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x1.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nfunction getCoeffs3x1(ps1, ps2) {\r\n    let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_: vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    let _vₓᵧ = abs(vₓᵧ);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let c0c0 = c0 * c0;\r\n    let c0c1 = c0 * c1;\r\n    let c0d0 = c0 * d0;\r\n    let c0d1 = c0 * d1;\r\n    let c1c1 = c1 * c1;\r\n    let c1d0 = c1 * d0;\r\n    let c1d1 = c1 * d1;\r\n    let d0d0 = d0 * d0;\r\n    let d0d1 = d0 * d1;\r\n    let d1d1 = d1 * d1;\r\n    let _c0c0 = abs(c0c0);\r\n    let _c0c1 = abs(c0c1);\r\n    let _c0d0 = abs(c0d0);\r\n    let _d0d0 = abs(d0d0);\r\n    let _d0d1 = abs(d0d1);\r\n    let _c0d1 = abs(c0d1);\r\n    let _c1d0 = abs(c1d0);\r\n    let _c1c1 = abs(c1c1);\r\n    let _c1d1 = abs(c1d1);\r\n    let _d1d1 = abs(d1d1);\r\n    let z1 = c0 * vₓₓₓ;\r\n    let z1_ = _c0 * vₓₓₓ_ + abs(z1);\r\n    let z7 = (3 * c0) * vₓₓₓ;\r\n    let z7_ = 3 * _c0 * vₓₓₓ_ + abs(z7);\r\n    let z2 = c0 * vₓₓᵧ;\r\n    let z2_ = _c0 * vₓₓᵧ_ + abs(z2);\r\n    let z3 = d0 * vₓₓᵧ;\r\n    let z3_ = _d0 * vₓₓᵧ_ + abs(z3);\r\n    let z4 = c0 * vₓᵧᵧ;\r\n    let z4_ = _c0 * vₓᵧᵧ_ + abs(z4);\r\n    let z5 = d0 * vₓᵧᵧ;\r\n    let z5_ = _d0 * vₓᵧᵧ_ + abs(z5);\r\n    let z6 = d0 * vᵧᵧᵧ;\r\n    let z6_ = _d0 * vᵧᵧᵧ_ + abs(z6);\r\n    let z8 = (3 * d0) * vᵧᵧᵧ;\r\n    let z8_ = 3 * _d0 * vᵧᵧᵧ_ + abs(z8);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //let v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    let u1 = c1 * vₓₓₓ;\r\n    let u1_ = _c1 * vₓₓₓ_ + abs(u1);\r\n    let u2 = c1 * vₓᵧᵧ;\r\n    let u2_ = _c1 * vₓᵧᵧ_ + abs(u2);\r\n    let u3 = d1 * vₓₓᵧ;\r\n    let u3_ = _d1 * vₓₓᵧ_ + abs(u3);\r\n    let u4 = d1 * vᵧᵧᵧ;\r\n    let u4_ = _d1 * vᵧᵧᵧ_ + abs(u4);\r\n    let u5 = u1 + u3;\r\n    let _u5 = abs(u5);\r\n    let u5_ = u1_ + u3_ + _u5;\r\n    let u6 = u2 + u4;\r\n    let _u6 = abs(u6);\r\n    let u6_ = u2_ + u4_ + _u6;\r\n    let u7 = c1c1 * u5;\r\n    let u7_ = _c1c1 * (_u5 + u5_) + abs(u7);\r\n    let u8 = d1d1 * u6;\r\n    let u8_ = _d1d1 * (_u6 + u6_) + abs(u8);\r\n    let v3 = u7 + u8;\r\n    let v3_ = u7_ + u8_ + abs(v3);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //let v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //let v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    let u9 = z7 + z3;\r\n    let u9_ = z7_ + z3_ + abs(u9);\r\n    let ua = 2 * (z2 + z5);\r\n    let ua_ = 2 * (z2_ + z5_) + abs(ua);\r\n    let ub = z4 + z8;\r\n    let ub_ = z4_ + z8_ + abs(ub);\r\n    let uc = u9 + vₓₓ;\r\n    let _uc = abs(uc);\r\n    let uc_ = u9_ + vₓₓ_ + _uc;\r\n    let ud = ua + vₓᵧ;\r\n    let _ud = abs(ud);\r\n    let ud_ = ua_ + vₓᵧ_ + _ud;\r\n    let ue = ub + vᵧᵧ;\r\n    let _ue = abs(ue);\r\n    let ue_ = ub_ + vᵧᵧ_ + _ue;\r\n    let uf = c1c1 * uc;\r\n    let uf_ = _c1c1 * (_uc + uc_) + abs(uf);\r\n    let ug = c1d1 * ud;\r\n    let ug_ = _c1d1 * (_ud + ud_) + abs(ug);\r\n    let uh = d1d1 * ue;\r\n    let uh_ = _d1d1 * (_ue + ue_) + abs(uh);\r\n    let ui = uf + ug;\r\n    let ui_ = uf_ + ug_ + abs(ui);\r\n    let v2 = ui + uh;\r\n    let v2_ = ui_ + uh_ + abs(v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    let uj = 2 * (z3 + vₓₓ);\r\n    let uj_ = 2 * (z3_ + vₓₓ_) + abs(uj);\r\n    let uk = 2 * (z4 + vᵧᵧ);\r\n    let uk_ = 2 * (z4_ + vᵧᵧ_) + abs(uk);\r\n    let un = z7 + uj;\r\n    let _un = abs(un);\r\n    let un_ = z7_ + uj_ + _un;\r\n    let uo = z8 + uk;\r\n    let _uo = abs(uo);\r\n    let uo_ = z8_ + uk_ + _uo;\r\n    let up = z2 + vₓᵧ;\r\n    let _up = abs(up);\r\n    let up_ = z2_ + vₓᵧ_ + _up;\r\n    let uq = z5 + vₓᵧ;\r\n    let _uq = abs(uq);\r\n    let uq_ = z5_ + vₓᵧ_ + _uq;\r\n    let ur = c0c1 * un;\r\n    let ur_ = _c0c1 * (_un + un_) + abs(ur);\r\n    let us = d0d1 * uo;\r\n    let us_ = _d0d1 * (_uo + uo_) + abs(us);\r\n    let ut = c0d1 * up;\r\n    let ut_ = _c0d1 * (_up + up_) + abs(ut);\r\n    let uu = c1d0 * uq;\r\n    let uu_ = _c1d0 * (_uq + uq_) + abs(uu);\r\n    let uv = c1 * vₓ;\r\n    let uv_ = _c1 * vₓ_ + abs(uv);\r\n    let uw = d1 * vᵧ;\r\n    let uw_ = _d1 * vᵧ_ + abs(uw);\r\n    let ux = ur + us;\r\n    let ux_ = ur_ + us_ + abs(ux);\r\n    let uy = ut + uu;\r\n    let uy_ = ut_ + uu_ + abs(uy);\r\n    let uz = ux + uy;\r\n    let uz_ = ux_ + uy_ + abs(uz);\r\n    let u0 = uv + uw;\r\n    let u0_ = uv_ + uw_ + abs(u0);\r\n    let v1 = uz + u0;\r\n    let v1_ = uz_ + u0_ + abs(v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //let v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    let f1 = z1 + z3;\r\n    let f1_ = z1_ + z3_ + abs(f1);\r\n    let f2 = z6 + z4;\r\n    let f2_ = z6_ + z4_ + abs(f2);\r\n    let f3 = f1 + vₓₓ;\r\n    let _f3 = abs(f3);\r\n    let f3_ = f1_ + vₓₓ_ + _f3;\r\n    let f4 = f2 + vᵧᵧ;\r\n    let _f4 = abs(f4);\r\n    let f4_ = f2_ + vᵧᵧ_ + _f4;\r\n    let f5 = c0c0 * f3;\r\n    let f5_ = _c0c0 * (_f3 + f3_) + abs(f5);\r\n    let f6 = d0d0 * f4;\r\n    let f6_ = _d0d0 * (_f4 + f4_) + abs(f6);\r\n    let f7 = c0d0 * vₓᵧ;\r\n    let f7_ = _c0d0 * (_vₓᵧ + vₓᵧ_) + abs(f7);\r\n    let f8 = f5 + f6;\r\n    let f8_ = f5_ + f6_ + abs(f8);\r\n    let f9 = f8 + f7;\r\n    let f9_ = f8_ + f7_ + abs(f9);\r\n    let fa = c0 * vₓ;\r\n    let fa_ = _c0 * vₓ_ + abs(fa);\r\n    let fb = d0 * vᵧ;\r\n    let fb_ = _d0 * vᵧ_ + abs(fb);\r\n    let fc = fa + fb;\r\n    let fc_ = fa_ + fb_ + abs(fc);\r\n    let fd = f9 + fc;\r\n    let fd_ = f9_ + fc_ + abs(fd);\r\n    let v0 = fd + v;\r\n    let v0_ = fd_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [v3_, v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs3x1 = getCoeffs3x1;\r\n//# sourceMappingURL=get-coefficients-3x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x2.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x2.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nfunction getCoeffs3x2(ps1, ps2) {\r\n    let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let _vₓₓₓ = abs(vₓₓₓ);\r\n    let _vₓₓᵧ = abs(vₓₓᵧ);\r\n    let _vₓᵧᵧ = abs(vₓᵧᵧ);\r\n    let _vᵧᵧᵧ = abs(vᵧᵧᵧ);\r\n    let _vₓₓ = abs(vₓₓ);\r\n    let _vₓᵧ = abs(vₓᵧ);\r\n    let _vᵧᵧ = abs(vᵧᵧ);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _c2 = abs(c2);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let _d2 = abs(d2);\r\n    let c0c0 = c0 * c0;\r\n    let c0c1 = c0 * c1;\r\n    let c0c2 = c0 * c2;\r\n    let c0d0 = c0 * d0;\r\n    let c0d1 = c0 * d1;\r\n    let c0d2 = c0 * d2;\r\n    let c1c1 = c1 * c1;\r\n    let c1c2 = c1 * c2;\r\n    let c1d0 = c1 * d0;\r\n    let c1d1 = c1 * d1;\r\n    let c1d2 = c1 * d2;\r\n    let c2c2 = c2 * c2;\r\n    let c2d0 = c2 * d0;\r\n    let c2d1 = c2 * d1;\r\n    let c2d2 = c2 * d2;\r\n    let d0d0 = d0 * d0;\r\n    let d0d1 = d0 * d1;\r\n    let d0d2 = d0 * d2;\r\n    let d1d1 = d1 * d1;\r\n    let d1d2 = d1 * d2;\r\n    let d2d2 = d2 * d2;\r\n    let _c0c0 = abs(c0c0);\r\n    let _c0c1 = abs(c0c1);\r\n    let _c0c2 = abs(c0c2);\r\n    let _c0d0 = abs(c0d0);\r\n    let _c0d1 = abs(c0d1);\r\n    let _c0d2 = abs(c0d2);\r\n    let _c1c1 = abs(c1c1);\r\n    let _c1c2 = abs(c1c2);\r\n    let _c1d0 = abs(c1d0);\r\n    let _c1d1 = abs(c1d1);\r\n    let _c1d2 = abs(c1d2);\r\n    let _c2c2 = abs(c2c2);\r\n    let _c2d0 = abs(c2d0);\r\n    let _c2d1 = abs(c2d1);\r\n    let _c2d2 = abs(c2d2);\r\n    let _d0d0 = abs(d0d0);\r\n    let _d0d1 = abs(d0d1);\r\n    let _d0d2 = abs(d0d2);\r\n    let _d1d1 = abs(d1d1);\r\n    let _d1d2 = abs(d1d2);\r\n    let _d2d2 = abs(d2d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //let v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    let e1 = c2 * vₓₓₓ;\r\n    let e1_ = _c2 * vₓₓₓ_ + abs(e1);\r\n    let e2 = c2 * vₓᵧᵧ;\r\n    let e2_ = _c2 * vₓᵧᵧ_ + abs(e2);\r\n    let e3 = d2 * vₓₓᵧ;\r\n    let e3_ = _d2 * vₓₓᵧ_ + abs(e3);\r\n    let e4 = d2 * vᵧᵧᵧ;\r\n    let e4_ = _d2 * vᵧᵧᵧ_ + abs(e4);\r\n    let e5 = e1 + e3;\r\n    let _e5 = abs(e5);\r\n    let e5_ = e1_ + e3_ + _e5;\r\n    let e6 = e2 + e4;\r\n    let _e6 = abs(e6);\r\n    let e6_ = e2_ + e4_ + _e6;\r\n    let e7 = c2c2 * e5;\r\n    let e7_ = _c2c2 * (_e5 + e5_) + abs(e7);\r\n    let e8 = d2d2 * e6;\r\n    let e8_ = _d2d2 * (_e6 + e6_) + abs(e8);\r\n    let v6 = e7 + e8;\r\n    let v6_ = e7_ + e8_ + abs(v6);\r\n    let z1 = c0c2 + c1c1;\r\n    let z1_ = _c0c2 + _c1c1 + abs(z1);\r\n    let z2 = d0d2 + d1d1;\r\n    let z2_ = _d0d2 + _d1d1 + abs(z2);\r\n    let z3 = 2 * c0c2 + c1c1;\r\n    let _z3 = abs(z3);\r\n    let z3_ = 2 * _c0c2 + _c1c1 + _z3;\r\n    let z4 = 2 * d0d2 + d1d1;\r\n    let _z4 = abs(z4);\r\n    let z4_ = 2 * _d0d2 + _d1d1 + _z4;\r\n    let z5 = 2 * c1d1 + c2d0;\r\n    let _z5 = abs(z5);\r\n    let z5_ = 2 * _c1d1 + _c2d0 + _z5;\r\n    let z6 = 2 * c1d1 + c0d2;\r\n    let z6_ = 2 * _c1d1 + _c0d2 + abs(z6);\r\n    let z7 = 2 * c2d0 + c1d1;\r\n    let z7_ = 2 * _c2d0 + _c1d1 + abs(z7);\r\n    let z8 = 6 * c0c2 + c1c1;\r\n    let z8_ = 12 * _c0c2 + _c1c1 + abs(z8);\r\n    let z9 = 6 * d0d2 + d1d1;\r\n    let z9_ = 12 * _d0d2 + _d1d1 + abs(z9);\r\n    let za = c1d2 + c2d1;\r\n    let _za = abs(za);\r\n    let za_ = _c1d2 + _c2d1 + _za;\r\n    let zb = c0d2 + c2d0;\r\n    let zb_ = _c0d2 + _c2d0 + abs(zb);\r\n    let zc = 2 * c1d0 + c0d1;\r\n    let zc_ = 2 * _c1d0 + _c0d1 + abs(zc);\r\n    let zd = 2 * c0d1 + c1d0;\r\n    let zd_ = 2 * _c0d1 + _c1d0 + abs(zd);\r\n    let zf = c0d2 + c1d1;\r\n    let zf_ = _c0d2 + _c1d1 + abs(zf);\r\n    let ze = zf + c2d0;\r\n    let _ze = abs(ze);\r\n    let ze_ = zf_ + _c2d0 + _ze;\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //let v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    let s0 = 3 * c2c2;\r\n    let _s0 = abs(s0);\r\n    let s0_ = 3 * _c2c2 + _s0;\r\n    let t1 = 3 * d2d2;\r\n    let _t1 = abs(t1);\r\n    let t1_ = 3 * _d2d2 + _t1;\r\n    let s1 = s0 * vₓₓₓ;\r\n    let s1_ = s0_ * _vₓₓₓ + _s0 * vₓₓₓ_ + abs(s1);\r\n    let s2 = c2c2 * vₓₓᵧ;\r\n    let s2_ = _c2c2 * (_vₓₓᵧ + vₓₓᵧ_) + abs(s2);\r\n    let s3 = 2 * c2d2 * vₓₓᵧ;\r\n    let s3_ = 2 * (_c2d2 * (_vₓₓᵧ + vₓₓᵧ_)) + abs(s3);\r\n    let s4 = 2 * c2d2 * vₓᵧᵧ;\r\n    let s4_ = 2 * (_c2d2 * (_vₓᵧᵧ + vₓᵧᵧ_)) + abs(s4);\r\n    let s5 = d2d2 * vₓᵧᵧ;\r\n    let s5_ = _d2d2 * (_vₓᵧᵧ + vₓᵧᵧ_) + abs(s5);\r\n    let s6 = t1 * vᵧᵧᵧ;\r\n    let s6_ = t1_ * _vᵧᵧᵧ + _t1 * vᵧᵧᵧ_ + abs(s6);\r\n    let s7 = s1 + s3;\r\n    let s7_ = s1_ + s3_ + abs(s7);\r\n    let s8 = s2 + s4;\r\n    let s8_ = s2_ + s4_ + abs(s8);\r\n    let s9 = s7 + s5;\r\n    let s9_ = s7_ + s5_ + abs(s9);\r\n    let sa = s8 + s6;\r\n    let sa_ = s8_ + s6_ + abs(sa);\r\n    let sb = c1 * s9;\r\n    let sb_ = _c1 * s9_ + abs(sb);\r\n    let sc = d1 * sa;\r\n    let sc_ = _d1 * sa_ + abs(sc);\r\n    let v5 = sb + sc;\r\n    let v5_ = sb_ + sc_ + abs(v5);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //let v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //let v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    let sd = d2 * z3;\r\n    let sd_ = _d2 * z3_ + abs(sd);\r\n    let se = d2 * z6;\r\n    let se_ = _d2 * z6_ + abs(se);\r\n    let sf = c2 * z5;\r\n    let sf_ = _c2 * z5_ + abs(sf);\r\n    let sg = c2 * z4;\r\n    let sg_ = _c2 * z4_ + abs(sg);\r\n    let sh = (3 * c2) * z1;\r\n    let _sh = abs(sh);\r\n    let sh_ = (3 * _c2) * z1_ + _sh; // 3*c2: 47-bit aligned => error free\r\n    let si = (3 * d2) * z2;\r\n    let _si = abs(si);\r\n    let si_ = (3 * _d2) * z2_ + _si; // 3*d2: 47-bit aligned => error free\r\n    let sj = sd + sf;\r\n    let _sj = abs(sj);\r\n    let sj_ = sd_ + sf_ + _sj;\r\n    let sk = se + sg;\r\n    let _sk = abs(sk);\r\n    let sk_ = se_ + sg_ + _sk;\r\n    let sl = sh * vₓₓₓ;\r\n    let sl_ = sh_ * _vₓₓₓ + _sh * vₓₓₓ_ + abs(sl);\r\n    let sm = si * vᵧᵧᵧ;\r\n    let sm_ = si_ * _vᵧᵧᵧ + _si * vᵧᵧᵧ_ + abs(sm);\r\n    let sn = sj * vₓₓᵧ;\r\n    let sn_ = sj_ * _vₓₓᵧ + _sj * vₓₓᵧ_ + abs(sn);\r\n    let so = sk * vₓᵧᵧ;\r\n    let so_ = sk_ * _vₓᵧᵧ + _sk * vₓᵧᵧ_ + abs(so);\r\n    let sp = sl + sm;\r\n    let sp_ = sl_ + sm_ + abs(sp);\r\n    let sq = sn + so;\r\n    let sq_ = sn_ + so_ + abs(sq);\r\n    let sr = c2c2 * vₓₓ;\r\n    let sr_ = _c2c2 * (vₓₓ_ + _vₓₓ) + abs(sr);\r\n    let ss = d2d2 * vᵧᵧ;\r\n    let ss_ = _d2d2 * (vᵧᵧ_ + _vᵧᵧ) + abs(ss);\r\n    let st = c2d2 * vₓᵧ;\r\n    let st_ = _c2d2 * (vₓᵧ_ + _vₓᵧ) + abs(st);\r\n    let su = sr + ss;\r\n    let su_ = sr_ + ss_ + abs(su);\r\n    let sv = sp + sq;\r\n    let sv_ = sp_ + sq_ + abs(sv);\r\n    let sw = su + st;\r\n    let sw_ = su_ + st_ + abs(sw);\r\n    let v4 = sv + sw;\r\n    let v4_ = sv_ + sw_ + abs(v4);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //let v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //let v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    let sx = c1 * z8;\r\n    let _sx = abs(sx);\r\n    let sx_ = _c1 * z8_ + _sx;\r\n    let sy = d1 * z9;\r\n    let _sy = abs(sy);\r\n    let sy_ = _d1 * z9_ + _sy;\r\n    let sz = 2 * c0 * za;\r\n    let sz_ = 2 * (_c0 * za_) + abs(sz);\r\n    let o1 = 2 * d1 * zb;\r\n    let o1_ = 2 * (_d1 * zb_) + abs(o1);\r\n    let o2 = c1 * z7;\r\n    let o2_ = _c1 * z7_ + abs(o2);\r\n    let o3 = c1 * z4;\r\n    let o3_ = _c1 * z4_ + abs(o3);\r\n    let o4 = sz + o2;\r\n    let _o4 = abs(o4);\r\n    let o4_ = sz_ + o2_ + _o4;\r\n    let o5 = o1 + o3;\r\n    let _o5 = abs(o5);\r\n    let o5_ = o1_ + o3_ + _o5;\r\n    let o6 = d1d2 * vᵧᵧ;\r\n    let o6_ = _d1d2 * (_vᵧᵧ + vᵧᵧ_) + abs(o6);\r\n    let o7 = c1c2 * vₓₓ;\r\n    let o7_ = _c1c2 * (_vₓₓ + vₓₓ_) + abs(o7);\r\n    let o8 = za * vₓᵧ;\r\n    let o8_ = za_ * _vₓᵧ + _za * vₓᵧ_ + abs(o8);\r\n    let o9 = o6 + o7;\r\n    let o9_ = o6_ + o7_ + abs(o9);\r\n    let oa = sx * vₓₓₓ;\r\n    let oa_ = sx_ * _vₓₓₓ + _sx * vₓₓₓ_ + abs(oa);\r\n    let ob = o4 * vₓₓᵧ;\r\n    let ob_ = o4_ * _vₓₓᵧ + _o4 * vₓₓᵧ_ + abs(ob);\r\n    let oc = sy * vᵧᵧᵧ;\r\n    let oc_ = sy_ * _vᵧᵧᵧ + _sy * vᵧᵧᵧ_ + abs(oc);\r\n    let od = o5 * vₓᵧᵧ;\r\n    let od_ = o5_ * _vₓᵧᵧ + _o5 * vₓᵧᵧ_ + abs(od);\r\n    let oe = oa + oc;\r\n    let oe_ = oa_ + oc_ + abs(oe);\r\n    let og = ob + od;\r\n    let og_ = ob_ + od_ + abs(og);\r\n    let oh = oe + og;\r\n    let oh_ = oe_ + og_ + abs(oh);\r\n    let oi = 2 * o9 + o8;\r\n    let oi_ = 2 * o9_ + o8_ + abs(oi);\r\n    let v3 = oh + oi;\r\n    let v3_ = oh_ + oi_ + abs(v3);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //let v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    //let v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    let oj = (3 * c0) * z1;\r\n    let _oj = abs(oj);\r\n    let oj_ = (3 * _c0) * z1_ + _oj;\r\n    let ok = (3 * d0) * z2;\r\n    let _ok = abs(ok);\r\n    let ok_ = (3 * _d0) * z2_ + _ok;\r\n    let ol = c0 * z6;\r\n    let ol_ = _c0 * z6_ + abs(ol);\r\n    let om = c0 * z4;\r\n    let om_ = _c0 * z4_ + abs(om);\r\n    let on = d0 * z3;\r\n    let on_ = _d0 * z3_ + abs(on);\r\n    let oo = d0 * z5;\r\n    let oo_ = _d0 * z5_ + abs(oo);\r\n    let op = ol + on;\r\n    let _op = abs(op);\r\n    let op_ = ol_ + on_ + _op;\r\n    let oq = om + oo;\r\n    let _oq = abs(oq);\r\n    let oq_ = om_ + oo_ + _oq;\r\n    let or = oj * vₓₓₓ;\r\n    let or_ = oj_ * _vₓₓₓ + _oj * vₓₓₓ_ + abs(or);\r\n    let os = ok * vᵧᵧᵧ;\r\n    let os_ = ok_ * _vᵧᵧᵧ + _ok * vᵧᵧᵧ_ + abs(os);\r\n    let ot = op * vₓₓᵧ;\r\n    let ot_ = op_ * _vₓₓᵧ + _op * vₓₓᵧ_ + abs(ot);\r\n    let ou = oq * vₓᵧᵧ;\r\n    let ou_ = oq_ * _vₓᵧᵧ + _oq * vₓᵧᵧ_ + abs(ou);\r\n    let ov = z3 * vₓₓ;\r\n    let ov_ = z3_ * _vₓₓ + _z3 * vₓₓ_ + abs(ov);\r\n    let ow = z4 * vᵧᵧ;\r\n    let ow_ = z4_ * _vᵧᵧ + _z4 * vᵧᵧ_ + abs(ow);\r\n    let ox = ze * vₓᵧ;\r\n    let ox_ = ze_ * _vₓᵧ + _ze * vₓᵧ_ + abs(ox);\r\n    let oy = c2 * vₓ;\r\n    let oy_ = _c2 * vₓ_ + abs(oy);\r\n    let oz = d2 * vᵧ;\r\n    let oz_ = _d2 * vᵧ_ + abs(oz);\r\n    let p1 = or + os;\r\n    let p1_ = or_ + os_ + abs(p1);\r\n    let p2 = ot + ou;\r\n    let p2_ = ot_ + ou_ + abs(p2);\r\n    let p3 = ov + ow;\r\n    let p3_ = ov_ + ow_ + abs(p3);\r\n    let p4 = p1 + p2;\r\n    let p4_ = p1_ + p2_ + abs(p4);\r\n    let p5 = p3 + ox;\r\n    let p5_ = p3_ + ox_ + abs(p5);\r\n    let p6 = oy + oz;\r\n    let p6_ = oy_ + oz_ + abs(p6);\r\n    let p7 = p4 + p5;\r\n    let p7_ = p4_ + p5_ + abs(p7);\r\n    let v2 = p7 + p6;\r\n    let v2_ = p7_ + p6_ + abs(v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //let v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    let p8 = (3 * c0) * c0c1;\r\n    let _p8 = abs(p8);\r\n    let p8_ = (3 * _c0) * _c0c1 + _p8;\r\n    let p9 = (3 * d0) * d0d1;\r\n    let _p9 = abs(p9);\r\n    let p9_ = (3 * _d0) * _d0d1 + _p9;\r\n    let pa = c0 * zc;\r\n    let _pa = abs(pa);\r\n    let pa_ = _c0 * zc_ + _pa;\r\n    let pb = d0 * zd;\r\n    let _pb = abs(pb);\r\n    let pb_ = _d0 * zd_ + _pb;\r\n    let pc = c0c1 * vₓₓ;\r\n    let pc_ = _c0c1 * (_vₓₓ + vₓₓ_) + abs(pc);\r\n    let pd = d0d1 * vᵧᵧ;\r\n    let pd_ = _d0d1 * (_vᵧᵧ + vᵧᵧ_) + abs(pd);\r\n    let pe = c0d1 * vₓᵧ;\r\n    let pe_ = _c0d1 * (_vₓᵧ + vₓᵧ_) + abs(pe);\r\n    let pf = c1d0 * vₓᵧ;\r\n    let pf_ = _c1d0 * (_vₓᵧ + vₓᵧ_) + abs(pf);\r\n    let pg = 2 * (pc + pd);\r\n    let pg_ = 2 * (pc_ + pd_) + abs(pg);\r\n    let ph = pe + pf;\r\n    let ph_ = pe_ + pf_ + abs(ph);\r\n    let pi = c1 * vₓ;\r\n    let pi_ = _c1 * vₓ_ + abs(pi);\r\n    let pj = d1 * vᵧ;\r\n    let pj_ = _d1 * vᵧ_ + abs(pj);\r\n    let pk = p8 * vₓₓₓ;\r\n    let pk_ = p8_ * _vₓₓₓ + _p8 * vₓₓₓ_ + abs(pk);\r\n    let pl = p9 * vᵧᵧᵧ;\r\n    let pl_ = p9_ * _vᵧᵧᵧ + _p9 * vᵧᵧᵧ_ + abs(pl);\r\n    let pm = pa * vₓₓᵧ;\r\n    let pm_ = pa_ * _vₓₓᵧ + _pa * vₓₓᵧ_ + abs(pm);\r\n    let pn = pb * vₓᵧᵧ;\r\n    let pn_ = pb_ * _vₓᵧᵧ + _pb * vₓᵧᵧ_ + abs(pn);\r\n    let po = pk + pl;\r\n    let po_ = pk_ + pl_ + abs(po);\r\n    let pp = pm + pn;\r\n    let pp_ = pm_ + pn_ + abs(pp);\r\n    let pq = po + pp;\r\n    let pq_ = po_ + pp_ + abs(pq);\r\n    let pr = pg + ph;\r\n    let pr_ = pg_ + ph_ + abs(pr);\r\n    let ps = pi + pj;\r\n    let ps_ = pi_ + pj_ + abs(ps);\r\n    let pt = pq + pr;\r\n    let pt_ = pq_ + pr_ + abs(pt);\r\n    let v1 = pt + ps;\r\n    let v1_ = pt_ + ps_ + abs(v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    let pu = c0 * vₓₓₓ;\r\n    let pu_ = _c0 * vₓₓₓ_ + abs(pu);\r\n    let pv = c0 * vₓᵧᵧ;\r\n    let pv_ = _c0 * vₓᵧᵧ_ + abs(pv);\r\n    let pw = d0 * vₓₓᵧ;\r\n    let pw_ = _d0 * vₓₓᵧ_ + abs(pw);\r\n    let px = d0 * vᵧᵧᵧ;\r\n    let px_ = _d0 * vᵧᵧᵧ_ + abs(px);\r\n    let py = pu + pw;\r\n    let py_ = pu_ + pw_ + abs(py);\r\n    let pz = pv + px;\r\n    let pz_ = pv_ + px_ + abs(pz);\r\n    let u1 = py + vₓₓ;\r\n    let _u1 = abs(u1);\r\n    let u1_ = py_ + vₓₓ_ + _u1;\r\n    let u2 = pz + vᵧᵧ;\r\n    let _u2 = abs(u2);\r\n    let u2_ = pz_ + vᵧᵧ_ + _u2;\r\n    let u3 = c0c0 * u1;\r\n    let u3_ = _c0c0 * (_u1 + u1_) + abs(u3);\r\n    let u4 = d0d0 * u2;\r\n    let u4_ = _d0d0 * (_u2 + u2_) + abs(u4);\r\n    let u5 = c0d0 * vₓᵧ;\r\n    let u5_ = _c0d0 * (_vₓᵧ + vₓᵧ_) + abs(u5);\r\n    let u6 = c0 * vₓ;\r\n    let u6_ = _c0 * vₓ_ + abs(u6);\r\n    let u7 = d0 * vᵧ;\r\n    let u7_ = _d0 * vᵧ_ + abs(u7);\r\n    let u8 = u3 + u4;\r\n    let u8_ = u3_ + u4_ + abs(u8);\r\n    let u9 = u8 + u5;\r\n    let u9_ = u8_ + u5_ + abs(u9);\r\n    let ua = u6 + u7;\r\n    let ua_ = u6_ + u7_ + abs(ua);\r\n    let ub = u9 + ua;\r\n    let ub_ = u9_ + ua_ + abs(ub);\r\n    let v0 = ub + v;\r\n    let v0_ = ub_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [v6_, v5_, v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs3x2 = getCoeffs3x2;\r\n//# sourceMappingURL=get-coefficients-3x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x3.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x3.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/naive/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\n/**\r\n * @param ps1\r\n * @param ps2\r\n */\r\nfunction getCoeffs3x3(ps1, ps2) {\r\n    let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2); // Assume exact -> max bitlength = 47\r\n    let _vₓₓₓ = abs(vₓₓₓ);\r\n    let _vₓₓᵧ = abs(vₓₓᵧ);\r\n    let _vₓᵧᵧ = abs(vₓᵧᵧ);\r\n    let _vᵧᵧᵧ = abs(vᵧᵧᵧ);\r\n    let _vₓₓ = abs(vₓₓ);\r\n    let _vₓᵧ = abs(vₓᵧ);\r\n    let _vᵧᵧ = abs(vᵧᵧ);\r\n    let c0c0 = c0 * c0;\r\n    let c0c1 = c0 * c1;\r\n    let c0c2 = c0 * c2;\r\n    let c0c3 = c0 * c3;\r\n    let c0d0 = c0 * d0;\r\n    let c0d1 = c0 * d1;\r\n    let c0d2 = c0 * d2;\r\n    let c0d3 = c0 * d3;\r\n    let c1c1 = c1 * c1;\r\n    let c1c2 = c1 * c2;\r\n    let c1c3 = c1 * c3;\r\n    let c1d0 = c1 * d0;\r\n    let c1d1 = c1 * d1;\r\n    let c1d2 = c1 * d2;\r\n    let c1d3 = c1 * d3;\r\n    let c2d1 = c2 * d1;\r\n    let c2c2 = c2 * c2;\r\n    let c2c3 = c2 * c3;\r\n    let c2d0 = c2 * d0;\r\n    let c2d2 = c2 * d2;\r\n    let c2d3 = c2 * d3;\r\n    let c3c3 = c3 * c3;\r\n    let c3d0 = c3 * d0;\r\n    let c3d1 = c3 * d1;\r\n    let c3d2 = c3 * d2;\r\n    let c3d3 = c3 * d3;\r\n    let d0d0 = d0 * d0;\r\n    let d0d1 = d0 * d1;\r\n    let d0d2 = d0 * d2;\r\n    let d0d3 = d0 * d3;\r\n    let d1d1 = d1 * d1;\r\n    let d1d2 = d1 * d2;\r\n    let d3d3 = d3 * d3;\r\n    let d2d2 = d2 * d2;\r\n    let d2d3 = d2 * d3;\r\n    let d1d3 = d1 * d3;\r\n    let _c0c0 = abs(c0c0);\r\n    let _c0c1 = abs(c0c1);\r\n    let _c0c2 = abs(c0c2);\r\n    let _c0c3 = abs(c0c3);\r\n    let _c0d1 = abs(c0d1);\r\n    let _c0d2 = abs(c0d2);\r\n    let _c0d3 = abs(c0d3);\r\n    let _c1c1 = abs(c1c1);\r\n    let _c1c2 = abs(c1c2);\r\n    let _c1c3 = abs(c1c3);\r\n    let _c2c2 = abs(c2c2);\r\n    let _c2c3 = abs(c2c3);\r\n    let _c2d2 = abs(c2d2);\r\n    let _c1d0 = abs(c1d0);\r\n    let _c1d1 = abs(c1d1);\r\n    let _c1d2 = abs(c1d2);\r\n    let _c1d3 = abs(c1d3);\r\n    let _c2d0 = abs(c2d0);\r\n    let _c2d1 = abs(c2d1);\r\n    let _c2d3 = abs(c2d3);\r\n    let _c3c3 = abs(c3c3);\r\n    let _c3d0 = abs(c3d0);\r\n    let _c3d1 = abs(c3d1);\r\n    let _c3d2 = abs(c3d2);\r\n    let _c3d3 = abs(c3d3);\r\n    let _c0d0 = abs(c0d0);\r\n    let _d0d0 = abs(d0d0);\r\n    let _d0d1 = abs(d0d1);\r\n    let _d0d2 = abs(d0d2);\r\n    let _d0d3 = abs(d0d3);\r\n    let _d1d1 = abs(d1d1);\r\n    let _d1d2 = abs(d1d2);\r\n    let _d1d3 = abs(d1d3);\r\n    let _d2d2 = abs(d2d2);\r\n    let _d2d3 = abs(d2d3);\r\n    let _d3d3 = abs(d3d3);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _c2 = abs(c2);\r\n    let _c3 = abs(c3);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let _d2 = abs(d2);\r\n    let _d3 = abs(d3);\r\n    //let v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;  \r\n    let g1 = c3 * c3c3;\r\n    let _g1 = _c3 * _c3c3;\r\n    let g1_ = 2 * _g1;\r\n    let g2 = c3 * d3d3;\r\n    let _g2 = _c3 * _d3d3;\r\n    let g2_ = 2 * _g2;\r\n    let g3 = d3 * c3c3;\r\n    let _g3 = _d3 * _c3c3;\r\n    let g3_ = 2 * _g3;\r\n    let g4 = d3 * d3d3;\r\n    let _g4 = _d3 * _d3d3;\r\n    let g4_ = 2 * _g4;\r\n    let g5 = g1 * vₓₓₓ;\r\n    let g5_ = g1_ * _vₓₓₓ + _g1 * vₓₓₓ_ + abs(g5);\r\n    let g6 = g2 * vₓᵧᵧ;\r\n    let g6_ = g2_ * _vₓᵧᵧ + _g2 * vₓᵧᵧ_ + abs(g2);\r\n    let g7 = g3 * vₓₓᵧ;\r\n    let g7_ = g3_ * _vₓₓᵧ + _g3 * vₓₓᵧ_ + abs(g3);\r\n    let g8 = g4 * vᵧᵧᵧ;\r\n    let g8_ = g4_ * _vᵧᵧᵧ + _g4 * vᵧᵧᵧ_ + abs(g4);\r\n    let g9 = g5 + g6;\r\n    let g9_ = g5_ + g6_ + abs(g9);\r\n    let ga = g7 + g8;\r\n    let ga_ = g7_ + g8_ + abs(ga);\r\n    let v9 = g9 + ga;\r\n    let v9_ = g9_ + ga_ + abs(v9);\r\n    //let v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    let w1 = 2 * c2d3 + c3d2;\r\n    let w1_ = 2 * _c2d3 + _c3d2 + abs(w1);\r\n    let w2 = 2 * c3d2 + c2d3;\r\n    let w2_ = 2 * _c3d2 + _c2d3 + abs(w2);\r\n    let w3 = c3 * w1;\r\n    let _w3 = abs(w3);\r\n    let w3_ = _c3 * w1_ + _w3;\r\n    let w4 = d3 * w2;\r\n    let _w4 = abs(w4);\r\n    let w4_ = _d3 * w2_ + w4;\r\n    let w5 = c2 * c3c3;\r\n    let _w5 = abs(w5);\r\n    let w5_ = _c2 * _c3c3 + w5;\r\n    let w6 = d2 * d3d3;\r\n    let _w6 = abs(w6);\r\n    let w6_ = _d2 * _d3d3 + w6;\r\n    let w7 = vₓₓₓ * w5;\r\n    let w7_ = vₓₓₓ_ * _w5 + _vₓₓₓ * w5_ + abs(w7);\r\n    let u1 = vᵧᵧᵧ * w6;\r\n    let u1_ = vᵧᵧᵧ_ * _w6 + _vᵧᵧᵧ * w6_ + abs(u1);\r\n    let u2 = vₓₓᵧ * w3;\r\n    let u2_ = vₓₓᵧ_ * _w3 + _vₓₓᵧ * w3_ + abs(u2);\r\n    let u3 = vₓᵧᵧ * w4;\r\n    let u3_ = vₓᵧᵧ_ * _w4 + _vₓᵧᵧ * w4_ + abs(u3);\r\n    let u4 = u2 + u3;\r\n    let u4_ = u2_ + u3_ + abs(u4);\r\n    let u5 = 3 * (w7 + u1);\r\n    let u5_ = 3 * (w7_ + u1_) + 2 * abs(u5);\r\n    let v8 = u4 + u5;\r\n    let v8_ = u4_ + u5_ + abs(v8);\r\n    //let w1 = c2*vₓₓᵧ + d2*vₓᵧᵧ;\r\n    //let _w1 = abs(w1);\r\n    //let w1_ = _c2*vₓₓᵧ_ + _d2*vₓᵧᵧ_ + _w1;\r\n    //let w2 = d2*vₓₓᵧ + 3*c2*vₓₓₓ;\r\n    //let _w2 = abs(w2);\r\n    //let w2_ = _d2*vₓₓᵧ_ + 3*_c2*vₓₓₓ_ + _w2;\r\n    //let w3 = c2*vₓᵧᵧ + 3*d2*vᵧᵧᵧ;\r\n    //let _w3 = abs(w3);\r\n    //let w3_ = _c2*vₓᵧᵧ_ + _d2*vᵧᵧᵧ_ + _w3;\r\n    //let w5 = c3c3*w2;\r\n    //let w5_ = _c3c3*(_w2 + w2_) + abs(w5);\r\n    //let w6 = d3d3*w3;\r\n    //let w6_ = _d3d3*(_w3 + w3_) + abs(w6);\r\n    //let w4 = w5 + w6;\r\n    //let _w4 = abs(w4);\r\n    //let w4_ = w5_ + w6_ + _w4;\r\n    //let w7 = 2*c3d3*w1;\r\n    //let _w7 = abs(w7);\r\n    //let w7_ = 2*(_c3d3*_w1 + _c3d3*w1_ + _w7);\r\n    //let v8 = w7 + w4;\r\n    //let v8_ = w7_ + w4_ + abs(v8);\r\n    //let v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    let o1 = c1 * c3d3;\r\n    let o1_ = _c1 * _c3d3 + abs(o1);\r\n    let o2 = d1 * c3c3;\r\n    let o2_ = _d1 * _c3c3 + abs(o2);\r\n    let o3 = c2 * d2d3;\r\n    let o3_ = _c2 * _d2d3 + abs(o3);\r\n    let o4 = c1 * d3d3;\r\n    let o4_ = _c1 * _d3d3 + abs(o4);\r\n    let o5 = c2 * c3d2;\r\n    let o5_ = _c2 * _c3d2 + abs(o5);\r\n    let o6 = d3 * c2c2;\r\n    let o6_ = _d3 * _c2c2 + abs(o6);\r\n    let o7 = c3 * d1d3;\r\n    let o7_ = _c3 * _d1d3 + abs(o7);\r\n    let o8 = d2 * c3d2;\r\n    let o8_ = _d2 * _c3d2 + abs(o8);\r\n    let w8 = o1 + o5;\r\n    let w8_ = o1_ + o5_ + abs(w8);\r\n    let w9 = o2 + o6;\r\n    let w9_ = o2_ + o6_ + abs(w9);\r\n    let wa = o3 + o7;\r\n    let wa_ = o3_ + o7_ + abs(wa);\r\n    let wb = o4 + o8;\r\n    let wb_ = o4_ + o8_ + abs(wb);\r\n    let wc = c1c3 + c2c2;\r\n    let wc_ = _c1c3 + _c2c2 + abs(wc);\r\n    let wd = d1d3 + d2d2;\r\n    let wd_ = _d1d3 + _d2d2 + abs(wd);\r\n    let we = 2 * w8 + w9;\r\n    let _we = abs(we);\r\n    let we_ = 2 * w8_ + w9_ + _we;\r\n    let wf = 2 * wa + wb;\r\n    let _wf = abs(wf);\r\n    let wf_ = 2 * wa_ + wb_ + _wf;\r\n    let wg = vₓₓᵧ * we;\r\n    let wg_ = vₓₓᵧ_ * _we + _vₓₓᵧ * we_ + abs(wg);\r\n    let wh = vₓᵧᵧ * wf;\r\n    let wh_ = vₓᵧᵧ_ * _wf + _vₓᵧᵧ * wf_ + abs(wh);\r\n    let wi = c3 * wc;\r\n    let _wi = abs(wi);\r\n    let wi_ = _c3 * wc_ + _wi;\r\n    let wj = d3 * wd;\r\n    let _wj = abs(wj);\r\n    let wj_ = _d3 * wd_ + _wj;\r\n    let wk = vₓₓₓ * wi;\r\n    let wk_ = vₓₓₓ_ * _wi + _vₓₓₓ * wi_ + abs(wk);\r\n    let wl = vᵧᵧᵧ * wj;\r\n    let wl_ = vᵧᵧᵧ_ * _wj + _vᵧᵧᵧ * wj_ + abs(wl);\r\n    let wm = wg + wh;\r\n    let wm_ = wg_ + wh_ + abs(wm);\r\n    let wn = 3 * (wk + wl);\r\n    let wn_ = 3 * (wk_ + wl_) + 2 * abs(wn);\r\n    let v7 = wm + wn;\r\n    let v7_ = wm_ + wn_ + abs(v7);\r\n    //let v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    let wo = c2d3 + c3d2;\r\n    let _wo = abs(wo);\r\n    let wo_ = _c2d3 + _c3d2 + _wo;\r\n    let zc = d2 * c2c2;\r\n    let zc_ = _d2 * _c2c2 + abs(zc);\r\n    let zd = 2 * c1 * wo;\r\n    let zd_ = 2 * (_c1 * wo_) + abs(zd);\r\n    let wp = zc + zd;\r\n    let wp_ = zc_ + zd_ + abs(wp);\r\n    let wq = 2 * (c0d3 + c2d1);\r\n    let wq_ = 2 * (_c0d3 + _c2d1) + abs(wq);\r\n    let wr = wq + c3d0;\r\n    let wr_ = wq_ + _c3d0 + abs(wr);\r\n    let ze = c3 * wr;\r\n    let ze_ = _c3 * wr_ + abs(ze);\r\n    let ws = wp + ze;\r\n    let _ws = abs(ws);\r\n    let ws_ = wp_ + ze_ + _ws;\r\n    let zf = c2 * d2d2;\r\n    let zf_ = _c2 * _d2d2 + abs(zf);\r\n    let zg = 2 * d1 * wo;\r\n    let zg_ = 2 * (_d1 * wo_) + abs(zg);\r\n    let wt = zf + zg;\r\n    let wt_ = zf_ + zg_ + abs(wt);\r\n    let wu = 2 * (c1d2 + c3d0);\r\n    let wu_ = 2 * (_c1d2 + _c3d0) + abs(wu);\r\n    let wv = wu + c0d3;\r\n    let wv_ = wu_ + _c0d3 + abs(wv);\r\n    let zh = d3 * wv;\r\n    let zh_ = _d3 * wv_ + abs(zh);\r\n    let ww = wt + zh;\r\n    let _ww = abs(ww);\r\n    let ww_ = wt_ + zh_ + _ww;\r\n    let wx = c2 * c2c2;\r\n    let wx_ = _c2 * _c2c2 + abs(wx);\r\n    let wy = 2 * c1c2 + c0c3;\r\n    let wy_ = 2 * _c1c2 + _c0c3 + abs(wy);\r\n    let wz = 3 * (c3 * wy);\r\n    let wz_ = 3 * _c3 * wy_ + 2 * abs(wz);\r\n    let z1 = wx + wz;\r\n    let _z1 = abs(z1);\r\n    let z1_ = wx_ + wz_ + _z1;\r\n    let z2 = d2 * d2d2;\r\n    let z2_ = _d2 * _d2d2 + abs(z2);\r\n    let z3 = 2 * d1d2 + d0d3;\r\n    let z3_ = 2 * _d1d2 + _d0d3 + abs(z3);\r\n    let z4 = 3 * (d3 * z3);\r\n    let z4_ = 3 * (_d3 * z3_) + 2 * abs(z4);\r\n    let z5 = z2 + z4;\r\n    let _z5 = abs(z5);\r\n    let z5_ = z2_ + z4_ + _z5;\r\n    let zi = vₓₓᵧ * ws;\r\n    let zi_ = vₓₓᵧ_ * _ws + _vₓₓᵧ * ws_ + abs(zi);\r\n    let zj = vₓᵧᵧ * ww;\r\n    let zj_ = vₓᵧᵧ_ * _ww + _vₓᵧᵧ * ww_ + abs(zj);\r\n    let z6 = zi + zj;\r\n    let z6_ = zi_ + zj_ + abs(z6);\r\n    let zk = vₓₓₓ * z1;\r\n    let zk_ = vₓₓₓ_ * _z1 + _vₓₓₓ * z1_ + abs(zk);\r\n    let zl = vᵧᵧᵧ * z5;\r\n    let zl_ = vᵧᵧᵧ_ * _z5 + _vᵧᵧᵧ * z5_ + abs(zl);\r\n    let z7 = zk + zl;\r\n    let z7_ = zk_ + zl_ + abs(z7);\r\n    let zm = vₓₓ * c3c3;\r\n    let zm_ = _c3c3 * (vₓₓ_ + _vₓₓ) + abs(zm);\r\n    let zn = vᵧᵧ * d3d3;\r\n    let zn_ = _d3d3 * (vᵧᵧ_ + _vᵧᵧ) + abs(zn);\r\n    let z8 = zm + zn;\r\n    let z8_ = zm_ + zn_ + abs(z8);\r\n    let z9 = vₓᵧ * c3d3;\r\n    let z9_ = _c3d3 * (vₓᵧ_ + _vₓᵧ) + abs(z9);\r\n    let za = z6 + z7;\r\n    let za_ = z6_ + z7_ + abs(za);\r\n    let zb = z8 + z9;\r\n    let zb_ = z8_ + z9_ + abs(zb);\r\n    let v6 = za + zb;\r\n    let v6_ = za_ + zb_ + abs(z6);\r\n    //let r4 = c2d2 + c3d1;\r\n    //let r5 = c1d3 + c2d2;\r\n    //let v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    let r4 = c2d2 + c3d1;\r\n    let r4_ = _c2d2 + _c3d1 + abs(r4);\r\n    let r5 = c1d3 + c2d2;\r\n    let r5_ = _c1d3 + _c2d2 + abs(r5);\r\n    let k1 = c0 * wo;\r\n    let k1_ = _c0 * wo_ + abs(k1);\r\n    let k2 = d0 * wo;\r\n    let k2_ = _d0 * wo_ + abs(k2);\r\n    let k3 = c1 * r4;\r\n    let k3_ = _c1 * r4_ + abs(k3);\r\n    let k4 = d1 * r5;\r\n    let k4_ = _d1 * r5_ + abs(k4);\r\n    let k5 = 2 * c3d0 + c2d1;\r\n    let k5_ = 2 * _c3d0 + _c2d1 + abs(k5);\r\n    let k6 = 2 * c0d3 + c1d2;\r\n    let k6_ = 2 * _c0d3 + _c1d2 + abs(k6);\r\n    let k7 = d3 * c1c1;\r\n    let k7_ = _d3 * _c1c1 + abs(k7);\r\n    let k8 = c3 * d1d1;\r\n    let k8_ = _c3 * _d1d1 + abs(k8);\r\n    let k9 = c2 * k5;\r\n    let k9_ = _c2 * k5_ + abs(k9);\r\n    let ka = d2 * k6;\r\n    let ka_ = _d2 * k6_ + abs(ka);\r\n    let kb = 2 * (k1 + k3);\r\n    let kb_ = 2 * (k1_ + k3_) + abs(kb);\r\n    let kc = 2 * (k2 + k4);\r\n    let kc_ = 2 * (k2_ + k4_) + abs(kc);\r\n    let kd = 2 * c0 * c2c3;\r\n    let kd_ = 2 * (_c0 * _c2c3) + abs(kd);\r\n    let ke = 2 * d0 * d2d3;\r\n    let ke_ = 2 * (_d0 * _d2d3) + abs(ke);\r\n    let kf = c1 * wc;\r\n    let kf_ = _c1 * wc_ + abs(kf);\r\n    let kg = d1 * wd;\r\n    let kg_ = _d1 * wd_ + abs(kg);\r\n    let kh = vₓₓ * c2c3;\r\n    let kh_ = _c2c3 * (vₓₓ_ + _vₓₓ) + abs(kh);\r\n    let ki = vᵧᵧ * d2d3;\r\n    let ki_ = _d2d3 * (vᵧᵧ_ + _vᵧᵧ) + abs(ki);\r\n    let kj = kb + k7;\r\n    let kj_ = kb_ + k7_ + abs(kj);\r\n    let kk = kc + k8;\r\n    let kk_ = kc_ + k8_ + abs(kk);\r\n    let kl = kj + k9;\r\n    let _kl = abs(kl);\r\n    let kl_ = kj_ + k9_ + _kl;\r\n    let km = kk + ka;\r\n    let _km = abs(km);\r\n    let km_ = kk_ + ka_ + _km;\r\n    let kn = kd + kf;\r\n    let _kn = abs(kn);\r\n    let kn_ = kd_ + kf_ + _kn;\r\n    let ko = ke + kg;\r\n    let _ko = abs(ko);\r\n    let ko_ = ke_ + kg_ + _ko;\r\n    let kp = 2 * (kh + ki);\r\n    let kp_ = 2 * (kh_ + ki_) + abs(kp);\r\n    let kq = vₓₓᵧ * kl;\r\n    let kq_ = vₓₓᵧ_ * _kl + _vₓₓᵧ * kl_ + abs(kq);\r\n    let kr = vₓᵧᵧ * km;\r\n    let kr_ = vₓᵧᵧ_ * _km + _vₓᵧᵧ * km_ + abs(kr);\r\n    let ks = vₓₓₓ * kn;\r\n    let ks_ = vₓₓₓ_ * _kn + _vₓₓₓ * kn_ + abs(ks);\r\n    let kt = vᵧᵧᵧ * ko;\r\n    let kt_ = vᵧᵧᵧ_ * _ko + _vᵧᵧᵧ * ko_ + abs(kt);\r\n    let ku = kq + kr;\r\n    let ku_ = kq_ + kr_ + abs(ku);\r\n    let kv = 3 * (ks + kt);\r\n    let kv_ = 3 * (ks_ + kt_) + 2 * abs(kv);\r\n    let kw = vₓᵧ * wo;\r\n    let kw_ = vₓᵧ_ * _wo + _vₓᵧ * wo_ + abs(kw);\r\n    let kx = ku + kv;\r\n    let kx_ = ku_ + kv_ + abs(kx);\r\n    let ky = kw + kp;\r\n    let ky_ = kw_ + kp_ + abs(ky);\r\n    let v5 = kx + ky;\r\n    let v5_ = kx_ + ky_ + abs(v5);\r\n    //let r1 = c1d3 + r4;\r\n    //let r2 = 2*c1c3 + c2c2;\r\n    //let r3 = 2*d1d3 + d2d2;\r\n    //let v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    let r1 = c1d3 + r4;\r\n    let _r1 = abs(r1);\r\n    let r1_ = _c1d3 + r4_ + _r1;\r\n    let r2 = 2 * c1c3 + c2c2;\r\n    let _r2 = abs(r2);\r\n    let r2_ = 2 * _c1c3 + _c2c2 + _r2;\r\n    let r3 = 2 * d1d3 + d2d2;\r\n    let _r3 = abs(r3);\r\n    let r3_ = 2 * _d1d3 + _d2d2 + _r3;\r\n    let s1 = 2 * c0 * r1;\r\n    let s1_ = 2 * _c0 * r1_ + abs(s1);\r\n    let s2 = 2 * d0 * r1;\r\n    let s2_ = 2 * _d0 * r1_ + abs(s2);\r\n    let s5 = c1d2 + 2 * c2d1;\r\n    let s5_ = _c1d2 + 2 * _c2d1 + abs(s5);\r\n    let s6 = c2d1 + 2 * c1d2;\r\n    let s6_ = _c2d1 + 2 * _c1d2 + abs(s6);\r\n    let s3 = d0 * r2;\r\n    let s3_ = _d0 * r2_ + abs(s3);\r\n    let s4 = c0 * r3;\r\n    let s4_ = _c0 * r3_ + abs(s4);\r\n    let s7 = c1 * s5;\r\n    let s7_ = _c1 * s5_ + abs(s7);\r\n    let s8 = d1 * s6;\r\n    let s8_ = _d1 * s6_ + abs(s8);\r\n    let s9 = c0 * r2;\r\n    let s9_ = _c0 * r2_ + abs(s9);\r\n    let sa = d0 * r3;\r\n    let sa_ = _d0 * r3_ + abs(sa);\r\n    let sb = c2 * c1c1;\r\n    let sb_ = _c2 * _c1c1 + abs(sb);\r\n    let sc = d2 * d1d1;\r\n    let sc_ = _d2 * _d1d1 + abs(sc);\r\n    let sd = s1 + s3;\r\n    let sd_ = s1_ + s3_ + abs(sd);\r\n    let se = s2 + s4;\r\n    let se_ = s2_ + s4_ + abs(se);\r\n    let sf = sd + s7;\r\n    let _sf = abs(sf);\r\n    let sf_ = sd_ + s7_ + _sf;\r\n    let sg = se + s8;\r\n    let _sg = abs(sg);\r\n    let sg_ = se_ + s8_ + _sg;\r\n    let sh = s9 + sb;\r\n    let _sh = abs(sh);\r\n    let sh_ = s9_ + sb_ + _sh;\r\n    let si = sa + sc;\r\n    let _si = abs(si);\r\n    let si_ = sa_ + sc_ + _si;\r\n    let sj = vₓₓᵧ * sf;\r\n    let sj_ = vₓₓᵧ_ * _sf + _vₓₓᵧ * sf_ + abs(sj);\r\n    let sk = vₓᵧᵧ * sg;\r\n    let sk_ = vₓᵧᵧ_ * _sg + _vₓᵧᵧ * sg_ + abs(sk);\r\n    let sl = vₓₓₓ * sh;\r\n    let sl_ = vₓₓₓ_ * _sh + _vₓₓₓ * sh_ + abs(sl);\r\n    let sm = vᵧᵧᵧ * si;\r\n    let sm_ = vᵧᵧᵧ_ * _si + _vᵧᵧᵧ * si_ + abs(sm);\r\n    let sn = sl + sm;\r\n    let _sn = abs(sn);\r\n    let sn_ = sl_ + sm_ + _sn;\r\n    let so = sj + sk;\r\n    let so_ = sj_ + sk_ + abs(so);\r\n    let sp = so + 3 * sn;\r\n    let sp_ = so_ + 3 * (sn_ + _sn) + abs(sp);\r\n    let ss = vₓᵧ * r1;\r\n    let ss_ = vₓᵧ_ * _r1 + _vₓᵧ * r1_ + abs(ss);\r\n    let st = vₓₓ * r2;\r\n    let st_ = vₓₓ_ * _r2 + _vₓₓ * r2_ + abs(st);\r\n    let sq = ss + st;\r\n    let sq_ = ss_ + st_ + abs(sq);\r\n    let su = vᵧᵧ * r3;\r\n    let su_ = vᵧᵧ_ * _r3 + _vᵧᵧ * r3_ + abs(su);\r\n    let sr = sq + su;\r\n    let sr_ = sq_ + su_ + abs(sr);\r\n    let v4 = sp + sr;\r\n    let v4_ = sp_ + sr_ + abs(v4);\r\n    //let r6 = c1d2 + c2d1;\r\n    //let r7 = c3d0 + c0d3;\r\n    //let r8 = c1c2 + c0c3;\r\n    //let r9 = d1d2 + d0d3;\r\n    //let v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    let r6 = c1d2 + c2d1;\r\n    let r6_ = _c1d2 + _c2d1 + abs(r6);\r\n    let r7 = c3d0 + c0d3;\r\n    let r7_ = _c3d0 + _c0d3 + abs(r7);\r\n    let r8 = c1c2 + c0c3;\r\n    let _r8 = abs(r8);\r\n    let r8_ = _c1c2 + _c0c3 + _r8;\r\n    let r9 = d1d2 + d0d3;\r\n    let _r9 = abs(r9);\r\n    let r9_ = _d1d2 + _d0d3 + _r9;\r\n    let m1 = 2 * r6 + c3d0;\r\n    let m1_ = 2 * r6_ + _c3d0 + abs(m1);\r\n    let m2 = 2 * r6 + c0d3;\r\n    let m2_ = 2 * r6_ + _c0d3 + abs(m2);\r\n    let m3 = 2 * c2d0 + c1d1;\r\n    let m3_ = 2 * _c2d0 + _c1d1 + abs(m3);\r\n    let m4 = 2 * c0d2 + c1d1;\r\n    let m4_ = 2 * _c0d2 + _c1d1 + abs(m4);\r\n    let m5 = r8 + c1c2;\r\n    let m5_ = r8_ + _c1c2 + abs(m5);\r\n    let m6 = r9 + d1d2;\r\n    let m6_ = r9_ + _d1d2 + abs(m6);\r\n    let m7 = 3 * c0 * m5;\r\n    let m7_ = 3 * (_c0 * m5_) + 2 * abs(m7);\r\n    let m8 = 3 * d0 * m6;\r\n    let m8_ = 3 * (_d0 * m6_) + 2 * abs(m8);\r\n    let m9 = c1 * c1c1;\r\n    let m9_ = _c1 * _c1c1 + abs(m9);\r\n    let ma = d1 * d1d1;\r\n    let ma_ = _d1 * _d1d1 + abs(ma);\r\n    let mb = vₓₓ * r8;\r\n    let mb_ = vₓₓ_ * _r8 + _vₓₓ * r8_ + abs(mb);\r\n    let mc = vᵧᵧ * r9;\r\n    let mc_ = vᵧᵧ_ * _r9 + _vᵧᵧ * r9_ + abs(mc);\r\n    let md = m1 + r7;\r\n    let md_ = m1_ + r7_ + abs(md);\r\n    let me = m2 + r7;\r\n    let me_ = m2_ + r7_ + abs(me);\r\n    let mf = c0 * md;\r\n    let mf_ = _c0 * md_ + abs(mf);\r\n    let mg = d0 * me;\r\n    let mg_ = _d0 * me_ + abs(mg);\r\n    let mh = c1 * m3;\r\n    let mh_ = _c1 * m3_ + abs(mh);\r\n    let mi = d1 * m4;\r\n    let mi_ = _d1 * m4_ + abs(mi);\r\n    let mj = c3 * vₓ;\r\n    let mj_ = _c3 * vₓ_ + abs(mj);\r\n    let mk = d3 * vᵧ;\r\n    let mk_ = _d3 * vᵧ_ + abs(mk);\r\n    let ml = mf + mh;\r\n    let _ml = abs(ml);\r\n    let ml_ = mf_ + mh_ + _ml;\r\n    let mm = mg + mi;\r\n    let _mm = abs(mm);\r\n    let mm_ = mg_ + mi_ + _mm;\r\n    let mn = m7 + m9;\r\n    let _mn = abs(mn);\r\n    let mn_ = m7_ + m9_ + _mn;\r\n    let mo = m8 + ma;\r\n    let _mo = abs(mo);\r\n    let mo_ = m8_ + ma_ + _mo;\r\n    let mp = r7 + r6;\r\n    let _mp = abs(mp);\r\n    let mp_ = r7_ + r6_ + _mp;\r\n    let mq = 2 * (mb + mc);\r\n    let mq_ = 2 * (mb_ + mc_) + abs(mq);\r\n    let mr = vₓₓᵧ * ml;\r\n    let mr_ = vₓₓᵧ_ * _ml + _vₓₓᵧ * ml_ + abs(mr);\r\n    let ms = vₓᵧᵧ * mm;\r\n    let ms_ = vₓᵧᵧ_ * _mm + _vₓᵧᵧ * mm_ + abs(ms);\r\n    let mt = vₓₓₓ * mn;\r\n    let mt_ = vₓₓₓ_ * _mn + _vₓₓₓ * mn_ + abs(mt);\r\n    let mu = vᵧᵧᵧ * mo;\r\n    let mu_ = vᵧᵧᵧ_ * _mo + _vᵧᵧᵧ * mo_ + abs(mu);\r\n    let mv = vₓᵧ * mp;\r\n    let mv_ = vₓᵧ_ * _mp + _vₓᵧ * mp_ + abs(mv);\r\n    let mw = mr + ms;\r\n    let mw_ = mr_ + ms_ + abs(mw);\r\n    let mx = mt + mu;\r\n    let mx_ = mt_ + mu_ + abs(mx);\r\n    let my = mv + mq;\r\n    let my_ = mv_ + mq_ + abs(my);\r\n    let mz = mj + mk;\r\n    let mz_ = mj_ + mk_ + abs(mz);\r\n    let n1 = mw + mx;\r\n    let n1_ = mw_ + mx_ + abs(n1);\r\n    let n2 = my + mz;\r\n    let n2_ = my_ + mz_ + abs(n2);\r\n    let v3 = n1 + n2;\r\n    let v3_ = n1_ + n2_ + abs(v3);\r\n    //    let ra = c1d1 + c2d0;\r\n    //    let rb = c1d1 + c0d2;\r\n    //    let v2 =\r\n    //        vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //        vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //        3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //        3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //        vₓᵧ*(ra + c0d2) +\r\n    //        vₓₓ*(2*c0c2 + c1c1) + \r\n    //        vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //        c2*vₓ + d2*vᵧ;\r\n    let ra = c1d1 + c2d0;\r\n    let ra_ = _c1d1 + _c2d0 + abs(ra);\r\n    let rb = c1d1 + c0d2;\r\n    let rb_ = _c1d1 + _c0d2 + abs(rb);\r\n    let l1 = 2 * ra + c0d2;\r\n    let l1_ = 2 * ra_ + _c0d2 + abs(l1);\r\n    let l2 = 2 * rb + c2d0;\r\n    let l2_ = 2 * rb_ + _c2d0 + abs(l2);\r\n    let l3 = c0 * l1;\r\n    let l3_ = _c0 * l1_ + abs(l3);\r\n    let l4 = d0 * c1c1;\r\n    let l4_ = _d0 * _c1c1 + abs(l4);\r\n    let l5 = d0 * l2;\r\n    let l5_ = _d0 * l2_ + abs(l5);\r\n    let l6 = c0 * d1d1;\r\n    let l6_ = _c0 * _d1d1 + abs(l6);\r\n    let l7 = c0 * c1c1;\r\n    let l7_ = _c0 * _c1c1 + abs(l7);\r\n    let l8 = c2 * c0c0;\r\n    let l8_ = _c2 * _c0c0 + abs(l8);\r\n    let l9 = d0 * d1d1;\r\n    let l9_ = _d0 * _d1d1 + abs(l9);\r\n    let la = d2 * d0d0;\r\n    let la_ = _d2 * _d0d0 + abs(la);\r\n    let lb = l3 + l4;\r\n    let _lb = abs(lb);\r\n    let lb_ = l3_ + l4_ + _lb;\r\n    let lc = l5 + l6;\r\n    let _lc = abs(lc);\r\n    let lc_ = l5_ + l6_ + _lc;\r\n    let ld = l7 + l8;\r\n    let _ld = abs(ld);\r\n    let ld_ = l7_ + l8_ + _ld;\r\n    let le = l9 + la;\r\n    let _le = abs(le);\r\n    let le_ = l9_ + la_ + _le;\r\n    let lf = vₓₓₓ * ld;\r\n    let lf_ = vₓₓₓ_ * _ld + _vₓₓₓ * ld_ + abs(lf);\r\n    let lg = vᵧᵧᵧ * le;\r\n    let lg_ = vᵧᵧᵧ_ * _le + _vᵧᵧᵧ * le_ + abs(lg);\r\n    let lh = 3 * (lf + lg);\r\n    let lh_ = 3 * (lf_ + lg_) + 2 * abs(lh);\r\n    let li = ra + c0d2;\r\n    let _li = abs(li);\r\n    let li_ = ra_ + _c0d2 + _li;\r\n    let lj = 2 * c0c2 + c1c1;\r\n    let _lj = abs(lj);\r\n    let lj_ = 2 * _c0c2 + _c1c1 + _lj;\r\n    let lk = 2 * d0d2 + d1d1;\r\n    let _lk = abs(lk);\r\n    let lk_ = 2 * _d0d2 + _d1d1 + _lk;\r\n    let ll = vₓₓᵧ * lb;\r\n    let ll_ = vₓₓᵧ_ * _lb + _vₓₓᵧ * lb_ + abs(ll);\r\n    let lm = vₓᵧᵧ * lc;\r\n    let lm_ = vₓᵧᵧ_ * _lc + _vₓᵧᵧ * lc_ + abs(lm);\r\n    let ln = vₓᵧ * li;\r\n    let ln_ = vₓᵧ_ * _li + _vₓᵧ * li_ + abs(ln);\r\n    let lo = vₓₓ * lj;\r\n    let lo_ = vₓₓ_ * _lj + _vₓₓ * lj_ + abs(lo);\r\n    let lp = vᵧᵧ * lk;\r\n    let lp_ = vᵧᵧ_ * _lk + _vᵧᵧ * lk_ + abs(lp);\r\n    let lq = c2 * vₓ;\r\n    let lq_ = _c2 * vₓ_ + abs(lq);\r\n    let lr = d2 * vᵧ;\r\n    let lr_ = _d2 * vᵧ_ + abs(lr);\r\n    let ls = lq + lr;\r\n    let ls_ = lq_ + lr_ + abs(ls);\r\n    let lt = ll + lm;\r\n    let lt_ = ll_ + lm_ + abs(lt);\r\n    let lu = lh + ln;\r\n    let lu_ = lh_ + ln_ + abs(lu);\r\n    let lv = lo + lp;\r\n    let lv_ = lo_ + lp_ + abs(lv);\r\n    let lw = lt + lu;\r\n    let lw_ = lt_ + lu_ + abs(lw);\r\n    let lx = lv + ls;\r\n    let lx_ = lv_ + ls_ + abs(lx);\r\n    let v2 = lw + lx;\r\n    let v2_ = lw_ + lx_ + abs(v2);\r\n    //let rc = c1d0 + c0d1;\r\n    //let v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    let rc = c1d0 + c0d1;\r\n    let _rc = abs(rc);\r\n    let rc_ = _c1d0 + _c0d1 + _rc;\r\n    let rd = c0 * vₓₓᵧ;\r\n    let _rd = abs(rd);\r\n    let rd_ = _c0 * vₓₓᵧ_ + _rd;\r\n    let re = d0 * vₓᵧᵧ;\r\n    let _re = abs(re);\r\n    let re_ = _d0 * vₓᵧᵧ_ + _re;\r\n    let rf = rc + c1d0;\r\n    let _rf = abs(rf);\r\n    let rf_ = rc_ + _c1d0 + _rf;\r\n    let rg = rc + c0d1;\r\n    let _rg = abs(rg);\r\n    let rg_ = rc_ + _c0d1 + _rg;\r\n    let rx = c1 * c0c0;\r\n    let _rx = abs(rx);\r\n    let rx_ = _c1 * _c0c0 + _rx;\r\n    let rh = rx * vₓₓₓ;\r\n    let rh_ = rx_ * _vₓₓₓ + _rx * vₓₓₓ_ + abs(rh);\r\n    let ry = d1 * d0d0;\r\n    let _ry = abs(ry);\r\n    let ry_ = _d1 * _d0d0 + _ry;\r\n    let ri = ry * vᵧᵧᵧ;\r\n    let ri_ = ry_ * _vᵧᵧᵧ + _ry * vᵧᵧᵧ_ + abs(ri);\r\n    let rj = vₓᵧ * rc;\r\n    let rj_ = vₓᵧ_ * _rc + _vₓᵧ * rc_ + abs(rj);\r\n    let rk = c0c1 * vₓₓ;\r\n    let rk_ = _c0c1 * (_vₓₓ + vₓₓ_) + abs(rk);\r\n    let rl = d0d1 * vᵧᵧ;\r\n    let rl_ = _d0d1 * (_vᵧᵧ + vᵧᵧ_) + abs(rl);\r\n    let rm = rk + rl;\r\n    let rm_ = rk_ + rl_ + abs(rm);\r\n    let rn = c1 * vₓ;\r\n    let rn_ = _c1 * vₓ_ + abs(rn);\r\n    let ro = d1 * vᵧ;\r\n    let ro_ = _d1 * vᵧ_ + abs(ro);\r\n    let rp = rn + ro;\r\n    let rp_ = rn_ + ro_ + abs(rp);\r\n    let rq = rd * rf;\r\n    let rq_ = rd_ * _rf + _rd * rf_ + abs(rq);\r\n    let rr = re * rg;\r\n    let rr_ = re_ * _rg + _re * rg_ + abs(rr);\r\n    let rs = rq + rr;\r\n    let rs_ = rq_ + rr_ + abs(rs);\r\n    let rt = 3 * (rh + ri);\r\n    let rt_ = 3 * (rh_ + ri_) + 2 * abs(rt);\r\n    let ru = rj + 2 * rm;\r\n    let ru_ = rj_ + 2 * rm_ + abs(ru);\r\n    let rv = rs + rt;\r\n    let rv_ = rs_ + rt_ + abs(rv);\r\n    let rw = ru + rp;\r\n    let rw_ = ru_ + rp_ + abs(rw);\r\n    let v1 = rv + rw;\r\n    let v1_ = rv_ + rw_ + abs(v1);\r\n    // v0\r\n    let t1 = c0 * vₓₓₓ;\r\n    let t1_ = _c0 * vₓₓₓ_ + abs(t1);\r\n    let t2 = d0 * vₓₓᵧ;\r\n    let t2_ = _d0 * vₓₓᵧ_ + abs(t2);\r\n    let p4 = t1 + t2;\r\n    let p4_ = t1_ + t2_ + abs(p4);\r\n    let t3 = c0 * vₓᵧᵧ;\r\n    let t3_ = _c0 * vₓᵧᵧ_ + abs(t3);\r\n    let t4 = d0 * vᵧᵧᵧ;\r\n    let t4_ = _d0 * vᵧᵧᵧ_ + abs(t4);\r\n    let p5 = t3 + t4;\r\n    let p5_ = t3_ + t4_ + abs(p5);\r\n    let p7 = p4 + vₓₓ;\r\n    let _p7 = abs(p7);\r\n    let p7_ = p4_ + vₓₓ_ + _p7;\r\n    let p8 = p5 + vᵧᵧ;\r\n    let _p8 = abs(p8);\r\n    let p8_ = p5_ + vᵧᵧ_ + _p8;\r\n    let pc = c0c0 * p7;\r\n    let pc_ = _c0c0 * (_p7 + p7_) + abs(pc);\r\n    let pd = d0d0 * p8;\r\n    let pd_ = _d0d0 * (_p8 + p8_) + abs(pd);\r\n    let p6 = pc + pd;\r\n    let p6_ = pc_ + pd_ + abs(p6);\r\n    let pe = c0d0 * vₓᵧ;\r\n    let pe_ = _c0d0 * (_vₓᵧ + vₓᵧ_) + abs(pe);\r\n    let p9 = p6 + pe;\r\n    let p9_ = p6_ + pe_ + abs(p9);\r\n    let pf = c0 * vₓ;\r\n    let pf_ = _c0 * vₓ_ + abs(pf);\r\n    let pg = d0 * vᵧ;\r\n    let pg_ = _d0 * vᵧ_ + abs(pg);\r\n    let pa = pf + pg;\r\n    let pa_ = pf_ + pg_ + abs(pa);\r\n    let pb = p9 + pa;\r\n    let pb_ = p9_ + pa_ + abs(pb);\r\n    let v0 = pb + v;\r\n    let v0_ = pb_ + v_ + abs(v0);\r\n    return {\r\n        coeffs: [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [v9_, v8_, v7_, v6_, v5_, v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs3x3 = getCoeffs3x3;\r\n//# sourceMappingURL=get-coefficients-3x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/naive/get-coefficients-3x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x1.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x1.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs1x1Quad(ps1, ps2) {\r\n    let { coeffs: { vₓ, vᵧ, v } // vₓ, vᵧ, v:  48-bit aligned => error free\r\n     } = get_implicit_form1_1.getImplicitForm1Quad(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p1 = tp(c1, vₓ); // vₓ is a double => error free\r\n    let p2 = tp(d1, vᵧ); // vᵧ is a double => error free\r\n    let v1 = qaq(p1, p2); // 48-bit aligned => error free\r\n    //let v0 = c0*vₓ + d0*vᵧ + v_0;\r\n    let p3 = tp(c0, vₓ); // vₓ is a double => error free\r\n    let p4 = tp(d0, vᵧ); // vᵧ is a double => error free\r\n    let p5 = qaq(p3, p4); // 48-bit aligned => error free\r\n    let v0 = qaq(p5, v); // 48-bit aligned => error free \r\n    return {\r\n        coeffs: [v1, v0],\r\n        errBound: [0, 0] // 48-bit aligned => completely error free\r\n    };\r\n}\r\nexports.getCoeffs1x1Quad = getCoeffs1x1Quad;\r\n//# sourceMappingURL=get-coefficients-1x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x2.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x2.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs1x2Quad(ps1, ps2) {\r\n    let { coeffs: { vₓ, vᵧ, v } // vₓ, vᵧ, v:  48-bit aligned => error free\r\n     } = get_implicit_form1_1.getImplicitForm1Quad(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a2*v_x + b2*v_y\r\n    //let v2 = c2*vₓ + d2*vᵧ;\r\n    let p1 = tp(c2, vₓ); // vₓ is a double => error free\r\n    let p2 = tp(d2, vᵧ); // vᵧ is a double => error free\r\n    let v2 = qaq(p1, p2); // 48-bit aligned => error free\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p3 = tp(c1, vₓ); // vₓ is a double => error free\r\n    let p4 = tp(d1, vᵧ); // vᵧ is a double => error free\r\n    let v1 = qaq(p3, p4); // 48-bit aligned => error free\r\n    // a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p5 = tp(c0, vₓ); // vₓ is a double => error free\r\n    let p6 = tp(d0, vᵧ); // vᵧ is a double => error free\r\n    let p7 = qaq(p5, p6); // 48-bit aligned => error free\r\n    let v0 = qaq(p7, v); // 48-bit aligned => error free\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [0, 0, 0] // 48-bit aligned => completely error free\r\n    };\r\n}\r\nexports.getCoeffs1x2Quad = getCoeffs1x2Quad;\r\n//# sourceMappingURL=get-coefficients-1x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x3.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x3.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs1x3Quad(ps1, ps2) {\r\n    let { coeffs: { vₓ, vᵧ, v } // vₓ, vᵧ, v:  48-bit aligned => error free\r\n     } = get_implicit_form1_1.getImplicitForm1Quad(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    // a3*v_x + b3*v_y\r\n    //let v3 = c3*vₓ + d3*vᵧ;\r\n    let p1 = tp(c3, vₓ); // vₓ is a double => error free\r\n    let p2 = tp(d3, vᵧ); // vᵧ is a double => error free\r\n    let v3 = qaq(p1, p2); // 48-bit aligned => error free\r\n    // a2*v_x + b2*v_y\r\n    //let v2 = c2*vₓ + d2*vᵧ;\r\n    let p3 = tp(c2, vₓ); // vₓ is a double => error free\r\n    let p4 = tp(d2, vᵧ); // vᵧ is a double => error free\r\n    let v2 = qaq(p3, p4); // 48-bit aligned => error free\r\n    // a1*v_x + b1*v_y\r\n    //let v1 = c1*vₓ + d1*vᵧ;\r\n    let p5 = tp(c1, vₓ); // vₓ is a double => error free\r\n    let p6 = tp(d1, vᵧ); // vᵧ is a double => error free\r\n    let v1 = qaq(p5, p6); // 48-bit aligned => error free\r\n    // a0*v_x + b0*v_y + v_0\r\n    //let v0 = c0*vₓ + d0*vᵧ + v;\r\n    let p7 = tp(c0, vₓ); // vₓ is a double => error free\r\n    let p8 = tp(d0, vᵧ); // vᵧ is a double => error free\r\n    let p9 = qaq(p7, p8); // 48-bit aligned => error free\r\n    let v0 = qaq(p9, v); // 48-bit aligned => error free\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [0, 0, 0, 0] // 48-bit aligned => completely error free\r\n    };\r\n}\r\nexports.getCoeffs1x3Quad = getCoeffs1x3Quad;\r\n//# sourceMappingURL=get-coefficients-1x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-1x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x1.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x1.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs2x1Quad(ps1, ps2) {\r\n    let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓ_, vᵧ_, v_ } // vₓₓ_, vₓᵧ_, vᵧᵧ_ === 0\r\n     } = get_implicit_form2_1.getImplicitForm2Quad(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    let $vₓₓ = vₓₓ[1];\r\n    let $vₓᵧ = vₓᵧ[1];\r\n    let $vᵧᵧ = vᵧᵧ[1];\r\n    let $vₓ = vₓ[1];\r\n    let $vᵧ = vᵧ[1];\r\n    let $v = v[1];\r\n    let $c0c0 = c0 * c0;\r\n    let $c0c1 = c0 * c1;\r\n    let $c0d0 = c0 * d0;\r\n    let $c0d1 = c0 * d1;\r\n    let $c1c1 = c1 * c1;\r\n    let $c1d0 = c1 * d0;\r\n    let $c1d1 = c1 * d1;\r\n    let $d0d0 = d0 * d0;\r\n    let $d0d1 = d0 * d1;\r\n    let $d1d1 = d1 * d1;\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d1d1 = tp(d1, d1);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\r\n    let $p1 = $c1c1 * $vₓₓ;\r\n    let p1 = qmq(c1c1, vₓₓ);\r\n    let p1_ = 2 * abs($p1);\r\n    let $p2 = $d1d1 * $vᵧᵧ;\r\n    let p2 = qmq(d1d1, vᵧᵧ);\r\n    let p2_ = 2 * abs($p2);\r\n    let $p3 = $c1d1 * $vₓᵧ;\r\n    let p3 = qmq(c1d1, vₓᵧ);\r\n    let p3_ = 2 * abs($p3);\r\n    let $p4 = $p1 + $p2;\r\n    let p4 = qaq(p1, p2);\r\n    let p4_ = p1_ + p2_ + abs($p4);\r\n    let $v2 = $p4 + $p3;\r\n    let v2 = qaq(p4, p3);\r\n    let v2_ = p4_ + p3_ + abs($v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\r\n    let $p5 = $c0c1 * $vₓₓ;\r\n    let p5 = qmq(c0c1, vₓₓ);\r\n    let p5_ = 2 * abs($p5);\r\n    let $p6 = $d0d1 * $vᵧᵧ;\r\n    let p6 = qmq(d0d1, vᵧᵧ);\r\n    let p6_ = 2 * abs($p6);\r\n    let $p7 = $c0d1 + $c1d0;\r\n    let p7 = qaq(c0d1, c1d0); // 48-bit aligned => error free\r\n    let $pn = $p7 * $vₓᵧ;\r\n    let pn = qmq(p7, vₓᵧ);\r\n    let pn_ = 2 * abs($pn);\r\n    let $p8 = 2 * ($p5 + $p6);\r\n    let p8 = qm2(qaq(p5, p6));\r\n    let p8_ = 2 * (p5_ + p6_) + abs($p8);\r\n    let $p9 = $p8 + $pn;\r\n    let p9 = qaq(p8, pn);\r\n    let p9_ = p8_ + pn_ + abs($p9);\r\n    let $pa = c1 * $vₓ;\r\n    let pa = qmd(c1, vₓ);\r\n    let pa_ = _c1 * vₓ_ + abs($pa);\r\n    let $pb = d1 * $vᵧ;\r\n    let pb = qmd(d1, vᵧ);\r\n    let pb_ = _d1 * vᵧ_ + abs($pb);\r\n    let $pc = $pa + $pb;\r\n    let pc = qaq(pa, pb);\r\n    let pc_ = pa_ + pb_ + abs($pc);\r\n    let $v1 = $p9 + $pc;\r\n    let v1 = qaq(p9, pc);\r\n    let v1_ = p9_ + pc_ + abs($v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\r\n    let $pe = $c0c0 * $vₓₓ;\r\n    let pe = qmq(c0c0, vₓₓ);\r\n    let pe_ = 2 * abs($pe);\r\n    let $pf = $c0d0 * $vₓᵧ;\r\n    let pf = qmq(c0d0, vₓᵧ);\r\n    let pf_ = 2 * abs($pf);\r\n    let $pg = $d0d0 * $vᵧᵧ;\r\n    let pg = qmq(d0d0, vᵧᵧ);\r\n    let pg_ = 2 * abs($pg);\r\n    let $ph = $pe + $pf;\r\n    let ph = qaq(pe, pf);\r\n    let ph_ = pe_ + pf_ + abs($ph);\r\n    let $pi = $ph + $pg;\r\n    let pi = qaq(ph, pg);\r\n    let pi_ = ph_ + pg_ + abs($pi);\r\n    let $pj = c0 * $vₓ;\r\n    let pj = qmd(c0, vₓ);\r\n    let pj_ = _c0 * vₓ_ + abs($pj);\r\n    let $pk = d0 * $vᵧ;\r\n    let pk = qmd(d0, vᵧ);\r\n    let pk_ = _d0 * vᵧ_ + abs($pk);\r\n    let $pl = $pj + $pk;\r\n    let pl = qaq(pj, pk);\r\n    let pl_ = pj_ + pk_ + abs($pl);\r\n    let $pm = $pi + $pl;\r\n    let pm = qaq(pi, pl);\r\n    let pm_ = pi_ + pl_ + abs($pm);\r\n    let $v0 = $pm + $v;\r\n    let v0 = qaq(pm, v);\r\n    let v0_ = pm_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [v2_, v1_, v0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs2x1Quad = getCoeffs2x1Quad;\r\n//# sourceMappingURL=get-coefficients-2x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x2.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x2.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs2x2Quad(ps1, ps2) {\r\n    let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓ_, vᵧ_, v_ } // vₓₓ_, vₓᵧ_, vᵧᵧ_ === 0\r\n     } = get_implicit_form2_1.getImplicitForm2Quad(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let $vₓₓ = vₓₓ[1];\r\n    let $vₓᵧ = vₓᵧ[1];\r\n    let $vᵧᵧ = vᵧᵧ[1];\r\n    let $vₓ = vₓ[1];\r\n    let $vᵧ = vᵧ[1];\r\n    let $v = v[1];\r\n    let $c0c0 = c0 * c0;\r\n    let $c0c1 = c0 * c1;\r\n    let $c0c2 = c0 * c2;\r\n    let $c0d0 = c0 * d0;\r\n    let $c0d1 = c0 * d1;\r\n    let $c0d2 = c0 * d2;\r\n    let $c1c1 = c1 * c1;\r\n    let $c1c2 = c1 * c2;\r\n    let $c1d0 = c1 * d0;\r\n    let $c1d1 = c1 * d1;\r\n    let $c1d2 = c1 * d2;\r\n    let $c2d1 = c2 * d1;\r\n    let $c2c2 = c2 * c2;\r\n    let $c2d0 = c2 * d0;\r\n    let $c2d2 = c2 * d2;\r\n    let $d0d0 = d0 * d0;\r\n    let $d0d1 = d0 * d1;\r\n    let $d0d2 = d0 * d2;\r\n    let $d1d1 = d1 * d1;\r\n    let $d1d2 = d1 * d2;\r\n    let $d2d2 = d2 * d2;\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d2d2 = tp(d2, d2);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _c2 = abs(c2);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let _d2 = abs(d2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //let v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    let $p1 = $c2c2 * $vₓₓ;\r\n    let p1 = qmq(c2c2, vₓₓ);\r\n    let p1_ = 2 * abs($p1);\r\n    let $p2 = $c2d2 * $vₓᵧ;\r\n    let p2 = qmq(c2d2, vₓᵧ);\r\n    let p2_ = 2 * abs($p2);\r\n    let $p3 = $d2d2 * $vᵧᵧ;\r\n    let p3 = qmq(d2d2, vᵧᵧ);\r\n    let p3_ = 2 * abs($p3);\r\n    let $p4 = $p1 + $p2;\r\n    let p4 = qaq(p1, p2);\r\n    let p4_ = p1_ + p2_ + abs($p4);\r\n    let $v4 = $p4 + $p3;\r\n    let v4 = qaq(p4, p3);\r\n    let v4_ = p4_ + p3_ + abs($v4);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //let v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    let $p5 = $c1c2 * $vₓₓ;\r\n    let p5 = qmq(c1c2, vₓₓ);\r\n    let p5_ = 2 * abs($p5);\r\n    let $p6 = $d1d2 * $vᵧᵧ;\r\n    let p6 = qmq(d1d2, vᵧᵧ);\r\n    let p6_ = 2 * abs($p6);\r\n    let $p7 = $c1d2 + $c2d1;\r\n    let p7 = qaq(c1d2, c2d1); // 48-bit aligned => error free\r\n    let $p8 = $p7 * $vₓᵧ;\r\n    let p8 = qmq(p7, vₓᵧ);\r\n    let p8_ = 2 * abs($p8);\r\n    let $p9 = 2 * ($p5 + $p6);\r\n    let p9 = qm2(qaq(p5, p6));\r\n    let p9_ = 2 * (p5_ + p6_) + abs($p9);\r\n    let $v3 = $p9 + $p8;\r\n    let v3 = qaq(p9, p8);\r\n    let v3_ = p9_ + p8_ + abs($v3);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //let v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    let $pa = 2 * $c0c2 + $c1c1;\r\n    let pa = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let $pb = 2 * $d0d2 + $d1d1;\r\n    let pb = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let $pc = $c0d2 + $c1d1;\r\n    let pc = qaq(c0d2, c1d1); // 48-bit aligned => error free\r\n    let $pd = $pc + $c2d0;\r\n    let pd = qaq(pc, c2d0); // 48-bit aligned => error free\r\n    let $pe = $pa * $vₓₓ;\r\n    let pe = qmq(pa, vₓₓ);\r\n    let pe_ = 2 * abs($pe);\r\n    let $pf = $pb * $vᵧᵧ;\r\n    let pf = qmq(pb, vᵧᵧ);\r\n    let pf_ = 2 * abs($pf);\r\n    let $pg = $pd * $vₓᵧ;\r\n    let pg = qmq(pd, vₓᵧ);\r\n    let pg_ = 2 * abs($pg);\r\n    let $ph = c2 * $vₓ;\r\n    let ph = qmd(c2, vₓ);\r\n    let ph_ = _c2 * vₓ_ + abs($ph);\r\n    let $pi = d2 * $vᵧ;\r\n    let pi = qmd(d2, vᵧ);\r\n    let pi_ = _d2 * vᵧ_ + abs($pi);\r\n    let $pj = $pe + $pf;\r\n    let pj = qaq(pe, pf);\r\n    let pj_ = pe_ + pf_ + abs($pj);\r\n    let $pk = $pj + $pg;\r\n    let pk = qaq(pj, pg);\r\n    let pk_ = pj_ + pg_ + abs($pk);\r\n    let $pl = $ph + $pi;\r\n    let pl = qaq(ph, pi);\r\n    let pl_ = ph_ + pi_ + abs($pl);\r\n    let $v2 = $pk + $pl;\r\n    let v2 = qaq(pk, pl);\r\n    let v2_ = pk_ + pl_ + abs($v2);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    let $pm = $c0c1 * $vₓₓ;\r\n    let pm = qmq(c0c1, vₓₓ);\r\n    let pm_ = 2 * abs($pm);\r\n    let $pn = $d0d1 * $vᵧᵧ;\r\n    let pn = qmq(d0d1, vᵧᵧ);\r\n    let pn_ = 2 * abs($pn);\r\n    let $po = $c0d1 + $c1d0;\r\n    let po = qaq(c0d1, c1d0); // 48-bit aligned => error free\r\n    let $pp = $po * $vₓᵧ;\r\n    let pp = qmq(po, vₓᵧ);\r\n    let pp_ = 2 * abs($pp);\r\n    let $pq = 2 * ($pm + $pn);\r\n    let pq = qm2(qaq(pm, pn));\r\n    let pq_ = 2 * (pm_ + pn_) + abs($pq);\r\n    let $pr = c1 * $vₓ;\r\n    let pr = qmd(c1, vₓ);\r\n    let pr_ = _c1 * vₓ_ + abs($pr);\r\n    let $ps = d1 * $vᵧ;\r\n    let ps = qmd(d1, vᵧ);\r\n    let ps_ = _d1 * vᵧ_ + abs($ps);\r\n    let $pt = $pq + $pp;\r\n    let pt = qaq(pq, pp);\r\n    let pt_ = pq_ + pp_ + abs($pt);\r\n    let $pu = $pr + $ps;\r\n    let pu = qaq(pr, ps);\r\n    let pu_ = pr_ + ps_ + abs($pu);\r\n    let $v1 = $pt + $pu;\r\n    let v1 = qaq(pt, pu);\r\n    let v1_ = pt_ + pu_ + abs($v1);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    let $pv = $c0c0 * $vₓₓ;\r\n    let pv = qmq(c0c0, vₓₓ);\r\n    let pv_ = 2 * abs($pv);\r\n    let $pw = $c0d0 * $vₓᵧ;\r\n    let pw = qmq(c0d0, vₓᵧ);\r\n    let pw_ = 2 * abs($pw);\r\n    let $px = $d0d0 * $vᵧᵧ;\r\n    let px = qmq(d0d0, vᵧᵧ);\r\n    let px_ = 2 * abs($px);\r\n    let $py = c0 * $vₓ;\r\n    let py = qmd(c0, vₓ);\r\n    let py_ = _c0 * vₓ_ + abs($py);\r\n    let $pz = d0 * $vᵧ;\r\n    let pz = qmd(d0, vᵧ);\r\n    let pz_ = _d0 * vᵧ_ + abs($pz);\r\n    let $q1 = $pv + $pw;\r\n    let q1 = qaq(pv, pw);\r\n    let q1_ = pv_ + pw_ + abs($q1);\r\n    let $q2 = $q1 + $px;\r\n    let q2 = qaq(q1, px);\r\n    let q2_ = q1_ + px_ + abs($q2);\r\n    let $q3 = $py + $pz;\r\n    let q3 = qaq(py, pz);\r\n    let q3_ = py_ + pz_ + abs($q3);\r\n    let $q4 = $q2 + $q3;\r\n    let q4 = qaq(q2, q3);\r\n    let q4_ = q2_ + q3_ + abs($q4);\r\n    let $v0 = $q4 + $v;\r\n    let v0 = qaq(q4, v);\r\n    let v0_ = q4_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v4, v3, v2, v1, v0],\r\n        errBound: [v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs2x2Quad = getCoeffs2x2Quad;\r\n//# sourceMappingURL=get-coefficients-2x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x3.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x3.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs2x3Quad(ps1, ps2) {\r\n    let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓ_, vᵧ_, v_ } // vₓₓ_, vₓᵧ_, vᵧᵧ_ === 0\r\n     } = get_implicit_form2_1.getImplicitForm2Quad(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let $vₓₓ = vₓₓ[1];\r\n    let $vₓᵧ = vₓᵧ[1];\r\n    let $vᵧᵧ = vᵧᵧ[1];\r\n    let $vₓ = vₓ[1];\r\n    let $vᵧ = vᵧ[1];\r\n    let $v = v[1];\r\n    let $c0c0 = c0 * c0;\r\n    let $c0c1 = c0 * c1;\r\n    let $c0c2 = c0 * c2;\r\n    let $c0c3 = c0 * c3;\r\n    let $c0d0 = c0 * d0;\r\n    let $c0d1 = c0 * d1;\r\n    let $c0d2 = c0 * d2;\r\n    let $c0d3 = c0 * d3;\r\n    let $c1c1 = c1 * c1;\r\n    let $c1c2 = c1 * c2;\r\n    let $c1c3 = c1 * c3;\r\n    let $c1d0 = c1 * d0;\r\n    let $c1d1 = c1 * d1;\r\n    let $c1d2 = c1 * d2;\r\n    let $c1d3 = c1 * d3;\r\n    let $c2d1 = c2 * d1;\r\n    let $c2c2 = c2 * c2;\r\n    let $c2c3 = c2 * c3;\r\n    let $c2d0 = c2 * d0;\r\n    let $c2d2 = c2 * d2;\r\n    let $c2d3 = c2 * d3;\r\n    let $c3c3 = c3 * c3;\r\n    let $c3d0 = c3 * d0;\r\n    let $c3d1 = c3 * d1;\r\n    let $c3d2 = c3 * d2;\r\n    let $c3d3 = c3 * d3;\r\n    let $d0d0 = d0 * d0;\r\n    let $d0d1 = d0 * d1;\r\n    let $d0d2 = d0 * d2;\r\n    let $d0d3 = d0 * d3;\r\n    let $d1d1 = d1 * d1;\r\n    let $d1d2 = d1 * d2;\r\n    let $d3d3 = d3 * d3;\r\n    let $d2d2 = d2 * d2;\r\n    let $d2d3 = d2 * d3;\r\n    let $d1d3 = d1 * d3;\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0c3 = tp(c0, c3);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c0d3 = tp(c0, d3);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1c3 = tp(c1, c3);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c1d3 = tp(c1, d3);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2c3 = tp(c2, c3);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let c2d3 = tp(c2, d3);\r\n    let c3c3 = tp(c3, c3);\r\n    let c3d0 = tp(c3, d0);\r\n    let c3d1 = tp(c3, d1);\r\n    let c3d2 = tp(c3, d2);\r\n    let c3d3 = tp(c3, d3);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d0d3 = tp(d0, d3);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d3d3 = tp(d3, d3);\r\n    let d2d2 = tp(d2, d2);\r\n    let d2d3 = tp(d2, d3);\r\n    let d1d3 = tp(d1, d3);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _c2 = abs(c2);\r\n    let _c3 = abs(c3);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let _d2 = abs(d2);\r\n    let _d3 = abs(d3);\r\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\r\n    //let v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    let $p1 = $c3c3 * $vₓₓ;\r\n    let p1 = qmq(c3c3, vₓₓ);\r\n    let p1_ = 2 * abs($p1);\r\n    let $p2 = $c3d3 * $vₓᵧ;\r\n    let p2 = qmq(c3d3, vₓᵧ);\r\n    let p2_ = 2 * abs($p2);\r\n    let $p3 = $d3d3 * $vᵧᵧ;\r\n    let p3 = qmq(d3d3, vᵧᵧ);\r\n    let p3_ = 2 * abs($p3);\r\n    let $p4 = $p1 + $p2;\r\n    let p4 = qaq(p1, p2);\r\n    let p4_ = p1_ + p2_ + abs($p4);\r\n    let $v6 = $p4 + $p3;\r\n    let v6 = qaq(p4, p3);\r\n    let v6_ = p4_ + p3_ + abs($v6);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //let v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    vₓᵧ*(c2d3 + c3d2);\r\n    let $p5 = $c2c3 * $vₓₓ;\r\n    let p5 = qmq(c2c3, vₓₓ);\r\n    let p5_ = 2 * abs($p5);\r\n    let $p6 = $d2d3 * $vᵧᵧ;\r\n    let p6 = qmq(d2d3, vᵧᵧ);\r\n    let p6_ = 2 * abs($p6);\r\n    let $p7 = $p5 + $p6;\r\n    let p7 = qaq(p5, p6);\r\n    let p7_ = p5_ + p6_ + abs($p7);\r\n    let $p8 = $c2d3 + $c3d2;\r\n    let p8 = qaq(c2d3, c3d2); // 48-bit aligned => error free\r\n    let $p9 = $p8 * $vₓᵧ;\r\n    let p9 = qmq(p8, vₓᵧ);\r\n    let p9_ = 2 * abs($p9);\r\n    let $v5 = 2 * $p7 + $p9;\r\n    let v5 = qaq(qm2(p7), p9);\r\n    let v5_ = 2 * p7_ + p9_ + abs($v5);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //let v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    let $pa = 2 * $c1c3 + $c2c2;\r\n    let pa = qaq(qm2(c1c3), c2c2); // 48-bit aligned => error free\r\n    let $pb = 2 * $d1d3 + $d2d2;\r\n    let pb = qaq(qm2(d1d3), d2d2); // 48-bit aligned => error free\r\n    let $pc = $c1d3 + $c2d2;\r\n    let pc = qaq(c1d3, c2d2); // 48-bit aligned => error free\r\n    let $pd = $pc + $c3d1;\r\n    let pd = qaq(pc, c3d1); // 48-bit aligned => error free\r\n    let $pe = $pa * $vₓₓ;\r\n    let pe = qmq(pa, vₓₓ);\r\n    let pe_ = 2 * abs($pe);\r\n    let $pf = $pb * $vᵧᵧ;\r\n    let pf = qmq(pb, vᵧᵧ);\r\n    let pf_ = 2 * abs($pf);\r\n    let $pg = $pe + $pf;\r\n    let pg = qaq(pe, pf);\r\n    let pg_ = pe_ + pf_ + abs($pg);\r\n    let $rp = $pd * $vₓᵧ;\r\n    let rp = qmq(pd, vₓᵧ);\r\n    let rp_ = 2 * abs($rp);\r\n    let $v4 = $pg + $rp;\r\n    let v4 = qaq(pg, rp);\r\n    let v4_ = pg_ + rp_ + abs($v4);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //let v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    let $ph = $c0c3 + $c1c2;\r\n    let ph = qaq(c0c3, c1c2); // 48-bit aligned => error free\r\n    let $pi = $d0d3 + $d1d2;\r\n    let pi = qaq(d0d3, d1d2); // 48-bit aligned => error free\r\n    let $pj = $c0d3 + $c1d2;\r\n    let pj = qaq(c0d3, c1d2); // 48-bit aligned => error free\r\n    let $pk = $c2d1 + $c3d0;\r\n    let pk = qaq(c2d1, c3d0); // 48-bit aligned => error free\r\n    let $pl = $pj + $pk;\r\n    let pl = qaq(pj, pk); // 48-bit aligned => error free\r\n    let $pm = $ph * $vₓₓ;\r\n    let pm = qmq(ph, vₓₓ);\r\n    let pm_ = 2 * abs($pm);\r\n    let $pn = $pi * $vᵧᵧ;\r\n    let pn = qmq(pi, vᵧᵧ);\r\n    let pn_ = 2 * abs($pn);\r\n    let $po = 2 * ($pm + $pn);\r\n    let po = qm2(qaq(pm, pn));\r\n    let po_ = 2 * (pm_ + pn_) + abs($po);\r\n    let $pp = $pl * $vₓᵧ;\r\n    let pp = qmq(pl, vₓᵧ);\r\n    let pp_ = 2 * abs($pp);\r\n    let $rn = c3 * $vₓ;\r\n    let rn = qmd(c3, vₓ);\r\n    let rn_ = _c3 * vₓ_ + abs($rn);\r\n    let $ro = d3 * $vᵧ;\r\n    let ro = qmd(d3, vᵧ);\r\n    let ro_ = _d3 * vᵧ_ + abs($ro);\r\n    let $pq = $rn + $ro;\r\n    let pq = qaq(rn, ro);\r\n    let pq_ = rn_ + ro_ + abs($pq);\r\n    let $pr = $po + $pp;\r\n    let pr = qaq(po, pp);\r\n    let pr_ = po_ + pp_ + abs($pr);\r\n    let $v3 = $pr + $pq;\r\n    let v3 = qaq(pr, pq);\r\n    let v3_ = pr_ + pq_ + abs($v3);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //let v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    let $ps = 2 * $c0c2 + $c1c1;\r\n    let ps = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let $pt = 2 * $d0d2 + $d1d1;\r\n    let pt = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let $pu = $c0d2 + $c1d1;\r\n    let pu = qaq(c0d2, c1d1); // 48-bit aligned => error free\r\n    let $pv = $pu + $c2d0;\r\n    let pv = qaq(pu, c2d0); // 48-bit aligned => error free\r\n    let $pw = $ps * $vₓₓ;\r\n    let pw = qmq(ps, vₓₓ);\r\n    let pw_ = 2 * abs($pw);\r\n    let $px = $pt * $vᵧᵧ;\r\n    let px = qmq(pt, vᵧᵧ);\r\n    let px_ = 2 * abs($px);\r\n    let $py = $pv * $vₓᵧ;\r\n    let py = qmq(pv, vₓᵧ);\r\n    let py_ = 2 * abs($py);\r\n    let $pz = $pw + $px;\r\n    let pz = qaq(pw, px);\r\n    let pz_ = pw_ + px_ + abs($pz);\r\n    let $r1 = $pz + $py;\r\n    let r1 = qaq(pz, py);\r\n    let r1_ = pz_ + py_ + abs($r1);\r\n    let $r2 = c2 * $vₓ;\r\n    let r2 = qmd(c2, vₓ);\r\n    let r2_ = _c2 * vₓ_ + abs($r2);\r\n    let $r3 = d2 * $vᵧ;\r\n    let r3 = qmd(d2, vᵧ);\r\n    let r3_ = _d2 * vᵧ_ + abs($r3);\r\n    let $r4 = $r2 + $r3;\r\n    let r4 = qaq(r2, r3);\r\n    let r4_ = r2_ + r3_ + abs($r4);\r\n    let $v2 = $r1 + $r4;\r\n    let v2 = qaq(r1, r4);\r\n    let v2_ = r1_ + r4_ + abs($v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //let v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    let $r5 = $c0c1 * $vₓₓ;\r\n    let r5 = qmq(c0c1, vₓₓ);\r\n    let r5_ = 2 * abs($r5);\r\n    let $r6 = $d0d1 * $vᵧᵧ;\r\n    let r6 = qmq(d0d1, vᵧᵧ);\r\n    let r6_ = 2 * abs($r6);\r\n    let $r7 = $c0d1 + $c1d0;\r\n    let r7 = qaq(c0d1, c1d0); // 48-bit aligned => error free\r\n    let $r8 = $r7 * $vₓᵧ;\r\n    let r8 = qmq(r7, vₓᵧ);\r\n    let r8_ = 2 * abs($r8);\r\n    let $r9 = 2 * ($r5 + $r6);\r\n    let r9 = qm2(qaq(r5, r6));\r\n    let r9_ = 2 * (r5_ + r6_) + abs($r9);\r\n    let $ra = $r9 + $r8;\r\n    let ra = qaq(r9, r8);\r\n    let ra_ = r9_ + r8_ + abs($ra);\r\n    let $rb = c1 * $vₓ;\r\n    let rb = qmd(c1, vₓ);\r\n    let rb_ = _c1 * vₓ_ + abs($rb);\r\n    let $rc = d1 * $vᵧ;\r\n    let rc = qmd(d1, vᵧ);\r\n    let rc_ = _d1 * vᵧ_ + abs($rc);\r\n    let $rd = $rb + $rc;\r\n    let rd = qaq(rb, rc);\r\n    let rd_ = rb_ + rc_ + abs($rd);\r\n    let $v1 = $ra + $rd;\r\n    let v1 = qaq(ra, rd);\r\n    let v1_ = ra_ + rd_ + abs($v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    let $re = $c0c0 * $vₓₓ;\r\n    let re = qmq(c0c0, vₓₓ);\r\n    let re_ = 2 * abs($re);\r\n    let $rf = $c0d0 * $vₓᵧ;\r\n    let rf = qmq(c0d0, vₓᵧ);\r\n    let rf_ = 2 * abs($rf);\r\n    let $rg = $d0d0 * $vᵧᵧ;\r\n    let rg = qmq(d0d0, vᵧᵧ);\r\n    let rg_ = 2 * abs($rg);\r\n    let $rh = c0 * $vₓ;\r\n    let rh = qmd(c0, vₓ);\r\n    let rh_ = _c0 * vₓ_ + abs($rh);\r\n    let $ri = d0 * $vᵧ;\r\n    let ri = qmd(d0, vᵧ);\r\n    let ri_ = _d0 * vᵧ_ + abs($ri);\r\n    let $rj = $re + $rf;\r\n    let rj = qaq(re, rf);\r\n    let rj_ = re_ + rf_ + abs($rj);\r\n    let $rk = $rj + $rg;\r\n    let rk = qaq(rj, rg);\r\n    let rk_ = rj_ + rg_ + abs($rk);\r\n    let $rl = $rh + $ri;\r\n    let rl = qaq(rh, ri);\r\n    let rl_ = rh_ + ri_ + abs($rl);\r\n    let $rm = $rk + $rl;\r\n    let rm = qaq(rk, rl);\r\n    let rm_ = rk_ + rl_ + abs($rm);\r\n    let $v0 = $rm + $v;\r\n    let v0 = qaq(rm, v);\r\n    let v0_ = rm_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [v6_, v5_, v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs2x3Quad = getCoeffs2x3Quad;\r\n//# sourceMappingURL=get-coefficients-2x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-2x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x1.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x1.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs3x1Quad(ps1, ps2) {\r\n    let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3Quad(ps1);\r\n    let [[c1, c0], [d1, d0]] = get_xy_1.getXY(ps2);\r\n    let $vₓₓₓ = vₓₓₓ[1];\r\n    let $vₓₓᵧ = vₓₓᵧ[1];\r\n    let $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    let $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    let $vₓₓ = vₓₓ[1];\r\n    let $vₓᵧ = vₓᵧ[1];\r\n    let $vᵧᵧ = vᵧᵧ[1];\r\n    let $vₓ = vₓ[1];\r\n    let $vᵧ = vᵧ[1];\r\n    let $v = v[1];\r\n    let $c0c0 = c0 * c0;\r\n    let $c0c1 = c0 * c1;\r\n    let $c0d0 = c0 * d0;\r\n    let $c0d1 = c0 * d1;\r\n    let $c1c1 = c1 * c1;\r\n    let $c1d0 = c1 * d0;\r\n    let $c1d1 = c1 * d1;\r\n    let $d0d0 = d0 * d0;\r\n    let $d0d1 = d0 * d1;\r\n    let $d1d1 = d1 * d1;\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d1d1 = tp(d1, d1);\r\n    let _c0c0 = abs($c0c0);\r\n    let _c0c1 = abs($c0c1);\r\n    let _c0d0 = abs($c0d0);\r\n    let _c0d1 = abs($c0d1);\r\n    let _c1c1 = abs($c1c1);\r\n    let _c1d0 = abs($c1d0);\r\n    let _c1d1 = abs($c1d1);\r\n    let _d0d0 = abs($d0d0);\r\n    let _d0d1 = abs($d0d1);\r\n    let _d1d1 = abs($d1d1);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let $z1 = c0 * $vₓₓₓ;\r\n    let z1 = qmd(c0, vₓₓₓ);\r\n    let z1_ = _c0 * vₓₓₓ_ + abs($z1);\r\n    let $z7 = (3 * c0) * $vₓₓₓ;\r\n    let z7 = qmd(3 * c0, vₓₓₓ); // 3*c0: 47-bit aligned => error free \r\n    let z7_ = 3 * _c0 * vₓₓₓ_ + abs($z7);\r\n    let $z2 = c0 * $vₓₓᵧ;\r\n    let z2 = qmd(c0, vₓₓᵧ);\r\n    let z2_ = _c0 * vₓₓᵧ_ + abs($z2);\r\n    let $z3 = d0 * $vₓₓᵧ;\r\n    let z3 = qmd(d0, vₓₓᵧ);\r\n    let z3_ = _d0 * vₓₓᵧ_ + abs($z3);\r\n    let $z4 = c0 * $vₓᵧᵧ;\r\n    let z4 = qmd(c0, vₓᵧᵧ);\r\n    let z4_ = _c0 * vₓᵧᵧ_ + abs($z4);\r\n    let $z5 = d0 * $vₓᵧᵧ;\r\n    let z5 = qmd(d0, vₓᵧᵧ);\r\n    let z5_ = _d0 * vₓᵧᵧ_ + abs($z5);\r\n    let $z6 = d0 * $vᵧᵧᵧ;\r\n    let z6 = qmd(d0, vᵧᵧᵧ);\r\n    let z6_ = _d0 * vᵧᵧᵧ_ + abs($z6);\r\n    let $z8 = (3 * d0) * $vᵧᵧᵧ;\r\n    let z8 = qmd(3 * d0, vᵧᵧᵧ);\r\n    let z8_ = 3 * _d0 * vᵧᵧᵧ_ + abs($z8);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //let v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    let $u1 = c1 * $vₓₓₓ;\r\n    let u1 = qmd(c1, vₓₓₓ);\r\n    let u1_ = _c1 * vₓₓₓ_ + abs($u1);\r\n    let $u2 = c1 * $vₓᵧᵧ;\r\n    let u2 = qmd(c1, vₓᵧᵧ);\r\n    let u2_ = _c1 * vₓᵧᵧ_ + abs($u2);\r\n    let $u3 = d1 * $vₓₓᵧ;\r\n    let u3 = qmd(d1, vₓₓᵧ);\r\n    let u3_ = _d1 * vₓₓᵧ_ + abs($u3);\r\n    let $u4 = d1 * $vᵧᵧᵧ;\r\n    let u4 = qmd(d1, vᵧᵧᵧ);\r\n    let u4_ = _d1 * vᵧᵧᵧ_ + abs($u4);\r\n    let $u5 = $u1 + $u3;\r\n    let u5 = qaq(u1, u3);\r\n    let _u5 = abs($u5);\r\n    let u5_ = u1_ + u3_ + _u5;\r\n    let $u6 = $u2 + $u4;\r\n    let u6 = qaq(u2, u4);\r\n    let _u6 = abs($u6);\r\n    let u6_ = u2_ + u4_ + _u6;\r\n    let $u7 = $c1c1 * $u5;\r\n    let u7 = qmq(c1c1, u5);\r\n    let u7_ = _c1c1 * u5_ + 2 * abs($u7);\r\n    let $u8 = $d1d1 * $u6;\r\n    let u8 = qmq(d1d1, u6);\r\n    let u8_ = _d1d1 * u6_ + 2 * abs($u8);\r\n    let $v3 = $u7 + $u8;\r\n    let v3 = qaq(u7, u8);\r\n    let v3_ = u7_ + u8_ + abs($v3);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //let v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //let v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    let $u9 = $z7 + $z3;\r\n    let u9 = qaq(z7, z3);\r\n    let u9_ = z7_ + z3_ + abs($u9);\r\n    let $ua = 2 * ($z2 + $z5);\r\n    let ua = qm2(qaq(z2, z5));\r\n    let ua_ = 2 * (z2_ + z5_) + abs($ua);\r\n    let $ub = $z4 + $z8;\r\n    let ub = qaq(z4, z8);\r\n    let ub_ = z4_ + z8_ + abs($ub);\r\n    let $uc = $u9 + $vₓₓ;\r\n    let uc = qaq(u9, vₓₓ);\r\n    let _uc = abs($uc);\r\n    let uc_ = u9_ + vₓₓ_ + _uc;\r\n    let $ud = $ua + $vₓᵧ;\r\n    let ud = qaq(ua, vₓᵧ);\r\n    let _ud = abs($ud);\r\n    let ud_ = ua_ + vₓᵧ_ + _ud;\r\n    let $ue = $ub + $vᵧᵧ;\r\n    let ue = qaq(ub, vᵧᵧ);\r\n    let _ue = abs($ue);\r\n    let ue_ = ub_ + vᵧᵧ_ + _ue;\r\n    let $uf = $c1c1 * $uc;\r\n    let uf = qmq(c1c1, uc);\r\n    let uf_ = _c1c1 * uc_ + 2 * abs($uf);\r\n    let $ug = $c1d1 * $ud;\r\n    let ug = qmq(c1d1, ud);\r\n    let ug_ = _c1d1 * ud_ + 2 * abs($ug);\r\n    let $uh = $d1d1 * $ue;\r\n    let uh = qmq(d1d1, ue);\r\n    let uh_ = _d1d1 * ue_ + 2 * abs($uh);\r\n    let $ui = $uf + $ug;\r\n    let ui = qaq(uf, ug);\r\n    let ui_ = uf_ + ug_ + abs($ui);\r\n    let $v2 = $ui + $uh;\r\n    let v2 = qaq(ui, uh);\r\n    let v2_ = ui_ + uh_ + abs($v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    let $uj = 2 * ($z3 + $vₓₓ);\r\n    let uj = qm2(qaq(z3, vₓₓ));\r\n    let uj_ = 2 * (z3_ + vₓₓ_) + abs($uj);\r\n    let $uk = 2 * ($z4 + $vᵧᵧ);\r\n    let uk = qm2(qaq(z4, vᵧᵧ));\r\n    let uk_ = 2 * (z4_ + vᵧᵧ_) + abs($uk);\r\n    let $un = $z7 + $uj;\r\n    let un = qaq(z7, uj);\r\n    let _un = abs($un);\r\n    let un_ = z7_ + uj_ + _un;\r\n    let $uo = $z8 + $uk;\r\n    let uo = qaq(z8, uk);\r\n    let _uo = abs($uo);\r\n    let uo_ = z8_ + uk_ + _uo;\r\n    let $up = $z2 + $vₓᵧ;\r\n    let up = qaq(z2, vₓᵧ);\r\n    let _up = abs($up);\r\n    let up_ = z2_ + vₓᵧ_ + _up;\r\n    let $uq = $z5 + $vₓᵧ;\r\n    let uq = qaq(z5, vₓᵧ);\r\n    let _uq = abs($uq);\r\n    let uq_ = z5_ + vₓᵧ_ + _uq;\r\n    let $ur = $c0c1 * $un;\r\n    let ur = qmq(c0c1, un);\r\n    let ur_ = _c0c1 * un_ + 2 * abs($ur);\r\n    let $us = $d0d1 * $uo;\r\n    let us = qmq(d0d1, uo);\r\n    let us_ = _d0d1 * uo_ + 2 * abs($us);\r\n    let $ut = $c0d1 * $up;\r\n    let ut = qmq(c0d1, up);\r\n    let ut_ = _c0d1 * up_ + 2 * abs($ut);\r\n    let $uu = $c1d0 * $uq;\r\n    let uu = qmq(c1d0, uq);\r\n    let uu_ = _c1d0 * uq_ + 2 * abs($uu);\r\n    let $uv = c1 * $vₓ;\r\n    let uv = qmd(c1, vₓ);\r\n    let uv_ = _c1 * vₓ_ + abs($uv);\r\n    let $uw = d1 * $vᵧ;\r\n    let uw = qmd(d1, vᵧ);\r\n    let uw_ = _d1 * vᵧ_ + abs($uw);\r\n    let $ux = $ur + $us;\r\n    let ux = qaq(ur, us);\r\n    let ux_ = ur_ + us_ + abs($ux);\r\n    let $uy = $ut + $uu;\r\n    let uy = qaq(ut, uu);\r\n    let uy_ = ut_ + uu_ + abs($uy);\r\n    let $uz = $ux + $uy;\r\n    let uz = qaq(ux, uy);\r\n    let uz_ = ux_ + uy_ + abs($uz);\r\n    let $u0 = $uv + $uw;\r\n    let u0 = qaq(uv, uw);\r\n    let u0_ = uv_ + uw_ + abs($u0);\r\n    let $v1 = $uz + $u0;\r\n    let v1 = qaq(uz, u0);\r\n    let v1_ = uz_ + u0_ + abs($v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //let v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    let $f1 = $z1 + $z3;\r\n    let f1 = qaq(z1, z3);\r\n    let f1_ = z1_ + z3_ + abs($f1);\r\n    let $f2 = $z6 + $z4;\r\n    let f2 = qaq(z6, z4);\r\n    let f2_ = z6_ + z4_ + abs($f2);\r\n    let $f3 = $f1 + $vₓₓ;\r\n    let f3 = qaq(f1, vₓₓ);\r\n    let _f3 = abs($f3);\r\n    let f3_ = f1_ + vₓₓ_ + _f3;\r\n    let $f4 = $f2 + $vᵧᵧ;\r\n    let f4 = qaq(f2, vᵧᵧ);\r\n    let _f4 = abs($f4);\r\n    let f4_ = f2_ + vᵧᵧ_ + _f4;\r\n    let $f5 = $c0c0 * $f3;\r\n    let f5 = qmq(c0c0, f3);\r\n    let f5_ = _c0c0 * f3_ + 2 * abs($f5);\r\n    let $f6 = $d0d0 * $f4;\r\n    let f6 = qmq(d0d0, f4);\r\n    let f6_ = _d0d0 * f4_ + 2 * abs($f6);\r\n    let $f7 = $c0d0 * $vₓᵧ;\r\n    let f7 = qmq(c0d0, vₓᵧ);\r\n    let f7_ = _c0d0 * vₓᵧ_ + 2 * abs($f7);\r\n    let $f8 = $f5 + $f6;\r\n    let f8 = qaq(f5, f6);\r\n    let f8_ = f5_ + f6_ + abs($f8);\r\n    let $f9 = $f8 + $f7;\r\n    let f9 = qaq(f8, f7);\r\n    let f9_ = f8_ + f7_ + abs($f9);\r\n    let $fa = c0 * $vₓ;\r\n    let fa = qmd(c0, vₓ);\r\n    let fa_ = _c0 * vₓ_ + abs($fa);\r\n    let $fb = d0 * $vᵧ;\r\n    let fb = qmd(d0, vᵧ);\r\n    let fb_ = _d0 * vᵧ_ + abs($fb);\r\n    let $fc = $fa + $fb;\r\n    let fc = qaq(fa, fb);\r\n    let fc_ = fa_ + fb_ + abs($fc);\r\n    let $fd = $f9 + $fc;\r\n    let fd = qaq(f9, fc);\r\n    let fd_ = f9_ + fc_ + abs($fd);\r\n    let $v0 = $fd + $v;\r\n    let v0 = qaq(fd, v);\r\n    let v0_ = fd_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [v3_, v2_, v1_, v0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs3x1Quad = getCoeffs3x1Quad;\r\n//# sourceMappingURL=get-coefficients-3x1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x2.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x2.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\nfunction getCoeffs3x2Quad(ps1, ps2) {\r\n    let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3Quad(ps1);\r\n    let [[c2, c1, c0], [d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let $vₓₓₓ = vₓₓₓ[1];\r\n    let $vₓₓᵧ = vₓₓᵧ[1];\r\n    let $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    let $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    let $vₓₓ = vₓₓ[1];\r\n    let $vₓᵧ = vₓᵧ[1];\r\n    let $vᵧᵧ = vᵧᵧ[1];\r\n    let $vₓ = vₓ[1];\r\n    let $vᵧ = vᵧ[1];\r\n    let $v = v[1];\r\n    let _vₓₓₓ = abs($vₓₓₓ);\r\n    let _vₓₓᵧ = abs($vₓₓᵧ);\r\n    let _vₓᵧᵧ = abs($vₓᵧᵧ);\r\n    let _vᵧᵧᵧ = abs($vᵧᵧᵧ);\r\n    let $c0c0 = c0 * c0;\r\n    let $c0c1 = c0 * c1;\r\n    let $c0c2 = c0 * c2;\r\n    let $c0d0 = c0 * d0;\r\n    let $c0d1 = c0 * d1;\r\n    let $c0d2 = c0 * d2;\r\n    let $c1c1 = c1 * c1;\r\n    let $c1c2 = c1 * c2;\r\n    let $c1d0 = c1 * d0;\r\n    let $c1d1 = c1 * d1;\r\n    let $c1d2 = c1 * d2;\r\n    let $c2d1 = c2 * d1;\r\n    let $c2c2 = c2 * c2;\r\n    let $c2d0 = c2 * d0;\r\n    let $c2d2 = c2 * d2;\r\n    let $d0d0 = d0 * d0;\r\n    let $d0d1 = d0 * d1;\r\n    let $d0d2 = d0 * d2;\r\n    let $d1d1 = d1 * d1;\r\n    let $d1d2 = d1 * d2;\r\n    let $d2d2 = d2 * d2;\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d2d2 = tp(d2, d2);\r\n    let _c0c0 = abs($c0c0);\r\n    let _c0c1 = abs($c0c1);\r\n    let _c0d0 = abs($c0d0);\r\n    let _c0d1 = abs($c0d1);\r\n    let _c1c2 = abs($c1c2);\r\n    let _c2c2 = abs($c2c2);\r\n    let _c2d2 = abs($c2d2);\r\n    let _c1d0 = abs($c1d0);\r\n    let _d0d0 = abs($d0d0);\r\n    let _d0d1 = abs($d0d1);\r\n    let _d1d2 = abs($d1d2);\r\n    let _d2d2 = abs($d2d2);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _c2 = abs(c2);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let _d2 = abs(d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //let v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    let e1 = qmd(c2, vₓₓₓ);\r\n    let $e1 = c2 * $vₓₓₓ;\r\n    let e1_ = _c2 * vₓₓₓ_ + abs($e1);\r\n    let e2 = qmd(c2, vₓᵧᵧ);\r\n    let $e2 = c2 * $vₓᵧᵧ;\r\n    let e2_ = _c2 * vₓᵧᵧ_ + abs($e2);\r\n    let e3 = qmd(d2, vₓₓᵧ);\r\n    let $e3 = d2 * $vₓₓᵧ;\r\n    let e3_ = _d2 * vₓₓᵧ_ + abs($e3);\r\n    let e4 = qmd(d2, vᵧᵧᵧ);\r\n    let $e4 = d2 * $vᵧᵧᵧ;\r\n    let e4_ = _d2 * vᵧᵧᵧ_ + abs($e4);\r\n    let $e5 = $e1 + $e3;\r\n    let e5 = qaq(e1, e3);\r\n    let _e5 = abs($e5);\r\n    let e5_ = e1_ + e3_ + _e5;\r\n    let $e6 = $e2 + $e4;\r\n    let e6 = qaq(e2, e4);\r\n    let _e6 = abs($e6);\r\n    let e6_ = e2_ + e4_ + _e6;\r\n    let $e7 = $c2c2 * $e5;\r\n    let e7 = qmq(c2c2, e5);\r\n    let e7_ = _c2c2 * e5_ + 2 * abs($e7);\r\n    let $e8 = $d2d2 * $e6;\r\n    let e8 = qmq(d2d2, e6);\r\n    let e8_ = _d2d2 * e6_ + 2 * abs($e8);\r\n    let $v6 = $e7 + $e8;\r\n    let v6 = qaq(e7, e8);\r\n    let v6_ = e7_ + e8_ + abs($v6);\r\n    let $z1 = $c0c2 + $c1c1;\r\n    let z1 = qaq(c0c2, c1c1); // 48-bit aligned => error free\r\n    let $z2 = $d0d2 + $d1d1;\r\n    let z2 = qaq(d0d2, d1d1); // 48-bit aligned => error free\r\n    let $z3 = 2 * $c0c2 + $c1c1;\r\n    let z3 = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let $z4 = 2 * $d0d2 + $d1d1;\r\n    let z4 = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let $z5 = 2 * $c1d1 + $c2d0;\r\n    let z5 = qaq(qm2(c1d1), c2d0); // 48-bit aligned => error free\r\n    let $z6 = 2 * $c1d1 + $c0d2;\r\n    let z6 = qaq(qm2(c1d1), c0d2); // 48-bit aligned => error free\r\n    let $z7 = 2 * $c2d0 + $c1d1;\r\n    let z7 = qaq(qm2(c2d0), c1d1); // 48-bit aligned => error free\r\n    let $z8 = 6 * $c0c2 + $c1c1;\r\n    let z8 = qaq(qmd(6, c0c2), c1c1); // 47-bit aligned => error free\r\n    let $z9 = 6 * $d0d2 + $d1d1;\r\n    let z9 = qaq(qmd(6, d0d2), d1d1); // 47-bit aligned => error free\r\n    let $za = $c1d2 + $c2d1;\r\n    let za = qaq(c1d2, c2d1); // 48-bit aligned => error free\r\n    let $zb = $c0d2 + $c2d0;\r\n    let zb = qaq(c0d2, c2d0); // 48-bit aligned => error free\r\n    let $zc = 2 * $c1d0 + $c0d1;\r\n    let zc = qaq(qm2(c1d0), c0d1); // 48-bit aligned => error free\r\n    let $zd = 2 * $c0d1 + $c1d0;\r\n    let zd = qaq(qm2(c0d1), c1d0); // 48-bit aligned => error free\r\n    let $zf = $c0d2 + $c1d1;\r\n    let zf = qaq(c0d2, c1d1); // 48-bit aligned => error free\r\n    let $ze = $zf + $c2d0;\r\n    let ze = qaq(zf, c2d0); // 48-bit aligned => error free\r\n    let _z3 = abs($z3);\r\n    let _z4 = abs($z4);\r\n    let _z5 = abs($z5);\r\n    let _za = abs($za);\r\n    let _ze = abs($ze);\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //let v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    let $s0 = 3 * $c2c2;\r\n    let s0 = qmd(3, c2c2); // 48-bit aligned => error free\r\n    let _s0 = abs($s0);\r\n    let $t1 = 3 * $d2d2;\r\n    let t1 = qmd(3, d2d2); // 48-bit aligned => error free\r\n    let _t1 = abs($t1);\r\n    let $s1 = $s0 * $vₓₓₓ;\r\n    let s1 = qmq(s0, vₓₓₓ);\r\n    let s1_ = _s0 * vₓₓₓ_ + 2 * abs($s1);\r\n    let $s2 = $c2c2 * $vₓₓᵧ;\r\n    let s2 = qmq(c2c2, vₓₓᵧ);\r\n    let s2_ = _c2c2 * vₓₓᵧ_ + 2 * abs($s2);\r\n    let $s3 = 2 * $c2d2 * $vₓₓᵧ;\r\n    let s3 = qm2(qmq(c2d2, vₓₓᵧ));\r\n    let s3_ = 2 * (_c2d2 * vₓₓᵧ_ + abs($s3));\r\n    let $s4 = 2 * $c2d2 * $vₓᵧᵧ;\r\n    let s4 = qm2(qmq(c2d2, vₓᵧᵧ));\r\n    let s4_ = 2 * (_c2d2 * vₓᵧᵧ_ + abs($s4));\r\n    let $s5 = $d2d2 * $vₓᵧᵧ;\r\n    let s5 = qmq(d2d2, vₓᵧᵧ);\r\n    let s5_ = _d2d2 * vₓᵧᵧ_ + 2 * abs($s5);\r\n    let $s6 = $t1 * $vᵧᵧᵧ;\r\n    let s6 = qmq(t1, vᵧᵧᵧ);\r\n    let s6_ = _t1 * vᵧᵧᵧ_ + 2 * abs($s6);\r\n    let $s7 = $s1 + $s3;\r\n    let s7 = qaq(s1, s3);\r\n    let s7_ = s1_ + s3_ + abs($s7);\r\n    let $s8 = $s2 + $s4;\r\n    let s8 = qaq(s2, s4);\r\n    let s8_ = s2_ + s4_ + abs($s8);\r\n    let $s9 = $s7 + $s5;\r\n    let s9 = qaq(s7, s5);\r\n    let s9_ = s7_ + s5_ + abs($s9);\r\n    let $sa = $s8 + $s6;\r\n    let sa = qaq(s8, s6);\r\n    let sa_ = s8_ + s6_ + abs($sa);\r\n    let $sb = c1 * $s9;\r\n    let sb = qmd(c1, s9);\r\n    let sb_ = _c1 * s9_ + abs($sb);\r\n    let $sc = d1 * $sa;\r\n    let sc = qmd(d1, sa);\r\n    let sc_ = _d1 * sa_ + abs($sc);\r\n    let $v5 = $sb + $sc;\r\n    let v5 = qaq(sb, sc);\r\n    let v5_ = sb_ + sc_ + abs($v5);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //let v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //let v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    let $sd = d2 * $z3;\r\n    let sd = qmd(d2, z3);\r\n    let sd_ = abs($sd);\r\n    let $se = d2 * $z6;\r\n    let se = qmd(d2, z6);\r\n    let se_ = abs($se);\r\n    let $sf = c2 * $z5;\r\n    let sf = qmd(c2, z5);\r\n    let sf_ = abs($sf);\r\n    let $sg = c2 * $z4;\r\n    let sg = qmd(c2, z4);\r\n    let sg_ = abs($sg);\r\n    let $sh = (3 * c2) * $z1;\r\n    let sh = qmd(3 * c2, z1); // 3*c2: 47-bit aligned => error free\r\n    //let _sh = sh_;\r\n    let sh_ = abs($sh);\r\n    let $si = (3 * d2) * $z2;\r\n    let si = qmd(3 * d2, z2); // 3*d2: 47-bit aligned => error free\r\n    //let _si = si_;\r\n    let si_ = abs($si);\r\n    let $sj = $sd + $sf;\r\n    let sj = qaq(sd, sf);\r\n    let _sj = abs($sj);\r\n    let sj_ = sd_ + sf_ + _sj;\r\n    let $sk = $se + $sg;\r\n    let sk = qaq(se, sg);\r\n    let _sk = abs($sk);\r\n    let sk_ = se_ + sg_ + _sk;\r\n    let $sl = $sh * $vₓₓₓ;\r\n    let sl = qmq(sh, vₓₓₓ);\r\n    let sl_ = sh_ * (_vₓₓₓ + vₓₓₓ_) + 2 * abs($sl);\r\n    let $sm = $si * $vᵧᵧᵧ;\r\n    let sm = qmq(si, vᵧᵧᵧ);\r\n    let sm_ = si_ * (_vᵧᵧᵧ + vᵧᵧᵧ_) + 2 * abs($sm);\r\n    let $sn = $sj * $vₓₓᵧ;\r\n    let sn = qmq(sj, vₓₓᵧ);\r\n    let sn_ = sj_ * _vₓₓᵧ + _sj * vₓₓᵧ_ + 2 * abs($sn);\r\n    let $so = $sk * $vₓᵧᵧ;\r\n    let so = qmq(sk, vₓᵧᵧ);\r\n    let so_ = sk_ * _vₓᵧᵧ + _sk * vₓᵧᵧ_ + 2 * abs($so);\r\n    let $sp = $sl + $sm;\r\n    let sp = qaq(sl, sm);\r\n    let sp_ = sl_ + sm_ + abs($sp);\r\n    let $sq = $sn + $so;\r\n    let sq = qaq(sn, so);\r\n    let sq_ = sn_ + so_ + abs($sq);\r\n    let $sr = $c2c2 * $vₓₓ;\r\n    let sr = qmq(c2c2, vₓₓ);\r\n    let sr_ = _c2c2 * vₓₓ_ + 2 * abs($sr);\r\n    let $ss = $d2d2 * $vᵧᵧ;\r\n    let ss = qmq(d2d2, vᵧᵧ);\r\n    let ss_ = _d2d2 * vᵧᵧ_ + 2 * abs($ss);\r\n    let $st = $c2d2 * $vₓᵧ;\r\n    let st = qmq(c2d2, vₓᵧ);\r\n    let st_ = _c2d2 * vₓᵧ_ + 2 * abs($st);\r\n    let $su = $sr + $ss;\r\n    let su = qaq(sr, ss);\r\n    let su_ = sr_ + ss_ + abs($su);\r\n    let $sv = $sp + $sq;\r\n    let sv = qaq(sp, sq);\r\n    let sv_ = sp_ + sq_ + abs($sv);\r\n    let $sw = $su + $st;\r\n    let sw = qaq(su, st);\r\n    let sw_ = su_ + st_ + abs($sw);\r\n    let $v4 = $sv + $sw;\r\n    let v4 = qaq(sv, sw);\r\n    let v4_ = sv_ + sw_ + abs($v4);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //let v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //let v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    let $sx = c1 * $z8;\r\n    let sx = qmd(c1, z8);\r\n    //let _sx = abs($sx);\r\n    let sx_ = abs($sx);\r\n    let $sy = d1 * $z9;\r\n    let sy = qmd(d1, z9);\r\n    //let _sy = abs($sy);\r\n    let sy_ = abs($sy);\r\n    let $sz = 2 * c0 * $za;\r\n    let sz = qmd(2 * c0, za);\r\n    let sz_ = abs($sz);\r\n    let $o1 = 2 * d1 * $zb;\r\n    let o1 = qmd(2 * d1, zb);\r\n    let o1_ = abs($o1);\r\n    let $o2 = c1 * $z7;\r\n    let o2 = qmd(c1, z7);\r\n    let o2_ = abs($o2);\r\n    let $o3 = c1 * $z4;\r\n    let o3 = qmd(c1, z4);\r\n    let o3_ = abs($o3);\r\n    let $o4 = $sz + $o2;\r\n    let o4 = qaq(sz, o2);\r\n    let _o4 = abs($o4);\r\n    let o4_ = sz_ + o2_ + _o4;\r\n    let $o5 = $o1 + $o3;\r\n    let o5 = qaq(o1, o3);\r\n    let _o5 = abs($o5);\r\n    let o5_ = o1_ + o3_ + _o5;\r\n    let $o6 = $d1d2 * $vᵧᵧ;\r\n    let o6 = qmq(d1d2, vᵧᵧ);\r\n    let o6_ = _d1d2 * vᵧᵧ_ + 2 * abs($o6);\r\n    let $o7 = $c1c2 * $vₓₓ;\r\n    let o7 = qmq(c1c2, vₓₓ);\r\n    let o7_ = _c1c2 * vₓₓ_ + 2 * abs($o7);\r\n    let $o8 = $za * $vₓᵧ;\r\n    let o8 = qmq(za, vₓᵧ);\r\n    let o8_ = _za * vₓᵧ_ + 2 * abs($o8);\r\n    let $o9 = $o6 + $o7;\r\n    let o9 = qaq(o6, o7);\r\n    let o9_ = o6_ + o7_ + abs($o9);\r\n    let $oa = $sx * $vₓₓₓ;\r\n    let oa = qmq(sx, vₓₓₓ);\r\n    let oa_ = sx_ * (_vₓₓₓ + vₓₓₓ_) + 2 * abs($oa);\r\n    let $ob = $o4 * $vₓₓᵧ;\r\n    let ob = qmq(o4, vₓₓᵧ);\r\n    let ob_ = o4_ * _vₓₓᵧ + _o4 * vₓₓᵧ_ + 2 * abs($ob);\r\n    let $oc = $sy * $vᵧᵧᵧ;\r\n    let oc = qmq(sy, vᵧᵧᵧ);\r\n    let oc_ = sy_ * (_vᵧᵧᵧ + vᵧᵧᵧ_) + 2 * abs($oc);\r\n    let $od = $o5 * $vₓᵧᵧ;\r\n    let od = qmq(o5, vₓᵧᵧ);\r\n    let od_ = o5_ * _vₓᵧᵧ + _o5 * vₓᵧᵧ_ + 2 * abs($od);\r\n    let $oe = $oa + $oc;\r\n    let oe = qaq(oa, oc);\r\n    let oe_ = oa_ + oc_ + abs($oe);\r\n    let $og = $ob + $od;\r\n    let og = qaq(ob, od);\r\n    let og_ = ob_ + od_ + abs($og);\r\n    let $oh = $oe + $og;\r\n    let oh = qaq(oe, og);\r\n    let oh_ = oe_ + og_ + abs($oh);\r\n    let $oi = 2 * $o9 + $o8;\r\n    let oi = qaq(qm2(o9), o8);\r\n    let oi_ = 2 * o9_ + o8_ + abs($oi);\r\n    let $v3 = $oh + $oi;\r\n    let v3 = qaq(oh, oi);\r\n    let v3_ = oh_ + oi_ + abs($v3);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //let v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    //let v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    let $oj = (3 * c0) * $z1;\r\n    let oj = qmd(3 * c0, z1);\r\n    //let _oj = abs(oj);\r\n    let oj_ = abs($oj);\r\n    let $ok = (3 * d0) * $z2;\r\n    let ok = qmd(3 * d0, z2);\r\n    //let _ok = abs(ok);\r\n    let ok_ = abs($ok);\r\n    let $ol = c0 * $z6;\r\n    let ol = qmd(c0, z6);\r\n    let ol_ = abs($ol);\r\n    let $om = c0 * $z4;\r\n    let om = qmd(c0, z4);\r\n    let om_ = abs($om);\r\n    let $on = d0 * $z3;\r\n    let on = qmd(d0, z3);\r\n    let on_ = abs($on);\r\n    let $oo = d0 * $z5;\r\n    let oo = qmd(d0, z5);\r\n    let oo_ = abs($oo);\r\n    let $op = $ol + $on;\r\n    let op = qaq(ol, on);\r\n    let _op = abs($op);\r\n    let op_ = ol_ + on_ + _op;\r\n    let $oq = $om + $oo;\r\n    let oq = qaq(om, oo);\r\n    let _oq = abs($oq);\r\n    let oq_ = om_ + oo_ + _oq;\r\n    let $or = $oj * $vₓₓₓ;\r\n    let or = qmq(oj, vₓₓₓ);\r\n    let or_ = oj_ * (_vₓₓₓ + vₓₓₓ_) + 2 * abs($or);\r\n    let $os = $ok * $vᵧᵧᵧ;\r\n    let os = qmq(ok, vᵧᵧᵧ);\r\n    let os_ = ok_ * (_vᵧᵧᵧ + vᵧᵧᵧ_) + 2 * abs($os);\r\n    let $ot = $op * $vₓₓᵧ;\r\n    let ot = qmq(op, vₓₓᵧ);\r\n    let ot_ = op_ * _vₓₓᵧ + _op * vₓₓᵧ_ + 2 * abs($ot);\r\n    let $ou = $oq * $vₓᵧᵧ;\r\n    let ou = qmq(oq, vₓᵧᵧ);\r\n    let ou_ = oq_ * _vₓᵧᵧ + _oq * vₓᵧᵧ_ + 2 * abs($ou);\r\n    let $ov = $z3 * $vₓₓ;\r\n    let ov = qmq(z3, vₓₓ);\r\n    let ov_ = _z3 * vₓₓ_ + 2 * abs($ov);\r\n    let $ow = $z4 * $vᵧᵧ;\r\n    let ow = qmq(z4, vᵧᵧ);\r\n    let ow_ = _z4 * vᵧᵧ_ + 2 * abs($ow);\r\n    let $ox = $ze * $vₓᵧ;\r\n    let ox = qmq(ze, vₓᵧ);\r\n    let ox_ = _ze * vₓᵧ_ + 2 * abs($ox);\r\n    let $oy = c2 * $vₓ;\r\n    let oy = qmd(c2, vₓ);\r\n    let oy_ = _c2 * vₓ_ + abs($oy);\r\n    let $oz = d2 * $vᵧ;\r\n    let oz = qmd(d2, vᵧ);\r\n    let oz_ = _d2 * vᵧ_ + abs($oz);\r\n    let $p1 = $or + $os;\r\n    let p1 = qaq(or, os);\r\n    let p1_ = or_ + os_ + abs($p1);\r\n    let $p2 = $ot + $ou;\r\n    let p2 = qaq(ot, ou);\r\n    let p2_ = ot_ + ou_ + abs($p2);\r\n    let $p3 = $ov + $ow;\r\n    let p3 = qaq(ov, ow);\r\n    let p3_ = ov_ + ow_ + abs($p3);\r\n    let $p4 = $p1 + $p2;\r\n    let p4 = qaq(p1, p2);\r\n    let p4_ = p1_ + p2_ + abs($p4);\r\n    let $p5 = $p3 + $ox;\r\n    let p5 = qaq(p3, ox);\r\n    let p5_ = p3_ + ox_ + abs($p5);\r\n    let $p6 = $oy + $oz;\r\n    let p6 = qaq(oy, oz);\r\n    let p6_ = oy_ + oz_ + abs($p6);\r\n    let $p7 = $p4 + $p5;\r\n    let p7 = qaq(p4, p5);\r\n    let p7_ = p4_ + p5_ + abs($p7);\r\n    let $v2 = $p7 + $p6;\r\n    let v2 = qaq(p7, p6);\r\n    let v2_ = p7_ + p6_ + abs($v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //let v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //let v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    let $p8 = (3 * c0) * $c0c1;\r\n    let p8 = qmd(3 * c0, c0c1);\r\n    //let _p8 = abs(p8);\r\n    let p8_ = abs($p8);\r\n    let $p9 = (3 * d0) * $d0d1;\r\n    let p9 = qmd(3 * d0, d0d1);\r\n    //let _p9 = abs(p9);\r\n    let p9_ = abs($p9);\r\n    let $pa = c0 * $zc;\r\n    let pa = qmd(c0, zc);\r\n    //let _pa = abs($pa);\r\n    let pa_ = abs($pa);\r\n    let $pb = d0 * $zd;\r\n    let pb = qmd(d0, zd);\r\n    //let _pb = abs($pb);\r\n    let pb_ = abs($pb);\r\n    let $pc = $c0c1 * $vₓₓ;\r\n    let pc = qmq(c0c1, vₓₓ);\r\n    let pc_ = _c0c1 * vₓₓ_ + 2 * abs($pc);\r\n    let $pd = $d0d1 * $vᵧᵧ;\r\n    let pd = qmq(d0d1, vᵧᵧ);\r\n    let pd_ = _d0d1 * vᵧᵧ_ + 2 * abs($pd);\r\n    let $pe = $c0d1 * $vₓᵧ;\r\n    let pe = qmq(c0d1, vₓᵧ);\r\n    let pe_ = _c0d1 * vₓᵧ_ + 2 * abs($pe);\r\n    let $pf = $c1d0 * $vₓᵧ;\r\n    let pf = qmq(c1d0, vₓᵧ);\r\n    let pf_ = _c1d0 * vₓᵧ_ + 2 * abs($pf);\r\n    let $pg = 2 * ($pc + $pd);\r\n    let pg = qm2(qaq(pc, pd));\r\n    let pg_ = 2 * (pc_ + pd_) + abs($pg);\r\n    let $ph = $pe + $pf;\r\n    let ph = qaq(pe, pf);\r\n    let ph_ = pe_ + pf_ + abs($ph);\r\n    let $pi = c1 * $vₓ;\r\n    let pi = qmd(c1, vₓ);\r\n    let pi_ = _c1 * vₓ_ + abs($pi);\r\n    let $pj = d1 * $vᵧ;\r\n    let pj = qmd(d1, vᵧ);\r\n    let pj_ = _d1 * vᵧ_ + abs($pj);\r\n    let $pk = $p8 * $vₓₓₓ;\r\n    let pk = qmq(p8, vₓₓₓ);\r\n    let pk_ = p8_ * (_vₓₓₓ + vₓₓₓ_) + 2 * abs($pk);\r\n    let $pl = $p9 * $vᵧᵧᵧ;\r\n    let pl = qmq(p9, vᵧᵧᵧ);\r\n    let pl_ = p9_ * (_vᵧᵧᵧ + vᵧᵧᵧ_) + 2 * abs($pl);\r\n    let $pm = $pa * $vₓₓᵧ;\r\n    let pm = qmq(pa, vₓₓᵧ);\r\n    let pm_ = pa_ * (_vₓₓᵧ + vₓₓᵧ_) + 2 * abs($pm);\r\n    let $pn = $pb * $vₓᵧᵧ;\r\n    let pn = qmq(pb, vₓᵧᵧ);\r\n    let pn_ = pb_ * (_vₓᵧᵧ + vₓᵧᵧ_) + 2 * abs($pn);\r\n    let $po = $pk + $pl;\r\n    let po = qaq(pk, pl);\r\n    let po_ = pk_ + pl_ + abs($po);\r\n    let $pp = $pm + $pn;\r\n    let pp = qaq(pm, pn);\r\n    let pp_ = pm_ + pn_ + abs($pp);\r\n    let $pq = $po + $pp;\r\n    let pq = qaq(po, pp);\r\n    let pq_ = po_ + pp_ + abs($pq);\r\n    let $pr = $pg + $ph;\r\n    let pr = qaq(pg, ph);\r\n    let pr_ = pg_ + ph_ + abs($pr);\r\n    let $ps = $pi + $pj;\r\n    let ps = qaq(pi, pj);\r\n    let ps_ = pi_ + pj_ + abs($ps);\r\n    let $pt = $pq + $pr;\r\n    let pt = qaq(pq, pr);\r\n    let pt_ = pq_ + pr_ + abs($pt);\r\n    let $v1 = $pt + $ps;\r\n    let v1 = qaq(pt, ps);\r\n    let v1_ = pt_ + ps_ + abs($v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //let v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    let $pu = c0 * $vₓₓₓ;\r\n    let pu = qmd(c0, vₓₓₓ);\r\n    let pu_ = _c0 * vₓₓₓ_ + abs($pu);\r\n    let $pv = c0 * $vₓᵧᵧ;\r\n    let pv = qmd(c0, vₓᵧᵧ);\r\n    let pv_ = _c0 * vₓᵧᵧ_ + abs($pv);\r\n    let $pw = d0 * $vₓₓᵧ;\r\n    let pw = qmd(d0, vₓₓᵧ);\r\n    let pw_ = _d0 * vₓₓᵧ_ + abs($pw);\r\n    let $px = d0 * $vᵧᵧᵧ;\r\n    let px = qmd(d0, vᵧᵧᵧ);\r\n    let px_ = _d0 * vᵧᵧᵧ_ + abs($px);\r\n    let $py = $pu + $pw;\r\n    let py = qaq(pu, pw);\r\n    let py_ = pu_ + pw_ + abs($py);\r\n    let $pz = $pv + $px;\r\n    let pz = qaq(pv, px);\r\n    let pz_ = pv_ + px_ + abs($pz);\r\n    let $u1 = $py + $vₓₓ;\r\n    let u1 = qaq(py, vₓₓ);\r\n    let _u1 = abs($u1);\r\n    let u1_ = py_ + vₓₓ_ + _u1;\r\n    let $u2 = $pz + $vᵧᵧ;\r\n    let u2 = qaq(pz, vᵧᵧ);\r\n    let _u2 = abs($u2);\r\n    let u2_ = pz_ + vᵧᵧ_ + _u2;\r\n    let $u3 = $c0c0 * $u1;\r\n    let u3 = qmq(c0c0, u1);\r\n    let u3_ = _c0c0 * u1_ + 2 * abs($u3);\r\n    let $u4 = $d0d0 * $u2;\r\n    let u4 = qmq(d0d0, u2);\r\n    let u4_ = _d0d0 * u2_ + 2 * abs($u4);\r\n    let $u5 = $c0d0 * $vₓᵧ;\r\n    let u5 = qmq(c0d0, vₓᵧ);\r\n    let u5_ = _c0d0 * vₓᵧ_ + 2 * abs($u5);\r\n    let $u6 = c0 * $vₓ;\r\n    let u6 = qmd(c0, vₓ);\r\n    let u6_ = _c0 * vₓ_ + abs($u6);\r\n    let $u7 = d0 * $vᵧ;\r\n    let u7 = qmd(d0, vᵧ);\r\n    let u7_ = _d0 * vᵧ_ + abs($u7);\r\n    let $u8 = $u3 + $u4;\r\n    let u8 = qaq(u3, u4);\r\n    let u8_ = u3_ + u4_ + abs($u8);\r\n    let $u9 = $u8 + $u5;\r\n    let u9 = qaq(u8, u5);\r\n    let u9_ = u8_ + u5_ + abs($u9);\r\n    let $ua = $u6 + $u7;\r\n    let ua = qaq(u6, u7);\r\n    let ua_ = u6_ + u7_ + abs($ua);\r\n    let $ub = $u9 + $ua;\r\n    let ub = qaq(u9, ua);\r\n    let ub_ = u9_ + ua_ + abs($ub);\r\n    let $v0 = $ub + $v;\r\n    let v0 = qaq(ub, v);\r\n    let v0_ = ub_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [v6_, v5_, v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs3x2Quad = getCoeffs3x2Quad;\r\n//# sourceMappingURL=get-coefficients-3x2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x2.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x3.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x3.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../../../implicit-form/quad/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nlet abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n// TODO - better docs\r\n/**\r\n * * the returned errors still need to be multiplied by 3*γ1*γ1\r\n * * precondition: 53-4-2 === 47-bit bit-aligned coefficient bitlength (this is\r\n * to improve speed considerably due to simpler error bound calculations)\r\n * @param ps1\r\n * @param ps2\r\n */\r\nfunction getCoeffs3x3Quad(ps1, ps2) {\r\n    let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3Quad(ps1);\r\n    let [[c3, c2, c1, c0], [d3, d2, d1, d0]] = get_xy_1.getXY(ps2);\r\n    let $vₓₓₓ = vₓₓₓ[1];\r\n    let $vₓₓᵧ = vₓₓᵧ[1];\r\n    let $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    let $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    let $vₓₓ = vₓₓ[1];\r\n    let $vₓᵧ = vₓᵧ[1];\r\n    let $vᵧᵧ = vᵧᵧ[1];\r\n    let $vₓ = vₓ[1];\r\n    let $vᵧ = vᵧ[1];\r\n    let $v = v[1];\r\n    let _vₓₓₓ = abs($vₓₓₓ);\r\n    let _vₓₓᵧ = abs($vₓₓᵧ);\r\n    let _vₓᵧᵧ = abs($vₓᵧᵧ);\r\n    let _vᵧᵧᵧ = abs($vᵧᵧᵧ);\r\n    let $c0c0 = c0 * c0;\r\n    let $c0c1 = c0 * c1;\r\n    let $c0c2 = c0 * c2;\r\n    let $c0c3 = c0 * c3;\r\n    let $c0d0 = c0 * d0;\r\n    let $c0d1 = c0 * d1;\r\n    let $c0d2 = c0 * d2;\r\n    let $c0d3 = c0 * d3;\r\n    let $c1c1 = c1 * c1;\r\n    let $c1c2 = c1 * c2;\r\n    let $c1c3 = c1 * c3;\r\n    let $c1d0 = c1 * d0;\r\n    let $c1d1 = c1 * d1;\r\n    let $c1d2 = c1 * d2;\r\n    let $c1d3 = c1 * d3;\r\n    let $c2d1 = c2 * d1;\r\n    let $c2c2 = c2 * c2;\r\n    let $c2c3 = c2 * c3;\r\n    let $c2d0 = c2 * d0;\r\n    let $c2d2 = c2 * d2;\r\n    let $c2d3 = c2 * d3;\r\n    let $c3c3 = c3 * c3;\r\n    let $c3d0 = c3 * d0;\r\n    let $c3d1 = c3 * d1;\r\n    let $c3d2 = c3 * d2;\r\n    let $c3d3 = c3 * d3;\r\n    let $d0d0 = d0 * d0;\r\n    let $d0d1 = d0 * d1;\r\n    let $d0d2 = d0 * d2;\r\n    let $d0d3 = d0 * d3;\r\n    let $d1d1 = d1 * d1;\r\n    let $d1d2 = d1 * d2;\r\n    let $d3d3 = d3 * d3;\r\n    let $d2d2 = d2 * d2;\r\n    let $d2d3 = d2 * d3;\r\n    let $d1d3 = d1 * d3;\r\n    let c0c0 = tp(c0, c0);\r\n    let c0c1 = tp(c0, c1);\r\n    let c0c2 = tp(c0, c2);\r\n    let c0c3 = tp(c0, c3);\r\n    let c0d0 = tp(c0, d0);\r\n    let c0d1 = tp(c0, d1);\r\n    let c0d2 = tp(c0, d2);\r\n    let c0d3 = tp(c0, d3);\r\n    let c1c1 = tp(c1, c1);\r\n    let c1c2 = tp(c1, c2);\r\n    let c1c3 = tp(c1, c3);\r\n    let c1d0 = tp(c1, d0);\r\n    let c1d1 = tp(c1, d1);\r\n    let c1d2 = tp(c1, d2);\r\n    let c1d3 = tp(c1, d3);\r\n    let c2d1 = tp(c2, d1);\r\n    let c2c2 = tp(c2, c2);\r\n    let c2c3 = tp(c2, c3);\r\n    let c2d0 = tp(c2, d0);\r\n    let c2d2 = tp(c2, d2);\r\n    let c2d3 = tp(c2, d3);\r\n    let c3c3 = tp(c3, c3);\r\n    let c3d0 = tp(c3, d0);\r\n    let c3d1 = tp(c3, d1);\r\n    let c3d2 = tp(c3, d2);\r\n    let c3d3 = tp(c3, d3);\r\n    let d0d0 = tp(d0, d0);\r\n    let d0d1 = tp(d0, d1);\r\n    let d0d2 = tp(d0, d2);\r\n    let d0d3 = tp(d0, d3);\r\n    let d1d1 = tp(d1, d1);\r\n    let d1d2 = tp(d1, d2);\r\n    let d3d3 = tp(d3, d3);\r\n    let d2d2 = tp(d2, d2);\r\n    let d2d3 = tp(d2, d3);\r\n    let d1d3 = tp(d1, d3);\r\n    let _c0c0 = abs($c0c0);\r\n    let _c0c1 = abs($c0c1);\r\n    let _c2c3 = abs($c2c3);\r\n    let _c3c3 = abs($c3c3);\r\n    let _c3d3 = abs($c3d3);\r\n    let _c0d0 = abs($c0d0);\r\n    let _d0d0 = abs($d0d0);\r\n    let _d0d1 = abs($d0d1);\r\n    let _d2d3 = abs($d2d3);\r\n    let _d3d3 = abs($d3d3);\r\n    let _c0 = abs(c0);\r\n    let _c1 = abs(c1);\r\n    let _c2 = abs(c2);\r\n    let _c3 = abs(c3);\r\n    let _d0 = abs(d0);\r\n    let _d1 = abs(d1);\r\n    let _d2 = abs(d2);\r\n    let _d3 = abs(d3);\r\n    //let v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;  \r\n    let $g1 = c3 * $c3c3;\r\n    let g1 = qmd(c3, c3c3);\r\n    let _g1 = _c3 * _c3c3;\r\n    let $g2 = c3 * $d3d3;\r\n    let g2 = qmd(c3, d3d3);\r\n    let _g2 = _c3 * _d3d3;\r\n    let $g3 = d3 * $c3c3;\r\n    let g3 = qmd(d3, c3c3);\r\n    let _g3 = _d3 * _c3c3;\r\n    let $g4 = d3 * $d3d3;\r\n    let g4 = qmd(d3, d3d3);\r\n    let _g4 = _d3 * _d3d3;\r\n    let $g5 = $g1 * $vₓₓₓ;\r\n    let g5 = qmq(g1, vₓₓₓ);\r\n    let g5_ = _g1 * (_vₓₓₓ + vₓₓₓ_) + 2 * abs($g5);\r\n    let $g6 = $g2 * $vₓᵧᵧ;\r\n    let g6 = qmq(g2, vₓᵧᵧ);\r\n    let g6_ = _g2 * (_vₓᵧᵧ + vₓᵧᵧ_) + 2 * abs($g2);\r\n    let $g7 = $g3 * $vₓₓᵧ;\r\n    let g7 = qmq(g3, vₓₓᵧ);\r\n    let g7_ = _g3 * (_vₓₓᵧ + vₓₓᵧ_) + 2 * abs($g3);\r\n    let $g8 = $g4 * $vᵧᵧᵧ;\r\n    let g8 = qmq(g4, vᵧᵧᵧ);\r\n    let g8_ = _g4 * (_vᵧᵧᵧ + vᵧᵧᵧ_) + 2 * abs($g4);\r\n    let $g9 = $g5 + $g6;\r\n    let g9 = qaq(g5, g6);\r\n    let g9_ = g5_ + g6_ + abs($g9);\r\n    let $ga = $g7 + $g8;\r\n    let ga = qaq(g7, g8);\r\n    let ga_ = g7_ + g8_ + abs($ga);\r\n    let $v9 = $g9 + $ga;\r\n    let v9 = qaq(g9, ga);\r\n    let v9_ = g9_ + ga_ + abs($v9);\r\n    //let v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    let $w1 = 2 * $c2d3 + $c3d2;\r\n    let w1 = qaq(qm2(c2d3), c3d2); // 47-bit aligned => error free\r\n    let $w2 = 2 * $c3d2 + $c2d3;\r\n    let w2 = qaq(qm2(c3d2), c2d3); // 47-bit aligned => error free\r\n    let $w3 = c3 * $w1;\r\n    let w3 = qmd(c3, w1);\r\n    //let _w3 = abs($w3);\r\n    let w3_ = abs($w3);\r\n    let $w4 = d3 * $w2;\r\n    let w4 = qmd(d3, w2);\r\n    //let _w4 = abs($w4);\r\n    let w4_ = abs($w4);\r\n    let $w5 = c2 * $c3c3;\r\n    let w5 = qmd(c2, c3c3);\r\n    //let _w5 = abs($w5);\r\n    let w5_ = abs($w5);\r\n    let $w6 = d2 * $d3d3;\r\n    let w6 = qmd(d2, d3d3);\r\n    //let _w6 = abs($w6);\r\n    let w6_ = abs($w6);\r\n    let $w7 = $vₓₓₓ * $w5;\r\n    let w7 = qmq(vₓₓₓ, w5);\r\n    let w7_ = w5_ * (vₓₓₓ_ + _vₓₓₓ) + 2 * abs($w7);\r\n    let $u1 = $vᵧᵧᵧ * $w6;\r\n    let u1 = qmq(vᵧᵧᵧ, w6);\r\n    let u1_ = w6_ * (vᵧᵧᵧ_ + _vᵧᵧᵧ) + 2 * abs($u1);\r\n    let $u2 = $vₓₓᵧ * $w3;\r\n    let u2 = qmq(vₓₓᵧ, w3);\r\n    let u2_ = w3_ * (vₓₓᵧ_ + _vₓₓᵧ) + 2 * abs($u2);\r\n    let $u3 = $vₓᵧᵧ * $w4;\r\n    let u3 = qmq(vₓᵧᵧ, w4);\r\n    let u3_ = w4_ * (vₓᵧᵧ_ + _vₓᵧᵧ) + 2 * abs($u3);\r\n    let $u4 = $u2 + $u3;\r\n    let u4 = qaq(u2, u3);\r\n    let u4_ = u2_ + u3_ + abs($u4);\r\n    let $u5 = 3 * ($w7 + $u1);\r\n    let u5 = qmd(3, qaq(w7, u1));\r\n    let u5_ = 3 * (w7_ + u1_) + 2 * abs($u5);\r\n    let $v8 = $u4 + $u5;\r\n    let v8 = qaq(u4, u5);\r\n    let v8_ = u4_ + u5_ + abs($v8);\r\n    //let v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    let $o1 = c1 * $c3d3;\r\n    let o1 = qmd(c1, c3d3);\r\n    let o1_ = abs($o1);\r\n    let $o2 = d1 * $c3c3;\r\n    let o2 = qmd(d1, c3c3);\r\n    let o2_ = abs($o2);\r\n    let $o3 = c2 * $d2d3;\r\n    let o3 = qmd(c2, d2d3);\r\n    let o3_ = abs($o3);\r\n    let $o4 = c1 * $d3d3;\r\n    let o4 = qmd(c1, d3d3);\r\n    let o4_ = abs($o4);\r\n    let $o5 = c2 * $c3d2;\r\n    let o5 = qmd(c2, c3d2);\r\n    let o5_ = abs($o5);\r\n    let $o6 = d3 * $c2c2;\r\n    let o6 = qmd(d3, c2c2);\r\n    let o6_ = abs($o6);\r\n    let $o7 = c3 * $d1d3;\r\n    let o7 = qmd(c3, d1d3);\r\n    let o7_ = abs($o7);\r\n    let $o8 = d2 * $c3d2;\r\n    let o8 = qmd(d2, c3d2);\r\n    let o8_ = abs($o8);\r\n    let $w8 = $o1 + $o5;\r\n    let w8 = qaq(o1, o5);\r\n    let w8_ = o1_ + o5_ + abs($w8);\r\n    let $w9 = $o2 + $o6;\r\n    let w9 = qaq(o2, o6);\r\n    let w9_ = o2_ + o6_ + abs($w9);\r\n    let $wa = $o3 + $o7;\r\n    let wa = qaq(o3, o7);\r\n    let wa_ = o3_ + o7_ + abs($wa);\r\n    let $wb = $o4 + $o8;\r\n    let wb = qaq(o4, o8);\r\n    let wb_ = o4_ + o8_ + abs($wb);\r\n    let $wc = $c1c3 + $c2c2;\r\n    let wc = qaq(c1c3, c2c2); // 48-bit aligned => error free\r\n    let $wd = $d1d3 + $d2d2;\r\n    let wd = qaq(d1d3, d2d2); // 48-bit aligned => error free\r\n    let $we = 2 * $w8 + $w9;\r\n    let we = qaq(qm2(w8), w9);\r\n    let _we = abs($we);\r\n    let we_ = 2 * w8_ + w9_ + _we;\r\n    let $wf = 2 * $wa + $wb;\r\n    let wf = qaq(qm2(wa), wb);\r\n    let _wf = abs($wf);\r\n    let wf_ = 2 * wa_ + wb_ + _wf;\r\n    let $wg = $vₓₓᵧ * $we;\r\n    let wg = qmq(vₓₓᵧ, we);\r\n    let wg_ = vₓₓᵧ_ * _we + _vₓₓᵧ * we_ + 2 * abs($wg);\r\n    let $wh = $vₓᵧᵧ * $wf;\r\n    let wh = qmq(vₓᵧᵧ, wf);\r\n    let wh_ = vₓᵧᵧ_ * _wf + _vₓᵧᵧ * wf_ + 2 * abs($wh);\r\n    let $wi = c3 * $wc;\r\n    let wi = qmd(c3, wc);\r\n    let _wi = abs($wi);\r\n    let wi_ = _wi;\r\n    let $wj = d3 * $wd;\r\n    let wj = qmd(d3, wd);\r\n    let _wj = abs($wj);\r\n    let wj_ = _wj;\r\n    let $wk = $vₓₓₓ * $wi;\r\n    let wk = qmq(vₓₓₓ, wi);\r\n    let wk_ = vₓₓₓ_ * _wi + _vₓₓₓ * wi_ + 2 * abs($wk);\r\n    let $wl = $vᵧᵧᵧ * $wj;\r\n    let wl = qmq(vᵧᵧᵧ, wj);\r\n    let wl_ = vᵧᵧᵧ_ * _wj + _vᵧᵧᵧ * wj_ + 2 * abs($wl);\r\n    let $wm = $wg + $wh;\r\n    let wm = qaq(wg, wh);\r\n    let wm_ = wg_ + wh_ + abs($wm);\r\n    let $wn = 3 * ($wk + $wl);\r\n    let wn = qmd(3, qaq(wk, wl));\r\n    let wn_ = 3 * (wk_ + wl_) + 2 * abs($wn);\r\n    let $v7 = $wm + $wn;\r\n    let v7 = qaq(wm, wn);\r\n    let v7_ = wm_ + wn_ + abs($v7);\r\n    //let v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    let $wo = $c2d3 + $c3d2;\r\n    let wo = qaq(c2d3, c3d2); // 48-bit aligned => error free\r\n    let _wo = abs($wo);\r\n    let $zc = d2 * $c2c2;\r\n    let zc = qmd(d2, c2c2);\r\n    let zc_ = abs($zc);\r\n    let $zd = 2 * c1 * $wo;\r\n    let zd = qm2(qmd(c1, wo));\r\n    let zd_ = 2 * abs($zd);\r\n    let $wp = $zc + $zd;\r\n    let wp = qaq(zc, zd);\r\n    let wp_ = zc_ + zd_ + abs($wp);\r\n    let $wq = 2 * ($c0d3 + $c2d1);\r\n    let wq = qm2(qaq(c0d3, c2d1)); // 48-bit aligned => error free\r\n    let $wr = $wq + $c3d0;\r\n    let wr = qaq(wq, c3d0); // 47-bit aligned => error free\r\n    let $ze = c3 * $wr;\r\n    let ze = qmd(c3, wr);\r\n    let ze_ = abs($ze);\r\n    let $ws = $wp + $ze;\r\n    let ws = qaq(wp, ze);\r\n    let _ws = abs($ws);\r\n    let ws_ = wp_ + ze_ + _ws;\r\n    let $zf = c2 * $d2d2;\r\n    let zf = qmd(c2, d2d2);\r\n    let zf_ = abs($zf);\r\n    let $zg = 2 * d1 * $wo;\r\n    let zg = qm2(qmd(d1, wo));\r\n    let zg_ = 2 * abs($zg);\r\n    let $wt = $zf + $zg;\r\n    let wt = qaq(zf, zg);\r\n    let wt_ = zf_ + zg_ + abs($wt);\r\n    let $wu = 2 * ($c1d2 + $c3d0);\r\n    let wu = qm2(qaq(c1d2, c3d0)); // 48-bit aligned => error free\r\n    let $wv = $wu + $c0d3;\r\n    let wv = qaq(wu, c0d3); // 47-bit aligned => error free\r\n    let $zh = d3 * $wv;\r\n    let zh = qmd(d3, wv);\r\n    let zh_ = abs($zh);\r\n    let $ww = $wt + $zh;\r\n    let ww = qaq(wt, zh);\r\n    let _ww = abs($ww);\r\n    let ww_ = wt_ + zh_ + _ww;\r\n    let $wx = c2 * $c2c2;\r\n    let wx = qmd(c2, c2c2);\r\n    let wx_ = abs($wx);\r\n    let $wy = 2 * $c1c2 + $c0c3;\r\n    let wy = qaq(qm2(c1c2), c0c3); // 48-bit aligned => error free\r\n    let $wz = (3 * c3) * $wy;\r\n    let wz = qmd(3 * c3, wy); // 3*c3: 47-bit aligned => error free\r\n    let wz_ = abs($wz);\r\n    let $z1 = $wx + $wz;\r\n    let z1 = qaq(wx, wz);\r\n    let _z1 = abs($z1);\r\n    let z1_ = wx_ + wz_ + _z1;\r\n    let $z2 = d2 * $d2d2;\r\n    let z2 = qmd(d2, d2d2);\r\n    let z2_ = abs($z2);\r\n    let $z3 = 2 * $d1d2 + $d0d3;\r\n    let z3 = qaq(qm2(d1d2), d0d3); // 47-bit aligned => error free\r\n    let $z4 = (3 * d3) * $z3;\r\n    let z4 = qmd(3 * d3, z3); // 3*d3: 47-bit aligned => error free\r\n    let z4_ = abs($z4);\r\n    let $z5 = $z2 + $z4;\r\n    let z5 = qaq(z2, z4);\r\n    let _z5 = abs($z5);\r\n    let z5_ = z2_ + z4_ + _z5;\r\n    let $zi = $vₓₓᵧ * $ws;\r\n    let zi = qmq(vₓₓᵧ, ws);\r\n    let zi_ = vₓₓᵧ_ * _ws + _vₓₓᵧ * ws_ + 2 * abs($zi);\r\n    let $zj = $vₓᵧᵧ * $ww;\r\n    let zj = qmq(vₓᵧᵧ, ww);\r\n    let zj_ = vₓᵧᵧ_ * _ww + _vₓᵧᵧ * ww_ + 2 * abs($zj);\r\n    let $z6 = $zi + $zj;\r\n    let z6 = qaq(zi, zj);\r\n    let z6_ = zi_ + zj_ + abs($z6);\r\n    let $zk = $vₓₓₓ * $z1;\r\n    let zk = qmq(vₓₓₓ, z1);\r\n    let zk_ = vₓₓₓ_ * _z1 + _vₓₓₓ * z1_ + 2 * abs($zk);\r\n    let $zl = $vᵧᵧᵧ * $z5;\r\n    let zl = qmq(vᵧᵧᵧ, z5);\r\n    let zl_ = vᵧᵧᵧ_ * _z5 + _vᵧᵧᵧ * z5_ + 2 * abs($zl);\r\n    let $z7 = $zk + $zl;\r\n    let z7 = qaq(zk, zl);\r\n    let z7_ = zk_ + zl_ + abs($z7);\r\n    let $zm = $vₓₓ * $c3c3;\r\n    let zm = qmq(c3c3, vₓₓ);\r\n    let zm_ = _c3c3 * vₓₓ_ + 2 * abs($zm);\r\n    let $zn = $vᵧᵧ * $d3d3;\r\n    let zn = qmq(d3d3, vᵧᵧ);\r\n    let zn_ = _d3d3 * vᵧᵧ_ + 2 * abs($zn);\r\n    let $z8 = $zm + $zn;\r\n    let z8 = qaq(zm, zn);\r\n    let z8_ = zm_ + zn_ + abs($z8);\r\n    let $z9 = $vₓᵧ * $c3d3;\r\n    let z9 = qmq(c3d3, vₓᵧ);\r\n    let z9_ = _c3d3 * vₓᵧ_ + 2 * abs($z9);\r\n    let $za = $z6 + $z7;\r\n    let za = qaq(z6, z7);\r\n    let za_ = z6_ + z7_ + abs($za);\r\n    let $zb = $z8 + $z9;\r\n    let zb = qaq(z8, z9);\r\n    let zb_ = z8_ + z9_ + abs($zb);\r\n    let $v6 = $za + $zb;\r\n    let v6 = qaq(za, zb);\r\n    let v6_ = za_ + zb_ + abs($v6);\r\n    //let r4 = c2d2 + c3d1;\r\n    //let r5 = c1d3 + c2d2;\r\n    //let v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    let $r4 = $c2d2 + $c3d1;\r\n    let r4 = qaq(c2d2, c3d1); // 48-bit aligned => error free\r\n    let $r5 = $c1d3 + $c2d2;\r\n    let r5 = qaq(c1d3, c2d2); // 48-bit aligned => error free\r\n    let $k1 = c0 * $wo;\r\n    let k1 = qmd(c0, wo); // wo: 48-bit aligned => error free\r\n    let k1_ = abs($k1);\r\n    let $k2 = d0 * $wo;\r\n    let k2 = qmd(d0, wo);\r\n    let k2_ = abs($k2);\r\n    let $k3 = c1 * $r4;\r\n    let k3 = qmd(c1, r4);\r\n    let k3_ = abs($k3);\r\n    let $k4 = d1 * $r5;\r\n    let k4 = qmd(d1, r5);\r\n    let k4_ = abs($k4);\r\n    let $k5 = 2 * $c3d0 + $c2d1;\r\n    let k5 = qaq(qm2(c3d0), c2d1); // 48-bit aligned => error free\r\n    let $k6 = 2 * $c0d3 + $c1d2;\r\n    let k6 = qaq(qm2(c0d3), c1d2); // 48-bit aligned => error free\r\n    let $k7 = d3 * $c1c1;\r\n    let k7 = qmd(d3, c1c1);\r\n    let k7_ = abs($k7);\r\n    let $k8 = c3 * $d1d1;\r\n    let k8 = qmd(c3, d1d1);\r\n    let k8_ = abs($k8);\r\n    let $k9 = c2 * $k5;\r\n    let k9 = qmd(c2, k5);\r\n    let k9_ = abs($k9);\r\n    let $ka = d2 * $k6;\r\n    let ka = qmd(d2, k6);\r\n    let ka_ = abs($ka);\r\n    let $kb = 2 * ($k1 + $k3);\r\n    let kb = qm2(qaq(k1, k3));\r\n    let kb_ = 2 * (k1_ + k3_) + abs($kb);\r\n    let $kc = 2 * ($k2 + $k4);\r\n    let kc = qm2(qaq(k2, k4));\r\n    let kc_ = 2 * (k2_ + k4_) + abs($kc);\r\n    let $kd = 2 * c0 * $c2c3;\r\n    let kd = qm2(qmd(c0, c2c3));\r\n    let kd_ = abs($kd);\r\n    let $ke = 2 * d0 * $d2d3;\r\n    let ke = qm2(qmd(d0, d2d3));\r\n    let ke_ = abs($ke);\r\n    let $kf = c1 * $wc;\r\n    let kf = qmd(c1, wc);\r\n    let kf_ = abs($kf);\r\n    let $kg = d1 * $wd;\r\n    let kg = qmd(d1, wd);\r\n    let kg_ = abs($kg);\r\n    let $kh = $vₓₓ * $c2c3;\r\n    let kh = qmq(c2c3, vₓₓ);\r\n    let kh_ = _c2c3 * vₓₓ_ + 2 * abs($kh);\r\n    let $ki = $vᵧᵧ * $d2d3;\r\n    let ki = qmq(d2d3, vᵧᵧ);\r\n    let ki_ = _d2d3 * vᵧᵧ_ + 2 * abs($ki);\r\n    let $kj = $kb + $k7;\r\n    let kj = qaq(kb, k7);\r\n    let _kj = abs($kj);\r\n    let kj_ = kb_ + k7_ + _kj;\r\n    let $kk = $kc + $k8;\r\n    let kk = qaq(kc, k8);\r\n    let _kk = abs($kk);\r\n    let kk_ = kc_ + k8_ + _kk;\r\n    let $kl = $kj + $k9;\r\n    let kl = qaq(kj, k9);\r\n    let _kl = abs($kl);\r\n    let kl_ = kj_ + k9_ + _kl;\r\n    let $km = $kk + $ka;\r\n    let km = qaq(kk, ka);\r\n    let _km = abs($km);\r\n    let km_ = kk_ + ka_ + _km;\r\n    let $kn = $kd + $kf;\r\n    let kn = qaq(kd, kf);\r\n    let _kn = abs($kn);\r\n    let kn_ = kd_ + kf_ + _kn;\r\n    let $ko = $ke + $kg;\r\n    let ko = qaq(ke, kg);\r\n    let _ko = abs($ko);\r\n    let ko_ = ke_ + kg_ + _ko;\r\n    let $kp = 2 * ($kh + $ki);\r\n    let kp = qm2(qaq(kh, ki));\r\n    let kp_ = 2 * (kh_ + ki_) + abs($kp);\r\n    let $kq = $vₓₓᵧ * $kl;\r\n    let kq = qmq(vₓₓᵧ, kl);\r\n    let kq_ = vₓₓᵧ_ * _kl + _vₓₓᵧ * kl_ + 2 * abs($kq);\r\n    let $kr = $vₓᵧᵧ * $km;\r\n    let kr = qmq(vₓᵧᵧ, km);\r\n    let kr_ = vₓᵧᵧ_ * _km + _vₓᵧᵧ * km_ + 2 * abs($kr);\r\n    let $ks = $vₓₓₓ * $kn;\r\n    let ks = qmq(vₓₓₓ, kn);\r\n    let ks_ = vₓₓₓ_ * _kn + _vₓₓₓ * kn_ + 2 * abs($ks);\r\n    let $kt = $vᵧᵧᵧ * $ko;\r\n    let kt = qmq(vᵧᵧᵧ, ko);\r\n    let kt_ = vᵧᵧᵧ_ * _ko + _vᵧᵧᵧ * ko_ + 2 * abs($kt);\r\n    let $ku = $kq + $kr;\r\n    let ku = qaq(kq, kr);\r\n    let ku_ = kq_ + kr_ + abs($ku);\r\n    let $kv = 3 * ($ks + $kt);\r\n    let kv = qmd(3, qaq(ks, kt));\r\n    let kv_ = 3 * (ks_ + kt_) + 2 * abs($kv);\r\n    let $kw = $vₓᵧ * $wo;\r\n    let kw = qmq(vₓᵧ, wo);\r\n    let kw_ = vₓᵧ_ * _wo + 2 * abs($kw);\r\n    let $kx = $ku + $kv;\r\n    let kx = qaq(ku, kv);\r\n    let kx_ = ku_ + kv_ + abs($kx);\r\n    let $ky = $kw + $kp;\r\n    let ky = qaq(kw, kp);\r\n    let ky_ = kw_ + kp_ + abs($ky);\r\n    let $v5 = $kx + $ky;\r\n    let v5 = qaq(kx, ky);\r\n    let v5_ = kx_ + ky_ + abs($v5);\r\n    //let r1 = c1d3 + r4;\r\n    //let r2 = 2*c1c3 + c2c2;\r\n    //let r3 = 2*d1d3 + d2d2;\r\n    //let v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    let $r1 = $c1d3 + $r4;\r\n    let r1 = qaq(c1d3, r4); // 48-bit aligned => error free\r\n    let _r1 = abs($r1);\r\n    let $r2 = 2 * $c1c3 + $c2c2;\r\n    let r2 = qaq(qm2(c1c3), c2c2); // 48-bit aligned => error free\r\n    let _r2 = abs($r2);\r\n    let $r3 = 2 * $d1d3 + $d2d2;\r\n    let r3 = qaq(qm2(d1d3), d2d2); // 48-bit aligned => error free\r\n    let _r3 = abs($r3);\r\n    let $s1 = (2 * c0) * $r1;\r\n    let s1 = qmd((2 * c0), r1);\r\n    let s1_ = abs($s1);\r\n    let $s2 = (2 * d0) * $r1;\r\n    let s2 = qmd((2 * d0), r1);\r\n    let s2_ = abs($s2);\r\n    let $s5 = $c1d2 + 2 * $c2d1;\r\n    let s5 = qaq(c1d2, qm2(c2d1)); // 48-bit aligned => error free\r\n    let $s6 = $c2d1 + 2 * $c1d2;\r\n    let s6 = qaq(c2d1, qm2(c1d2)); // 48-bit aligned => error free\r\n    let $s3 = d0 * $r2;\r\n    let s3 = qmd(d0, r2);\r\n    let s3_ = abs($s3);\r\n    let $s4 = c0 * $r3;\r\n    let s4 = qmd(c0, r3);\r\n    let s4_ = abs($s4);\r\n    let $s7 = c1 * $s5;\r\n    let s7 = qmd(c1, s5);\r\n    let s7_ = abs($s7);\r\n    let $s8 = d1 * $s6;\r\n    let s8 = qmd(d1, s6);\r\n    let s8_ = abs($s8);\r\n    let $s9 = c0 * $r2;\r\n    let s9 = qmd(c0, r2);\r\n    let s9_ = abs($s9);\r\n    let $sa = d0 * $r3;\r\n    let sa = qmd(d0, r3);\r\n    let sa_ = abs($sa);\r\n    let $sb = c2 * $c1c1;\r\n    let sb = qmd(c2, c1c1);\r\n    let sb_ = abs($sb);\r\n    let $sc = d2 * $d1d1;\r\n    let sc = qmd(d2, d1d1);\r\n    let sc_ = abs($sc);\r\n    let $sd = $s1 + $s3;\r\n    let sd = qaq(s1, s3);\r\n    let sd_ = s1_ + s3_ + abs($sd);\r\n    let $se = $s2 + $s4;\r\n    let se = qaq(s2, s4);\r\n    let se_ = s2_ + s4_ + abs($se);\r\n    let $sf = $sd + $s7;\r\n    let sf = qaq(sd, s7);\r\n    let _sf = abs($sf);\r\n    let sf_ = sd_ + s7_ + _sf;\r\n    let $sg = $se + $s8;\r\n    let sg = qaq(se, s8);\r\n    let _sg = abs($sg);\r\n    let sg_ = se_ + s8_ + _sg;\r\n    let $sh = $s9 + $sb;\r\n    let sh = qaq(s9, sb);\r\n    let _sh = abs($sh);\r\n    let sh_ = s9_ + sb_ + _sh;\r\n    let $si = $sa + $sc;\r\n    let si = qaq(sa, sc);\r\n    let _si = abs($si);\r\n    let si_ = sa_ + sc_ + _si;\r\n    let $sj = $vₓₓᵧ * $sf;\r\n    let sj = qmq(vₓₓᵧ, sf);\r\n    let sj_ = vₓₓᵧ_ * _sf + _vₓₓᵧ * sf_ + 2 * abs($sj);\r\n    let $sk = $vₓᵧᵧ * $sg;\r\n    let sk = qmq(vₓᵧᵧ, sg);\r\n    let sk_ = vₓᵧᵧ_ * _sg + _vₓᵧᵧ * sg_ + 2 * abs($sk);\r\n    let $sl = $vₓₓₓ * $sh;\r\n    let sl = qmq(vₓₓₓ, sh);\r\n    let sl_ = vₓₓₓ_ * _sh + _vₓₓₓ * sh_ + 2 * abs($sl);\r\n    let $sm = $vᵧᵧᵧ * $si;\r\n    let sm = qmq(vᵧᵧᵧ, si);\r\n    let sm_ = vᵧᵧᵧ_ * _si + _vᵧᵧᵧ * si_ + 2 * abs($sm);\r\n    let $sn = $sl + $sm;\r\n    let _sn = abs($sn);\r\n    let sn = qaq(sl, sm);\r\n    let sn_ = sl_ + sm_ + _sn;\r\n    let $so = $sj + $sk;\r\n    let so = qaq(sj, sk);\r\n    let so_ = sj_ + sk_ + abs($so);\r\n    let $sp = $so + 3 * $sn;\r\n    let sp = qaq(so, qmd(3, sn));\r\n    let sp_ = so_ + 3 * (sn_ + _sn) + abs($sp);\r\n    let $ss = $vₓᵧ * $r1;\r\n    let ss = qmq(vₓᵧ, r1);\r\n    let ss_ = vₓᵧ_ * _r1 + 2 * abs($ss);\r\n    let $st = $vₓₓ * $r2;\r\n    let st = qmq(vₓₓ, r2);\r\n    let st_ = vₓₓ_ * _r2 + 2 * abs($st);\r\n    let $sq = $ss + $st;\r\n    let sq = qaq(ss, st);\r\n    let sq_ = ss_ + st_ + abs($sq);\r\n    let $su = $vᵧᵧ * $r3;\r\n    let su = qmq(vᵧᵧ, r3);\r\n    let su_ = vᵧᵧ_ * _r3 + 2 * abs($su);\r\n    let $sr = $sq + $su;\r\n    let sr = qaq(sq, su);\r\n    let sr_ = sq_ + su_ + abs($sr);\r\n    let $v4 = $sp + $sr;\r\n    let v4 = qaq(sp, sr);\r\n    let v4_ = sp_ + sr_ + abs($v4);\r\n    //let r6 = c1d2 + c2d1;\r\n    //let r7 = c3d0 + c0d3;\r\n    //let r8 = c1c2 + c0c3;\r\n    //let r9 = d1d2 + d0d3;\r\n    //let v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    // 48-bit aligned => error free\r\n    let $r6 = $c1d2 + $c2d1;\r\n    let r6 = qaq(c1d2, c2d1); // 48-bit aligned => error free\r\n    let $r7 = $c3d0 + $c0d3;\r\n    let r7 = qaq(c3d0, c0d3); // 48-bit aligned => error free\r\n    let $r8 = $c1c2 + $c0c3;\r\n    let r8 = qaq(c1c2, c0c3); // 48-bit aligned => error free\r\n    let _r8 = abs($r8);\r\n    let $r9 = $d1d2 + $d0d3;\r\n    let r9 = qaq(d1d2, d0d3); // 48-bit aligned => error free\r\n    let _r9 = abs($r9);\r\n    let $m1 = 2 * $r6 + $c3d0;\r\n    let m1 = qaq(qm2(r6), c3d0); // 47-bit aligned => error free\r\n    let $m2 = 2 * $r6 + $c0d3;\r\n    let m2 = qaq(qm2(r6), c0d3); // 47-bit aligned => error free\r\n    let $m3 = 2 * $c2d0 + $c1d1;\r\n    let m3 = qaq(qm2(c2d0), c1d1); // 48-bit aligned => error free\r\n    let $m4 = 2 * $c0d2 + $c1d1;\r\n    let m4 = qaq(qm2(c0d2), c1d1); // 48-bit aligned => error free\r\n    let $m5 = $r8 + $c1c2;\r\n    let m5 = qaq(r8, c1c2); // 48-bit aligned => error free\r\n    let $m6 = $r9 + $d1d2;\r\n    let m6 = qaq(r9, d1d2); // 48-bit aligned => error free\r\n    let $m7 = (3 * c0) * $m5;\r\n    let m7 = qmd(3 * c0, m5); // 3*c0: 47-bit aligned => error free\r\n    let m7_ = abs($m7);\r\n    let $m8 = (3 * d0) * $m6;\r\n    let m8 = qmd(3 * d0, m6); // 3*c0: 47-bit aligned => error free\r\n    let m8_ = abs($m8);\r\n    let $m9 = c1 * $c1c1;\r\n    let m9 = qmd(c1, c1c1);\r\n    let m9_ = abs($m9);\r\n    let $ma = d1 * $d1d1;\r\n    let ma = qmd(d1, d1d1);\r\n    let ma_ = abs($ma);\r\n    let $mb = $vₓₓ * $r8;\r\n    let mb = qmq(vₓₓ, r8);\r\n    let mb_ = vₓₓ_ * _r8 + abs($mb);\r\n    let $mc = $vᵧᵧ * $r9;\r\n    let mc = qmq(vᵧᵧ, r9);\r\n    let mc_ = vᵧᵧ_ * _r9 + abs($mc);\r\n    let $md = $m1 + $r7;\r\n    let md = qaq(m1, r7);\r\n    let md_ = abs($md);\r\n    let $me = $m2 + $r7;\r\n    let me = qaq(m2, r7);\r\n    let me_ = abs($me);\r\n    let $mf = c0 * $md;\r\n    let mf = qmd(c0, md);\r\n    let mf_ = _c0 * md_ + abs($mf);\r\n    let $mg = d0 * $me;\r\n    let mg = qmd(d0, me);\r\n    let mg_ = _d0 * me_ + abs($mg);\r\n    let $mh = c1 * $m3;\r\n    let mh = qmd(c1, m3);\r\n    let mh_ = abs($mh);\r\n    let $mi = d1 * $m4;\r\n    let mi = qmd(d1, m4);\r\n    let mi_ = abs($mi);\r\n    let $mj = c3 * $vₓ;\r\n    let mj = qmd(c3, vₓ);\r\n    let mj_ = _c3 * vₓ_ + abs($mj);\r\n    let $mk = d3 * $vᵧ;\r\n    let mk = qmd(d3, vᵧ);\r\n    let mk_ = _d3 * vᵧ_ + abs($mk);\r\n    let $ml = $mf + $mh;\r\n    let ml = qaq(mf, mh);\r\n    let _ml = abs($ml);\r\n    let ml_ = mf_ + mh_ + _ml;\r\n    let $mm = $mg + $mi;\r\n    let mm = qaq(mg, mi);\r\n    let _mm = abs($mm);\r\n    let mm_ = mg_ + mi_ + _mm;\r\n    let $mn = $m7 + $m9;\r\n    let mn = qaq(m7, m9);\r\n    let _mn = abs($mn);\r\n    let mn_ = m7_ + m9_ + _mn;\r\n    let $mo = $m8 + $ma;\r\n    let mo = qaq(m8, ma);\r\n    let _mo = abs($mo);\r\n    let mo_ = m8_ + ma_ + _mo;\r\n    let $mp = $r7 + $r6;\r\n    let mp = qaq(r7, r6); // 47-bit aligned => error free\r\n    let _mp = abs($mp);\r\n    let $mq = 2 * ($mb + $mc);\r\n    let mq = qm2(qaq(mb, mc));\r\n    let mq_ = 2 * (mb_ + mc_) + abs($mq);\r\n    let $mr = $vₓₓᵧ * $ml;\r\n    let mr = qmq(vₓₓᵧ, ml);\r\n    let mr_ = vₓₓᵧ_ * _ml + _vₓₓᵧ * ml_ + 2 * abs($mr);\r\n    let $ms = $vₓᵧᵧ * $mm;\r\n    let ms = qmq(vₓᵧᵧ, mm);\r\n    let ms_ = vₓᵧᵧ_ * _mm + _vₓᵧᵧ * mm_ + 2 * abs($ms);\r\n    let $mt = $vₓₓₓ * $mn;\r\n    let mt = qmq(vₓₓₓ, mn);\r\n    let mt_ = vₓₓₓ_ * _mn + _vₓₓₓ * mn_ + 2 * abs($mt);\r\n    let $mu = $vᵧᵧᵧ * $mo;\r\n    let mu = qmq(vᵧᵧᵧ, mo);\r\n    let mu_ = vᵧᵧᵧ_ * _mo + _vᵧᵧᵧ * mo_ + 2 * abs($mu);\r\n    let $mv = $vₓᵧ * $mp;\r\n    let mv = qmq(vₓᵧ, mp);\r\n    let mv_ = vₓᵧ_ * _mp + abs($mv);\r\n    let $mw = $mr + $ms;\r\n    let mw = qaq(mr, ms);\r\n    let mw_ = mr_ + ms_ + abs($mw);\r\n    let $mx = $mt + $mu;\r\n    let mx = qaq(mt, mu);\r\n    let mx_ = mt_ + mu_ + abs($mx);\r\n    let $my = $mv + $mq;\r\n    let my = qaq(mv, mq);\r\n    let my_ = mv_ + mq_ + abs($my);\r\n    let $mz = $mj + $mk;\r\n    let mz = qaq(mj, mk);\r\n    let mz_ = mj_ + mk_ + abs($mz);\r\n    let $n1 = $mw + $mx;\r\n    let n1 = qaq(mw, mx);\r\n    let n1_ = mw_ + mx_ + abs($n1);\r\n    let $n2 = $my + $mz;\r\n    let n2 = qaq(my, mz);\r\n    let n2_ = my_ + mz_ + abs($n2);\r\n    let $v3 = $n1 + $n2;\r\n    let v3 = qaq(n1, n2);\r\n    let v3_ = n1_ + n2_ + abs($v3);\r\n    //let ra = c1d1 + c2d0;\r\n    //let rb = c1d1 + c0d2;\r\n    //let v2 =\r\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //    vₓᵧ*(ra + c0d2) +\r\n    //    vₓₓ*(2*c0c2 + c1c1) + \r\n    //    vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //    c2*vₓ + d2*vᵧ;\r\n    let $ra = $c1d1 + $c2d0;\r\n    let ra = qaq(c1d1, c2d0); // 48-bit aligned => error free\r\n    let $rb = $c1d1 + $c0d2;\r\n    let rb = qaq(c1d1, c0d2); // 48-bit aligned => error free\r\n    let $l1 = 2 * $ra + $c0d2;\r\n    let l1 = qaq(qm2(ra), c0d2); // 47-bit aligned => error free\r\n    let $l2 = 2 * $rb + $c2d0;\r\n    let l2 = qaq(qm2(rb), c2d0); // 47-bit aligned => error free\r\n    let $l3 = c0 * $l1;\r\n    let l3 = qmd(c0, l1);\r\n    let l3_ = abs($l3);\r\n    let $l4 = d0 * $c1c1;\r\n    let l4 = qmd(d0, c1c1);\r\n    let l4_ = abs($l4);\r\n    let $l5 = d0 * $l2;\r\n    let l5 = qmd(d0, l2);\r\n    let l5_ = abs($l5);\r\n    let $l6 = c0 * $d1d1;\r\n    let l6 = qmd(c0, d1d1);\r\n    let l6_ = abs($l6);\r\n    let $l7 = c0 * $c1c1;\r\n    let l7 = qmd(c0, c1c1);\r\n    let l7_ = abs($l7);\r\n    let $l8 = c2 * $c0c0;\r\n    let l8 = qmd(c2, c0c0);\r\n    let l8_ = abs($l8);\r\n    let $l9 = d0 * $d1d1;\r\n    let l9 = qmd(d0, d1d1);\r\n    let l9_ = abs($l9);\r\n    let $la = d2 * $d0d0;\r\n    let la = qmd(d2, d0d0);\r\n    let la_ = abs($la);\r\n    let $lb = $l3 + $l4;\r\n    let lb = qaq(l3, l4);\r\n    let _lb = abs($lb);\r\n    let lb_ = l3_ + l4_ + _lb;\r\n    let $lc = $l5 + $l6;\r\n    let lc = qaq(l5, l6);\r\n    let _lc = abs($lc);\r\n    let lc_ = l5_ + l6_ + _lc;\r\n    let $ld = $l7 + $l8;\r\n    let ld = qaq(l7, l8);\r\n    let _ld = abs($ld);\r\n    let ld_ = l7_ + l8_ + _ld;\r\n    let $le = $l9 + $la;\r\n    let le = qaq(l9, la);\r\n    let _le = abs($le);\r\n    let le_ = l9_ + la_ + _le;\r\n    let $lf = $vₓₓₓ * $ld;\r\n    let lf = qmq(vₓₓₓ, ld);\r\n    let lf_ = vₓₓₓ_ * _ld + _vₓₓₓ * ld_ + 2 * abs($lf);\r\n    let $lg = $vᵧᵧᵧ * $le;\r\n    let lg = qmq(vᵧᵧᵧ, le);\r\n    let lg_ = vᵧᵧᵧ_ * _le + _vᵧᵧᵧ * le_ + 2 * abs($lg);\r\n    let $lh = 3 * ($lf + $lg);\r\n    let lh = qmd(3, qaq(lf, lg));\r\n    let lh_ = 3 * (lf_ + lg_) + 2 * abs($lh);\r\n    let $li = $ra + $c0d2;\r\n    let li = qaq(ra, c0d2); // 48-bit aligned => error free\r\n    let _li = abs($li);\r\n    let $lj = 2 * $c0c2 + $c1c1;\r\n    let lj = qaq(qm2(c0c2), c1c1); // 48-bit aligned => error free\r\n    let _lj = abs($lj);\r\n    let $lk = 2 * $d0d2 + $d1d1;\r\n    let lk = qaq(qm2(d0d2), d1d1); // 48-bit aligned => error free\r\n    let _lk = abs($lk);\r\n    let $ll = $vₓₓᵧ * $lb;\r\n    let ll = qmq(vₓₓᵧ, lb);\r\n    let ll_ = vₓₓᵧ_ * _lb + _vₓₓᵧ * lb_ + 2 * abs($ll);\r\n    let $lm = $vₓᵧᵧ * $lc;\r\n    let lm = qmq(vₓᵧᵧ, lc);\r\n    let lm_ = vₓᵧᵧ_ * _lc + _vₓᵧᵧ * lc_ + 2 * abs($lm);\r\n    let $ln = $vₓᵧ * $li;\r\n    let ln = qmq(vₓᵧ, li);\r\n    let ln_ = vₓᵧ_ * _li + 2 * abs($ln);\r\n    let $lo = $vₓₓ * $lj;\r\n    let lo = qmq(vₓₓ, lj);\r\n    let lo_ = vₓₓ_ * _lj + 2 * abs($lo);\r\n    let $lp = $vᵧᵧ * $lk;\r\n    let lp = qmq(vᵧᵧ, lk);\r\n    let lp_ = vᵧᵧ_ * _lk + 2 * abs($lp);\r\n    let $lq = c2 * $vₓ;\r\n    let lq = qmd(c2, vₓ);\r\n    let lq_ = _c2 * vₓ_ + abs($lq);\r\n    let $lr = d2 * $vᵧ;\r\n    let lr = qmd(d2, vᵧ);\r\n    let lr_ = _d2 * vᵧ_ + abs($lr);\r\n    let $ls = $lq + $lr;\r\n    let ls = qaq(lq, lr);\r\n    let ls_ = lq_ + lr_ + abs($ls);\r\n    let $lt = $ll + $lm;\r\n    let lt = qaq(ll, lm);\r\n    let lt_ = ll_ + lm_ + abs($lt);\r\n    let $lu = $lh + $ln;\r\n    let lu = qaq(lh, ln);\r\n    let lu_ = lh_ + ln_ + abs($lu);\r\n    let $lv = $lo + $lp;\r\n    let lv = qaq(lo, lp);\r\n    let lv_ = lo_ + lp_ + abs($lv);\r\n    let $lw = $lt + $lu;\r\n    let lw = qaq(lt, lu);\r\n    let lw_ = lt_ + lu_ + abs($lw);\r\n    let $lx = $lv + $ls;\r\n    let lx = qaq(lv, ls);\r\n    let lx_ = lv_ + ls_ + abs($lx);\r\n    let $v2 = $lw + $lx;\r\n    let v2 = qaq(lw, lx);\r\n    let v2_ = lw_ + lx_ + abs($v2);\r\n    //let rc = c1d0 + c0d1;\r\n    //let v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    let $rc = $c1d0 + $c0d1;\r\n    let rc = qaq(c1d0, c0d1); // 48-bit aligned => error free\r\n    let _rc = abs($rc);\r\n    let $rd = c0 * $vₓₓᵧ;\r\n    let rd = qmd(c0, vₓₓᵧ);\r\n    let _rd = abs($rd);\r\n    let rd_ = _c0 * vₓₓᵧ_ + _rd;\r\n    let $re = d0 * $vₓᵧᵧ;\r\n    let re = qmd(d0, vₓᵧᵧ);\r\n    let _re = abs($re);\r\n    let re_ = _d0 * vₓᵧᵧ_ + _re;\r\n    let $rf = $rc + $c1d0;\r\n    let rf = qaq(rc, c1d0); // 48-bit aligned => error free\r\n    let _rf = abs($rf);\r\n    let $rg = $rc + $c0d1;\r\n    let rg = qaq(rc, c0d1); // 48-bit aligned => error free\r\n    let _rg = abs($rg);\r\n    let $rx = c1 * $c0c0;\r\n    let rx = qmd(c1, c0c0);\r\n    let rx_ = abs($rx);\r\n    let $rh = $rx * $vₓₓₓ;\r\n    let rh = qmq(rx, vₓₓₓ);\r\n    let rh_ = rx_ * (_vₓₓₓ + vₓₓₓ_) + 2 * abs($rh);\r\n    let $ry = d1 * $d0d0;\r\n    let ry = qmd(d1, d0d0);\r\n    let ry_ = abs($ry);\r\n    let $ri = $ry * $vᵧᵧᵧ;\r\n    let ri = qmq(ry, vᵧᵧᵧ);\r\n    let ri_ = ry_ * (_vᵧᵧᵧ + vᵧᵧᵧ_) + 2 * abs($ri);\r\n    let $rj = $vₓᵧ * $rc;\r\n    let rj = qmq(vₓᵧ, rc);\r\n    let rj_ = vₓᵧ_ * _rc + 2 * abs($rj);\r\n    let $rk = $c0c1 * $vₓₓ;\r\n    let rk = qmq(c0c1, vₓₓ);\r\n    let rk_ = _c0c1 * vₓₓ_ + 2 * abs($rk);\r\n    let $rl = $d0d1 * $vᵧᵧ;\r\n    let rl = qmq(d0d1, vᵧᵧ);\r\n    let rl_ = _d0d1 * vᵧᵧ_ + 2 * abs($rl);\r\n    let $rm = $rk + $rl;\r\n    let rm = qaq(rk, rl);\r\n    let rm_ = rk_ + rl_ + abs($rm);\r\n    let $rn = c1 * $vₓ;\r\n    let rn = qmd(c1, vₓ);\r\n    let rn_ = _c1 * vₓ_ + abs($rn);\r\n    let $ro = d1 * $vᵧ;\r\n    let ro = qmd(d1, vᵧ);\r\n    let ro_ = _d1 * vᵧ_ + abs($ro);\r\n    let $rp = $rn + $ro;\r\n    let rp = qaq(rn, ro);\r\n    let rp_ = rn_ + ro_ + abs($rp);\r\n    let $rq = $rd * $rf;\r\n    let rq = qmq(rd, rf);\r\n    let rq_ = rd_ * _rf + 2 * abs($rq);\r\n    let $rr = $re * $rg;\r\n    let rr = qmq(re, rg);\r\n    let rr_ = re_ * _rg + 2 * abs($rr);\r\n    let $rs = $rq + $rr;\r\n    let rs = qaq(rq, rr);\r\n    let rs_ = rq_ + rr_ + abs($rs);\r\n    let $rt = 3 * ($rh + $ri);\r\n    let rt = qmd(3, qaq(rh, ri));\r\n    let rt_ = 3 * (rh_ + ri_) + 2 * abs($rt);\r\n    let $ru = $rj + 2 * $rm;\r\n    let ru = qaq(rj, qm2(rm));\r\n    let ru_ = rj_ + 2 * rm_ + abs($ru);\r\n    let $rv = $rs + $rt;\r\n    let rv = qaq(rs, rt);\r\n    let rv_ = rs_ + rt_ + abs($rv);\r\n    let $rw = $ru + $rp;\r\n    let rw = qaq(ru, rp);\r\n    let rw_ = ru_ + rp_ + abs($rw);\r\n    let $v1 = $rv + $rw;\r\n    let v1 = qaq(rv, rw);\r\n    let v1_ = rv_ + rw_ + abs($v1);\r\n    // v0\r\n    let $t1 = c0 * $vₓₓₓ;\r\n    let t1 = qmd(c0, vₓₓₓ);\r\n    let t1_ = _c0 * vₓₓₓ_ + abs($t1);\r\n    let $t2 = d0 * $vₓₓᵧ;\r\n    let t2 = qmd(d0, vₓₓᵧ);\r\n    let t2_ = _d0 * vₓₓᵧ_ + abs($t2);\r\n    let $p4 = $t1 + $t2;\r\n    let p4 = qaq(t1, t2);\r\n    let p4_ = t1_ + t2_ + abs($p4);\r\n    let $t3 = c0 * $vₓᵧᵧ;\r\n    let t3 = qmd(c0, vₓᵧᵧ);\r\n    let t3_ = _c0 * vₓᵧᵧ_ + abs($t3);\r\n    let $t4 = d0 * $vᵧᵧᵧ;\r\n    let t4 = qmd(d0, vᵧᵧᵧ);\r\n    let t4_ = _d0 * vᵧᵧᵧ_ + abs($t4);\r\n    let $p5 = $t3 + $t4;\r\n    let p5 = qaq(t3, t4);\r\n    let p5_ = t3_ + t4_ + abs($p5);\r\n    let $p7 = $p4 + $vₓₓ;\r\n    let p7 = qaq(p4, vₓₓ);\r\n    let _p7 = abs($p7);\r\n    let p7_ = p4_ + vₓₓ_ + _p7;\r\n    let $p8 = $p5 + $vᵧᵧ;\r\n    let p8 = qaq(p5, vᵧᵧ);\r\n    let _p8 = abs($p8);\r\n    let p8_ = p5_ + vᵧᵧ_ + _p8;\r\n    let $pc = $c0c0 * $p7;\r\n    let pc = qmq(c0c0, p7);\r\n    let pc_ = _c0c0 * p7_ + 2 * abs($pc);\r\n    let $pd = $d0d0 * $p8;\r\n    let pd = qmq(d0d0, p8);\r\n    let pd_ = _d0d0 * p8_ + 2 * abs($pd);\r\n    let $p6 = $pc + $pd;\r\n    let p6 = qaq(pc, pd);\r\n    let p6_ = pc_ + pd_ + abs($p6);\r\n    let $pe = $c0d0 * $vₓᵧ;\r\n    let pe = qmq(c0d0, vₓᵧ);\r\n    let pe_ = _c0d0 * vₓᵧ_ + abs($pe);\r\n    let $p9 = $p6 + $pe;\r\n    let p9 = qaq(p6, pe);\r\n    let p9_ = p6_ + pe_ + abs($p9);\r\n    let $pf = c0 * $vₓ;\r\n    let pf = qmd(c0, vₓ);\r\n    let pf_ = _c0 * vₓ_ + abs($pf);\r\n    let $pg = d0 * $vᵧ;\r\n    let pg = qmd(d0, vᵧ);\r\n    let pg_ = _d0 * vᵧ_ + abs($pg);\r\n    let $pa = $pf + $pg;\r\n    let pa = qaq(pf, pg);\r\n    let pa_ = pf_ + pg_ + abs($pa);\r\n    let $pb = $p9 + $pa;\r\n    let pb = qaq(p9, pa);\r\n    let pb_ = p9_ + pa_ + abs($pb);\r\n    let $v0 = $pb + $v;\r\n    let v0 = qaq(pb, v);\r\n    let v0_ = pb_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [v9_, v8_, v7_, v6_, v5_, v4_, v3_, v2_, v1_, v0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs3x3Quad = getCoeffs3x3Quad;\r\n//# sourceMappingURL=get-coefficients-3x3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/bezier-intersection-implicit/quad/get-coefficients-3x3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection-precise.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection-precise.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_coeffs_quad_1 = __webpack_require__(/*! ./quad/get-coeffs-quad */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/quad/get-coeffs-quad.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * * **precondition** max bit-aligned bitlength === 47\r\n * * returned parameter values are guaranteed accurate to within 4 ulps\r\n * @param circle\r\n * @param ps\r\n */\r\nfunction circleBezierIntersectionPrecise(circle, ps) {\r\n    let poly;\r\n    if (ps.length === 4) {\r\n        poly = get_coeffs_quad_1.getCoeffsCubicQuad(circle, ps);\r\n    }\r\n    else if (ps.length === 3) {\r\n        poly = get_coeffs_quad_1.getCoeffsQuadraticQuad(circle, ps);\r\n    }\r\n    else if (ps.length === 2) {\r\n        poly = get_coeffs_quad_1.getCoeffsLinearQuad(circle, ps);\r\n    }\r\n    let ts = flo_poly_1.allRootsMultiWithErrBounds(poly, poly.map(c => 0));\r\n    return ts.map(t => {\r\n        return {\r\n            //t: t.tM,\r\n            t: flo_poly_1.mid(t),\r\n            //p: evalDeCasteljau(ps, t.tM)\r\n            p: eval_de_casteljau_1.evalDeCasteljau(ps, flo_poly_1.mid(t))\r\n        };\r\n    });\r\n}\r\nexports.circleBezierIntersectionPrecise = circleBezierIntersectionPrecise;\r\n//# sourceMappingURL=circle-bezier-intersection-precise.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection-precise.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/circle-bezier-intersection.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/circle-bezier-intersection.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_coeffs_1 = __webpack_require__(/*! ./get-coeffs */ \"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/get-coeffs.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\nfunction circleBezierIntersection(circle, ps) {\r\n    let poly;\r\n    if (ps.length === 4) {\r\n        poly = get_coeffs_1.getCoeffsCubic(circle, ps);\r\n    }\r\n    else if (ps.length === 3) {\r\n        poly = get_coeffs_1.getCeoffsQuadratic(circle, ps);\r\n    }\r\n    else if (ps.length === 2) {\r\n        poly = get_coeffs_1.getCeoffsLine(circle, ps);\r\n    }\r\n    let ts = flo_poly_1.allRoots(poly, 0, 1);\r\n    return ts.map(t => {\r\n        return {\r\n            t,\r\n            p: eval_de_casteljau_1.evalDeCasteljau(ps, t)\r\n        };\r\n    });\r\n}\r\nexports.circleBezierIntersection = circleBezierIntersection;\r\n//# sourceMappingURL=circle-bezier-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/circle-bezier-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/get-coeffs.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/get-coeffs.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\n/**\r\n *\r\n * @param circle a circle\r\n * @param ps a cubic bezier curve\r\n */\r\nfunction getCoeffsCubic(circle, ps) {\r\n    let { radius: r, center: [cx, cy] } = circle;\r\n    let [[a3, a2, a1, a0], [b3, b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    // (a3*a3 + b3*b3)*t**6 + \r\n    let t6 = a3 * a3 + b3 * b3;\r\n    // (2*a2*a3 + 2*b2*b3)*t**5 + \r\n    let t5 = 2 * (a2 * a3 + b2 * b3);\r\n    // (2*a1*a3 + a2*a2 + 2*b1*b3 + b2*b2)*t**4 + \r\n    let t4 = 2 * (a1 * a3 + b1 * b3) + a2 * a2 + b2 * b2;\r\n    // (2*a0*a3 + 2*a1*a2 - 2*a3*cx + 2*b0*b3 + 2*b1*b2 - 2*b3*cy)*t**3 + \r\n    let t3 = 2 * (a0 * a3 + a1 * a2 - a3 * cx + b0 * b3 + b1 * b2 - b3 * cy);\r\n    // (2*a0*a2 + a1*a1 - 2*a2*cx + 2*b0*b2 + b1*b1 - 2*b2*cy)*t**2 + \r\n    let t2 = 2 * (a0 * a2 - a2 * cx + b0 * b2 - b2 * cy) + a1 * a1 + b1 * b1;\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    let t1 = 2 * (a0 * a1 - a1 * cx + b0 * b1 - b1 * cy);\r\n    // a0*a0 - 2*a0*cx + b0*b0 - 2*b0*cy + cx*cx + cy*cy - r*r\r\n    let t0 = -2 * (a0 * cx + b0 * cy) + a0 * a0 + b0 * b0 + cx * cx + cy * cy - r * r;\r\n    return [t6, t5, t4, t3, t2, t1, t0];\r\n}\r\nexports.getCoeffsCubic = getCoeffsCubic;\r\n/**\r\n*\r\n* @param circle a circle\r\n* @param ps a quadratic bezier curve\r\n*/\r\nfunction getCeoffsQuadratic(circle, ps) {\r\n    let { radius: r, center: [cx, cy] } = circle;\r\n    let [[a2, a1, a0], [b2, b1, b0]] = get_xy_1.getXY(ps);\r\n    // (a2*a2 + b2*b2)*t**4 + \r\n    let t4 = a2 * a2 + b2 * b2;\r\n    // (2*a1*a2 + 2*b1*b2)*t**3 + \r\n    let t3 = 2 * (a1 * a2 + b1 * b2);\r\n    // (2*a0*a2 + a1*a1 - 2*a2*cx + 2*b0*b2 + b1*b1 - 2*b2*cy)*t**2 + \r\n    let t2 = 2 * (a0 * a2 - a2 * cx + b0 * b2 - b2 * cy) + a1 * a1 + b1 * b1;\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    let t1 = 2 * (a0 * a1 - a1 * cx + b0 * b1 - b1 * cy);\r\n    // a0*a0 - 2*a0*cx + b0*b0 - 2*b0*cy + cx*cx + cy*cy - r*r\r\n    let t0 = -2 * (a0 * cx + b0 * cy) + a0 * a0 + b0 * b0 + cx * cx + cy * cy - r * r;\r\n    return [t4, t3, t2, t1, t0];\r\n}\r\nexports.getCeoffsQuadratic = getCeoffsQuadratic;\r\n/**\r\n*\r\n* @param circle a circle\r\n* @param ps a linear bezier curve\r\n*/\r\nfunction getCeoffsLine(circle, ps) {\r\n    let { radius: r, center: [cx, cy] } = circle;\r\n    let [[a1, a0], [b1, b0]] = get_xy_1.getXY(ps);\r\n    // (a1**2 + b1**2)*t**2 +\r\n    let t2 = a1 * a1 + b1 * b1;\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    let t1 = 2 * (a0 * a1 - a1 * cx + b0 * b1 - b1 * cy);\r\n    // a0*a0 - 2*a0*cx + b0*b0 - 2*b0*cy + cx*cx + cy*cy - r*r\r\n    let t0 = -2 * (a0 * cx + b0 * cy) + a0 * a0 + b0 * b0 + cx * cx + cy * cy - r * r;\r\n    return [t2, t1, t0];\r\n}\r\nexports.getCeoffsLine = getCeoffsLine;\r\n//# sourceMappingURL=get-coeffs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/naive/get-coeffs.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/quad/get-coeffs-quad.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/quad/get-coeffs-quad.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qmn2 = flo_numerical_1.qMultByNeg2;\r\nconst qdifq = flo_numerical_1.qDiffQuad;\r\n/**\r\n * * **precondition** bit-algined bitlength of coefficients <= 47\r\n * @param circle a circle\r\n * @param ps a cubic bezier curve\r\n */\r\nfunction getCoeffsCubicQuad(circle, ps) {\r\n    let { radius: r, center: [cx, cy] } = circle;\r\n    let [[a3, a2, a1, a0], [b3, b2, b1, b0]] = get_xy_1.getXY(ps); // exact if bitlength <= 49\r\n    // bitlength 48 -> saves 2 bits -> 1-4 summands\r\n    // bitlength 47 -> saves 4 bits -> 5-16 summands\r\n    // bitlength 46 -> saves 6 bits -> 17-64 summands\r\n    // (a3**2 + b3**2)*t**6 + \r\n    let t6 = qaq(tp(a3, a3), tp(b3, b3)); // exact if bitlength <= 48 - 2 summands\r\n    // (2*a2*a3 + 2*b2*b3)*t**5 + \r\n    let t5 = qm2(qaq(tp(a2, a3), tp(b2, b3))); // exact if bitlength <= 48 - 2 summands\r\n    // (2*a1*a3 + a2*a2 + 2*b1*b3 + b2*b2)*t**4 + \r\n    let t4 = qaq(qm2(qaq(tp(a1, a3), tp(b1, b3))), qaq(tp(a2, a2), tp(b2, b2))); // exact if bitlength <= 47 - 6 summands\r\n    // (2*a0*a3 + 2*a1*a2 - 2*a3*cx + 2*b0*b3 + 2*b1*b2 - 2*b3*cy)*t**3 + \r\n    let t3 = qm2(qdifq(qaq(qaq(tp(a0, a3), tp(a1, a2)), qaq(tp(b0, b3), tp(b1, b2))), (qaq(tp(a3, cx), tp(b3, cy))))); // exact if bitlength <= 47 - 6 summands\r\n    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + \r\n    let t2 = qaq(qm2(qdifq(qaq(tp(a0, a2), tp(b0, b2)), (qaq(tp(a2, cx), tp(b2, cy))))), qaq(tp(a1, a1), tp(b1, b1))); // exact if bitlength <= 47 - 10 summands\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    let t1 = qm2(qdifq(qaq(tp(a0, a1), tp(b0, b1)), (qaq(tp(a1, cx), tp(b1, cy))))); // exact if bitlength <= 48 - 4 summands\r\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\r\n    let t0 = qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), qdifq(qaq(qaq(tp(a0, a0), tp(b0, b0)), qaq(tp(cx, cx), tp(cy, cy))), tp(r, r))); // exact if bitlength <= 47 - 9 summands\r\n    return [t6, t5, t4, t3, t2, t1, t0];\r\n}\r\nexports.getCoeffsCubicQuad = getCoeffsCubicQuad;\r\n/**\r\n * * **precondition** bit-algined bitlength of coefficients <= 47\r\n * @param circle a circle\r\n * @param ps a quadratic bezier curve\r\n */\r\nfunction getCoeffsQuadraticQuad(circle, ps) {\r\n    let { radius: r, center: [cx, cy] } = circle;\r\n    let [[a2, a1, a0], [b2, b1, b0]] = get_xy_1.getXY(ps); // exact if bitlength <= 49\r\n    // (a2*a2 + b2*b2)*t**4 + \r\n    let t4 = qaq(tp(a2, a2), tp(b2, b2)); // exact if bitlength <= 48 - 2 summands\r\n    // (2*a1*a2 + 2*b1*b2)*t**3 + \r\n    let t3 = qm2(qaq(tp(a1, a2), tp(b1, b2))); // exact if bitlength <= 48 - 2 summands\r\n    // (2*a0*a2 + a1*a1 - 2*a2*cx + 2*b0*b2 + b1*b1 - 2*b2*cy)*t**2 + \r\n    let t2 = qaq(qm2(qdifq(qaq(tp(a0, a2), tp(b0, b2)), (qaq(tp(a2, cx), tp(b2, cy))))), qaq(tp(a1, a1), tp(b1, b1))); // exact if bitlength <= 47 - 10 summands\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    let t1 = qm2(qdifq(qaq(tp(a0, a1), tp(b0, b1)), (qaq(tp(a1, cx), tp(b1, cy))))); // exact if bitlength <= 48 - 4 summands\r\n    // a0*a0 - 2*a0*cx + b0*b0 - 2*b0*cy + cx*cx + cy*cy - r*r\r\n    let t0 = qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), qdifq(qaq(qaq(tp(a0, a0), tp(b0, b0)), qaq(tp(cx, cx), tp(cy, cy))), tp(r, r))); // exact if bitlength <= 47 - 9 summands\r\n    return [t4, t3, t2, t1, t0];\r\n}\r\nexports.getCoeffsQuadraticQuad = getCoeffsQuadraticQuad;\r\n/**\r\n * * **precondition** bit-algined bitlength of coefficients <= 47\r\n * @param circle a circle\r\n * @param ps a linear bezier curve\r\n */\r\nfunction getCoeffsLinearQuad(circle, ps) {\r\n    let { radius: r, center: [cx, cy] } = circle;\r\n    let [[a1, a0], [b1, b0]] = get_xy_1.getXY(ps); // exact if bitlength <= 49\r\n    // (a1**2 + b1**2)*t**2 +\r\n    let t2 = qaq(tp(a1, a1), tp(b1, b1)); // exact if bitlength <= 48 - 2 summands\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    let t1 = qm2(qdifq(qaq(tp(a0, a1), tp(b0, b1)), (qaq(tp(a1, cx), tp(b1, cy))))); // exact if bitlength <= 48 - 4 summands\r\n    // a0*a0 - 2*a0*cx + b0*b0 - 2*b0*cy + cx*cx + cy*cy - r*r\r\n    let t0 = qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), qdifq(qaq(qaq(tp(a0, a0), tp(b0, b0)), qaq(tp(cx, cx), tp(cy, cy))), tp(r, r))); // exact if bitlength <= 47 - 9 summands\r\n    return [t2, t1, t0];\r\n}\r\nexports.getCoeffsLinearQuad = getCoeffsLinearQuad;\r\n//# sourceMappingURL=get-coeffs-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/quad/get-coeffs-quad.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst inversion_01_1 = __webpack_require__(/*! ./inversion-01 */ \"./node_modules/flo-bezier3/node/intersection/inversion-01.js\");\r\nconst root_interval_1 = __webpack_require__(/*! flo-poly/node/roots/multi-with-err-bound/root-interval */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval.js\");\r\n/**\r\n * Returns the t pairs where the endpoints of the two given same-k-family curves\r\n * overlap.\r\n * * **precondition**: the two given curves must be in the same k-family.\r\n * @param ps1 an order 1,2 or 3 bezier curve\r\n * @param ps2 another order 1,2 or 3 bezier curve\r\n * @param minD an error bound given as a distance\r\n */\r\nfunction getEndpointIntersections(ps1, ps2, minD) {\r\n    let p1S = ps1[0];\r\n    let p1E = ps1[ps1.length - 1];\r\n    let p2S = ps2[0];\r\n    let p2E = ps2[ps2.length - 1];\r\n    /** closest point on ps2 from p1S */\r\n    let ps2S1 = inversion_01_1.inversion01Precise(ps2, p1S);\r\n    let ps2E1 = inversion_01_1.inversion01Precise(ps2, p1E);\r\n    let ps1S2 = inversion_01_1.inversion01Precise(ps1, p2S);\r\n    let ps1E2 = inversion_01_1.inversion01Precise(ps1, p2E);\r\n    let riPairs = [];\r\n    if (ps2S1 && ps2S1.minD < minD) {\r\n        riPairs.push([\r\n            root_interval_1.createRootExact(0),\r\n            root_interval_1.createRootExact(ps2S1.t) // TODO - multiplicity should be +infinity ??\r\n        ]);\r\n    }\r\n    if (ps2E1 && ps2E1.minD < minD) {\r\n        riPairs.push([\r\n            root_interval_1.createRootExact(1),\r\n            root_interval_1.createRootExact(ps2E1.t),\r\n        ]);\r\n    }\r\n    if (ps1S2 && ps1S2.minD < minD) {\r\n        riPairs.push([\r\n            root_interval_1.createRootExact(ps1S2.t),\r\n            root_interval_1.createRootExact(0),\r\n        ]);\r\n    }\r\n    if (ps1E2 && ps1E2.minD < minD) {\r\n        riPairs.push([\r\n            root_interval_1.createRootExact(ps1E2.t),\r\n            root_interval_1.createRootExact(1),\r\n        ]);\r\n    }\r\n    return riPairs;\r\n}\r\nexports.getEndpointIntersections = getEndpointIntersections;\r\n//# sourceMappingURL=get-endpoint-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/inversion-01.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/inversion-01.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-xy/evaluate */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_tangent_poly_from_point_1 = __webpack_require__(/*! ../simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point.js\");\r\n/**\r\n * Returns the closest point t value on the bezier to the given point - only\r\n * returns t values in the range [0,1]. Also returns the minimum distance found.\r\n * **precondition** coefficients of curve and point bit-aligned bitlength <= 46\r\n * * this function also acts as an inversion formula.\r\n *\r\n * @param ps\r\n * @param p\r\n */\r\nfunction inversion01Precise(ps, p) {\r\n    // TODO - a double point could give two t-values which is not currently\r\n    // checked for and handled - this might or might not be important depending\r\n    // on the application\r\n    // the coefficients of the poly below is max double-double\r\n    let poly = get_tangent_poly_from_point_1.getTangentPolyFromPointExact(ps, p);\r\n    //let ts = quadAllRootsPrecise(poly, 0, 1);\r\n    let ts = flo_poly_1.allRootsMultiWithErrBounds(poly, poly.map(c => 0));\r\n    if (!ts.length) {\r\n        return undefined;\r\n    }\r\n    let ps_ = ts.map(t => ({\r\n        //t: t.tM,\r\n        t: flo_poly_1.mid(t),\r\n        p: evaluate_1.evaluateExact(ps, flo_poly_1.mid(t)).map(flo_numerical_1.estimate)\r\n    }));\r\n    // Get point with minimum distance\r\n    let minD = Number.POSITIVE_INFINITY;\r\n    let t = undefined;\r\n    ps_.forEach(p_ => {\r\n        let d = flo_vector2d_1.squaredDistanceBetween(p_.p, p);\r\n        if (d < minD) {\r\n            minD = d;\r\n            t = p_.t;\r\n        }\r\n    });\r\n    return { t, minD };\r\n}\r\nexports.inversion01Precise = inversion01Precise;\r\n//# sourceMappingURL=inversion-01.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/inversion-01.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3-.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3-.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qdq = flo_numerical_1.qDiffQuad;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\n/**\r\n * Returns the self-intersection poly to solve of the given cubic bezier curve.\r\n * see http://www.mare.ee/indrek/misc/2d.pdf\r\n * * precondition: max 47 bit bit-aligned coefficient bitlength\r\n * @param ps An order 3 bezier curve.\r\n */\r\nfunction getCoeffs3Exact_(ps) {\r\n    let [[a3, a2, a1], [b3, b2, b1]] = get_xy_1.getXY(ps); // 49-bit aligned => error free\r\n    let a2b3 = tp(a2, b3); // => error free\r\n    let a3b2 = tp(a3, b2); // => error free\r\n    let a3b1 = tp(a3, b1); // => error free\r\n    let a1b3 = tp(a1, b3); // => error free\r\n    let a2b1 = tp(a2, b1); // => error free\r\n    let a1b2 = tp(a1, b2); // => error free\r\n    let f4 = qdq(a2b3, a3b2); // 48-bit aligned => error free\r\n    let f5 = qdq(a1b3, a3b1); // 48-bit aligned => error free\r\n    let f6 = qdq(a2b1, a1b2); // 48-bit aligned => error free\r\n    //let u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    let u2 = epr(f4, f4);\r\n    //let u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    let u1 = epr(f4, f5);\r\n    //let u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    let g7 = epr(f4, f6);\r\n    let g9 = epr(f5, f5);\r\n    let u0 = fes(g7, g9);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return [u2, u1, u0];\r\n}\r\nexports.getCoeffs3Exact_ = getCoeffs3Exact_;\r\n//# sourceMappingURL=get-coeffs-3-.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3-.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_1 = __webpack_require__(/*! ../../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the self-intersection poly to solve of the given cubic bezier curve.\r\n * see http://www.mare.ee/indrek/misc/2d.pdf\r\n * @param ps An order 3 bezier curve.\r\n */\r\nfunction getCoeffs3Exact(ps) {\r\n    let [a3, a2, a1] = get_x_1.getXExact(ps);\r\n    let [b3, b2, b1] = get_y_1.getYExact(ps);\r\n    //let u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    let u2 = flo_numerical_1.calculate([\r\n        [[-2], a2, a3, b2, b3], [a2, a2, b3, b3], [a3, a3, b2, b2]\r\n    ]);\r\n    //let u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    let u1 = flo_numerical_1.calculate([\r\n        [[-1], a1, a3, b2, b3], [[-1], a2, a3, b1, b3], [a1, a2, b3, b3], [b1, b2, a3, a3]\r\n    ]);\r\n    //let u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    let u0 = flo_numerical_1.calculate([\r\n        [[-1], a1, a2, b2, b3], [[-1], a2, a3, b1, b2], [[-2], a1, a3, b1, b3],\r\n        [a1, a1, b3, b3], [a3, a3, b1, b1], [a1, a3, b2, b2],\r\n        [b1, b3, a2, a2]\r\n    ]);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return [u2, u1, u0];\r\n}\r\nexports.getCoeffs3Exact = getCoeffs3Exact;\r\n//# sourceMappingURL=get-coeffs-3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/naive/get-coeffs-3.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/naive/get-coeffs-3.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\n/**\r\n * Get self-intersection coefficients\r\n * * **precondition**: max bit-aligned bitlength: 47\r\n */\r\nfunction getCoeffs3(ps) {\r\n    let [[a3, a2, a1], [b3, b2, b1]] = get_xy_1.getXY(ps); // exact if max bit-aligned bitlength <= 49\r\n    let a2b3 = a2 * b3;\r\n    let a3b2 = a3 * b2;\r\n    let a3b1 = a3 * b1;\r\n    let a1b3 = a1 * b3;\r\n    let a2b1 = a2 * b1;\r\n    let a1b2 = a1 * b2;\r\n    // Note: a variable prepended with and underscore is an absolute value,\r\n    // postpended with an underscore denotes an absolute error (before \r\n    // multiplication by the round-off unit u) - both underscores present means\r\n    // it is both an absolute value and a round-off error.\r\n    let _a2b3_ = abs(a2b3);\r\n    let _a3b2_ = abs(a3b2);\r\n    let _a3b1_ = abs(a3b1);\r\n    let _a1b3_ = abs(a1b3);\r\n    let _a2b1_ = abs(a2b1);\r\n    let _a1b2_ = abs(a1b2);\r\n    let f4 = a2b3 - a3b2;\r\n    let _f4 = abs(f4);\r\n    let f4_ = _a2b3_ + _a3b2_ + _f4;\r\n    let f5 = a1b3 - a3b1;\r\n    let _f5 = abs(f5);\r\n    let f5_ = _a1b3_ + _a3b1_ + _f5;\r\n    let f6 = a2b1 - a1b2;\r\n    let _f6 = abs(f6);\r\n    let f6_ = _a2b1_ + _a1b2_ + _f6;\r\n    //let u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    //let u2 = a2b3*(-2*a3b2 + a2b3) + a3b2*a3b2\r\n    //let u2 = (a2b3 - a3b2)*(a2b3 - a3b2)\r\n    let u2 = f4 * f4;\r\n    let u2_ = 2 * f4_ * _f4 + abs(u2);\r\n    //let u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    //let u1 = a1*b3*-a3*b2 + a1*b3*a2*b3 + a3*b1*-a2*b3 + a3*b1*a3*b2\r\n    //let u1 = a1b3*(a2b3 - a3b2) - a3b1*(a2b3 - a3b2)\r\n    //let u1 = a1b3*f4 - a3b1*f4 = f4*(a1b3 - a3b1);\r\n    let u1 = f4 * f5;\r\n    let u1_ = f4_ * _f5 + _f4 * f5_ + abs(u1);\r\n    //let u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    //let u0 = \r\n    //       a2b3*(a2b1 - a1b2) - a3b2*(a2b1 - a1b2) +\r\n    //       a1b3*(-2*a3b1 + a1b3) + a3b1*a3b1;\r\n    //let u0 = \r\n    //       f6*f4 + \r\n    //       (a1b3 - a3b1)*(a1b3 - a3b1);\r\n    //let u0 = f6*f4 + f5*f5;\r\n    let g7 = f6 * f4;\r\n    let g7_ = f6_ * _f4 + _f6 * f4_ + abs(g7);\r\n    let g9 = f5 * f5;\r\n    let g9_ = 2 * _f5 * f5_ + abs(g9);\r\n    let u0 = g7 + g9;\r\n    let u0_ = g7_ + g9_ + abs(u0);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return {\r\n        coeffs: [u2, u1, u0],\r\n        errBound: [u2_, u1_, u0_].map(c => error_analysis_1.γ1 * c)\r\n    };\r\n}\r\nexports.getCoeffs3 = getCoeffs3;\r\n//# sourceMappingURL=get-coeffs-3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/self-intersection/naive/get-coeffs-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/quad/get-coeffs-3.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/quad/get-coeffs-3.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_xy_1 = __webpack_require__(/*! ../../../to-power-basis/get-xy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-xy.js\");\r\nconst abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qdq = flo_numerical_1.qDiffQuad;\r\n/**\r\n * Get self-intersection coefficients\r\n * * **precondition**: max bit-aligned bitlength: 47\r\n */\r\nfunction getCoeffs3Quad(ps) {\r\n    let [[a3, a2, a1], [b3, b2, b1]] = get_xy_1.getXY(ps); // exact if max bit-aligned bitlength <= 49\r\n    let a2b3 = tp(a2, b3); // => error free\r\n    let a3b2 = tp(a3, b2); // => error free\r\n    let a3b1 = tp(a3, b1); // => error free\r\n    let a1b3 = tp(a1, b3); // => error free\r\n    let a2b1 = tp(a2, b1); // => error free\r\n    let a1b2 = tp(a1, b2); // => error free\r\n    let f4 = qdq(a2b3, a3b2); // 48-bit aligned => error free\r\n    let f5 = qdq(a1b3, a3b1); // 48-bit aligned => error free\r\n    let f6 = qdq(a2b1, a1b2); // 48-bit aligned => error free\r\n    // Note: a variable prepended with and underscore is an absolute value,\r\n    // postpended with an underscore denotes an absolute error (before \r\n    // multiplication by the round-off unit u**2).\r\n    //let u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    //let u2 = a2b3*(-2*a3b2 + a2b3) + a3b2*a3b2\r\n    //let u2 = (a2b3 - a3b2)*(a2b3 - a3b2)\r\n    let u2 = qmq(f4, f4);\r\n    let u2_ = 2 * abs(u2[1]);\r\n    //let u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    //let u1 = a1*b3*-a3*b2 + a1*b3*a2*b3 + a3*b1*-a2*b3 + a3*b1*a3*b2\r\n    //let u1 = a1b3*(a2b3 - a3b2) - a3b1*(a2b3 - a3b2)\r\n    //let u1 = a1b3*f4 - a3b1*f4 = f4*(a1b3 - a3b1);\r\n    let u1 = qmq(f4, f5);\r\n    // 2* in line below since we're using an error of 6γγ for quad multiplication \r\n    // - other operations (plus, minus, etc.) have 3γγ.    \r\n    let u1_ = 2 * abs(u1[1]);\r\n    //let u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    //let u0 = \r\n    //       a2b3*(a2b1 - a1b2) - a3b2*(a2b1 - a1b2) +\r\n    //       a1b3*(-2*a3b1 + a1b3) + a3b1*a3b1;\r\n    //let u0 = \r\n    //       f6*f4 + \r\n    //       (a1b3 - a3b1)*(a1b3 - a3b1);\r\n    //let u0 = f6*f4 + f5*f5;\r\n    let g7 = qmq(f6, f4);\r\n    let g7_ = 2 * abs(g7[1]);\r\n    let g9 = qmq(f5, f5);\r\n    let g9_ = 2 * abs(g9[1]);\r\n    let u0 = qaq(g7, g9);\r\n    let u0_ = g7_ + g9_ + abs(u0[1]);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return {\r\n        coeffs: [u2, u1, u0],\r\n        errBound: [u2_, u1_, u0_].map(c => error_analysis_1.γγ3 * c)\r\n    };\r\n}\r\nexports.getCoeffs3Quad = getCoeffs3Quad;\r\n//# sourceMappingURL=get-coeffs-3.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/self-intersection/quad/get-coeffs-3.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/intersection/self-intersection/self-intersection.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/intersection/self-intersection/self-intersection.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_coeffs_3_1 = __webpack_require__(/*! ./naive/get-coeffs-3 */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/naive/get-coeffs-3.js\");\r\nconst get_coeffs_3_2 = __webpack_require__(/*! ./exact/get-coeffs-3- */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/exact/get-coeffs-3-.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst eps = Number.EPSILON;\r\nconst abs = Math.abs;\r\nconst edif = flo_numerical_1.expansionDiff;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst qno = flo_numerical_1.qNegativeOf;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qdivq = flo_numerical_1.qDivQuad;\r\n/**\r\n * Returns the self-intersection t values of the given bezier curve if it\r\n * exists and if both t-values are in [0,1], else returns undefined.\r\n * * **precondition**: max bit-aligned bitlength: 47\r\n * * only cubic (or higher order) bezier curves have self-intersections\r\n * * see http://www.mare.ee/indrek/misc/2d.pdf\r\n * * the returned t values are within 1 ulp accurate\r\n * @param ps A cubic bezier curve.\r\n */\r\nfunction bezierSelfIntersection(ps) {\r\n    if (ps.length < 4) {\r\n        // lines and quadratics don't have self-intersections (except of course\r\n        // degenerate quadratics).\r\n        return undefined;\r\n    }\r\n    // Apply fast pre-filter - we assume without good reason that about 1 in 10 \r\n    // beziers will have a cusp.\r\n    // First get fast naively calculated coefficients\r\n    let { coeffs: [a, b, c], errBound: [a_, b_, c_] } = get_coeffs_3_1.getCoeffs3(ps);\r\n    // if error in a cannot discern it from zero\r\n    if (abs(a) <= a_) {\r\n        // it is rare to get here \r\n        // check for sure if a === 0 exactly\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let a3 = x3 - 3 * x2 + 3 * x1 - x0; // <= exact if max bit-aligned bitlength <= 50\r\n        let a2 = 3 * x2 - 6 * x1 + 3 * x0; // <= exact if max bit-aligned bitlength <= 49\r\n        let b3 = y3 - 3 * y2 + 3 * y1 - y0; // <= exact if max bit-aligned bitlength <= 50\r\n        let b2 = 3 * y2 - 6 * y1 + 3 * y0; // <= exact if max bit-aligned bitlength <= 49\r\n        let a2b3 = flo_numerical_1.twoProduct(a2, b3);\r\n        let a3b2 = flo_numerical_1.twoProduct(a3, b2);\r\n        if (a2b3[0] === a3b2[0] && a2b3[1] === a3b2[1]) {\r\n            return undefined; // a === 0 => no roots possible\r\n        }\r\n    }\r\n    // DD = discriminant = b^2 - 4ac\r\n    // calculate DD and its absolute error DD_\r\n    let bb = b * b;\r\n    let bb_ = 2 * b_ * abs(b) + error_analysis_1.γ1 * bb; // the error in b**2\r\n    let ac4 = 4 * a * c;\r\n    let ac4_ = 4 * (a_ * abs(c) + abs(a) * c_) + error_analysis_1.γ1 * abs(ac4);\r\n    let DD = bb - ac4;\r\n    let DD_ = bb_ + ac4_ + error_analysis_1.γ1 * abs(DD);\r\n    // if the discriminant is smaller than negative the error bound then\r\n    // certainly there are no roots, i.e. no cusp and no self-intersections\r\n    if (DD < -DD_) {\r\n        // discriminant is definitely negative\r\n        return undefined;\r\n    }\r\n    // if the discriminant is definitely positive\r\n    if (DD > DD_) {\r\n        // calculate roots naively as a fast pre-filter\r\n        let { est: D, err: D_ } = flo_numerical_1.sqrtWithErr(DD, DD_);\r\n        let q1;\r\n        if (b >= 0) {\r\n            // let r1 = (-b - D) / 2*a;\r\n            // let r2 = (2*c) / (-b - D);\r\n            q1 = -b - D;\r\n        }\r\n        else {\r\n            // let r2 = (-b + D) / 2*a;\r\n            // let r1 = (2*c) / (-b + D);\r\n            q1 = -b + D;\r\n        }\r\n        let q1_ = b_ + D_ + error_analysis_1.γ1 * abs(q1);\r\n        let { est: r1, err: r1_ } = flo_numerical_1.divWithErr(q1, 2 * a, q1_, 2 * a_);\r\n        let { est: r2, err: r2_ } = flo_numerical_1.divWithErr(2 * c, q1, 2 * c_, q1_);\r\n        //console.log(r1,r2);\r\n        // the actual 'filter' follows\r\n        // IF\r\n        // at least one root is definitely smaller than 0  ||\r\n        // at least one root is definitely larger than 1 \r\n        // THEN no self-intersection\r\n        if (r1 + r1_ < 0 || r2 + r2_ < 0 ||\r\n            r1 - r1_ > 1 || r2 - r2_ > 1) {\r\n            return undefined;\r\n        }\r\n    }\r\n    // we need to check exactly - (a !== 0) at this point - tested for earlier\r\n    let [A, B, C] = get_coeffs_3_2.getCoeffs3Exact_(ps);\r\n    // exact - DD = b^2 - 4ac\r\n    let eDD = edif(epr(B, B), sce(4, epr(A, C)));\r\n    let sgn = flo_numerical_1.sign(eDD);\r\n    if (sgn < 0) {\r\n        // sgn < 0 => no real roots => no cusp or double point for t in [0,1]\r\n        return undefined;\r\n    }\r\n    if (sgn > 0) {\r\n        let D = flo_numerical_1.qSqrt(toQuad(eDD));\r\n        A = toQuad(A);\r\n        B = toQuad(B);\r\n        C = toQuad(C);\r\n        let nBD;\r\n        if (flo_numerical_1.sign(B) >= 0) {\r\n            nBD = qno(qaq(B, D));\r\n            //t1 = (-B - D) / (2*A);\r\n            //t2 = (2*C) / (-B - D);\r\n        }\r\n        else {\r\n            nBD = qaq(qno(B), D);\r\n            //t1 = (2*C) / (-B + D);\r\n            //t2 = (-B + D) / (2*A);\r\n        }\r\n        let t1 = flo_numerical_1.estimate(qdivq(nBD, qm2(A))); // max 1 ulps out\r\n        let t2 = flo_numerical_1.estimate(qdivq(qm2(C), nBD)); // max 1 ulps out\r\n        // if any root is outside the range => no double point for t in [0,1]\r\n        if (t1 < -eps || t1 > 1 + eps ||\r\n            t2 < -eps || t2 > 1 + eps) {\r\n            return undefined;\r\n        }\r\n        t1 = t1 < 0\r\n            ? 0\r\n            : t1 > 1 ? 1 : t1;\r\n        t2 = t2 < 0\r\n            ? 0\r\n            : t2 > 1 ? 1 : t2;\r\n        return t1 < t2 ? [t1, t2] : [t2, t1];\r\n    }\r\n    // sign === 0 => cusp\r\n    // set t = b/d = b/-2a\r\n    let d = flo_numerical_1.eMultByNeg2(A);\r\n    let sgnB = flo_numerical_1.sign(B);\r\n    let sgnD = flo_numerical_1.sign(d);\r\n    // if result is negative the cusp is outside the bezier endpoints\r\n    let sgn_ = sgnB * sgnD;\r\n    if (sgn_ < 0) {\r\n        return undefined;\r\n    }\r\n    // if result is > 1 the cusp is outside the bezier endpoints\r\n    if (flo_numerical_1.compare(flo_numerical_1.abs(B), flo_numerical_1.abs(d)) > 0) {\r\n        return undefined;\r\n    }\r\n    let qB = toQuad(B);\r\n    let qd = toQuad(d);\r\n    let qt = qdivq(qB, qd);\r\n    let t = qt[1];\r\n    return [t, t];\r\n}\r\nexports.bezierSelfIntersection = bezierSelfIntersection;\r\n/**\r\n * Returns the result of converting a floating point expansion to a\r\n * double-double.\r\n */\r\nfunction toQuad(e) {\r\n    // TODO - there's already a toQuad in flo-numerical ??\r\n    // investigate when to compress and when not to\r\n    // e = compress(e);\r\n    let len = e.length;\r\n    if (len === 2) {\r\n        return e; // already a quad\r\n    }\r\n    else if (len === 1) {\r\n        return [0, e[0]];\r\n    }\r\n    else {\r\n        return [e[len - 2], e[len - 1]];\r\n    }\r\n}\r\n//# sourceMappingURL=self-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/intersection/self-intersection/self-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./t-to-dxy/evaluate-dx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./t-to-dxy/evaluate-dy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js\");\r\nconst evaluate_ddx_1 = __webpack_require__(/*! ./t-to-ddxy/evaluate-ddx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddx.js\");\r\nconst evaluate_ddy_1 = __webpack_require__(/*! ./t-to-ddxy/evaluate-ddy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddy.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_dxy_at_0_1 = __webpack_require__(/*! ./t-to-dxy/get-dxy-at-0 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-0.js\");\r\nconst get_ddxy_at_0_1 = __webpack_require__(/*! ./t-to-ddxy/get-ddxy-at-0 */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-0.js\");\r\nconst get_dddxy_1 = __webpack_require__(/*! ../to-power-basis/get-dddxy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dddxy.js\");\r\nfunction κ(ps, t) {\r\n    let evDx = evaluate_dx_1.evaluateDx(ps);\r\n    let evDy = evaluate_dy_1.evaluateDy(ps);\r\n    let evDdx = evaluate_ddx_1.evaluateDdx(ps);\r\n    let evDdy = evaluate_ddy_1.evaluateDdy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        let ddx = evDdx(t);\r\n        let ddy = evDdy(t);\r\n        let a = dx * ddy - dy * ddx;\r\n        let b = Math.sqrt(Math.pow((dx * dx + dy * dy), 3));\r\n        return a / b;\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.κ = κ;\r\n/**\r\n * Compare the curvature, κ, between two curves at t === 0.\r\n *\r\n * Returns a positive number if κ for psI > κ for psO, negative if κ for psI < κ\r\n * for psO or zero if the curve extensions are identical (i.e. in same K-family).\r\n *\r\n * Precondition: The point psI evaluated at zero must === the point psO\r\n * evaluated at zero.\r\n *\r\n * Exact: Returns the exact result if the bithlength of all\r\n * coordinates <= 53 - 5 === 48 and are bit-aligned.\r\n *\r\n * @param psI An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * representing the incoming curve\r\n * @param psO Another bezier representing the outgoing curve\r\n */\r\nfunction compareCurvaturesAtInterface(psI, psO) {\r\n    // Get x' and y' for incoming curve evaluated at 0\r\n    let [dxI, dyI] = get_dxy_at_0_1.getDxyAt0(psI); // max bitlength increase / max shift === 3\r\n    // Get x'' and y'' for incoming curve evaluated at 0\r\n    let [ddxI, ddyI] = get_ddxy_at_0_1.getDdxyAt0(psI); // max bitlength increase / max shift === 5\r\n    // Get x' and y' for outgoing curve evaluated at 0\r\n    let [dxO, dyO] = get_dxy_at_0_1.getDxyAt0(psO); // max bitlength increase / max shift === 3\r\n    // Get x'' and y'' for outgoing curve evaluated at 0\r\n    let [ddxO, ddyO] = get_ddxy_at_0_1.getDdxyAt0(psO); // max bitlength increase / max shift === 5\r\n    //console.log('κI: ', κ(psI, 0));\r\n    //console.log('κO: ', κ(psO, 0));\r\n    // Remember the formula for the signed curvature of a parametric curve:\r\n    // κ = x′y′′ - y′x′′ / sqrt(x′² + y′²)³\r\n    // κ² = (x′y′′ - y′x′′)² / (x′² + y′²)³\r\n    // This allows us to do an exact comparison of curvatures\r\n    // Simplifying the above gives (denoting the incoming curve with a subscript\r\n    // of 1 and the outgoing with a 2):\r\n    //      κIncoming > κOutgoing\r\n    // <=>  (x₁′y₁′′ - y₁′x₁′′)²(x₂′² + y₂′²)³ > (x₂′y₂′′ - y₂′x₂′′)²(x₁′² + y₁′²)³\r\n    // <=>  a²b³ > c²d³\r\n    // Note b³ > 0 and d³ > 0\r\n    // max aggregate bitlength increase (let original bitlength === p):\r\n    // a -> 2 x ((p+3)+(p+5) + 1) === 4p + 18 -> max p in double precision === 8 -> too low\r\n    //let a = (dxI*ddyI - dyI*ddxI)**2;\r\n    // b -> 3 x ((p+3) + 1) === 3p + 12\r\n    //let b = (dxO*dxO  + dyO*dyO )**3;\r\n    // c -> 2 x ((p+3)+(p+5) + 1) === 4p + 18\r\n    //let c = (dxO*ddyO - dyO*ddxO)**2;\r\n    // d -> 3 x ((p+3) + 1) === 3p + 12\r\n    //let d = (dxI*dxI  + dyI*dyI )**3;\r\n    // We need to resort to exact floating point arithmetic at this point\r\n    let a = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxI, ddyI), flo_numerical_1.twoProduct(dyI, ddxI));\r\n    let c = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxO, ddyO), flo_numerical_1.twoProduct(dyO, ddxO));\r\n    let signA = flo_numerical_1.sign(a);\r\n    let signC = flo_numerical_1.sign(c);\r\n    if (signA !== signC) {\r\n        //console.log('branch 3');\r\n        return signA - signC;\r\n    }\r\n    let b = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxO, dxO), flo_numerical_1.twoProduct(dyO, dyO));\r\n    let d = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxI, dxI), flo_numerical_1.twoProduct(dyI, dyI));\r\n    let b2 = flo_numerical_1.expansionProduct(b, b);\r\n    let b3 = flo_numerical_1.expansionProduct(b2, b);\r\n    let d2 = flo_numerical_1.expansionProduct(d, d);\r\n    let d3 = flo_numerical_1.expansionProduct(d2, d);\r\n    if (signA !== 0 || signC !== 0) {\r\n        //console.log('branch 4');\r\n        let a2 = flo_numerical_1.expansionProduct(a, a);\r\n        let c2 = flo_numerical_1.expansionProduct(c, c);\r\n        // max aggregate bitlength increase (let original bitlength === p):\r\n        // κ -> (2 x ((p+3)+(p+5) + 1)) + (3 x ((p+3) + 1)) === 7p + 30\r\n        // e.g. for bit-aligned input bitlength p of 10 we get output bitlength \r\n        // of 100, or for p === 3 (the max exact bitlength allowed to have exact\r\n        // results without resorting to infinite precision) we get 51 bits.\r\n        let κI = flo_numerical_1.expansionProduct(a2, b3);\r\n        let κO = flo_numerical_1.expansionProduct(c2, d3);\r\n        let δκ = flo_numerical_1.sign(flo_numerical_1.expansionDiff(κI, κO));\r\n        if (δκ !== 0) {\r\n            //console.log('branch 5');\r\n            // At this point signA === signC, both +tive or -tive\r\n            return signA > 0 ? δκ : -δκ;\r\n        }\r\n    }\r\n    // At this point signA === signC, both +tive or -tive or 0\r\n    // Now we have to look at the change of curvature w.r.t. the parameter t,\r\n    // i.e. \r\n    // κ′ = [(x′²+y′²)(x′y′′′-y′x′′′) - 3(x′y′′-y′x′′)(x′x′′+y′y′′)] / (x′²+y′²)^(5/2)\r\n    // Therefore: (denoting the incoming curve with a subscript of 1 and the outgoing with a 2)\r\n    // κ′Incoming > κ′Outgoing\r\n    // <=> [(x₁′²+y₁′²)(x₁′y₁′′′-y₁′x₁′′′) - 3(x₁′y₁′′-y₁′x₁′′)(x₁′x₁′′+y₁′y₁′′)]²(x₂′²+y₂′²)⁵ >\r\n    //     [(x₂′²+y₂′²)(x₂′y₂′′′-y₂′x₂′′′) - 3(x₂′y₂′′-y₂′x₂′′)(x₂′x₂′′+y₂′y₂′′)]²(x₁′²+y₁′²)⁵\r\n    // <=> (de - 3af)²b⁵ > (bg - 3ch)²d⁵\r\n    // <=> i²b⁵ > j²d⁵\r\n    // Get x′′′ and y′′′ for incoming curve evaluated at 1\r\n    let [dddxI, dddyI] = get_dddxy_1.getDddxy(psI); // max bitlength increase === max shift === 6\r\n    let [dddxO, dddyO] = get_dddxy_1.getDddxy(psO); // max bitlength increase === max shift === 6\r\n    let e = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxI, dddyI), flo_numerical_1.twoProduct(dyI, dddxI));\r\n    let f = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxI, ddxI), flo_numerical_1.twoProduct(dyI, ddyI));\r\n    let g = flo_numerical_1.expansionDiff(flo_numerical_1.twoProduct(dxO, dddyO), flo_numerical_1.twoProduct(dyO, dddxO));\r\n    let h = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(dxO, ddxO), flo_numerical_1.twoProduct(dyO, ddyO));\r\n    // (de - 3af)²b⁵ > (bg - 3ch)²d⁵\r\n    // i²b⁵ > j²d⁵\r\n    let i = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(d, e), flo_numerical_1.scaleExpansion(flo_numerical_1.expansionProduct(a, f), 3));\r\n    let j = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(b, g), flo_numerical_1.scaleExpansion(flo_numerical_1.expansionProduct(c, h), 3));\r\n    let signI = flo_numerical_1.sign(i);\r\n    let signJ = flo_numerical_1.sign(j);\r\n    if (signA !== signC) {\r\n        return signI - signJ;\r\n    }\r\n    if (signI === 0 && signJ === 0) {\r\n        // Both curve extensions are identical, i.e. in the same K-family\r\n        return 0;\r\n    }\r\n    let i2 = flo_numerical_1.expansionProduct(i, i);\r\n    let b5 = flo_numerical_1.expansionProduct(b2, b3);\r\n    let j2 = flo_numerical_1.expansionProduct(j, j);\r\n    let d5 = flo_numerical_1.expansionProduct(d2, d3);\r\n    let dκI = flo_numerical_1.expansionProduct(i2, b5);\r\n    let dκO = flo_numerical_1.expansionProduct(j2, d5);\r\n    let sgn = flo_numerical_1.sign(flo_numerical_1.expansionDiff(dκI, dκO));\r\n    return signI > 0 ? sgn : -sgn;\r\n    // If the above returned value is still zero then the two curve extensions \r\n    // are identical, i.e. in the same K-family\r\n}\r\nexports.compareCurvaturesAtInterface = compareCurvaturesAtInterface;\r\n//# sourceMappingURL=curvature.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/ds.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/ds.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./t-to-dxy/evaluate-dx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./t-to-dxy/evaluate-dy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js\");\r\nfunction ds(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    function f(t) {\r\n        let dx = evDx(t);\r\n        let dy = evDy(t);\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.ds = ds;\r\n//# sourceMappingURL=ds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/ds.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/normal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/normal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tangent_1 = __webpack_require__(/*! ./tangent */ \"./node_modules/flo-bezier3/node/local-properties-at-t/tangent.js\");\r\nfunction normal(ps, t) {\r\n    const tan_ = tangent_1.tangent(ps);\r\n    function f(t) {\r\n        let v = tan_(t);\r\n        return [v[1], -v[0]];\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.normal = normal;\r\n//# sourceMappingURL=normal.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/normal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddx.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddx.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_ddx_1 = __webpack_require__(/*! ../../to-power-basis/get-ddx */ \"./node_modules/flo-bezier3/node/to-power-basis/get-ddx.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nfunction evaluateDdx(ps, t) {\r\n    const ddPs = get_ddx_1.getDdx(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(ddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDdx = evaluateDdx;\r\n//# sourceMappingURL=evaluate-ddx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddy.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_ddy_1 = __webpack_require__(/*! ../../to-power-basis/get-ddy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-ddy.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nfunction evaluateDdy(ps, t) {\r\n    const ddPs = get_ddy_1.getDdy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(ddPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDdy = evaluateDdy;\r\n//# sourceMappingURL=evaluate-ddy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/evaluate-ddy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-0.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-0.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x and y-coordinates when evaluated at t === 0.\r\n *\r\n * Bitlength: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === max shift === 5 (for cubics)\r\n * * max bitlength increase === max shift === 3 (for quadratics)\r\n * * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdxyAt0(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            6 * x2 - 12 * x1 + 6 * x0,\r\n            6 * y2 - 12 * y1 + 6 * y0\r\n        ]; // max bitlength increase 5\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * x2 - 4 * x1 + 2 * x0,\r\n            2 * y2 - 4 * y1 + 2 * y0\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0, 0];\r\n    }\r\n}\r\nexports.getDdxyAt0 = getDdxyAt0;\r\n//# sourceMappingURL=get-ddxy-at-0.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-1.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-1.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x and y-coordinates when evaluated at 1.\r\n *\r\n * This is a seperate function because it allows us to make stronger bitlength\r\n * guarantees.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * * max bitlength increase === max shift === 5 (for cubics)\r\n * * max bitlength increase === max shift === 3 (for quadratics)\r\n * * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdxyAt1(ps) {\r\n    if (ps.length === 4) {\r\n        let [, [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * x3 - 12 * x2 + 6 * x1,\r\n            6 * y3 - 12 * y2 + 6 * y1,\r\n        ]; // max bitlength increase 5\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * x2 - 4 * x1 + 2 * x0,\r\n            2 * y2 - 4 * y1 + 2 * y0,\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0, 0]; // max bitlength increase 0\r\n    }\r\n}\r\nexports.getDdxyAt1 = getDdxyAt1;\r\n//# sourceMappingURL=get-ddxy-at-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-ddxy/get-ddxy-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dx_1 = __webpack_require__(/*! ../../to-power-basis/get-dx */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dx.js\");\r\nfunction evaluateDx(ps, t) {\r\n    const dPs = get_dx_1.getDx(ps);\r\n    const f = flo_poly_1.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDx = evaluateDx;\r\n//# sourceMappingURL=evaluate-dx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_dy_1 = __webpack_require__(/*! ../../to-power-basis/get-dy */ \"./node_modules/flo-bezier3/node/to-power-basis/get-dy.js\");\r\nfunction evaluateDy(ps, t) {\r\n    const dPs = get_dy_1.getDy(ps); // Speed optimizing cache\r\n    const f = flo_poly_1.evaluate(dPs);\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateDy = evaluateDy;\r\n//# sourceMappingURL=evaluate-dy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-0.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-0.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x and y-coordinates when evaluated at t === 0.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * * max bitlength increase === max shift === 3 (for cubics)\r\n * * max bitlength increase === max shift === 2 (for quadratics)\r\n * * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDxyAt0(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            3 * (x1 - x0),\r\n            3 * (y1 - y0)\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            2 * (x1 - x0),\r\n            2 * (y1 - y0),\r\n        ]; // max bitlength increase 2\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            y1 - y0,\r\n        ]; // max bitlength increase 1\r\n    }\r\n}\r\nexports.getDxyAt0 = getDxyAt0;\r\n//# sourceMappingURL=get-dxy-at-0.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-1.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-1.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x and y-coordinates when evaluated at 1.\r\n *\r\n * This is a seperate function because it allows us to make stronger bitlength\r\n * guarantees.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * * max bitlength increase === max shift === 3 (for cubics)\r\n * * max bitlength increase === max shift === 2 (for quadratics)\r\n * * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDxyAt1(ps) {\r\n    if (ps.length === 4) {\r\n        let [, , [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            3 * (x3 - x2),\r\n            3 * (y3 - y2),\r\n        ]; // max bitlength increase 3\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [, [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * (x2 - x1),\r\n            2 * (y2 - y1),\r\n        ]; // max bitlength increase 2\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            y1 - y0\r\n        ]; // max bitlength increase 1\r\n    }\r\n}\r\nexports.getDxyAt1 = getDxyAt1;\r\n//# sourceMappingURL=get-dxy-at-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/get-dxy-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau-with-err.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau-with-err.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst error_analysis_1 = __webpack_require__(/*! ../../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst abs = Math.abs;\r\nconst u = Number.EPSILON / 2;\r\nconst qdq = flo_numerical_1.qDiffQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\n/**\r\n * Evaluates the given bezier curve at the parameter t, including error.\r\n * * **precondition**: 49-bit aligned coordinates\r\n * @param ps An order 1, 2 or 3 bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param t The parameter value where the bezier should be evaluated\r\n **/\r\nfunction evalDeCasteljauWithErr(ps, t) {\r\n    if (t === 0) {\r\n        return { p: ps[0], pE: [0, 0] };\r\n    }\r\n    else if (t === 1) {\r\n        return { p: ps[ps.length - 1], pE: [0, 0] };\r\n    }\r\n    //let s = 1-t;  // <= exact if eps | t, but not a precondition here\r\n    //let s = 1 - t;  // <1>s1\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let _x0 = abs(x0);\r\n        let _y0 = abs(y0);\r\n        let _x1 = abs(x1);\r\n        let _y1 = abs(y1);\r\n        let _x2 = abs(x2);\r\n        let _y2 = abs(y2);\r\n        let _x3 = abs(x3);\r\n        let _y3 = abs(y3);\r\n        let a01 = x0 + (x1 - x0) * t;\r\n        let a11 = x1 + (x2 - x1) * t;\r\n        let a21 = x2 + (x3 - x2) * t;\r\n        let a02 = a01 + (a11 - a01) * t;\r\n        let a12 = a11 + (a21 - a11) * t;\r\n        let x = a02 + (a12 - a02) * t;\r\n        let _a01 = _x0 + (_x1 + _x0) * t;\r\n        //let _a01 = <2>(_x0 + <1>((_x1 + _x0)*t));\r\n        let _a11 = _x1 + (_x2 + _x1) * t;\r\n        //let _a11 = <2>(_x1 + <1>((_x2 + _x1)*t));\r\n        let _a21 = _x2 + (_x3 + _x2) * t;\r\n        //let _a21 = <2>(_x2 + <1>((_x3 + _x2)*t));\r\n        let _a02 = _a01 + (_a11 + _a01) * t;\r\n        //let _a02 = <5>(<2>_a01 + <4>(<3>(<2>_a11 + <2>_a01)*t));\r\n        let _a12 = _a11 + (_a21 + _a11) * t;\r\n        //let _a12 = <5>(<2>_a11 + <4>(<3>(<2>_a21 + <2>_a11)*t));\r\n        let _x = _a02 + (_a12 + _a02) * t;\r\n        //let _x = <8>(<5>_a02 + <7>(<6>(<5>_a12 + <5>_a02)*t));\r\n        _x = 8 * error_analysis_1.γ1 * _x;\r\n        let b01 = y0 + (y1 - y0) * t;\r\n        let b11 = y1 + (y2 - y1) * t;\r\n        let b21 = y2 + (y3 - y2) * t;\r\n        let b02 = b01 + (b11 - b01) * t;\r\n        let b12 = b11 + (b21 - b11) * t;\r\n        let y = b02 + (b12 - b02) * t;\r\n        let _b01 = _y0 + (_y1 + _y0) * t;\r\n        let _b11 = _y1 + (_y2 + _y1) * t;\r\n        let _b21 = _y2 + (_y3 + _y2) * t;\r\n        let _b02 = _b01 + (_b11 + _b01) * t;\r\n        let _b12 = _b11 + (_b21 + _b11) * t;\r\n        let _y = _b02 + (_b12 + _b02) * t;\r\n        _y = 8 * error_analysis_1.γ1 * _y;\r\n        return { p: [x, y], pE: [_x, _y] };\r\n    }\r\n    else if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let _x0 = abs(x0);\r\n        let _y0 = abs(y0);\r\n        let _x1 = abs(x1);\r\n        let _y1 = abs(y1);\r\n        let _x2 = abs(x2);\r\n        let _y2 = abs(y2);\r\n        let a01 = x0 + (x1 - x0) * t;\r\n        let a11 = x1 + (x2 - x1) * t;\r\n        let x = a01 + (a11 - a01) * t;\r\n        let _a01 = _x0 + (_x1 + _x0) * t;\r\n        //let _a01 = <2>(_x0 + <1>((_x1 + _x0)*t));\r\n        let _a11 = _x1 + (_x2 + _x1) * t;\r\n        //let _a11 = <2>(_x1 + <1>((_x2 + _x1)*t));\r\n        let _x = _a01 + (_a11 + _a01) * t;\r\n        //let _x = <5>(<2>_a01 + <4>((<3>(<2>_a11 + <2>_a01))*t));\r\n        _x = 5 * error_analysis_1.γ1 * _x;\r\n        let b01 = y0 + (y1 - y0) * t;\r\n        let b11 = y1 + (y2 - y1) * t;\r\n        let y = b01 + (b11 - b01) * t;\r\n        let _b01 = _y0 + (_y1 + _y0) * t;\r\n        let _b11 = _y1 + (_y2 + _y1) * t;\r\n        let _y = _b01 + (_b11 + _b01) * t;\r\n        _y = 5 * error_analysis_1.γ1 * _y;\r\n        return { p: [x, y], pE: [_x, _y] };\r\n    }\r\n    else if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        let _x0 = abs(x0);\r\n        let _y0 = abs(y0);\r\n        let _x1 = abs(x1);\r\n        let _y1 = abs(y1);\r\n        let x = x0 + (x1 - x0) * t;\r\n        let y = y0 + (y1 - y0) * t;\r\n        let _x = _x0 + (_x1 + _x0) * t;\r\n        //let _x = <2>(_x0 + <1>((_x1 + _x0)*t));\r\n        _x = 2 * error_analysis_1.γ1 * _x;\r\n        let _y = _y0 + (_y1 + _y0) * t;\r\n        //let _y = <2>(_y0 + <1>((_y1 + _y0)*t));\r\n        _y = 2 * error_analysis_1.γ1 * _y;\r\n        return { p: [x, y], pE: [_x, _y] };\r\n    }\r\n}\r\nexports.evalDeCasteljauWithErr = evalDeCasteljauWithErr;\r\n/**\r\n * Evaluates the given bezier curve at the parameter t, including error.\r\n * * **precondition**: 49-bit aligned coordinates\r\n * @param ps An order 1, 2 or 3 bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param t The parameter value where the bezier should be evaluated\r\n **/\r\nfunction evalDeCasteljauWithErrQuad(ps, t) {\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        return { p: ps[0].map(c => [c]), pE: [0, 0] };\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        return { p: ps[ps.length - 1].map(c => [c]), pE: [0, 0] };\r\n    }\r\n    //let s = 1-t;  // <= exact if eps | t, but not a precondition here\r\n    //let s = 1 - t;  // <1>s1\r\n    let _t = t[1]; // <= assumed positive\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let _x0 = abs(x0);\r\n        let _y0 = abs(y0);\r\n        let _x1 = abs(x1);\r\n        let _y1 = abs(y1);\r\n        let _x2 = abs(x2);\r\n        let _y2 = abs(y2);\r\n        let _x3 = abs(x3);\r\n        let _y3 = abs(y3);\r\n        let a01 = qaq([0, x0], qmd(x1 - x0, t)); // 49-bit aligned => x1 - x0 exact\r\n        let a11 = qaq([0, x1], qmd(x2 - x1, t)); // 49-bit aligned => x2 - x1 exact\r\n        let a21 = qaq([0, x2], qmd(x3 - x2, t)); // 49-bit aligned => x3 - x2 exact\r\n        let a02 = qaq(a01, qmq(qdq(a11, a01), t));\r\n        let a12 = qaq(a11, qmq(qdq(a21, a11), t));\r\n        let x = qaq(a02, qmq(qdq(a12, a02), t));\r\n        let _a01 = _x0 + (_x1 + _x0) * _t; // <2>\r\n        //let _a01 = <2>(_x0 + <1>((_x1 + _x0)*_t));\r\n        let _a11 = _x1 + (_x2 + _x1) * _t; // <2>\r\n        //let _a11 = <2>(_x1 + <1>((_x2 + _x1)*_t));\r\n        let _a21 = _x2 + (_x3 + _x2) * _t; // <2>\r\n        //let _a21 = <2>(_x2 + <1>((_x3 + _x2)*_t));\r\n        let _a02 = _a01 + (_a11 + _a01) * _t;\r\n        //let _a02 = <6>(<2>_a01 + <5>(<3>(<2>_a11 + <2>_a01)*_t));\r\n        let _a12 = _a11 + (_a21 + _a11) * _t;\r\n        //let _a12 = <6>(<2>_a11 + <5>(<3>(<2>_a21 + <2>_a11)*_t));\r\n        let _x = _a02 + (_a12 + _a02) * _t;\r\n        //let _x = <10>(<6>_a02 + <9>(<7>(<6>_a12 + <6>_a02)*t));\r\n        // Note: using γ1 or u doesn't really make any practical difference\r\n        _x = 10 * error_analysis_1.γ1 * error_analysis_1.γ1 * _x;\r\n        let b01 = qaq([0, y0], qmd(y1 - y0, t)); // 49-bit aligned => y1 - y0 exact\r\n        let b11 = qaq([0, y1], qmd(y2 - y1, t)); // 49-bit aligned => y2 - y1 exact\r\n        let b21 = qaq([0, y2], qmd(y3 - y2, t)); // 49-bit aligned => y3 - y2 exact\r\n        let b02 = qaq(b01, qmq(qdq(b11, b01), t));\r\n        let b12 = qaq(b11, qmq(qdq(b21, b11), t));\r\n        let y = qaq(b02, qmq(qdq(b12, b02), t));\r\n        let _b01 = _y0 + (_y1 + _y0) * _t; // <2>\r\n        let _b11 = _y1 + (_y2 + _y1) * _t; // <2>\r\n        let _b21 = _y2 + (_y3 + _y2) * _t; // <2>\r\n        let _b02 = _b01 + (_b11 + _b01) * _t;\r\n        let _b12 = _b11 + (_b21 + _b11) * _t;\r\n        let _y = _b02 + (_b12 + _b02) * _t;\r\n        _y = 10 * error_analysis_1.γ1 * error_analysis_1.γ1 * _y;\r\n        return { p: [x, y], pE: [_x, _y] };\r\n    }\r\n    else if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let _x0 = abs(x0);\r\n        let _y0 = abs(y0);\r\n        let _x1 = abs(x1);\r\n        let _y1 = abs(y1);\r\n        let _x2 = abs(x2);\r\n        let _y2 = abs(y2);\r\n        let a01 = qaq([0, x0], qmd(x1 - x0, t)); // 49-bit aligned => x1 - x0 exact\r\n        let a11 = qaq([0, x1], qmd(x2 - x1, t)); // 49-bit aligned => x2 - x1 exact\r\n        let x = qaq(a01, qmq(qdq(a11, a01), t));\r\n        let _a01 = _x0 + (_x1 + _x0) * _t; // <2>\r\n        //let _a01 = <2>(_x0 + <1>((_x1 + _x0)*_t));\r\n        let _a11 = _x1 + (_x2 + _x1) * _t; // <2>\r\n        //let _a11 = <2>(_x1 + <1>((_x2 + _x1)*_t));\r\n        let _x = _a01 + (_a11 + _a01) * _t; // <6>\r\n        //let _x = <6>(<2>_a01 + <5>(<3>(<2>_a11 + <2>_a01)*_t));\r\n        _x = 6 * error_analysis_1.γ1 * error_analysis_1.γ1 * _x;\r\n        let b01 = qaq([0, y0], qmd(y1 - y0, t)); // 49-bit aligned => y1 - y0 exact\r\n        let b11 = qaq([0, y1], qmd(y2 - y1, t)); // 49-bit aligned => y2 - y1 exact\r\n        let y = qaq(b01, qmq(qdq(b11, b01), t));\r\n        let _b01 = _y0 + (_y1 + _y0) * _t; // <2>\r\n        //let _b01 = <2>(_y0 + <1>((_y1 + _y0)*_t));\r\n        let _b11 = _y1 + (_y2 + _y1) * _t; // <2>\r\n        //let _b11 = <2>(_y1 + <1>((_y2 + _y1)*_t));\r\n        let _y = _b01 + (_b11 + _b01) * _t; // <6>\r\n        //let _y = <6>(<2>_b01 + <5>(<3>(<2>_b11 + <2>_b01)*_t));\r\n        _y = 6 * error_analysis_1.γ1 * error_analysis_1.γ1 * _y;\r\n        return { p: [x, y], pE: [_x, _y] };\r\n    }\r\n    else if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        let _x0 = abs(x0);\r\n        let _y0 = abs(y0);\r\n        let _x1 = abs(x1);\r\n        let _y1 = abs(y1);\r\n        let x = qaq([0, x0], qmd(x1 - x0, t)); // 49-bit aligned => x1 - x0 exact;\r\n        let y = qaq([0, y0], qmd(y1 - y0, t)); // 49-bit aligned => y1 - y0 exact\r\n        let _x = _x0 + (_x1 + _x0) * _t; // <2>\r\n        //let _x = <2>(_x0 + <1>((_x1 + _x0)*_t));\r\n        _x = 2 * error_analysis_1.γ1 * error_analysis_1.γ1 * _x;\r\n        let _y = _y0 + (_y1 + _y0) * _t; // <2>\r\n        //let _y = <2>(_y0 + <1>((_y1 + _y0)*_t));\r\n        _y = 2 * error_analysis_1.γ1 * error_analysis_1.γ1 * _y;\r\n        return { p: [x, y], pE: [_x, _y] };\r\n    }\r\n}\r\nexports.evalDeCasteljauWithErrQuad = evalDeCasteljauWithErrQuad;\r\n//# sourceMappingURL=eval-de-casteljau-with-err.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Evaluates the given bezier curve at the parameter t.\r\n * @param ps An order 1, 2 or 3 bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param t The parameter value where the bezier should be evaluated\r\n **/\r\nfunction evalDeCasteljau(ps, t) {\r\n    if (t === 0) {\r\n        return ps[0];\r\n    }\r\n    else if (t === 1) {\r\n        return ps[ps.length - 1];\r\n    }\r\n    //let s = 1-t;  // <= exact if eps | t, but not a precondition here\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let a01 = x0 + (x1 - x0) * t;\r\n        let a11 = x1 + (x2 - x1) * t;\r\n        let a21 = x2 + (x3 - x2) * t;\r\n        let a02 = a01 + (a11 - a01) * t;\r\n        let a12 = a11 + (a21 - a11) * t;\r\n        let x = a02 + (a12 - a02) * t;\r\n        let b01 = y0 + (y1 - y0) * t;\r\n        let b11 = y1 + (y2 - y1) * t;\r\n        let b21 = y2 + (y3 - y2) * t;\r\n        let b02 = b01 + (b11 - b01) * t;\r\n        let b12 = b11 + (b21 - b11) * t;\r\n        let y = b02 + (b12 - b02) * t;\r\n        return [x, y];\r\n    }\r\n    else if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let a01 = x0 + (x1 - x0) * t;\r\n        let a11 = x1 + (x2 - x1) * t;\r\n        let x = a01 + (a11 - a01) * t;\r\n        let b01 = y0 + (y1 - y0) * t;\r\n        let b11 = y1 + (y2 - y1) * t;\r\n        let y = b01 + (b11 - b01) * t;\r\n        return [x, y];\r\n    }\r\n    else if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        let x = x0 + (x1 - x0) * t;\r\n        let y = y0 + (y1 - y0) * t;\r\n        return [x, y];\r\n    }\r\n}\r\nexports.evalDeCasteljau = evalDeCasteljau;\r\n/**\r\n * Evaluates the given bezier curve at the parameter t.\r\n * @param ps An order 1, 2 or 3 bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param t The parameter value where the bezier should be evaluated\r\n **/\r\nfunction evalDeCasteljauX(ps, t) {\r\n    if (t === 0) {\r\n        return ps[0][0];\r\n    }\r\n    else if (t === 1) {\r\n        return ps[ps.length - 1][0];\r\n    }\r\n    //let s = 1-t;  // <= exact if eps | t, but not a precondition here\r\n    if (ps.length === 4) {\r\n        const [[x0,], [x1], [x2], [x3,]] = ps;\r\n        let a01 = x0 + (x1 - x0) * t;\r\n        let a11 = x1 + (x2 - x1) * t;\r\n        let a21 = x2 + (x3 - x2) * t;\r\n        let a02 = a01 + (a11 - a01) * t;\r\n        let a12 = a11 + (a21 - a11) * t;\r\n        return a02 + (a12 - a02) * t;\r\n    }\r\n    else if (ps.length === 3) {\r\n        const [[x0,], [x1], [x2]] = ps;\r\n        let a01 = x0 + (x1 - x0) * t;\r\n        let a11 = x1 + (x2 - x1) * t;\r\n        return a01 + (a11 - a01) * t;\r\n    }\r\n    else if (ps.length === 2) {\r\n        const [[x0,], [x1]] = ps;\r\n        return x0 + (x1 - x0) * t;\r\n    }\r\n}\r\nexports.evalDeCasteljauX = evalDeCasteljauX;\r\n/**\r\n * Evaluates the given bezier curve at the parameter t.\r\n * @param ps An order 1, 2 or 3 bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param t The parameter value where the bezier should be evaluated\r\n **/\r\nfunction evalDeCasteljauY(ps, t) {\r\n    if (t === 0) {\r\n        return ps[0][1];\r\n    }\r\n    else if (t === 1) {\r\n        return ps[ps.length - 1][1];\r\n    }\r\n    //let s = 1-t;  // <= exact if eps | t, but not a precondition here\r\n    if (ps.length === 4) {\r\n        const [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        let b01 = y0 + (y1 - y0) * t;\r\n        let b11 = y1 + (y2 - y1) * t;\r\n        let b21 = y2 + (y3 - y2) * t;\r\n        let b02 = b01 + (b11 - b01) * t;\r\n        let b12 = b11 + (b21 - b11) * t;\r\n        return b02 + (b12 - b02) * t;\r\n    }\r\n    else if (ps.length === 3) {\r\n        const [[, y0], [, y1], [, y2]] = ps;\r\n        let b01 = y0 + (y1 - y0) * t;\r\n        let b11 = y1 + (y2 - y1) * t;\r\n        return b01 + (b11 - b01) * t;\r\n    }\r\n    else if (ps.length === 2) {\r\n        const [[, y0], [, y1]] = ps;\r\n        return y0 + (y1 - y0) * t;\r\n    }\r\n}\r\nexports.evalDeCasteljauY = evalDeCasteljauY;\r\n//# sourceMappingURL=eval-de-casteljau.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-hybrid-quadratic.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-hybrid-quadratic.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ./eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\r\n * toHybridQuadratic for details).\r\n * @param hq A hybrid quadratic\r\n * @param t The bezier parameter value\r\n * @param th The parameter value for the hybrid quadratic point.\r\n */\r\nfunction evaluateHybridQuadratic(hq, t, th) {\r\n    let P0 = hq[0];\r\n    let P1 = eval_de_casteljau_1.evalDeCasteljau(hq[1], th);\r\n    let P2 = hq[2];\r\n    return eval_de_casteljau_1.evalDeCasteljau([P0, P1, P2], t);\r\n}\r\nexports.evaluateHybridQuadratic = evaluateHybridQuadratic;\r\n//# sourceMappingURL=evaluate-hybrid-quadratic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-x.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-x.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_x_1 = __webpack_require__(/*! ../../to-power-basis/get-x */ \"./node_modules/flo-bezier3/node/to-power-basis/get-x.js\");\r\nfunction evaluateX(ps, t) {\r\n    const xPs = get_x_1.getX(ps);\r\n    const evPs = flo_poly_1.evaluate(xPs);\r\n    const len = ps.length;\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0][0];\r\n        }\r\n        if (t === 1) {\r\n            return ps[len - 1][0];\r\n        }\r\n        return evPs(t);\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateX = evaluateX;\r\n//# sourceMappingURL=evaluate-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-y.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-y.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst get_y_1 = __webpack_require__(/*! ../../to-power-basis/get-y */ \"./node_modules/flo-bezier3/node/to-power-basis/get-y.js\");\r\nfunction evaluateY(ps, t) {\r\n    const yPs = get_y_1.getY(ps);\r\n    const evPs = flo_poly_1.evaluate(yPs);\r\n    const len = ps.length;\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0][1];\r\n        }\r\n        if (t === 1) {\r\n            return ps[len - 1][1];\r\n        }\r\n        return evPs(t);\r\n    }\r\n    return t === undefined ? f : f(t); // Curry\r\n}\r\nexports.evaluateY = evaluateY;\r\n//# sourceMappingURL=evaluate-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nfunction evaluate(ps, t) {\r\n    const len = ps.length;\r\n    return t === undefined ? f : f(t);\r\n    function f(t) {\r\n        if (t === 0) {\r\n            return ps[0];\r\n        }\r\n        else if (t === 1) {\r\n            return ps[len - 1];\r\n        }\r\n        let s = 1 - t;\r\n        if (ps.length === 4) {\r\n            // cubic\r\n            let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n            let x = x0 * Math.pow(s, 3) + 3 * x1 * Math.pow(s, 2) * t + 3 * x2 * s * Math.pow(t, 2) + x3 * Math.pow(t, 3);\r\n            let y = y0 * Math.pow(s, 3) + 3 * y1 * Math.pow(s, 2) * t + 3 * y2 * s * Math.pow(t, 2) + y3 * Math.pow(t, 3);\r\n            return [x, y];\r\n        }\r\n        if (ps.length === 3) {\r\n            // quadratic\r\n            let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n            let x = x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2);\r\n            let y = y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2);\r\n            return [x, y];\r\n        }\r\n        if (ps.length === 2) {\r\n            // line\r\n            let [[x0, y0], [x1, y1]] = ps;\r\n            let x = x0 * s + x1 * t;\r\n            let y = y0 * s + y1 * t;\r\n            return [x, y];\r\n        }\r\n    }\r\n}\r\nexports.evaluate = evaluate;\r\nfunction evaluateExact(ps, t) {\r\n    const len = ps.length;\r\n    if (t === 0) {\r\n        return ps[0].map(c => [c]);\r\n    }\r\n    else if (t === 1) {\r\n        return ps[len - 1].map(c => [c]);\r\n    }\r\n    let s = 1 - t;\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let s3 = flo_numerical_1.scaleExpansion(s2, s);\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let t3 = flo_numerical_1.scaleExpansion(t2, t);\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        //let x = x0*s3 + 3*x1*s2*t + 3*x2*s*t2 + x3*t3;\r\n        //let y = y0*s3 + 3*y1*s2*t + 3*y2*s*t2 + y3*t3;\r\n        let x = flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s3, x0),\r\n            flo_numerical_1.expansionProduct(flo_numerical_1.scaleExpansion(flo_numerical_1.twoProduct(3, x1), t), s2),\r\n            flo_numerical_1.expansionProduct(flo_numerical_1.scaleExpansion(flo_numerical_1.twoProduct(3, x2), s), t2),\r\n            flo_numerical_1.scaleExpansion(t3, x3)\r\n        ]);\r\n        let y = flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s3, y0),\r\n            flo_numerical_1.expansionProduct(flo_numerical_1.scaleExpansion(flo_numerical_1.twoProduct(3, y1), t), s2),\r\n            flo_numerical_1.expansionProduct(flo_numerical_1.scaleExpansion(flo_numerical_1.twoProduct(3, y2), s), t2),\r\n            flo_numerical_1.scaleExpansion(t3, y3)\r\n        ]);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        //let x = x0*s**2 + 2*x1*s*t + x2*t**2;\r\n        //let y = y0*s**2 + 2*y1*s*t + y2*t**2;\r\n        let x = flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s2, x0),\r\n            flo_numerical_1.scaleExpansion(flo_numerical_1.twoProduct(2 * x1, s), t),\r\n            flo_numerical_1.scaleExpansion(t2, x2)\r\n        ]);\r\n        let y = flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s2, y0),\r\n            flo_numerical_1.scaleExpansion(flo_numerical_1.twoProduct(2 * y1, s), t),\r\n            flo_numerical_1.scaleExpansion(t2, y2)\r\n        ]);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        let x = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x0, s), flo_numerical_1.twoProduct(x1, t));\r\n        let y = flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y0, s), flo_numerical_1.twoProduct(y1, t));\r\n        ;\r\n        return [x, y];\r\n    }\r\n}\r\nexports.evaluateExact = evaluateExact;\r\nfunction expEvaluateExact(ps, t) {\r\n    const len = ps.length;\r\n    if (t === 0) {\r\n        return ps[0];\r\n    }\r\n    else if (t === 1) {\r\n        return ps[len - 1];\r\n    }\r\n    let s = 1 - t;\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let s3 = flo_numerical_1.scaleExpansion(s2, s);\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let t3 = flo_numerical_1.scaleExpansion(t2, t);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    let st2 = flo_numerical_1.scaleExpansion(t2, s);\r\n    let s2t = flo_numerical_1.scaleExpansion(s2, t);\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        //let x = x0*s3 + 3*x1*s2*t + 3*x2*s*t2 + x3*t3;\r\n        //let y = y0*s3 + 3*y1*s2*t + 3*y2*s*t2 + y3*t3;\r\n        let x = flo_numerical_1.calculate([[x0, s3], [[3], x1, s2, [t]], [[3], x2, [s], t2], [x3, t3]]);\r\n        let y = flo_numerical_1.calculate([[y0, s3], [[3], y1, s2, [t]], [[3], y2, [s], t2], [y3, t3]]);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        //let x = x0*s**2 + 2*x1*s*t + x2*t**2;\r\n        //let y = y0*s**2 + 2*y1*s*t + y2*t**2;\r\n        let x = flo_numerical_1.calculate([[x0, s2], [x1, [2 * s], [t]], [x2, t2]]);\r\n        let y = flo_numerical_1.calculate([[y0, s2], [y1, [2 * s], [t]], [y2, t2]]);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        let x = flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(x0, s), flo_numerical_1.scaleExpansion(x1, t));\r\n        let y = flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(y0, s), flo_numerical_1.scaleExpansion(y1, t));\r\n        ;\r\n        return [x, y];\r\n    }\r\n}\r\nexports.expEvaluateExact = expEvaluateExact;\r\n//# sourceMappingURL=evaluate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-at-t/tangent.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_dx_1 = __webpack_require__(/*! ./t-to-dxy/evaluate-dx */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dx.js\");\r\nconst evaluate_dy_1 = __webpack_require__(/*! ./t-to-dxy/evaluate-dy */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-dxy/evaluate-dy.js\");\r\nfunction tangent(ps, t) {\r\n    const evDx = evaluate_dx_1.evaluateDx(ps);\r\n    const evDy = evaluate_dy_1.evaluateDy(ps);\r\n    function f(t) {\r\n        return [evDx(t), evDy(t)];\r\n    }\r\n    // Curry\r\n    return t === undefined ? f : f(t);\r\n}\r\nexports.tangent = tangent;\r\n//# sourceMappingURL=tangent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-at-t/tangent.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-to-t/get-inflections.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-to-t/get-inflections.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_curvature_extrema_brackets_1 = __webpack_require__(/*! ../get-curvature-extrema/get-curvature-extrema-brackets */ \"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema-brackets.js\");\r\nfunction getInflections(ps) {\r\n    return get_curvature_extrema_brackets_1.getCurvatureExtremaBrackets(ps).inflections;\r\n}\r\nexports.getInflections = getInflections;\r\n//# sourceMappingURL=get-inflections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-to-t/get-inflections.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst to_cubic_1 = __webpack_require__(/*! ../transformation/degree-or-type/to-cubic */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js\");\r\nconst length_1 = __webpack_require__(/*! ../global-properties/length/length */ \"./node_modules/flo-bezier3/node/global-properties/length/length.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nfunction getTAtLength(ps, s) {\r\n    let ps_ = to_cubic_1.toCubic(ps);\r\n    const lenAtT = (t) => length_1.length([0, t], ps_);\r\n    function f(s) {\r\n        return flo_poly_1.brent(t => (lenAtT(t) - s), -0.1, 1.1);\r\n    }\r\n    // Curry\r\n    return s === undefined ? f : f(s);\r\n}\r\nexports.getTAtLength = getTAtLength;\r\n//# sourceMappingURL=get-t-at-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/are-beziers-in-same-k-family.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/are-beziers-in-same-k-family.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_point_on_bezier_extension_1 = __webpack_require__(/*! ./is-point-on-bezier-extension */ \"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * * TODO - bitlength calculation below is wrong due to evaluation.\r\n *\r\n * Returns true if two beziers are in the same K-family, i.e. when their infinte\r\n * extensions turn them into the same curve. This algorithm is robust if the\r\n * preconditions are met.\r\n * * probably better to use the bezierBezierIntersection function and see if it\r\n * returns undefined which is the case iff the two beziers are in the same\r\n * k-family.\r\n * * **Precondition**: bezier control points must be grid-aligned\r\n * * **Precondition**: max bit-length of each bezier's control points PLUS 4\r\n * (due to power basis conversion that can add 4 bits) PLUS 1 (due to testing of\r\n * t values at 1, 2, 4, 8, ...) must be < 53, therefore the max bitlength === 48.\r\n *\r\n * @param ps1 A bezier curve\r\n * @param ps2 Another bezier curve\r\n */\r\nfunction areBeziersInSameKFamily(ps1, ps2) {\r\n    // Get ten points on the first bezier or its extension. Ten, since there is\r\n    // max 9 intersections between two cubic bezier curves; \r\n    // cubic x cubic -> 3 x 3 according to Bezout's Theorem. Also, make each\r\n    // parametric t-value an integer power of two to keep the bitlength a \r\n    // minimum (1 in this case). Don't use 1 either since it could be likely\r\n    // two beziers share an endpoint by design causing the algorithm to do an\r\n    // additional check and run slower.\r\n    let ps = [0.03125, 0.0625, 0.125, 0.25, 0.5, 2, 4, 8, 16, 32].map(t => eval_de_casteljau_1.evalDeCasteljau(ps1, t));\r\n    for (let p of ps) {\r\n        if (!is_point_on_bezier_extension_1.isPointOnBezierExtension(ps2, p)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.areBeziersInSameKFamily = areBeziersInSameKFamily;\r\n//# sourceMappingURL=are-beziers-in-same-k-family.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/are-beziers-in-same-k-family.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_tangent_poly_from_point_1 = __webpack_require__(/*! ../get-tangent-poly-from-point/naive/get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/naive/get-tangent-poly-from-point.js\");\r\nconst get_tangent_poly_from_point_2 = __webpack_require__(/*! ../get-tangent-poly-from-point/exact/get-tangent-poly-from-point */ \"./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/evaluate */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Returns the closest point on the bezier to the given point - returns the point\r\n * and the t value.\r\n * * this function also acts as an excellent inversion formula.\r\n * @param ps\r\n * @param p\r\n */\r\nfunction closestPointOnBezierPrecise(ps, p) {\r\n    let poly = get_tangent_poly_from_point_2.getTangentPolyFromPointExact(ps, p);\r\n    // we give ample leeway for roots outside [0,1] since roots can be some \r\n    // distance outside this range at extemely high curvature where the tangent\r\n    // is very small. These can later be coerced to 0 or 1 if the distance from\r\n    // p to the bezier is calculated to be small enough. nope, we add [0,1] below\r\n    // as endpoints to check so no need.\r\n    let ts = flo_poly_1.allRootsMultiWithErrBounds(poly, poly.map(c => 0), // because all coefficients are exact\r\n    undefined // ...\r\n    //).map(t => t.tM);\r\n    ).map(flo_poly_1.mid);\r\n    ts.push(0);\r\n    ts.push(1);\r\n    let ps_ = ts.map(t => ({ p: evaluate_1.evaluateExact(ps, t).map(flo_numerical_1.estimate), t }));\r\n    //let ps_ = ts.map(t => ({ p: evalDeCasteljau(ps, t), t }));\r\n    // Get point with minimum distance\r\n    let minD = Number.POSITIVE_INFINITY;\r\n    let minT = undefined;\r\n    ps_.forEach(p_ => {\r\n        let d = flo_vector2d_1.squaredDistanceBetween(p_.p, p);\r\n        if (d < minD) {\r\n            minD = d;\r\n            minT = p_;\r\n        }\r\n    });\r\n    return minT;\r\n}\r\nexports.closestPointOnBezierPrecise = closestPointOnBezierPrecise;\r\nfunction closestPointOnBezier(ps, p) {\r\n    let poly = get_tangent_poly_from_point_1.getTangentPolyFromPoint(ps, p);\r\n    let ts = flo_poly_1.allRoots(poly, 0, 1);\r\n    ts.push(0);\r\n    ts.push(1);\r\n    let ps_ = ts.map(t => ({ p: eval_de_casteljau_1.evalDeCasteljau(ps, t), t }));\r\n    // Get point with minimum distance\r\n    let minD = Number.POSITIVE_INFINITY;\r\n    let minP = undefined;\r\n    ps_.forEach(p_ => {\r\n        let d = flo_vector2d_1.squaredDistanceBetween(p_.p, p);\r\n        if (d < minD) {\r\n            minD = d;\r\n            minP = p_;\r\n        }\r\n    });\r\n    return minP;\r\n}\r\nexports.closestPointOnBezier = closestPointOnBezier;\r\n//# sourceMappingURL=closest-point-on-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/equal.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/equal.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction equal(psA, psB) {\r\n    if (psA.length !== psB.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < psA.length; i++) {\r\n        if (psA[i] !== psB[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.equal = equal;\r\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/equal.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-ccw.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-ccw.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst curvature_1 = __webpack_require__(/*! ../local-properties-at-t/curvature */ \"./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js\");\r\n/**\r\n * Angle in degrees to radians.\r\n * @hidden\r\n */\r\nconst DEGREES = {\r\n    //'0'    : 0.0000,\r\n    0.25: 0.0050,\r\n    1: 0.0167,\r\n    4: 0.0698,\r\n    16: 0.2756,\r\n};\r\n/** @hidden */\r\n//const DEGREE_LIMIT = DEGREES[1];\r\nconst DEGREE_LIMIT = DEGREES[1];\r\n/**\r\n * Returns a positive value if the second bezier (of order 1, 2 or 3) curves\r\n * anti-clockwise with respect to the first at the point where the first bezier\r\n * ends and the second one starts. Returns a negative number if the turn is\r\n * clockwise. Returns 0 otherwise.\r\n *\r\n * The algorithm is a generalization of ccw, a.k.a orient2d.\r\n *\r\n * The above obviously necessitates that their endpoints coincide as described.\r\n *\r\n * Preconditions (for robustness):\r\n * * The beziers has control points with max bit-length of 25 and bit-aligned.\r\n * * The bezier does not have infinite curvature at either endpoint\r\n *\r\n * This is so the vectors between control points can be\r\n * calculated exactly without resorting to adaptive infinite precision floating\r\n * point operations. Note: aligned to 'grid' here means if you bitwise-and all\r\n * values together the resulting bitlength === the max bithlength of any value.\r\n *\r\n * @param psI The incoming bezier that ends at the interface\r\n * @param psO The outgoing bezier that starts at the interface\r\n */\r\n// TODO - improve and make at least 46-bitlength precondition\r\nfunction getInterfaceCcw(psI, psO) {\r\n    let lenI = psI.length;\r\n    // second last control point of incoming curve\r\n    let p0 = psI[lenI - 2];\r\n    // last control point of incoming curve / first control point of outgoing\r\n    let p1 = psO[0];\r\n    // second control point of outgoing curve\r\n    let p2 = psO[1];\r\n    /*\r\n    if (typeof _bez_debug_ !== 'undefined') {\r\n        let maxBitLength = 25;\r\n\r\n        let p1_ = psI[lenI-1];\r\n\r\n        // ---- precondition: does endpoints coincide\r\n        if (p1_[0] !== p1[0] || p1_[1] !== p1[1]) {\r\n            throw new Error('Curve endpoints must coincide.');\r\n        }\r\n\r\n        // ---- precondition: are coordinates grid-aligned\r\n\r\n        // Get all coordinate values into an array\r\n        let xs: number[] = [];\r\n        [psI, psO].forEach(ps => ps.forEach(p => p.forEach(x => {\r\n            xs.push(x);\r\n        })));\r\n        \r\n        let msb = xs.reduce((prevX, x) => Math.max(prevX, msbExponent(x)), Number.NEGATIVE_INFINITY);\r\n        let lsb = xs.reduce((prevX, x) => Math.min(prevX, lsbExponent(x)), Number.POSITIVE_INFINITY);\r\n\r\n        let bitlengthAll = msb - lsb + 1;\r\n        if (bitlengthAll > maxBitLength) {\r\n            throw new Error(\r\n                `Curve control point coordinates must be bit-aligned and <= ${maxBitLength}. bitlength === ${bitlengthAll}, coordinates: ${xs}`\r\n            );\r\n        }\r\n    }\r\n    */\r\n    // Max one bit can be added in the calculations below due to bit-alignment\r\n    let xE = p1[0] - p0[0]; // tangent x-coordinate\r\n    let yE = p1[1] - p0[1]; // tangent y-coordinate\r\n    let xS = p2[0] - p1[0]; // tangent x-coordinate\r\n    let yS = p2[1] - p1[1]; // tangent y-coordinate\r\n    // If the tangent is to be found at t === 0 or t === 1 then using a basic \r\n    // property of bezier curves we can find the tangents easily as below\r\n    // (non-normalized) tangent of incoming curve at t === 1\r\n    let tangentAtEnd = [xE, yE];\r\n    // (non-normalized) tangent of outgoing curve at t === 0\r\n    let tangentAtStart = [xS, yS];\r\n    // The cross calculated below will have a max bitlength of \r\n    // (2*(maxBitLength+1))+1 === e.g. (2*(25+1)) + 1 === 53\r\n    // If the preconditions are met it is exact\r\n    //let crossTangents = cross(tangentAtEnd, tangentAtStart);\r\n    // The cross below is exact by adaptive infinite precision\r\n    let crossTangents = flo_numerical_1.orient2d(p0, p1, p2);\r\n    if (crossTangents !== 0) {\r\n        return crossTangents;\r\n    }\r\n    // The dot calculated below will have a max bitlength of \r\n    // (2*(maxBitLength+1))+1 === e.g. (2*(25+1)) + 1 === 53\r\n    // If the preconditions are met it is exact\r\n    let dotTangents = flo_vector2d_1.dot(tangentAtEnd, tangentAtStart);\r\n    if (dotTangents > 0) {\r\n        // Curves go in same direction at interface - neither clock or \r\n        // anti-clockwise.\r\n        // Note: The above comment is not strictly true but as this case is not\r\n        // important for the algorithm we return 0\r\n        return 0;\r\n    }\r\n    // Curves go in opposite directions at interface starting off with the exact\r\n    // same tangent - look now at curvature to see which has the largest \r\n    // curvature so we can base the clock or anti-clockwise result on that\r\n    // Look at curvature\r\n    return curvature_1.compareCurvaturesAtInterface(psI.slice().reverse(), psO);\r\n}\r\nexports.getInterfaceCcw = getInterfaceCcw;\r\n//# sourceMappingURL=get-interface-ccw.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-ccw.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst qm2 = flo_numerical_1.qMultBy2;\r\nconst qm4 = flo_numerical_1.qMultBy4;\r\nconst qmn2 = flo_numerical_1.qMultByNeg2;\r\nconst qdifq = flo_numerical_1.qDiffQuad;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\n/**\r\n * Returns the polynomial whose roots are all the t values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at t is tangent to the bezier at t.\r\n * * **precondition** coefficients of curve and point bit-aligned bitlength <= 46\r\n * * the resulting coefficients are guaranteed to have max bitlength 106 (so it\r\n * can fit in a double-double)\r\n * @param ps An order 1, 2 or 3 bezier curve given by its control points.\r\n * @param p\r\n */\r\nfunction getTangentPolyFromPointExact(ps, p) {\r\n    if (ps.length === 4) {\r\n        return getPolyForCubicExact(ps, p);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return getPolyForQuadraticExact(ps, p);\r\n    }\r\n    else if (ps.length === 2) {\r\n        return getPolyForLineExact(ps, p);\r\n    }\r\n}\r\nexports.getTangentPolyFromPointExact = getTangentPolyFromPointExact;\r\n/**\r\n * * **precondition** coefficients of curve and point bit-aligned bitlength <= 46\r\n * @param ps\r\n * @param p\r\n */\r\nfunction getPolyForCubicExact(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let [x, y] = p;\r\n    let xx0 = x0 - x; // (bitlength <= 52) => exact\r\n    let xx1 = x1 - x; // (bitlength <= 52) => exact\r\n    let xx2 = x2 - x; // (bitlength <= 52) => exact\r\n    let xx3 = x3 - x; // (bitlength <= 52) => exact\r\n    let yy0 = y0 - y; // (bitlength <= 52) => exact\r\n    let yy1 = y1 - y; // (bitlength <= 52) => exact\r\n    let yy2 = y2 - y; // (bitlength <= 52) => exact\r\n    let yy3 = y3 - y; // (bitlength <= 52) => exact\r\n    // 52 -> 0 bits spare (1 summand)\r\n    // 51 -> 2 bits spare (2-4 summands)\r\n    // 50 -> 4 bits spare (5-16 summands)\r\n    // 49 -> 6 bits spare (17-64 summands)\r\n    // 48 -> 8 bits spare (65-256 summands)\r\n    // 47 -> 10 bits spare (257-1024 summands)\r\n    // 46 -> 12 bits spare (1025-4096 summands)\r\n    let x00 = tp(xx0, xx0); // (bitlength <= 52) => exact (1  summands)\r\n    let x01 = qmd(6, tp(xx0, xx1)); // (bitlength <= 50) => exact (6  summands)\r\n    let x02 = qmd(6, tp(xx0, xx2)); // (bitlength <= 50) => exact (6  summands)\r\n    let x03 = qm2(tp(xx0, xx3)); // (bitlength <= 52) => exact (2  summands)\r\n    let x11 = qmd(9, tp(xx1, xx1)); // (bitlength <= 50) => exact (9  summands)\r\n    let x12 = qmd(18, tp(xx1, xx2)); // (bitlength <= 49) => exact (18 summands)\r\n    let x13 = qmd(6, tp(xx1, xx3)); // (bitlength <= 50) => exact (6  summands)\r\n    let x22 = qmd(9, tp(xx2, xx2)); // (bitlength <= 50) => exact (9  summands)\r\n    let x23 = qmd(6, tp(xx2, xx3)); // (bitlength <= 50) => exact (6  summands)\r\n    let x33 = tp(xx3, xx3); // (bitlength <= 52) => exact (1  summands)\r\n    let y00 = tp(yy0, yy0); // (bitlength <= 52) => exact (1  summands)\r\n    let y01 = qmd(6, tp(yy0, yy1)); // (bitlength <= 50) => exact (6  summands)\r\n    let y02 = qmd(6, tp(yy0, yy2)); // (bitlength <= 50) => exact (6  summands)\r\n    let y03 = qm2(tp(yy0, yy3)); // (bitlength <= 52) => exact (2  summands)\r\n    let y11 = qmd(9, tp(yy1, yy1)); // (bitlength <= 49) => exact (9  summands)\r\n    let y12 = qmd(18, tp(yy1, yy2)); // (bitlength <= 48) => exact (18 summands)\r\n    let y13 = qmd(6, tp(yy1, yy3)); // (bitlength <= 50) => exact (6  summands)\r\n    let y22 = qmd(9, tp(yy2, yy2)); // (bitlength <= 49) => exact (9  summands)\r\n    let y23 = qmd(6, tp(yy2, yy3)); // (bitlength <= 50) => exact (6  summands)\r\n    let y33 = tp(yy3, yy3); // (bitlength <= 52) => exact (1  summands)\r\n    let q1 = qaq(x13, x22); // (bitlength <= 50) => exact (15 summands)\r\n    let q2 = qaq(x03, x12); // (bitlength <= 49) => exact (20 summands)\r\n    let q3 = qaq(x02, x11); // (bitlength <= 50) => exact (15 summands)\r\n    let r1 = qaq(y13, y22); // (bitlength <= 50) => exact (15 summands)\r\n    let r2 = qaq(y03, y12); // (bitlength <= 49) => exact (20 summands)\r\n    let r3 = qaq(y02, y11); // (bitlength <= 50) => exact (15 summands)\r\n    //let t5 = 6*((x33 - x23 + q1 - q2 + q3 - x01 + x00) + \r\n    //            (y33 - y23 + r1 - r2 + r3 - y01 + y00));\r\n    let t5a = qdifq(qaq(qaq(x33, x00), qaq(q1, q3)), (qaq(qaq(q2, x23), x01))); // (bitlength <= 49) => exact (64 summands)\r\n    let t5b = qdifq(qaq(qaq(y33, y00), qaq(r1, r3)), (qaq(qaq(r2, y23), y01))); // (bitlength <= 49) => exact (64 summands)\r\n    let t5 = qmd(6, qaq(t5a, t5b)); // (bitlength <= 47) => exact (768 summands)\r\n    //let t4 = 5*((x23 - 2*(q1 + 2*q3 + 3*x00) + 3*q2 + 5*x01) +\r\n    //            (y23 - 2*(r1 + 2*r3 + 3*y00) + 3*r2 + 5*y01));\r\n    let t4a = qaq(qmn2(qaq(qaq(q1, qm2(q3)), qmd(3, x00))), qaq(qaq(x23, qmd(3, q2)), qmd(5, x01))); // (bitlength <= 48) => exact (192 summands)\r\n    let t4b = qaq(qmn2(qaq(qaq(r1, qm2(r3)), qmd(3, y00))), qaq(qaq(y23, qmd(3, r2)), qmd(5, y01))); // (bitlength <= 48) => exact (192 summands)\r\n    let t4 = qmd(5, qaq(t4a, t4b)); // (bitlength <= 46) => exact (1920 summands)\r\n    //let t3 = 4*((q1 - 3*(q2 - 2*q3) - 5*(2*x01 - 3*x00)) +\r\n    //            (r1 - 3*(r2 - 2*r3) - 5*(2*y01 - 3*y00)));\r\n    let t3a = qaq(qaq(q1, qmd(3, (qdifq(qm2(q3), q2)))), qmd(5, (qdifq(qmd(3, x00), qm2(x01))))); // (bitlength <= 48) => exact (210 summands)\r\n    let t3b = qaq(qaq(r1, qmd(3, (qdifq(qm2(r3), r2)))), qmd(5, (qdifq(qmd(3, y00), qm2(y01))))); // (bitlength <= 48) => exact (210 summands)\r\n    let t3 = qmd(4, qaq(t3a, t3b)); // (bitlength <= 47) => exact (4*420 summands)\r\n    //let t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\r\n    //            (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\r\n    let t2a = qdifq(q2, qm2(qdifq(qm2(q3), qmd(5, (qdifq(x01, qm2(x00))))))); // (bitlength <= 48) => exact (160 summands)\r\n    let t2b = qdifq(r2, qm2(qdifq(qm2(r3), qmd(5, (qdifq(y01, qm2(y00))))))); // (bitlength <= 48) => exact (160 summands)\r\n    let t2 = qmd(3, qaq(t2a, t2b)); // (bitlength <= 47) => exact (960 summands)\r\n    //let t1 = 2*((q3 - 5*(x01 - 3*x00)) +\r\n    //            (r3 - 5*(y01 - 3*y00)));\r\n    let t1a = qdifq(q3, qmd(5, (qdifq(x01, qmd(3, x00))))); // (bitlength <= 49) => exact (60 summands)\r\n    let t1b = qdifq(r3, qmd(5, (qdifq(y01, qmd(3, y00))))); // (bitlength <= 49) => exact (60 summands)\r\n    let t1 = qm2(qaq(t1a, t1b)); // (bitlength <= 48) => exact (240 summands)\r\n    //let t0 = ((x01 - 6*x00) +\r\n    //          (y01 - 6*y00));\r\n    let t0a = qdifq(x01, qmd(6, x00)); // (bitlength <= 50) => exact (12 summands)\r\n    let t0b = qdifq(y01, qmd(6, y00)); // (bitlength <= 50) => exact (12 summands)\r\n    let t0 = qaq(t0a, t0b); // (bitlength <= 49) => exact (24 summands)\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\n/**\r\n * * **precondition** coefficients of curve and point bit-aligned bitlength <= 49\r\n * @param ps\r\n * @param p\r\n */\r\nfunction getPolyForQuadraticExact(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let [x, y] = p;\r\n    let xx0 = x0 - x; // (bitlength <= 52) => exact\r\n    let xx1 = x1 - x; // (bitlength <= 52) => exact\r\n    let xx2 = x2 - x; // (bitlength <= 52) => exact\r\n    let yy0 = y0 - y; // (bitlength <= 52) => exact\r\n    let yy1 = y1 - y; // (bitlength <= 52) => exact\r\n    let yy2 = y2 - y; // (bitlength <= 52) => exact\r\n    let x00 = tp(xx0, xx0); // (bitlength <= 52) => exact (1  summand)\r\n    let x01 = tp(xx0, xx1); // (bitlength <= 52) => exact (1  summand)\r\n    let x02 = tp(xx0, xx2); // (bitlength <= 52) => exact (1  summand)\r\n    let x11 = tp(xx1, xx1); // (bitlength <= 52) => exact (1  summand)\r\n    let x12 = tp(xx1, xx2); // (bitlength <= 52) => exact (1  summand)\r\n    let x22 = tp(xx2, xx2); // (bitlength <= 52) => exact (1  summand)\r\n    let y00 = tp(yy0, yy0);\r\n    let y01 = tp(yy0, yy1);\r\n    let y02 = tp(yy0, yy2);\r\n    let y11 = tp(yy1, yy1);\r\n    let y12 = tp(yy1, yy2);\r\n    let y22 = tp(yy2, yy2);\r\n    let q1 = qaq(y02, qm2(y11)); // (bitlength <= 51) => exact (3  summand)\r\n    let r1 = qaq(x02, qm2(x11)); // (bitlength <= 51) => exact (3  summand)\r\n    //let t3 = y22 + 2*q1 - 4*(y12 + y01) + y00 + \r\n    //         x22 + 2*r1 - 4*(x12 + x01) + x00;\r\n    let t3a = qaq(qdifq(qaq(x22, qm2(r1)), qm4(qaq(x12, x01))), x00); // (bitlength <= 50) => exact (13  summand)\r\n    let t3b = qaq(qdifq(qaq(y22, qm2(q1)), qm4(qaq(y12, y01))), y00); // (bitlength <= 50) => exact (13  summand)\r\n    let t3 = qaq(t3a, t3b); // (bitlength <= 49) => exact (26  summand)\r\n    //let t2 = 3*(y12 - q1 + 3*y01 - y00 + \r\n    //            x12 - r1 + 3*x01 - x00);\r\n    let t2a = qaq(qdifq(x12, r1), qdifq(qmd(3, x01), x00)); // (bitlength <= 49) => exact (24  summand)\r\n    let t2b = qaq(qdifq(y12, q1), qdifq(qmd(3, y01), y00)); // (bitlength <= 49) => exact (24  summand)\r\n    let t2 = qmd(3, qaq(t2a, t2b)); // (bitlength <= 48) => exact (144  summand)\r\n    //let t1 = q1 - 3*(2*y01 - y00) + \r\n    //         r1 - 3*(2*x01 - x00);\r\n    let t1a = qdifq(q1, qmd(3, qdifq(qm2(y01), y00))); // (bitlength <= 50) => exact (12  summand)\r\n    let t1b = qdifq(r1, qmd(3, qdifq(qm2(x01), x00))); // (bitlength <= 50) => exact (12  summand)\r\n    let t1 = qaq(t1a, t1b); // (bitlength <= 49) => exact (24  summand)\r\n    //let t0 = y01 - y00 + \r\n    //         x01 - x00;\r\n    let t0a = qdifq(y01, y00); // (bitlength <= 51) => exact (2  summand)\r\n    let t0b = qdifq(x01, x00); // (bitlength <= 51) => exact (2  summand)\r\n    let t0 = qaq(t0a, t0b); // (bitlength <= 51) => exact (4  summand)\r\n    return [t3, t2, t1, t0];\r\n}\r\n/**\r\n * * **precondition** coefficients of curve and point bit-aligned bitlength <= 49\r\n * @param ps\r\n * @param p\r\n */\r\nfunction getPolyForLineExact(ps, p) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let [x, y] = p;\r\n    let xx0 = x0 - x; // (bitlength <= 52) => exact\r\n    let xx1 = x1 - x; // (bitlength <= 52) => exact\r\n    let yy0 = y0 - y; // (bitlength <= 52) => exact\r\n    let yy1 = y1 - y; // (bitlength <= 52) => exact\r\n    let x00 = tp(xx0, xx0);\r\n    let x01 = tp(xx0, xx1);\r\n    let x11 = tp(xx1, xx1);\r\n    let y00 = tp(yy0, yy0);\r\n    let y01 = tp(yy0, yy1);\r\n    let y11 = tp(yy1, yy1);\r\n    let s1 = qaq(x01, y01); // (bitlength <= 51) => exact\r\n    let s2 = qaq(y00, x00); // (bitlength <= 51) => exact\r\n    //let t1 = x11 + y11 - 2*s1 + s2;\r\n    let t1 = qaq(qaq(x11, y11), qaq(qmn2(s1), s2)); // (bitlength <= 49) => exact\r\n    //let t0 = s1 - s2;\r\n    let t0 = qdifq(s1, s2); // (bitlength <= 50) => exact\r\n    return [t1, t0];\r\n}\r\n//# sourceMappingURL=get-tangent-poly-from-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/exact/get-tangent-poly-from-point.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/naive/get-tangent-poly-from-point.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/naive/get-tangent-poly-from-point.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the polynomial whose roots are all the t values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at t is tangent to the bezier at t.\r\n * @param ps An order 1, 2 or 3 bezier curve given by its control points.\r\n * @param p\r\n */\r\nfunction getTangentPolyFromPoint(ps, p) {\r\n    if (ps.length === 4) {\r\n        return getPolyForCubic(ps, p);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return getPolyForQuadratic(ps, p);\r\n    }\r\n    else if (ps.length === 2) {\r\n        return getPolyForLine(ps, p);\r\n    }\r\n}\r\nexports.getTangentPolyFromPoint = getTangentPolyFromPoint;\r\nfunction getPolyForCubic(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let xx3 = x3 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let yy3 = y3 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = 6 * xx0 * xx1;\r\n    let x02 = 6 * xx0 * xx2;\r\n    let x03 = 2 * xx0 * xx3;\r\n    let x11 = 9 * xx1 * xx1;\r\n    let x12 = 18 * xx1 * xx2;\r\n    let x13 = 6 * xx1 * xx3;\r\n    let x22 = 9 * xx2 * xx2;\r\n    let x23 = 6 * xx2 * xx3;\r\n    let x33 = xx3 * xx3;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = 6 * yy0 * yy1;\r\n    let y02 = 6 * yy0 * yy2;\r\n    let y03 = 2 * yy0 * yy3;\r\n    let y11 = 9 * yy1 * yy1;\r\n    let y12 = 18 * yy1 * yy2;\r\n    let y13 = 6 * yy1 * yy3;\r\n    let y22 = 9 * yy2 * yy2;\r\n    let y23 = 6 * yy2 * yy3;\r\n    let y33 = yy3 * yy3;\r\n    let q1 = x13 + x22;\r\n    let q2 = x03 + x12;\r\n    let q3 = x02 + x11;\r\n    let r1 = y13 + y22;\r\n    let r2 = y03 + y12;\r\n    let r3 = y02 + y11;\r\n    let t5 = 6 * ((x33 - x23 + q1 - q2 + q3 - x01 + x00) +\r\n        (y33 - y23 + r1 - r2 + r3 - y01 + y00));\r\n    let t4 = 5 * ((x23 - 2 * (q1 + 2 * q3 + 3 * x00) + 3 * q2 + 5 * x01) +\r\n        (y23 - 2 * (r1 + 2 * r3 + 3 * y00) + 3 * r2 + 5 * y01));\r\n    let t3 = 4 * ((q1 - 3 * (q2 - 2 * q3) - 5 * (2 * x01 - 3 * x00)) +\r\n        (r1 - 3 * (r2 - 2 * r3) - 5 * (2 * y01 - 3 * y00)));\r\n    let t2 = 3 * ((q2 - 2 * (2 * q3 - 5 * (x01 - 2 * x00))) +\r\n        (r2 - 2 * (2 * r3 - 5 * (y01 - 2 * y00))));\r\n    let t1 = 2 * ((q3 - 5 * (x01 - 3 * x00)) +\r\n        (r3 - 5 * (y01 - 3 * y00)));\r\n    let t0 = ((x01 - 6 * x00) +\r\n        (y01 - 6 * y00));\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\nfunction getPolyForQuadratic(ps, p) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let xx2 = x2 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let yy2 = y2 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = xx0 * xx1;\r\n    let x02 = xx0 * xx2;\r\n    let x11 = xx1 * xx1;\r\n    let x12 = xx1 * xx2;\r\n    let x22 = xx2 * xx2;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = yy0 * yy1;\r\n    let y02 = yy0 * yy2;\r\n    let y11 = yy1 * yy1;\r\n    let y12 = yy1 * yy2;\r\n    let y22 = yy2 * yy2;\r\n    let q1 = y02 + 2 * y11;\r\n    let r1 = x02 + 2 * x11;\r\n    let t3 = y22 + 2 * q1 - 4 * (y12 + y01) + y00 +\r\n        x22 + 2 * r1 - 4 * (x12 + x01) + x00;\r\n    let t2 = 3 * (y12 - q1 + 3 * y01 - y00 +\r\n        x12 - r1 + 3 * x01 - x00);\r\n    let t1 = q1 - 3 * (2 * y01 - y00) +\r\n        r1 - 3 * (2 * x01 - x00);\r\n    let t0 = y01 - y00 +\r\n        x01 - x00;\r\n    return [t3, t2, t1, t0];\r\n}\r\nfunction getPolyForLine(ps, p) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let [xp, yp] = p;\r\n    let xx0 = x0 - xp;\r\n    let xx1 = x1 - xp;\r\n    let yy0 = y0 - yp;\r\n    let yy1 = y1 - yp;\r\n    let x00 = xx0 * xx0;\r\n    let x01 = xx0 * xx1;\r\n    let x11 = xx1 * xx1;\r\n    let y00 = yy0 * yy0;\r\n    let y01 = yy0 * yy1;\r\n    let y11 = yy1 * yy1;\r\n    let s1 = x01 + y01;\r\n    let s2 = y00 + x00;\r\n    let t1 = x11 + y11 - 2 * s1 + s2;\r\n    let t0 = s1 - s2;\r\n    return [t1, t0];\r\n}\r\n//# sourceMappingURL=get-tangent-poly-from-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/get-tangent-poly-from-point/naive/get-tangent-poly-from-point.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! ./closest-point-on-bezier/closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js\");\r\nconst split_by_max_curve_length_1 = __webpack_require__(/*! ../transformation/split-merge-clone/split-by-max-curve-length */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curve-length.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\nfunction hausdorffDistanceCandidates(ps1, ps2, maxLength) {\r\n    let ts = split_by_max_curve_length_1.splitByMaxCurveLength(ps1, maxLength);\r\n    let candidates = [];\r\n    for (let i = 0; i < ts.length; i++) {\r\n        let t = ts[i];\r\n        let p = eval_de_casteljau_1.evalDeCasteljau(ps1, t);\r\n        let v = closest_point_on_bezier_1.closestPointOnBezier(ps2, p);\r\n        candidates.push({\r\n            p1: p,\r\n            p2: v.p,\r\n            d: flo_vector2d_1.distanceBetween(p, v.p)\r\n        });\r\n    }\r\n    return candidates;\r\n}\r\nexports.hausdorffDistanceCandidates = hausdorffDistanceCandidates;\r\n/**\r\n * Calculates and returns an approximation to the one-sided Hausdorff distance\r\n * from ps1 to ps2 between two bezier curves.\r\n * @param ps1\r\n * @param ps2\r\n * @param maxLength The first curve (ps1) will be split into pieces such that\r\n * each piece is shorter than maxLength. All endpoints of the smaller curves\r\n * are then used to check the distance to the other curve. The max of these\r\n * are given as an estimate of the Hausdorff distance.\r\n */\r\nfunction hausdorffDistance(ps1, ps2, maxLength) {\r\n    let candidates = hausdorffDistanceCandidates(ps1, ps2, maxLength);\r\n    let maxD = Number.NEGATIVE_INFINITY;\r\n    for (let candidate of candidates) {\r\n        if (candidate.d > maxD) {\r\n            maxD = candidate.d;\r\n        }\r\n    }\r\n    return maxD;\r\n}\r\nexports.hausdorffDistance = hausdorffDistance;\r\n//# sourceMappingURL=hausdorff-distance.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_implicit_form3_1 = __webpack_require__(/*! ../implicit-form/naive/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form3.js\");\r\nconst get_implicit_form3_2 = __webpack_require__(/*! ../implicit-form/quad/get-implicit-form3 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form3.js\");\r\nconst error_analysis_1 = __webpack_require__(/*! ../error-analysis/error-analysis */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_implicit_form3_3 = __webpack_require__(/*! ../implicit-form/exact/get-implicit-form3- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-.js\");\r\nconst get_implicit_form2_1 = __webpack_require__(/*! ../implicit-form/naive/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/naive/get-implicit-form2.js\");\r\nconst get_implicit_form2_2 = __webpack_require__(/*! ../implicit-form/quad/get-implicit-form2 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form2.js\");\r\nconst get_implicit_form2_3 = __webpack_require__(/*! ../implicit-form/exact/get-implicit-form2- */ \"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-.js\");\r\nconst get_implicit_form1_1 = __webpack_require__(/*! ../implicit-form/quad/get-implicit-form1 */ \"./node_modules/flo-bezier3/node/implicit-form/quad/get-implicit-form1.js\");\r\nconst abs = Math.abs;\r\nconst tp = flo_numerical_1.twoProduct;\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qmq = flo_numerical_1.qMultQuad;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\nconst sce = flo_numerical_1.scaleExpansion2;\r\nconst epr = flo_numerical_1.expansionProduct;\r\nconst fes = flo_numerical_1.fastExpansionSum;\r\n/**\r\n * Returns true if the given point is on the given cubic bezier curve where the\r\n * parameter t is allowed to extend to +-infinity, i.e. t is an element of\r\n * [-inf, +inf], false otherwise.\r\n *\r\n * * Precondition: ps must be grid-aligned and have a maximum bitlength of 47.\r\n * (p may have any bitlength - no restrictions)\r\n */\r\nfunction isPointOnBezierExtension3(ps, p) {\r\n    let [x, y] = p;\r\n    //---- first pre-filter\r\n    {\r\n        // The below takes about 1.2 micro-seconds on a 1st gen i7 and Chrome 79\r\n        let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_1.getImplicitForm3(ps);\r\n        let _vₓₓₓ = abs(vₓₓₓ);\r\n        let _vₓₓᵧ = abs(vₓₓᵧ);\r\n        let _vₓᵧᵧ = abs(vₓᵧᵧ);\r\n        let _vᵧᵧᵧ = abs(vᵧᵧᵧ);\r\n        let _vₓₓ = abs(vₓₓ);\r\n        let _vₓᵧ = abs(vₓᵧ);\r\n        let _vᵧᵧ = abs(vᵧᵧ);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // let h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        let _x = abs(x);\r\n        let xx = x * x;\r\n        let _xx_ = xx;\r\n        let xxx = xx * x;\r\n        let _xxx = abs(xxx);\r\n        let xxx_ = _xx_ * _x + _xxx;\r\n        let _y = abs(y);\r\n        let yy = y * y;\r\n        let _yy_ = yy;\r\n        let yyy = yy * y;\r\n        let _yyy = abs(yyy);\r\n        let yyy_ = _yy_ * _y + _yyy;\r\n        let xxy = xx * y;\r\n        let _xxy = abs(xxy);\r\n        let xxy_ = _xx_ * _y + _xxy;\r\n        let xyy = x * yy;\r\n        let _xyy = abs(xyy);\r\n        let xyy_ = _x * _yy_ + _xyy;\r\n        let xy = x * y;\r\n        let _xy_ = abs(xy);\r\n        let vₓₓₓxxx = vₓₓₓ * xxx;\r\n        let vₓₓₓxxx_ = vₓₓₓ_ * _xxx + _vₓₓₓ * xxx_ + abs(vₓₓₓxxx);\r\n        let vₓₓᵧxxy = vₓₓᵧ * xxy;\r\n        let vₓₓᵧxxy_ = vₓₓᵧ_ * _xxy + _vₓₓᵧ * xxy_ + abs(vₓₓᵧxxy);\r\n        let vₓᵧᵧxyy = vₓᵧᵧ * xyy;\r\n        let vₓᵧᵧxyy_ = vₓᵧᵧ_ * _xyy + _vₓᵧᵧ * xyy_ + abs(vₓᵧᵧxyy);\r\n        let vᵧᵧᵧyyy = vᵧᵧᵧ * yyy;\r\n        let vᵧᵧᵧyyy_ = vᵧᵧᵧ_ * _yyy + _vᵧᵧᵧ * yyy_ + abs(vᵧᵧᵧyyy);\r\n        let vₓₓxx = vₓₓ * xx;\r\n        let vₓₓxx_ = (vₓₓ_ + _vₓₓ) * _xx_ + abs(vₓₓxx);\r\n        let vₓᵧxy = vₓᵧ * xy;\r\n        let vₓᵧxy_ = (vₓᵧ_ + _vₓᵧ) * _xy_ + abs(vₓᵧxy);\r\n        let vᵧᵧyy = vᵧᵧ * yy;\r\n        let vᵧᵧyy_ = (vᵧᵧ_ + _vᵧᵧ) * _yy_ + abs(vᵧᵧyy);\r\n        let vₓx = vₓ * x;\r\n        let vₓx_ = vₓ_ * _x + abs(vₓx);\r\n        let vᵧy = vᵧ * y;\r\n        let vᵧy_ = vᵧ_ * _y + abs(vᵧy);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //let h = \r\n        //    (\r\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \r\n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\r\n        //    ) + \r\n        //    (\r\n        //        (vₓx + vᵧy) + \r\n        //        v\r\n        //    );\r\n        let q1 = vₓₓₓxxx + vₓₓᵧxxy;\r\n        let q1_ = vₓₓₓxxx_ + vₓₓᵧxxy_ + abs(q1);\r\n        let q2 = vₓᵧᵧxyy + vᵧᵧᵧyyy;\r\n        let q2_ = vₓᵧᵧxyy_ + vᵧᵧᵧyyy_ + abs(q2);\r\n        let q3 = q1 + q2;\r\n        let q3_ = q1_ + q2_ + abs(q3);\r\n        let q4 = vₓₓxx + vₓᵧxy;\r\n        let q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4);\r\n        let q5 = q4 + vᵧᵧyy;\r\n        let q5_ = q4_ + vᵧᵧyy_ + abs(q5);\r\n        let q6 = q3 + q5;\r\n        let q6_ = q3_ + q5_ + abs(q6);\r\n        let q7 = vₓx + vᵧy;\r\n        let q7_ = vₓx_ + vᵧy_ + abs(q7);\r\n        let q8 = q7 + v;\r\n        let q8_ = q7_ + v_ + abs(q8);\r\n        let h = q6 + q8;\r\n        let h_ = q6_ + q8_ + abs(h);\r\n        // if the error is not too high too discern h away from zero\r\n        if (error_analysis_1.γ1 * h_ < abs(h)) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error too high - let's try quad precision\r\n    {\r\n        // The below takes about 15 micro-seconds on a 1st gen i7 and Chrome 79\r\n        let { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form3_2.getImplicitForm3Quad(ps);\r\n        let _vₓₓₓ = abs(vₓₓₓ[1]);\r\n        let _vₓₓᵧ = abs(vₓₓᵧ[1]);\r\n        let _vₓᵧᵧ = abs(vₓᵧᵧ[1]);\r\n        let _vᵧᵧᵧ = abs(vᵧᵧᵧ[1]);\r\n        let _vₓₓ = abs(vₓₓ[1]);\r\n        let _vₓᵧ = abs(vₓᵧ[1]);\r\n        let _vᵧᵧ = abs(vᵧᵧ[1]);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // let h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        let _x = abs(x);\r\n        let xx = tp(x, x); // <= error free\r\n        let _xx = abs(xx[1]);\r\n        let xxx = qmd(x, xx);\r\n        let _xxx_ = abs(xxx[1]);\r\n        let _y = abs(y);\r\n        let yy = tp(y, y); // <= error free\r\n        let _yy = abs(yy[1]);\r\n        let yyy = qmd(y, yy);\r\n        let _yyy_ = abs(yyy[1]);\r\n        let xxy = qmd(y, xx);\r\n        let _xxy_ = abs(xxy[1]);\r\n        let xyy = qmd(x, yy);\r\n        let _xyy_ = abs(xyy[1]);\r\n        let xy = tp(x, y); // <= error free\r\n        let _xy = abs(xy[1]);\r\n        let vₓₓₓxxx = qmq(vₓₓₓ, xxx);\r\n        let vₓₓₓxxx_ = (vₓₓₓ_ + _vₓₓₓ) * _xxx_ + 2 * abs(vₓₓₓxxx[1]);\r\n        let vₓₓᵧxxy = qmq(vₓₓᵧ, xxy);\r\n        let vₓₓᵧxxy_ = (vₓₓᵧ_ + _vₓₓᵧ) * _xxy_ + 2 * abs(vₓₓᵧxxy[1]);\r\n        let vₓᵧᵧxyy = qmq(vₓᵧᵧ, xyy);\r\n        let vₓᵧᵧxyy_ = (vₓᵧᵧ_ + _vₓᵧᵧ) * _xyy_ + 2 * abs(vₓᵧᵧxyy[1]);\r\n        let vᵧᵧᵧyyy = qmq(vᵧᵧᵧ, yyy);\r\n        let vᵧᵧᵧyyy_ = (vᵧᵧᵧ_ + _vᵧᵧᵧ) * _yyy_ + 2 * abs(vᵧᵧᵧyyy[1]);\r\n        let vₓₓxx = qmq(vₓₓ, xx);\r\n        let vₓₓxx_ = vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\r\n        let vₓᵧxy = qmq(vₓᵧ, xy);\r\n        let vₓᵧxy_ = vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\r\n        let vᵧᵧyy = qmq(vᵧᵧ, yy);\r\n        let vᵧᵧyy_ = vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\r\n        let vₓx = qmd(x, vₓ);\r\n        let vₓx_ = vₓ_ * _x + abs(vₓx[1]);\r\n        let vᵧy = qmd(y, vᵧ);\r\n        let vᵧy_ = vᵧ_ * _y + abs(vᵧy[1]);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //let h = \r\n        //    (\r\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \r\n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\r\n        //    ) + \r\n        //    (\r\n        //        (vₓx + vᵧy) + \r\n        //        v\r\n        //    );\r\n        let q1 = qaq(vₓₓₓxxx, vₓₓᵧxxy);\r\n        let q1_ = vₓₓₓxxx_ + vₓₓᵧxxy_ + abs(q1[1]);\r\n        let q2 = qaq(vₓᵧᵧxyy, vᵧᵧᵧyyy);\r\n        let q2_ = vₓᵧᵧxyy_ + vᵧᵧᵧyyy_ + abs(q2[1]);\r\n        let q3 = qaq(q1, q2);\r\n        let q3_ = q1_ + q2_ + abs(q3[1]);\r\n        let q4 = qaq(vₓₓxx, vₓᵧxy);\r\n        let q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\r\n        let q5 = qaq(q4, vᵧᵧyy);\r\n        let q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\r\n        let q6 = qaq(q3, q5);\r\n        let q6_ = q3_ + q5_ + abs(q6[1]);\r\n        let q7 = qaq(vₓx, vᵧy);\r\n        let q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        let q8 = qaq(q7, v);\r\n        let q8_ = q7_ + v_ + abs(q8[1]);\r\n        let h = qaq(q6, q8);\r\n        let h_ = q6_ + q8_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (error_analysis_1.γγ3 * h_ < abs(flo_numerical_1.estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error still too high - let's go exact\r\n    {\r\n        // The below takes about 155 micro-seconds on a 1st gen i7 and Chrome 79\r\n        let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form3_3.getImplicitForm3Exact_(ps);\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // let h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        let xx = tp(x, x); // <= error free\r\n        let xxx = sce(x, xx);\r\n        let yy = tp(y, y); // <= error free\r\n        let yyy = sce(y, yy);\r\n        let xxy = sce(y, xx);\r\n        let xyy = sce(x, yy);\r\n        let xy = tp(x, y); // <= error free\r\n        let vₓₓₓxxx = epr(vₓₓₓ, xxx);\r\n        let vₓₓᵧxxy = epr(vₓₓᵧ, xxy);\r\n        let vₓᵧᵧxyy = epr(vₓᵧᵧ, xyy);\r\n        let vᵧᵧᵧyyy = epr(vᵧᵧᵧ, yyy);\r\n        let vₓₓxx = epr(vₓₓ, xx);\r\n        let vₓᵧxy = epr(vₓᵧ, xy);\r\n        let vᵧᵧyy = epr(vᵧᵧ, yy);\r\n        let vₓx = sce(x, vₓ);\r\n        let vᵧy = sce(y, vᵧ);\r\n        let q1 = fes(vₓₓₓxxx, vₓₓᵧxxy);\r\n        let q2 = fes(vₓᵧᵧxyy, vᵧᵧᵧyyy);\r\n        let q3 = fes(q1, q2);\r\n        let q4 = fes(vₓₓxx, vₓᵧxy);\r\n        let q5 = fes(q4, vᵧᵧyy);\r\n        let q6 = fes(q3, q5);\r\n        let q7 = fes(vₓx, vᵧy);\r\n        let q8 = fes(q7, v);\r\n        let h = fes(q6, q8);\r\n        return flo_numerical_1.sign(h) === 0; // <= calculation was exact\r\n    }\r\n}\r\n/**\r\n * Returns true if the given point is on the given quadratic bezier curve where\r\n * the parameter t is allowed to extend to +-infinity, i.e. t is an element of\r\n * [-inf, +inf], false otherwise.\r\n *\r\n * * Precondition: ps must be grid-aligned and have a maximum bitlength of 47.\r\n * (p may have any bitlength - no restrictions)\r\n */\r\nfunction isPointOnBezierExtension2(ps, p) {\r\n    let [x, y] = p;\r\n    //---- first pre-filter\r\n    {\r\n        let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = get_implicit_form2_1.getImplicitForm2(ps);\r\n        let _vₓₓ = abs(vₓₓ);\r\n        let _vₓᵧ = abs(vₓᵧ);\r\n        let _vᵧᵧ = abs(vᵧᵧ);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // let h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        let _x = abs(x);\r\n        let xx = x * x;\r\n        let _xx_ = xx;\r\n        let _y = abs(y);\r\n        let yy = y * y;\r\n        let _yy_ = yy;\r\n        let xy = x * y;\r\n        let _xy_ = abs(xy);\r\n        let vₓₓxx = vₓₓ * xx;\r\n        let vₓₓxx_ = (vₓₓ_ + _vₓₓ) * _xx_ + abs(vₓₓxx);\r\n        let vₓᵧxy = vₓᵧ * xy;\r\n        let vₓᵧxy_ = (vₓᵧ_ + _vₓᵧ) * _xy_ + abs(vₓᵧxy);\r\n        let vᵧᵧyy = vᵧᵧ * yy;\r\n        let vᵧᵧyy_ = (vᵧᵧ_ + _vᵧᵧ) * _yy_ + abs(vᵧᵧyy);\r\n        let vₓx = vₓ * x;\r\n        let vₓx_ = vₓ_ * _x + abs(vₓx);\r\n        let vᵧy = vᵧ * y;\r\n        let vᵧy_ = vᵧ_ * _y + abs(vᵧy);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //let h = \r\n        //    (\r\n        //      ((vₓₓxx + vₓᵧxy) + vᵧᵧyy) + \r\n        //      (vₓx + vᵧy)\r\n        //    ) + \r\n        //    v;\r\n        let q4 = vₓₓxx + vₓᵧxy;\r\n        let q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4);\r\n        let q5 = q4 + vᵧᵧyy;\r\n        let q5_ = q4_ + vᵧᵧyy_ + abs(q5);\r\n        let q7 = vₓx + vᵧy;\r\n        let q7_ = vₓx_ + vᵧy_ + abs(q7);\r\n        let q8 = q5 + q7;\r\n        let q8_ = q5_ + q7_ + abs(q8);\r\n        let h = q8 + v;\r\n        let h_ = q8_ + v_ + abs(h);\r\n        // if the error is not too high too discern h away from zero\r\n        if (error_analysis_1.γ1 * h_ < abs(h)) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error too high - let's try quad precision\r\n    {\r\n        let { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓ_, vᵧ_, v_ } } = get_implicit_form2_2.getImplicitForm2Quad(ps);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we're not.\r\n        // let h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        let _x = abs(x);\r\n        let xx = tp(x, x); // <= error free\r\n        let _y = abs(y);\r\n        let yy = tp(y, y); // <= error free\r\n        let xy = tp(x, y); // <= error free\r\n        let vₓₓxx = qmq(vₓₓ, xx);\r\n        let vₓₓxx_ = 2 * abs(vₓₓxx[1]);\r\n        let vₓᵧxy = qmq(vₓᵧ, xy);\r\n        let vₓᵧxy_ = 2 * abs(vₓᵧxy[1]);\r\n        let vᵧᵧyy = qmq(vᵧᵧ, yy);\r\n        let vᵧᵧyy_ = 2 * abs(vᵧᵧyy[1]);\r\n        let vₓx = qmd(x, vₓ);\r\n        let vₓx_ = vₓ_ * _x + abs(vₓx[1]);\r\n        let vᵧy = qmd(y, vᵧ);\r\n        let vᵧy_ = vᵧ_ * _y + abs(vᵧy[1]);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //let h = \r\n        //    (\r\n        //      ((vₓₓxx + vₓᵧxy) + vᵧᵧyy) + \r\n        //      (vₓx + vᵧy)\r\n        //    ) + \r\n        //    v;\r\n        let q4 = qaq(vₓₓxx, vₓᵧxy);\r\n        let q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\r\n        let q5 = qaq(q4, vᵧᵧyy);\r\n        let q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\r\n        let q7 = qaq(vₓx, vᵧy);\r\n        let q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        let q8 = qaq(q5, q7);\r\n        let q8_ = q5_ + q7_ + abs(q8[1]);\r\n        let h = qaq(q8, v);\r\n        let h_ = q8_ + v_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (error_analysis_1.γγ3 * h_ < abs(flo_numerical_1.estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error still too high - let's go exact\r\n    {\r\n        let { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = get_implicit_form2_3.getImplicitForm2Exact_(ps);\r\n        // h (say height) is the the result of evaluating the implicit equation; \r\n        // if it is 0 we are on the curve, else we're not.\r\n        // let h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        let xx = tp(x, x); // <= error free\r\n        let yy = tp(y, y); // <= error free\r\n        let xy = tp(x, y); // <= error free\r\n        let vₓₓxx = epr(vₓₓ, xx);\r\n        let vₓᵧxy = epr(vₓᵧ, xy);\r\n        let vᵧᵧyy = epr(vᵧᵧ, yy);\r\n        let vₓx = sce(x, vₓ);\r\n        let vᵧy = sce(y, vᵧ);\r\n        let q4 = fes(vₓₓxx, vₓᵧxy);\r\n        let q5 = fes(q4, vᵧᵧyy);\r\n        let q7 = fes(vₓx, vᵧy);\r\n        let q8 = fes(q7, v);\r\n        let h = fes(q5, q8);\r\n        return flo_numerical_1.sign(h) === 0; // <= calculation was exact\r\n    }\r\n}\r\n/**\r\n * Returns true if the given point is on the given line where\r\n * the parameter t is allowed to extend to +-infinity, i.e. t is an element of\r\n * [-inf, +inf], false otherwise.\r\n *\r\n * * Precondition: ps must be grid-aligned and have a maximum bitlength of 47.\r\n * (p may have any bitlength - no restrictions)\r\n * * there are many alternative implementations to this function, e.g. ccw, etc;\r\n * it is just kept for symmetry.\r\n * o\r\n */\r\nfunction isPointOnBezierExtension1(ps, p) {\r\n    let [x, y] = p;\r\n    //---- pre-filter - note all coefficients below vₓ, vᵧ, v are exact\r\n    let { coeffs: { vₓ, vᵧ, v } } = get_implicit_form1_1.getImplicitForm1Quad(ps);\r\n    // In the below a prefix underscore on a variable means absolute value, \r\n    // a postfix underscore means error bound (before multiplication by gamma).\r\n    // h (say height) is the the result of evaluating the implicit equation; if\r\n    // it is 0 we are on the curve, else we're not.\r\n    // let h = vₓ*x + vᵧ*y + v;\r\n    let vₓx = tp(x, vₓ); // <= error free\r\n    let vᵧy = tp(y, vᵧ);\r\n    // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n    //let h = (vₓx + vᵧy) + v;\r\n    let q7 = qaq(vₓx, vᵧy);\r\n    let q7_ = abs(q7[1]);\r\n    let h = qaq(q7, v);\r\n    let h_ = q7_ + abs(h[1]);\r\n    // if the error is not too high too discern h away from zero\r\n    if (error_analysis_1.γγ3 * h_ < abs(flo_numerical_1.estimate(h))) {\r\n        return false; // <-- prefilter applied\r\n    }\r\n    q7 = epr(vₓx, vᵧy);\r\n    h = fes(q7, v);\r\n    return flo_numerical_1.sign(h) === 0; // <= calculation was exact\r\n}\r\n/**\r\n * Returns true if the given point is on the given bezier curve where the\r\n * parameter t is allowed to extend to +-infinity, i.e. t is an element of\r\n * [-inf, +inf], false otherwise.\r\n *\r\n * * **precondition**: ps and p must be grid-aligned with a maximum bitlength of 47.\r\n * @param ps\r\n * @param p\r\n */\r\nfunction isPointOnBezierExtension(ps, p) {\r\n    if (ps.length === 4) {\r\n        return isPointOnBezierExtension3(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return isPointOnBezierExtension2(ps, p);\r\n    }\r\n    return isPointOnBezierExtension1(ps, p);\r\n}\r\nexports.isPointOnBezierExtension = isPointOnBezierExtension;\r\n//# sourceMappingURL=is-point-on-bezier-extension.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-dddxy.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-dddxy.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 3rd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x and y-coordinates.\r\n *\r\n * Note: this is a constant value and the same for all t-values and, in\r\n * particular, zero for a line or quadratic.\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n *\r\n * Bitlength: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === max shift === 6 (for cubics)\r\n * * max bitlength increase === max shift === 0 (for quadratics)\r\n * * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDddxy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * (x3 + 3 * (x1 - x2) - x0),\r\n            6 * (y3 + 3 * (y1 - y2) - y0)\r\n        ]; // max bitlength increase 6\r\n    }\r\n    else if (ps.length === 3 || ps.length === 2) {\r\n        return [0, 0];\r\n    }\r\n    // if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], then\r\n    // max(dddx)(t) <= 48*X for all t.\r\n}\r\nexports.getDddxy = getDddxy;\r\n//# sourceMappingURL=get-dddxy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-dddxy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-ddx.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-ddx.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x-coordinates.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 6 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdx(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            6 * (x3 + 3 * (x1 - x2) - x0),\r\n            6 * (x2 - 2 * x1 + x0) // t^0 - max bitlength increase 5\r\n        ];\r\n        // if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], then\r\n        // max(ddx)(t) <= 24*X for all t.\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            2 * (x2 - 2 * x1 + x0) // t^0 - max bitlength increase 3\r\n        ];\r\n        // if x0,x1,x2 <= X (for some X) and t is an element of [0,1], then\r\n        // max(ddx)(t) <= 8*X for all t.\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0];\r\n    }\r\n}\r\nexports.getDdx = getDdx;\r\n//# sourceMappingURL=get-ddx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-ddx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-ddxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-ddxy.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x-coordinates.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 6 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdxy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                6 * (x3 + 3 * (x1 - x2) - x0),\r\n                6 * (x2 - 2 * x1 + x0) // t^0 - max bitlength increase 5\r\n            ], [\r\n                6 * (y3 + 3 * (y1 - y2) - y0),\r\n                6 * (y2 - 2 * y1 + y0) // t^0 - max bitlength increase 5\r\n            ]];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                2 * (x2 - 2 * x1 + x0) // t^0 - max bitlength increase 3\r\n            ], [\r\n                2 * (y2 - 2 * y1 + y0) // t^0 - max bitlength increase 3\r\n            ]];\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [[0], [0]];\r\n    }\r\n}\r\nexports.getDdxy = getDdxy;\r\n//# sourceMappingURL=get-ddxy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-ddxy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-ddy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-ddy.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's y-coordinates.\r\n *\r\n * This function is memoized on its points parameter by object reference.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 6 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 0 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDdy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            6 * (y3 + 3 * (y1 - y2) - y0),\r\n            6 * (y2 - 2 * y1 + y0) // t^0 - max bitlength increase 5\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            2 * (y2 - 2 * y1 + y0) // t^0 - max bitlength increase 3\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        return [0];\r\n    }\r\n}\r\nexports.getDdy = getDdy;\r\n//# sourceMappingURL=get-ddy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-ddy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-dx.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-dx.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's x-coordinates.\r\n *\r\n * **bitlength**: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === max shift === 5 (for cubics - 5,5,3)\r\n * * max bitlength increase === max shift === 3 (for quadratics - 3,2)\r\n * * max bitlength increase === max shift === 1 (for lines - 1)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDx(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            3 * (x3 + 3 * (x1 - x2) - x0),\r\n            6 * (x2 - 2 * x1 + x0),\r\n            3 * (x1 - x0) // t^0 - max bitlength increase 3\r\n        ];\r\n        // if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], then\r\n        // max(dx)(t) <= 6*X for all t.\r\n        // A tight bound occurs when -x0,x1,-x2,x3 === X and t === 1.\r\n        // e.g. for X === 1,    max(dx)(t) === 6\r\n        //      for x === 1024, max(dx)(t) === 6*1024 === 6144\r\n    }\r\n    if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            2 * (x2 - 2 * x1 + x0),\r\n            2 * (x1 - x0),\r\n        ];\r\n        // if x0,x1,x2 <= X (for some X) and t is an element of [0,1], then\r\n        // max(dx)(t) <= 4*X for all t.\r\n    }\r\n    if (ps.length === 2) {\r\n        let [[x0,], [x1,]] = ps;\r\n        return [\r\n            x1 - x0,\r\n        ];\r\n        // if x0,x1 <= X (for some X) and t is an element of [0,1], then\r\n        // max(dx)(t) <= 2*X for all t.\r\n    }\r\n    throw new Error('The bezier curve must be of order 1, 2 or 3.');\r\n}\r\nexports.getDx = getDx;\r\n/**\r\n * Returns the exact derivative of the power basis representation of a line,\r\n * quadratic or cubic bezier's x-coordinates.\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDxExact(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            //3*x3 - 9*x2 + 9*x1 - 3*x0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoProduct(3, x3),\r\n                flo_numerical_1.twoProduct(-9, x2),\r\n                flo_numerical_1.twoProduct(9, x1),\r\n                flo_numerical_1.twoProduct(-3, x0)\r\n            ]),\r\n            //6*x2 - 12*x1 + 6*x0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoProduct(6, x2),\r\n                flo_numerical_1.twoProduct(-12, x1),\r\n                flo_numerical_1.twoProduct(6, x0)\r\n            ]),\r\n            //3*x1 - 3*x0\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoProduct(3, x1),\r\n                flo_numerical_1.twoProduct(-3, x0)\r\n            ])\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            //2*x2 - 4*x1 + 2*x0,\r\n            flo_numerical_1.calculateSum([\r\n                [2 * x2], [-4, x1], [2 * x0]\r\n            ]),\r\n            //2*x1 - 2*x0,\r\n            flo_numerical_1.fastExpansionSum([2 * x1], [-2, x0])\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        let [[x0,], [x1,]] = ps;\r\n        return [\r\n            //x1 - x0,\r\n            flo_numerical_1.twoDiff(x1, x0)\r\n        ];\r\n    }\r\n    throw new Error('The bezier curve must be of order 1, 2 or 3.');\r\n}\r\nexports.getDxExact = getDxExact;\r\n//# sourceMappingURL=get-dx.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-dx.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-dxy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-dxy.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's.\r\n *\r\n * **bitlength**: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === max shift === 5 (for cubics)\r\n * * max bitlength increase === max shift === 3 (for quadratics)\r\n * * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDxy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                3 * (x3 + 3 * (x1 - x2) - x0),\r\n                6 * (x2 - 2 * x1 + x0),\r\n                3 * (x1 - x0) // t^0 - max bitlength increase 3\r\n            ], [\r\n                3 * (y3 + 3 * (y1 - y2) - y0),\r\n                6 * (y2 - 2 * y1 + y0),\r\n                3 * (y1 - y0) // t^0 - max bitlength increase 3\r\n            ]];\r\n    }\r\n    if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                2 * (x2 - 2 * x1 + x0),\r\n                2 * (x1 - x0),\r\n            ], [\r\n                2 * (y2 - 2 * y1 + y0),\r\n                2 * (y1 - y0),\r\n            ]];\r\n    }\r\n    if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [[\r\n                x1 - x0,\r\n            ], [\r\n                y1 - y0,\r\n            ]];\r\n    }\r\n    throw new Error('The bezier curve must be of order 1, 2 or 3.');\r\n}\r\nexports.getDxy = getDxy;\r\n//# sourceMappingURL=get-dxy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-dxy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-dy.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-dy.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's y-coordinates.\r\n *\r\n * **bitlength**: If the coordinates of the control points are bit-aligned then\r\n * max bitlength increase === max shift === 5 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDy(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            3 * (y3 + 3 * (y1 - y2) - y0),\r\n            6 * (y2 - 2 * y1 + y0),\r\n            3 * (y1 - y0) // t^0 - max bitlength increase 3\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            2 * (y2 - 2 * y1 + y0),\r\n            2 * (y1 - y0),\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        let [[, y0], [, y1]] = ps;\r\n        return [\r\n            y1 - y0,\r\n        ];\r\n    }\r\n    throw new Error('The bezier curve must be of order 1, 2 or 3.');\r\n}\r\nexports.getDy = getDy;\r\n/**\r\n * Returns the derivative of the power basis representation of a line, quadratic\r\n * or cubic bezier's y-coordinates.\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 5 (for cubics)\r\n * max bitlength increase === max shift === 3 (for quadratics)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getDyExact(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            //3*y3 - 9*y2 + 9*y1 - 3*y0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoProduct(3, y3),\r\n                flo_numerical_1.twoProduct(-9, y2),\r\n                flo_numerical_1.twoProduct(9, y1),\r\n                flo_numerical_1.twoProduct(-3, y0)\r\n            ]),\r\n            //6*y2 - 12*y1 + 6*y0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoProduct(6, y2),\r\n                flo_numerical_1.twoProduct(-12, y1),\r\n                flo_numerical_1.twoProduct(6, y0)\r\n            ]),\r\n            //3*y1 - 3*y0\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoProduct(3, y1),\r\n                flo_numerical_1.twoProduct(-3, y0)\r\n            ])\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            //2*y2 - 4*y1 + 2*y0,\r\n            flo_numerical_1.calculateSum([\r\n                [2 * y2], [-4, y1], [2 * y0]\r\n            ]),\r\n            //2*y1 - 2*y0,\r\n            flo_numerical_1.fastExpansionSum([2 * y1], [-2, y0])\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        let [[, y0], [, y1]] = ps;\r\n        return [\r\n            //y1 - y0,\r\n            flo_numerical_1.twoDiff(y1, y0)\r\n        ];\r\n    }\r\n    throw new Error('The bezier curve must be of order 1, 2 or 3.');\r\n}\r\nexports.getDyExact = getDyExact;\r\n//# sourceMappingURL=get-dy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-dy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-x.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-x.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate power basis representation of a line, quadratic or\r\n * cubic bezier's x-coordinates.\r\n *\r\n * If certain preconditions are met (see below) it returns the exact result.\r\n *\r\n * Returns the power basis polynomial from highest power to lowest,\r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n *\r\n * Bitlength: If the coordinates of the control points are bit-aligned then\r\n * max bitlength increase === max shift === 4 (for cubics)\r\n * (due to 'multiplication' by 12 (3x 6x 3x) -> ceil(log2(12)) === 4\r\n * max bitlength increase === max shift === 2 (for quadratics)\r\n * (due to 'multiplication' by 4 (1x 2x 1x)  -> ceil(log2(4)) === 2\r\n * max bitlength increase === max shift === 1 (for lines)\r\n * (due to 'multiplication' by 4 (1x 1x) -> ceil(log2(2)) === 1\r\n *\r\n * @param ps An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getX(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            x3 + 3 * (x1 - x2) - x0,\r\n            3 * (x2 - 2 * x1 + x0),\r\n            3 * (x1 - x0),\r\n            x0,\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            x2 - 2 * x1 + x0,\r\n            2 * (x1 - x0),\r\n            x0,\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0,], [x1,]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            x0,\r\n        ];\r\n    }\r\n}\r\nexports.getX = getX;\r\nfunction getXExact(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0,], [x1,], [x2,], [x3,]] = ps;\r\n        return [\r\n            //x3 - 3*x2 + 3*x1 - x0,\r\n            flo_numerical_1.calculateSum([\r\n                [x3],\r\n                flo_numerical_1.twoSum(-2 * x2, -x2),\r\n                flo_numerical_1.twoSum(2 * x1, x1),\r\n                [-x0]\r\n            ]),\r\n            //3*x2 - 6*x1 + 3*x0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoSum(2 * x2, x2),\r\n                flo_numerical_1.twoSum(-4 * x1, -2 * x1),\r\n                flo_numerical_1.twoSum(2 * x0, x0),\r\n            ]),\r\n            //3*x1 - 3*x0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoSum(2 * x1, x1),\r\n                flo_numerical_1.twoSum(-2 * x0, -x0),\r\n            ]),\r\n            //x0\r\n            [x0]\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0,], [x1,], [x2,]] = ps;\r\n        return [\r\n            //x2 - 2*x1 + x0,\r\n            flo_numerical_1.calculateSum([[x2], [-2 * x1], [x0]]),\r\n            //2*x1 - 2*x0,\r\n            flo_numerical_1.twoDiff(2 * x1, 2 * x0),\r\n            //x0\r\n            [x0]\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0,], [x1,]] = ps;\r\n        return [\r\n            //x1 - x0,\r\n            flo_numerical_1.twoDiff(x1, x0),\r\n            //x0\r\n            [x0]\r\n        ];\r\n    }\r\n}\r\nexports.getXExact = getXExact;\r\n//# sourceMappingURL=get-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-x.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-xy.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-xy.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the approximate power basis representation of a line, quadratic or\r\n * cubic bezier.\r\n *\r\n * If certain preconditions are met (see below) it returns the exact result.\r\n *\r\n * Returns the power basis polynomial from highest power to lowest,\r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n *\r\n * Bitlength: If the coordinates of the control points are bit-aligned then\r\n * max bitlength increase === max shift === 4 (for cubics)\r\n * (due to 'multiplication' by 9 (3x 6x 3x)\r\n * max bitlength increase === max shift === 2 (for quadratics)\r\n * (due to 'multiplication' by 4 (1x 2x 1x)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n * (due to 'multiplication' by 4 (1x 1x)\r\n *\r\n * @param ps An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getXY(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                x3 + 3 * (x1 - x2) - x0,\r\n                3 * (x2 - 2 * x1 + x0),\r\n                3 * (x1 - x0),\r\n                x0,\r\n            ], [\r\n                y3 + 3 * (y1 - y2) - y0,\r\n                3 * (y2 - 2 * y1 + y0),\r\n                3 * (y1 - y0),\r\n                y0,\r\n            ]];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                x2 - 2 * x1 + x0,\r\n                2 * (x1 - x0),\r\n                x0,\r\n            ], [\r\n                y2 - 2 * y1 + y0,\r\n                2 * (y1 - y0),\r\n                y0,\r\n            ]];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [[\r\n                x1 - x0,\r\n                x0,\r\n            ], [\r\n                y1 - y0,\r\n                y0,\r\n            ]];\r\n    }\r\n}\r\nexports.getXY = getXY;\r\n//# sourceMappingURL=get-xy.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-xy.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/to-power-basis/get-y.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/to-power-basis/get-y.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate power basis representation of a line, quadratic or\r\n * cubic bezier's y-coordinates.\r\n *\r\n * If certain preconditions are met (see below) it returns the exact result.\r\n *\r\n * This function is memoized on its points parameter by object reference.\r\n *\r\n * Returns the power basis polynomial from highest power to lowest,\r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n *\r\n * Bitlength: If the coordinates of the control points are grid-aligned then\r\n * max bitlength increase === max shift === 4 (for cubics)\r\n * (due to 'multiplication' by 9 (3x 6x 3x)\r\n * max bitlength increase === max shift === 2 (for quadratics)\r\n * (due to 'multiplication' by 4 (1x 2x 1x)\r\n * max bitlength increase === max shift === 1 (for lines)\r\n * (due to 'multiplication' by 4 (1x 1x)\r\n *\r\n * @param ps An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n */\r\nfunction getY(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            y3 + 3 * (y1 - y2) - y0,\r\n            3 * (y2 - 2 * y1 + y0),\r\n            3 * (y1 - y0),\r\n            y0,\r\n        ];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            y2 - 2 * y1 + y0,\r\n            2 * (y1 - y0),\r\n            y0,\r\n        ];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[, y0], [, y1]] = ps;\r\n        return [\r\n            y1 - y0,\r\n            y0,\r\n        ];\r\n    }\r\n}\r\nexports.getY = getY;\r\nfunction getYExact(ps) {\r\n    if (ps.length === 4) {\r\n        let [[, y0], [, y1], [, y2], [, y3]] = ps;\r\n        return [\r\n            //y3 - 3*y2 + 3*y1 - y0,\r\n            flo_numerical_1.calculateSum([\r\n                [y3],\r\n                flo_numerical_1.twoSum(-2 * y2, -y2),\r\n                flo_numerical_1.twoSum(2 * y1, y1),\r\n                [-y0]\r\n            ]),\r\n            //3*y2 - 6*y1 + 3*y0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoSum(2 * y2, y2),\r\n                flo_numerical_1.twoSum(-4 * y1, -2 * y1),\r\n                flo_numerical_1.twoSum(2 * y0, y0),\r\n            ]),\r\n            //3*y1 - 3*y0,\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.twoSum(2 * y1, y1),\r\n                flo_numerical_1.twoSum(-2 * y0, -y0),\r\n            ]),\r\n            //y0\r\n            [y0]\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        let [[, y0], [, y1], [, y2]] = ps;\r\n        return [\r\n            //y2 - 2*y1 + y0,\r\n            flo_numerical_1.calculateSum([[y2], [-2 * y1], [y0]]),\r\n            //2*y1 - 2*y0,\r\n            flo_numerical_1.twoDiff(2 * y1, 2 * y0),\r\n            //y0\r\n            [y0]\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        let [[, y0], [, y1]] = ps;\r\n        return [\r\n            //y1 - y0,\r\n            flo_numerical_1.twoDiff(y1, y0),\r\n            //y0\r\n            [y0]\r\n        ];\r\n    }\r\n}\r\nexports.getYExact = getYExact;\r\n//# sourceMappingURL=get-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/to-power-basis/get-y.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/clone.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/clone.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns a clone of the given cubic bezier (with a different reference).\r\n * @param ps A cubic bezier given by its array of control points\r\n */\r\nfunction clone(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\r\n    }\r\n    else if (ps.length === 3) {\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[x0, y0], [x1, y1], [x2, y2]];\r\n    }\r\n    else if (ps.length === 2) {\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [[x0, y0], [x1, y1]];\r\n    }\r\n}\r\nexports.clone = clone;\r\n//# sourceMappingURL=clone.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/clone.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/cubic-to-quadratic.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/cubic-to-quadratic.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the best least squares quadratic bezier approximation to the given\r\n * cubic bezier.\r\n * * the two bezier endpoints differ in general\r\n * @param ps - A cubic bezier curve.\r\n */\r\nfunction cubicToQuadratic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [\r\n        [(19 / 20) * x0 + (3 / 20) * x1 + (-3 / 20) * x2 + (1 / 20) * x3,\r\n            (19 / 20) * y0 + (3 / 20) * y1 + (-3 / 20) * y2 + (1 / 20) * y3],\r\n        [(-1 / 4) * x0 + (3 / 4) * x1 + (3 / 4) * x2 + (-1 / 4) * x3,\r\n            (-1 / 4) * y0 + (3 / 4) * y1 + (3 / 4) * y2 + (-1 / 4) * y3],\r\n        [(1 / 20) * x0 + (-3 / 20) * x1 + (3 / 20) * x2 + (19 / 20) * x3,\r\n            (1 / 20) * y0 + (-3 / 20) * y1 + (3 / 20) * y2 + (19 / 20) * y3]\r\n    ];\r\n}\r\nexports.cubicToQuadratic = cubicToQuadratic;\r\n//# sourceMappingURL=cubic-to-quadratic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/cubic-to-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/linear-to-cubic.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/linear-to-cubic.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns a cubic bezier from the given line with evenly spaced control points.\r\n * @param l a 2d line represented by two points\r\n */\r\nfunction linearToCubic(ps) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let xInterval = (x1 - x0) / 3;\r\n    let yInterval = (y1 - y0) / 3;\r\n    return [\r\n        [x0, y0],\r\n        [x0 + xInterval, y0 + yInterval],\r\n        [x0 + xInterval * 2, y0 + yInterval * 2],\r\n        [x1, y1]\r\n    ];\r\n}\r\nexports.linearToCubic = linearToCubic;\r\n//# sourceMappingURL=linear-to-cubic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/degree-or-type/linear-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\r\n * bezier curves can always be represented by cubics - the converse is false.\r\n * @param ps a quadratic bezier curve.\r\n */\r\nfunction quadraticToCubic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\r\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\r\n        [x2, y2]\r\n    ];\r\n}\r\nexports.quadraticToCubic = quadraticToCubic;\r\n//# sourceMappingURL=quadratic-to-cubic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst linear_to_cubic_1 = __webpack_require__(/*! ./linear-to-cubic */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/linear-to-cubic.js\");\r\nconst quadratic_to_cubic_1 = __webpack_require__(/*! ./quadratic-to-cubic */ \"./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js\");\r\n/**\r\n * Returns a cubic bezier curve that is equivalent to the given linear or\r\n * quadratic bezier curve. Cubics are just returned unaltered.\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n */\r\nfunction toCubic(ps) {\r\n    if (ps.length === 2) { // Linear\r\n        return linear_to_cubic_1.linearToCubic(ps);\r\n    }\r\n    else if (ps.length === 3) { // Quadratic\r\n        return quadratic_to_cubic_1.quadraticToCubic(ps);\r\n    }\r\n    else if (ps.length === 4) { // Cubic\r\n        return ps;\r\n    }\r\n}\r\nexports.toCubic = toCubic;\r\n//# sourceMappingURL=to-cubic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/to-hybrid-quadratic.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/to-hybrid-quadratic.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the hybrid quadratic version of the given cubic bezier. For a\r\n * definition of hybrid quadratic bezier curves see this paper:\r\n * http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\r\n * @param ps a cubic bezier curve.\r\n * @returns An array of three quadratic bezier points where the\r\n * middle point is a 'hybrid' point represented as a line (itself represented\r\n * by two points (a linear bezier curve)) which can be evaluated at a different\r\n * t value (call it th). If evaluated at the same t value the result is the same\r\n * as evaluating the original cubic bezier at t. The set generated by evaluating\r\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\r\n * bound around the orginal cubic bezier curve. The length of the linear bezier\r\n * curve mentioned above is a measure of how closely the cubic can be\r\n * represented as a quadratic bezier curve.\r\n */\r\nfunction toHybridQuadratic(ps) {\r\n    if (ps.length === 4) {\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [\r\n                [(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\r\n                [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2] // evaluated at t\r\n            ],\r\n            [x3, y3] // evaluated at t\r\n        ];\r\n    }\r\n}\r\nexports.toHybridQuadratic = toHybridQuadratic;\r\n//# sourceMappingURL=to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/degree-or-type/to-hybrid-quadratic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/degree-or-type/to-quad-from-cubic.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/degree-or-type/to-quad-from-cubic.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns a quadratic closest to the given cubic bezier by taking the midpoint\r\n * of the moving line of the hybrid quadratic version of the cubic as the\r\n * new quadratics middle control point.\r\n * * the resulting quadratic will be exactly the cubic if the cubic is really\r\n * a quadratic in disguise and the bit-aligned bitlength of the coordinates of\r\n * the control points <= 52.\r\n * @param ps a cubic bezier curve.\r\n */\r\nfunction toQuadraticFromCubic(ps) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [\r\n            //[(3*(x1+x2) - (x0+x3)) / 4, \r\n            //(3*(y1+y2) - (y0+y3)) / 4]\r\n            flo_numerical_1.estimate(flo_numerical_1.expansionDiff(flo_numerical_1.scaleExpansion(flo_numerical_1.twoSum(x1 / 4, x2 / 4), 3), flo_numerical_1.twoSum(x0 / 4, x3 / 4))),\r\n            flo_numerical_1.estimate(flo_numerical_1.expansionDiff(flo_numerical_1.scaleExpansion(flo_numerical_1.twoSum(y1 / 4, y2 / 4), 3), flo_numerical_1.twoSum(y0 / 4, y3 / 4)))\r\n        ],\r\n        [x3, y3]\r\n    ];\r\n}\r\nexports.toQuadraticFromCubic = toQuadraticFromCubic;\r\n//# sourceMappingURL=to-quad-from-cubic.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/degree-or-type/to-quad-from-cubic.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/from-bezier-piece.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/from-bezier-piece.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_0_to_T_1 = __webpack_require__(/*! ./split-merge-clone/from-0-to-T */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-0-to-T.js\");\r\nconst from_T_to_1_1 = __webpack_require__(/*! ./split-merge-clone/from-T-to-1 */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-T-to-1.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * @param ps A bezier\r\n * @param tRange A t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = eval_de_casteljau_1.evalDeCasteljau(ps, tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return from_0_to_T_1.from0ToT(ps, tRange[1]);\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return from_T_to_1_1.fromTTo1(ps, tRange[0]);\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return from_0_to_T_1.from0ToT(from_T_to_1_1.fromTTo1(ps, tRange[0]), (tRange[1] - tRange[0]) / (1 - tRange[0]));\r\n}\r\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\r\n//# sourceMappingURL=from-bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/from-bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/get-hodograph.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/get-hodograph.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an approximation of the hodograph of the given bezier curve.\r\n * * **bitlength**: If the coordinates of the control points are bit-aligned then\r\n * * max bitlength increase === 3, max shift === 3 (for cubics)\r\n * * max bitlength increase === 1, max shift === 2 (for quadratics)\r\n * * max bitlength increase === 1, max shift === 1 (for lines)\r\n * @param ps An order 1, 2 or 3 bezier curve.\r\n */\r\nfunction getHodograph(ps) {\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [3 * (x1 - x0), 3 * (y1 - y0)],\r\n            [3 * (x2 - x1), 3 * (y2 - y1)],\r\n            [3 * (x3 - x2), 3 * (y3 - y2)]\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            [2 * (x1 - x0), 2 * (y1 - y0)],\r\n            [2 * (x2 - x1), 2 * (y2 - y1)]\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        // a line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            [x1 - x0, y1 - y0]\r\n        ];\r\n    }\r\n}\r\nexports.getHodograph = getHodograph;\r\n//# sourceMappingURL=get-hodograph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/get-hodograph.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/quad-to-polyline.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/quad-to-polyline.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_quad_flat_1 = __webpack_require__(/*! ../global-properties/type/is-quad-flat */ \"./node_modules/flo-bezier3/node/global-properties/type/is-quad-flat.js\");\r\nconst split_at_1 = __webpack_require__(/*! ./split-merge-clone/split-at */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js\");\r\n/**\r\n * Transforms the given quadratic bezier into a polyline approximation to within\r\n * a given tolerance.\r\n * @param ps A quadratic bezier curve given as an array of points.\r\n */\r\nfunction quadToPolyline(ps, tolerance) {\r\n    // A quad bezier has the following useful properties (Let the control\r\n    // points be labeled P0, P1 and P2 respectively and let the point at t = 0.5\r\n    // be labeled M1):\r\n    // -------------------------------------------------------------------------\r\n    // * At t = 0.5 P1 has its maximum influence of 0.5 and P0 and P2 each an \r\n    // influence of 0.25.\r\n    // * The tangent at t = 0.5 is given by P2 - P0.\r\n    // * The line implied by the tangent at t = 0.5 cuts the line segments P0-P1\r\n    // and P2-P1 in half. Lets call these points M0 and M2.\r\n    // * The polygon P0-M0-M2-P2 bounds the curve.\r\n    // * The curve can be cut into two quad bezier curves. \r\n    // * If it is cut at t = 0.5, i.e. at M1 so that we have two quad beziers \r\n    // defined by the triangles Q1 = P0-M0-M1 and Q2 = M0-M2-P2 then both \r\n    // the interior angles at P0 and P2 are < 90 degrees (acute). Lets call such\r\n    // a quad acute, otherwise obtuse.\r\n    // * If we split an obtuse quad at t = 0.5 then the resulting quads are both\r\n    // acute.\r\n    // * Acute quads is such that the point at t = 0.5, i.e. at M1) is the \r\n    // furthest away from the line P0-P2.\r\n    // Note: In our algorithm the above property can be used to measure the \r\n    // flatness of the quad reliably.\r\n    // The algorithm: q: quad => lines[] such that the Hausdorff distance \r\n    // between the polyline and the quad < tolerance.\r\n    // Strategy: Use linked list for polyline - makes splitting easier\r\n    // -------------------------------------------------------------------------\r\n    // quad obtuse ? \r\n    //   no  : Push the quad onto the stack\r\n    //   yes : Split the quad at t = 0.5 and push both halves onto the stack\r\n    // Loop while stack not empty\r\n    //   pop from stack => q\r\n    //   d <= calculate distance from t = 0.5 to line p0-p2\r\n    //   tolerance < tol ?\r\n    //     yes : do nothing\r\n    //     no  : split quad at t = 0.5 and push both halves onto the stack\r\n    // Loop end\r\n    // Stack with nodes still to be checked\r\n    let stack = [];\r\n    // Polyline linked list\r\n    let head = {\r\n        ps,\r\n        prev: undefined,\r\n        next: undefined\r\n    };\r\n    stack.push(head);\r\n    while (stack.length) {\r\n        let node = stack.pop();\r\n        if (is_quad_flat_1.isQuadFlat(node.ps, tolerance)) {\r\n            continue;\r\n        }\r\n        let quads = split_at_1.splitAt(node.ps, 0.5);\r\n        let prev = node.prev;\r\n        let next = node.next;\r\n        let node1 = {\r\n            ps: quads[0],\r\n            prev,\r\n            next: undefined // to be set below\r\n        };\r\n        let node2 = {\r\n            ps: quads[1],\r\n            prev: undefined,\r\n            next\r\n        };\r\n        node1.next = node2;\r\n        node2.prev = node1;\r\n        if (prev) {\r\n            prev.next = node1;\r\n        }\r\n        if (next) {\r\n            next.prev = node2;\r\n        }\r\n        if (head === node) {\r\n            head = node1;\r\n        }\r\n        stack.push(node1);\r\n        stack.push(node2);\r\n    }\r\n    let linePs = [];\r\n    let node = head;\r\n    linePs.push(head.ps[0]);\r\n    while (node) {\r\n        linePs.push(node.ps[2]);\r\n        node = node.next;\r\n    }\r\n    return linePs;\r\n}\r\nexports.quadToPolyline = quadToPolyline;\r\n//# sourceMappingURL=quad-to-polyline.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/quad-to-polyline.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/reverse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/reverse.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the given points (e.g. bezier) in reverse order.\r\n * @param ps\r\n */\r\nfunction reverse(ps) {\r\n    return ps.slice().reverse();\r\n}\r\nexports.reverse = reverse;\r\n//# sourceMappingURL=reverse.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/reverse.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-0-to-T.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-0-to-T.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js\");\r\n/**\r\n * Returns an order 1, 2 or 3 bezier curve that starts at the given curve's t=0\r\n * and ends at the given t parameter.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * and η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the resultant bezier should end\r\n */\r\nfunction from0ToT(ps, t) {\r\n    return split_at_1.splitAt(ps, t)[0];\r\n}\r\nexports.from0ToT = from0ToT;\r\n//# sourceMappingURL=from-0-to-T.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-0-to-T.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-T-to-1.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-T-to-1.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js\");\r\n/**\r\n * Returns an order 1, 2 or 3 bezier curve that starts at the given t parameter\r\n * and ends at t=1.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t - The t parameter where the resultant bezier should start\r\n */\r\nfunction fromTTo1(ps, t) {\r\n    return split_at_1.splitAt(ps, t)[1];\r\n}\r\nexports.fromTTo1 = fromTTo1;\r\n//# sourceMappingURL=from-T-to-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-T-to-1.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/evaluate */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/evaluate.js\");\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js\");\r\nconst eval_de_casteljau_1 = __webpack_require__(/*! ../../local-properties-at-t/t-to-xy/eval-de-casteljau */ \"./node_modules/flo-bezier3/node/local-properties-at-t/t-to-xy/eval-de-casteljau.js\");\r\n/**\r\n * Returns a bezier curve that starts and ends at the given t parameters.\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (for a cubic), b_k are the control\r\n * points and η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t1 The t parameter where the resultant bezier should start\r\n * @param t2 The t parameter where the resultant bezier should end\r\n */\r\nfunction fromTo(ps) {\r\n    return function (t1, t2) {\r\n        let reverse = t1 > t2;\r\n        if (t1 > t2) {\r\n            [t1, t2] = [t2, t1];\r\n        }\r\n        let ps_;\r\n        if (t1 === 0 && t2 === 1) {\r\n            ps_ = ps;\r\n        }\r\n        else if (t1 === 0) {\r\n            ps_ = split_at_1.splitAt(ps, t2)[0];\r\n        }\r\n        else if (t2 === 1) {\r\n            ps_ = split_at_1.splitAt(ps, t1)[1];\r\n        }\r\n        else if (t1 === t2) {\r\n            // Degenerate case\r\n            let p = eval_de_casteljau_1.evalDeCasteljau(ps, t1);\r\n            if (ps.length === 2) {\r\n                return [p, p];\r\n            }\r\n            if (ps.length === 3) {\r\n                return [p, p, p];\r\n            }\r\n            if (ps.length === 4) {\r\n                return [p, p, p, p];\r\n            }\r\n        }\r\n        else {\r\n            ps_ = split_at_1.splitAt(split_at_1.splitAt(ps, t1)[1], (t2 - t1) / (1 - t1))[0];\r\n        }\r\n        return reverse ? ps_.slice().reverse() : ps_;\r\n    };\r\n}\r\nexports.fromTo = fromTo;\r\n/**\r\n * Returns a bezier curve that starts at the given curve and ends at the\r\n * given t parameter. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (for a cubic), b_k are the control\r\n * points and η is Number.EPSILON.\r\n * @param ps - A cubic bezier curve\r\n * @param t1 - The t parameter where the resultant bezier should start\r\n * @param t2 - The t parameter where the resultant bezier should end\r\n */\r\nfunction fromToPrecise(ps) {\r\n    return function (t1, t2) {\r\n        let reverse = t1 > t2;\r\n        if (t1 > t2) {\r\n            [t1, t2] = [t2, t1];\r\n        }\r\n        let ps_;\r\n        if (t1 === 0 && t2 === 1) {\r\n            ps_ = ps;\r\n        }\r\n        else if (t1 === 0) {\r\n            ps_ = split_at_1.splitAtPrecise(ps, t2)[0];\r\n        }\r\n        else if (t2 === 1) {\r\n            ps_ = split_at_1.splitAtPrecise(ps, t1)[1];\r\n        }\r\n        else if (t1 === t2) {\r\n            // Degenerate case\r\n            let p = eval_de_casteljau_1.evalDeCasteljau(ps, t1);\r\n            if (ps.length === 2) {\r\n                return [p, p];\r\n            }\r\n            if (ps.length === 3) {\r\n                return [p, p, p];\r\n            }\r\n            if (ps.length === 4) {\r\n                return [p, p, p, p];\r\n            }\r\n        }\r\n        else {\r\n            ps_ = split_at_1.splitAtPrecise(split_at_1.splitAtPrecise(ps, t1)[1], (t2 - t1) / (1 - t1))[0];\r\n        }\r\n        return reverse ? ps_.slice().reverse() : ps_;\r\n    };\r\n}\r\nexports.fromToPrecise = fromToPrecise;\r\n// TODO - currently the bezier returned is exact, but not exactly according\r\n// to the given ts due to division\r\nfunction fromToExact(ps) {\r\n    return function (t1, t2) {\r\n        if (t1 === 0 && t2 === 1) {\r\n            return ps;\r\n        }\r\n        else if (t1 === 0) {\r\n            return split_at_1.splitAtExact(ps, t2)[0];\r\n        }\r\n        else if (t2 === 1) {\r\n            return split_at_1.splitAtExact(ps, t1)[1];\r\n        }\r\n        else if (t1 === t2) {\r\n            // Degenerate case\r\n            let p = evaluate_1.expEvaluateExact(ps, t1);\r\n            if (ps.length === 2) {\r\n                return [p, p];\r\n            }\r\n            if (ps.length === 3) {\r\n                return [p, p, p];\r\n            }\r\n            if (ps.length === 4) {\r\n                return [p, p, p, p];\r\n            }\r\n        }\r\n        else {\r\n            return split_at_1.splitAtExact(split_at_1.splitAtExact(ps, t1)[1], (t2 - t1) / (1 - t1))[0];\r\n        }\r\n    };\r\n}\r\nexports.fromToExact = fromToExact;\r\n//# sourceMappingURL=from-to.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nlet splitAtFs = [splitLineAt, splitQuadAt, splitCubicAt];\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n * @param t The curve parameter\r\n */\r\nfunction splitAt(ps, t) {\r\n    return splitAtFs[ps.length - 2](ps, t);\r\n}\r\nexports.splitAt = splitAt;\r\nlet splitAtPreciseFs = [\r\n    splitLineAtPrecise,\r\n    splitQuadAtPrecise,\r\n    splitCubicAtPrecise\r\n];\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n *\r\n * The result is precise, i.e. each returned coordinate is rounded to the\r\n * nearest ulp (unit in the last place)\r\n *\r\n * @param ps An order 1, 2 or 3 bezier curve\r\n * @param t The curve parameter\r\n */\r\nfunction splitAtPrecise(ps, t) {\r\n    return splitAtPreciseFs[ps.length - 2](ps, t);\r\n}\r\nexports.splitAtPrecise = splitAtPrecise;\r\nlet splitAtExactFs = [\r\n    splitLineAtExact,\r\n    splitQuadAtExact,\r\n    splitCubicAtExact\r\n];\r\n// TODO - currently the bezier returned is exact, but not exactly according\r\n// to the given ts due to division\r\nfunction splitAtExact(ps, t) {\r\n    return splitAtExactFs[ps.length - 2](ps, t);\r\n}\r\nexports.splitAtExact = splitAtExact;\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * and η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        x3 * Math.pow(t, 3) + 3 * x2 * s * Math.pow(t, 2) + 3 * x1 * Math.pow(s, 2) * t + x0 * Math.pow(s, 3),\r\n        y3 * Math.pow(t, 3) + 3 * y2 * s * Math.pow(t, 2) + 3 * y1 * Math.pow(s, 2) * t + y0 * Math.pow(s, 3)\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [x1 * t + x0 * s,\r\n            y1 * t + y0 * s],\r\n        [x2 * Math.pow(t, 2) + 2 * x1 * s * t + x0 * Math.pow(s, 2),\r\n            y2 * Math.pow(t, 2) + 2 * y1 * s * t + y0 * Math.pow(s, 2)],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x3 * Math.pow(t, 2) + 2 * x2 * t * s + x1 * Math.pow(s, 2),\r\n            y3 * Math.pow(t, 2) + 2 * y2 * t * s + y1 * Math.pow(s, 2)],\r\n        [x3 * t + x2 * s,\r\n            y3 * t + y2 * s],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitCubicAtExact(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let s3 = flo_numerical_1.scaleExpansion(s2, s);\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let t3 = flo_numerical_1.scaleExpansion(t2, t);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    let st2 = flo_numerical_1.scaleExpansion(t2, s);\r\n    let s2t = flo_numerical_1.scaleExpansion(s2, t);\r\n    /** The split point */\r\n    let p = [\r\n        //x3*t**3 + 3*x2*s*t**2 + 3*x1*s**2*t + x0*s**3,\r\n        //y3*t**3 + 3*y2*s*t**2 + 3*y1*s**2*t + y0*s**3\r\n        flo_numerical_1.calculateSum([\r\n            flo_numerical_1.expansionProduct(t3, x3),\r\n            flo_numerical_1.expansionProduct(st2, flo_numerical_1.scaleExpansion(x2, 3)),\r\n            flo_numerical_1.expansionProduct(s2t, flo_numerical_1.scaleExpansion(x1, 3)),\r\n            flo_numerical_1.expansionProduct(s3, x0)\r\n        ]),\r\n        flo_numerical_1.calculateSum([\r\n            flo_numerical_1.expansionProduct(t3, y3),\r\n            flo_numerical_1.expansionProduct(st2, flo_numerical_1.scaleExpansion(y2, 3)),\r\n            flo_numerical_1.expansionProduct(s2t, flo_numerical_1.scaleExpansion(y1, 3)),\r\n            flo_numerical_1.expansionProduct(s3, y0)\r\n        ])\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [\r\n            //x1*t + x0*s,\r\n            //y1*t + y0*s\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(x1, t), flo_numerical_1.scaleExpansion(x0, s)),\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(y1, t), flo_numerical_1.scaleExpansion(y0, s))\r\n        ],\r\n        [\r\n            //x2*t**2 + 2*x1*s*t + x0*s**2, \r\n            //y2*t**2 + 2*y1*s*t + y0*s**2\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.expansionProduct(t2, x2),\r\n                flo_numerical_1.expansionProduct(st, flo_numerical_1.scaleExpansion(x1, 2)),\r\n                flo_numerical_1.expansionProduct(s2, x0)\r\n            ]),\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.expansionProduct(t2, y2),\r\n                flo_numerical_1.expansionProduct(st, flo_numerical_1.scaleExpansion(y1, 2)),\r\n                flo_numerical_1.expansionProduct(s2, y0)\r\n            ])\r\n        ],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [\r\n            //x3*t**2 + 2*x2*t*s + x1*s**2, \r\n            //y3*t**2 + 2*y2*t*s + y1*s**2\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.expansionProduct(t2, x3),\r\n                flo_numerical_1.expansionProduct(st, flo_numerical_1.scaleExpansion(x2, 2)),\r\n                flo_numerical_1.expansionProduct(s2, x1)\r\n            ]),\r\n            flo_numerical_1.calculateSum([\r\n                flo_numerical_1.expansionProduct(t2, y3),\r\n                flo_numerical_1.expansionProduct(st, flo_numerical_1.scaleExpansion(y2, 2)),\r\n                flo_numerical_1.expansionProduct(s2, y1)\r\n            ])\r\n        ],\r\n        [\r\n            //x3*t + x2*s, \r\n            //y3*t + y2*s\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(x3, t), flo_numerical_1.scaleExpansion(x2, s)),\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(y3, t), flo_numerical_1.scaleExpansion(y2, s)),\r\n        ],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * The result is precise, i.e. each returned coordinate is rounded to the\r\n * nearest ulp (unit in the last place)\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAtPrecise(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let s3 = flo_numerical_1.scaleExpansion(s2, s);\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let t3 = flo_numerical_1.scaleExpansion(t2, t);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    let st2 = flo_numerical_1.scaleExpansion(t2, s);\r\n    let s2t = flo_numerical_1.scaleExpansion(s2, t);\r\n    /** The split point */\r\n    let p = [\r\n        //x3*t**3 + 3*x2*s*t**2 + 3*x1*s**2*t + x0*s**3,\r\n        //y3*t**3 + 3*y2*s*t**2 + 3*y1*s**2*t + y0*s**3\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(t3, x3),\r\n            flo_numerical_1.scaleExpansion(st2, 3 * x2),\r\n            flo_numerical_1.scaleExpansion(s2t, 3 * x1),\r\n            flo_numerical_1.scaleExpansion(s3, x0)\r\n        ])),\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(t3, y3),\r\n            flo_numerical_1.scaleExpansion(st2, 3 * y2),\r\n            flo_numerical_1.scaleExpansion(s2t, 3 * y1),\r\n            flo_numerical_1.scaleExpansion(s3, y0)\r\n        ]))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [\r\n            //x1*t + x0*s,\r\n            //y1*t + y0*s\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x1, t), flo_numerical_1.twoProduct(x0, s))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y1, t), flo_numerical_1.twoProduct(y0, s)))\r\n        ],\r\n        [\r\n            //x2*t**2 + 2*x1*s*t + x0*s**2, \r\n            //y2*t**2 + 2*y1*s*t + y0*s**2\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, x2),\r\n                flo_numerical_1.scaleExpansion(st, 2 * x1),\r\n                flo_numerical_1.scaleExpansion(s2, x0)\r\n            ])),\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, y2),\r\n                flo_numerical_1.scaleExpansion(st, 2 * y1),\r\n                flo_numerical_1.scaleExpansion(s2, y0)\r\n            ]))\r\n        ],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [\r\n            //x3*t**2 + 2*x2*t*s + x1*s**2, \r\n            //y3*t**2 + 2*y2*t*s + y1*s**2\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, x3),\r\n                flo_numerical_1.scaleExpansion(st, 2 * x2),\r\n                flo_numerical_1.scaleExpansion(s2, x1)\r\n            ])),\r\n            flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n                flo_numerical_1.scaleExpansion(t2, y3),\r\n                flo_numerical_1.scaleExpansion(st, 2 * y2),\r\n                flo_numerical_1.scaleExpansion(s2, y1)\r\n            ]))\r\n        ],\r\n        [\r\n            //x3*t + x2*s, \r\n            //y3*t + y2*s\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x3, t), flo_numerical_1.twoProduct(x2, s))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y3, t), flo_numerical_1.twoProduct(y2, s))),\r\n        ],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2),\r\n        y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2)\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [x0 * s + x1 * t,\r\n            y0 * s + y1 * t],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1 * s + x2 * t,\r\n            y1 * s + y2 * t],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAtExact(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    /** The split point */\r\n    let p = [\r\n        //x0*s**2 + 2*x1*s*t + x2*t**2,\r\n        //y0*s**2 + 2*y1*s*t + y2*t**2\r\n        flo_numerical_1.calculateSum([\r\n            flo_numerical_1.expansionProduct(s2, x0),\r\n            flo_numerical_1.expansionProduct(st, flo_numerical_1.scaleExpansion(x1, 2)),\r\n            flo_numerical_1.expansionProduct(t2, x2)\r\n        ]),\r\n        flo_numerical_1.calculateSum([\r\n            flo_numerical_1.expansionProduct(s2, y0),\r\n            flo_numerical_1.expansionProduct(st, flo_numerical_1.scaleExpansion(y1, 2)),\r\n            flo_numerical_1.expansionProduct(t2, y2)\r\n        ])\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [\r\n            //x0*s + x1*t, \r\n            //y0*s + y1*t\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(x0, s), flo_numerical_1.scaleExpansion(x1, t)),\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(y0, s), flo_numerical_1.scaleExpansion(y1, t)),\r\n        ],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [\r\n            //x1*s + x2*t, \r\n            //y1*s + y2*t\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(x1, s), flo_numerical_1.scaleExpansion(x2, t)),\r\n            flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(y1, s), flo_numerical_1.scaleExpansion(y2, t)),\r\n        ],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n/**\r\n *\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitQuadAtPrecise(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = flo_numerical_1.twoProduct(t, t);\r\n    let s2 = flo_numerical_1.twoProduct(s, s);\r\n    let st = flo_numerical_1.twoProduct(s, t);\r\n    /** The split point */\r\n    let p = [\r\n        //x0*s**2 + 2*x1*s*t + x2*t**2,\r\n        //y0*s**2 + 2*y1*s*t + y2*t**2\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s2, x0),\r\n            flo_numerical_1.scaleExpansion(st, 2 * x1),\r\n            flo_numerical_1.scaleExpansion(t2, x2)\r\n        ])),\r\n        flo_numerical_1.estimate(flo_numerical_1.calculateSum([\r\n            flo_numerical_1.scaleExpansion(s2, y0),\r\n            flo_numerical_1.scaleExpansion(st, 2 * y1),\r\n            flo_numerical_1.scaleExpansion(t2, y2)\r\n        ]))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [\r\n            //x0*s + x1*t, \r\n            //y0*s + y1*t\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x0, s), flo_numerical_1.twoProduct(x1, t))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y0, s), flo_numerical_1.twoProduct(y1, t))),\r\n        ],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [\r\n            //x1*s + x2*t, \r\n            //y1*s + y2*t\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(x1, s), flo_numerical_1.twoProduct(x2, t))),\r\n            flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(y1, s), flo_numerical_1.twoProduct(y2, t))),\r\n        ],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAtExact(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        //s*x0 + t*x1,\r\n        //s*y0 + t*y1\r\n        flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(x0, s), flo_numerical_1.scaleExpansion(x1, t)),\r\n        flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion(y0, s), flo_numerical_1.scaleExpansion(y1, t))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n/**\r\n *\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitLineAtPrecise(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        //s*x0 + t*x1,\r\n        //s*y0 + t*y1\r\n        flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(s, x0), flo_numerical_1.twoProduct(t, x1))),\r\n        flo_numerical_1.estimate(flo_numerical_1.fastExpansionSum(flo_numerical_1.twoProduct(s, y0), flo_numerical_1.twoProduct(t, y1)))\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-at.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-curvature-and-length.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-curvature-and-length.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js\");\r\nconst length_upper_bound_1 = __webpack_require__(/*! ../../global-properties/length/length-upper-bound */ \"./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter\r\n * (t) values) such that each piece is flat within a given tolerance given by\r\n * maxFlatness and maxLength.\r\n * @param ps\r\n * @param maxFlatness\r\n * @param maxLength\r\n */\r\nfunction splitByCurvatureAndLength(ps, maxFlatness = 1.001, maxLength = 10) {\r\n    let ts = [0, 1]; // include endpoints\r\n    let tStack = [[0, 1]];\r\n    let fromTo_ = from_to_1.fromTo(ps);\r\n    while (tStack.length) {\r\n        let ts_ = tStack.pop();\r\n        let ps_ = fromTo_(ts_[0], ts_[1]);\r\n        let l1 = length_upper_bound_1.lengthUpperBound(ps_);\r\n        let l2 = flo_vector2d_1.distanceBetween(ps_[0], ps_[ps_.length - 1]);\r\n        let flatness_ = 1 + (l1 / l2 - 1) * (l1 / maxLength);\r\n        if (flatness_ > maxFlatness) {\r\n            let t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\nexports.splitByCurvatureAndLength = splitByCurvatureAndLength;\r\n//# sourceMappingURL=split-by-curvature-and-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-curvature-and-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curvature.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curvature.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js\");\r\nconst flatness_1 = __webpack_require__(/*! ../../global-properties/flatness */ \"./node_modules/flo-bezier3/node/global-properties/flatness.js\");\r\n/**\r\n * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter\r\n * (t) values) such that each piece is flat within a given tolerance given by\r\n * the flatness function.\r\n * @param ps\r\n * @param tolerance Maximum tolerance (must be > 1) for flatness measure.\r\n */\r\nfunction splitByMaxCurvature(ps, tolerance = 1.1) {\r\n    let ts = [0, 1]; // include endpoints\r\n    let tStack = [[0, 1]];\r\n    let fromTo_ = from_to_1.fromTo(ps);\r\n    while (tStack.length) {\r\n        let ts_ = tStack.pop();\r\n        let ps_ = fromTo_(ts_[0], ts_[1]);\r\n        //lengthUpperBound(ps) / distanceBetween(ps[0], ps[ps.length-1])\r\n        if (flatness_1.flatness(ps_) > tolerance) {\r\n            let t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\nexports.splitByMaxCurvature = splitByMaxCurvature;\r\n//# sourceMappingURL=split-by-max-curvature.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curvature.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curve-length.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curve-length.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst length_upper_bound_1 = __webpack_require__(/*! ../../global-properties/length/length-upper-bound */ \"./node_modules/flo-bezier3/node/global-properties/length/length-upper-bound.js\");\r\nconst from_to_1 = __webpack_require__(/*! ./from-to */ \"./node_modules/flo-bezier3/node/transformation/split-merge-clone/from-to.js\");\r\n/**\r\n * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter\r\n * (t) values) such that the longest curve length is guaranteed to be lower than\r\n * the given max length.\r\n * @param ps\r\n * @param maxLength\r\n */\r\nfunction splitByMaxCurveLength(ps, maxLength) {\r\n    let ts = [0, 1]; // include endpoints\r\n    let tStack = [[0, 1]];\r\n    let fromTo_ = from_to_1.fromTo(ps);\r\n    while (tStack.length) {\r\n        let ts_ = tStack.pop();\r\n        let ps_ = fromTo_(ts_[0], ts_[1]);\r\n        if (length_upper_bound_1.lengthUpperBound(ps_) > maxLength) {\r\n            let t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\nexports.splitByMaxCurveLength = splitByMaxCurveLength;\r\n//# sourceMappingURL=split-by-max-curve-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/split-merge-clone/split-by-max-curve-length.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/to-estimation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/to-estimation.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nfunction toEstimation(ps) {\r\n    return ps.map(p => p.map(c => flo_numerical_1.estimate(c)));\r\n}\r\nexports.toEstimation = toEstimation;\r\n//# sourceMappingURL=to-estimation.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/to-estimation.js?");

/***/ }),

/***/ "./node_modules/flo-bezier3/node/transformation/to-expansion.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-bezier3/node/transformation/to-expansion.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction toExpansion(ps) {\r\n    return ps.map(p => p.map(c => [c]));\r\n}\r\nexports.toExpansion = toExpansion;\r\n//# sourceMappingURL=to-expansion.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-bezier3/node/transformation/to-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst are_boxes_intersecting_1 = __webpack_require__(/*! ../sweep-line/are-boxes-intersecting */ \"./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js\");\r\nfunction areContainersIntersecting(container1, container2) {\r\n    return are_boxes_intersecting_1.areBoxesIntersecting(true)(container1.box, container2.box);\r\n}\r\nexports.areContainersIntersecting = areContainersIntersecting;\r\n//# sourceMappingURL=are-containers-intersecting.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_in_outs_via_sides_1 = __webpack_require__(/*! ./get-in-outs-via-sides/get-in-outs-via-sides */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js\");\r\nconst get_in_outs_via_crossing_1 = __webpack_require__(/*! ./get-in-outs-via-crossing/get-in-outs-via-crossing */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js\");\r\n/**\r\n * * **warning** ioIdx will be modified by this function\r\n * @param container\r\n * @param ioIdx\r\n */\r\nfunction getContainerInOuts(container, ioIdx) {\r\n    // We check one X for each curve with an intersection within this container\r\n    let xs = container.xs;\r\n    // Check nature of Xs. If Xs is the very common case where two curves cross\r\n    // we can use a faster check. Also in the bit less common case where all\r\n    // curves are joining at an interface we can do a fast ccw (the ccw part\r\n    // has not been implemented yet).\r\n    if (xs.length === 2) {\r\n        if (xs[0].x.kind === 1 && xs[1].x.kind === 1 &&\r\n            xs[0].x.ri.multiplicity % 2 === 1 && xs[1].x.ri.multiplicity % 2 === 1) {\r\n            return get_in_outs_via_crossing_1.getInOutsViaCrossing(container, ioIdx);\r\n        }\r\n    }\r\n    return get_in_outs_via_sides_1.getInOutsViaSides(container, ioIdx);\r\n}\r\nexports.getContainerInOuts = getContainerInOuts;\r\n//# sourceMappingURL=get-container-in-outs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_in_outs_via_sides_1 = __webpack_require__(/*! ../get-in-outs-via-sides/get-in-outs-via-sides */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the incoming / outgoing curves (as InOuts) for the given container.\r\n * @param container\r\n * @param ioIdx\r\n */\r\nfunction getInOutsViaCrossing(container, ioIdx) {\r\n    let xs = container.xs;\r\n    let inOuts = [];\r\n    let x1 = xs[0];\r\n    let x2 = xs[1];\r\n    let ps1 = x1.curve.ps;\r\n    let ps2 = x2.curve.ps;\r\n    let p = flo_bezier3_1.evalDeCasteljau(ps1, x1.x.ri.tS);\r\n    let t1S = x1.x.ri.tS;\r\n    let t1E = x1.x.ri.tE;\r\n    let t2S = x2.x.ri.tS;\r\n    let t2E = x2.x.ri.tE;\r\n    let v1s;\r\n    let v2s;\r\n    if (ps1.length === 4 || ps1.length === 3) {\r\n        // cubic => hodograph is a parabola\r\n        // quadratic => hodograph is a line (we still get the box, but in future maybe we can do better)\r\n        let h1 = flo_bezier3_1.getHodograph(ps1); // <= cubic: 50 bit-aligned => exact, quadratic: 52 bit-aligned => exact\r\n        v1s = flo_bezier3_1.getIntervalBox(h1, [t1S, t1E]);\r\n    }\r\n    else if (ps1.length === 2) {\r\n        // line => hodograph is a fixed point\r\n        v1s = flo_bezier3_1.getHodograph(ps1); // <= 52 bit-aligned => exact\r\n    }\r\n    if (ps2.length === 4 || ps2.length === 3) {\r\n        // cubic => hodograph is a parabola\r\n        // quadratic => hodograph is a line (we still get the box, but in future maybe we can do better)\r\n        let h2 = flo_bezier3_1.getHodograph(ps2); // <= cubic: 50 bit-aligned => exact, quadratic: 52 bit-aligned => exact\r\n        v2s = flo_bezier3_1.getIntervalBox(h2, [t2S, t2E]);\r\n    }\r\n    else if (ps2.length === 2) {\r\n        // line => hodograph is a fixed point\r\n        v2s = flo_bezier3_1.getHodograph(ps2); // <= 52 bit-aligned => exact\r\n    }\r\n    // possible configurations: (up to cyclic permutation)\r\n    // config1: i1 o2 o1 i2 ==== i2 i1 o2 o1 ==== etc.\r\n    // config2: i1 i2 o1 o2 ==== o2 i1 i2 o1 ==== etc.\r\n    let cSign;\r\n    // TODO - investigate faster method by finding and using the 2 extreme points only\r\n    for (let i = 0; i < v1s.length; i++) {\r\n        for (let j = 0; j < v2s.length; j++) {\r\n            // we use orient2d below since it is completely robust (cross is not)\r\n            //let c = Math.sign(cross(v1s[i],v2s[j]));\r\n            let c = Math.sign(flo_numerical_1.orient2d(v1s[i], v2s[j], [0, 0]));\r\n            if (c === 0) {\r\n                // too close to call \r\n                // use a more accurate but slower method\r\n                return get_in_outs_via_sides_1.getInOutsViaSides(container, ioIdx);\r\n            }\r\n            if (cSign === undefined) {\r\n                cSign = c;\r\n                continue;\r\n            }\r\n            if (cSign !== c) {\r\n                // conflicting results\r\n                // use a more accurate but slower method\r\n                return get_in_outs_via_sides_1.getInOutsViaSides(container, ioIdx);\r\n            }\r\n        }\r\n    }\r\n    let config1 = cSign > 0;\r\n    if (config1) {\r\n        // config1 (the 1st of the 2 possible configurations)\r\n        inOuts.push({ dir: -1, p, _x_: x1, container });\r\n        inOuts.push({ dir: +1, p, _x_: x2, container });\r\n        inOuts.push({ dir: +1, p, _x_: x1, container });\r\n        inOuts.push({ dir: -1, p, _x_: x2, container });\r\n        x1.in_ = inOuts[0];\r\n        x2.in_ = inOuts[3];\r\n    }\r\n    else {\r\n        // config2 (the 2nd of the 2 possible configurations)\r\n        inOuts.push({ dir: -1, p, _x_: x1, container });\r\n        inOuts.push({ dir: -1, p, _x_: x2, container });\r\n        inOuts.push({ dir: +1, p, _x_: x1, container });\r\n        inOuts.push({ dir: +1, p, _x_: x2, container });\r\n        x1.in_ = inOuts[0];\r\n        x2.in_ = inOuts[1];\r\n    }\r\n    return { inOuts, ioIdx };\r\n}\r\nexports.getInOutsViaCrossing = getInOutsViaCrossing;\r\n//# sourceMappingURL=get-in-outs-via-crossing.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst abs = Math.abs;\r\n// TODO - memoize (probably at some deeper level)\r\n/**\r\n *\r\n * @param inOutA\r\n * @param inOutB\r\n */\r\nfunction compareOrderedInOut(inOutA, inOutB) {\r\n    // First compare side indexes - side indexes are the coursest ordering\r\n    let res = inOutA.side - inOutB.side;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Could not resolve by side indexes (they are the same)\r\n    // Compare by side t values\r\n    let xA = inOutA.sideX;\r\n    let xB = inOutB.sideX;\r\n    res = xA.ri.tS - xB.ri.tS;\r\n    let errBound = 2 * 4 * Number.EPSILON; // is factor of 2 necessary\r\n    if (abs(res) >= errBound) {\r\n        return res;\r\n    }\r\n    // At this point we zoom in once more (compensated once) to add an \r\n    // additional 49 bits accuracy\r\n    // TODO - first check if they are in the same k family - this will speed\r\n    // up the algorithm in those cases.\r\n    if (!xA.compensated) { // else the root is already compensated once\r\n        xA.compensated = 1; // compensate once - in future we can compensate more times if necessary\r\n        // there should be only 1 root in the 4u interval\r\n        xA.riExp = flo_poly_1.refineK1(xA.ri.tS, xA.getPsExact)[0];\r\n    }\r\n    if (!xB.compensated) { // else the root is already compensated once\r\n        xB.compensated = 1; // compensate once - in future we can compensate more times if necessary\r\n        // there should be only 1 root in the 4u interval\r\n        xB.riExp = flo_poly_1.refineK1(xB.ri.tS, xB.getPsExact)[0];\r\n    }\r\n    //console.log('compensated')\r\n    //console.log('xA', expEst(xA.riExp.tS), ' - ', expEst(xA.riExp.tE));\r\n    //console.log('xB', expEst(xB.riExp.tS), ' - ', expEst(xB.riExp.tE));\r\n    res = flo_numerical_1.compare(xA.riExp.tS, xB.riExp.tS);\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // At this stage it is either the same curve (mathematically if endpoints\r\n    // and direction is ignored) or even the once compenensated roots cannot be\r\n    // resolved. In future we can cascade compensations to ensure resolution\r\n    // but we are already about a quadrillionth of a quadrillionth of a unit\r\n    // accurate at this stage.\r\n    res = inOutB.inOut.dir - inOutA.inOut.dir;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // At this stage they are both in or both out\r\n    // We reverse sort the ins in comparison to the outs\r\n    return inOutA.inOut.dir === 1\r\n        ? inOutA.inOut.idx - inOutB.inOut.idx\r\n        : inOutB.inOut.idx - inOutA.inOut.idx;\r\n}\r\nexports.compareOrderedInOut = compareOrderedInOut;\r\n//# sourceMappingURL=compare-in-out.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_x_in_outs_1 = __webpack_require__(/*! ./get-x-in-outs */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js\");\r\nconst compare_in_out_1 = __webpack_require__(/*! ./compare-in-out */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js\");\r\n/**\r\n * Returns the incoming / outgoing curves (as InOuts) for the given container\r\n * using an extremely small rectangle around the intersections.\r\n * * **warning** ioIdx will be modified by this function\r\n * @param container\r\n * @param ioIdx\r\n */\r\nfunction getInOutsViaSides(container, ioIdx) {\r\n    // We check one X for each curve with an intersection within this container\r\n    let xs_ = container.xs;\r\n    //console.log(container.xs);\r\n    let inOuts = [];\r\n    // get a map from each Curve to each X of this container\r\n    let xMap = new Map();\r\n    for (let x of xs_) {\r\n        let curve = x.curve;\r\n        let xs = xMap.get(curve);\r\n        if (!xs) {\r\n            xMap.set(curve, [x]);\r\n        }\r\n        else {\r\n            xs.push(x);\r\n        }\r\n    }\r\n    let getXInOuts_ = get_x_in_outs_1.getXInOuts(container);\r\n    for (let entry of xMap) {\r\n        let [curve, xs] = entry;\r\n        let ins;\r\n        let outs;\r\n        ({ ins, outs, ioIdx } = getXInOuts_(curve, xs, ioIdx));\r\n        inOuts.push(...ins);\r\n        inOuts.push(...outs);\r\n    }\r\n    inOuts.sort(compare_in_out_1.compareOrderedInOut);\r\n    return { inOuts: inOuts.map(inOut => inOut.inOut), ioIdx };\r\n}\r\nexports.getInOutsViaSides = getInOutsViaSides;\r\n//# sourceMappingURL=get-in-outs-via-sides.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst are_boxes_intersecting_1 = __webpack_require__(/*! ../../../sweep-line/are-boxes-intersecting */ \"./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nfunction midBox(_x_) {\r\n    return [\r\n        (_x_.x.box[0][0] + _x_.x.box[1][0]) / 2,\r\n        (_x_.x.box[0][1] + _x_.x.box[1][1]) / 2\r\n    ];\r\n}\r\n/**\r\n * * **warning** modifies container.xs[i].in_\r\n * @param container\r\n */\r\nfunction getXInOuts(container) {\r\n    let [[left, top], [right, bottom]] = container.box;\r\n    let sides = [\r\n        [[right, top], [left, top]],\r\n        [[left, top], [left, bottom]],\r\n        [[left, bottom], [right, bottom]],\r\n        [[right, bottom], [right, top]]\r\n    ];\r\n    return (curve, xs_, ioIdx) => {\r\n        // At this point all xs belong to the same curve and container.\r\n        // For each of the four sides get the t values closest to the \r\n        // intersection t.\r\n        let ps = curve.ps;\r\n        let xs = xs_.slice();\r\n        for (let i = 0; i < sides.length; i++) {\r\n            let xs_ = getTs(ps, sides[i]);\r\n            for (let { psX, sideX } of xs_) {\r\n                xs.push({\r\n                    x: psX,\r\n                    side: i,\r\n                    sideX,\r\n                    curve: undefined,\r\n                });\r\n            }\r\n        }\r\n        //---- resolve in-outs\r\n        // the sort below should always resolve if the container dimension is\r\n        // 'large enough', where large enough is based on the maximum value that\r\n        // the tangent magnitude of a curve can attain (no need to resort to \r\n        // compensated intervals)\r\n        xs.sort((xA, xB) => xA.x.ri.tS - xB.x.ri.tS);\r\n        let ins = [];\r\n        let outs = [];\r\n        let prevX;\r\n        /** true if the prevX was a proper X, false if it was a SideX */\r\n        let prevWasX = undefined;\r\n        for (let x of xs) {\r\n            if (x.side !== undefined) {\r\n                // it is a sideX\r\n                if (prevWasX === true) {\r\n                    //console.log(midBox(x))\r\n                    outs.push({\r\n                        inOut: {\r\n                            dir: +1,\r\n                            p: midBox(x),\r\n                            _x_: prevX,\r\n                            container,\r\n                            idx: ++ioIdx\r\n                        },\r\n                        side: x.side,\r\n                        sideX: x.sideX\r\n                    });\r\n                }\r\n                prevWasX = false;\r\n            }\r\n            else {\r\n                // it is a proper X\r\n                if (prevWasX === false) {\r\n                    ins.push({\r\n                        inOut: {\r\n                            dir: -1,\r\n                            p: midBox(prevX),\r\n                            _x_: x,\r\n                            container,\r\n                            idx: ++ioIdx\r\n                        },\r\n                        side: prevX.side,\r\n                        sideX: prevX.sideX\r\n                    });\r\n                    x.in_ = ins[ins.length - 1].inOut;\r\n                }\r\n                prevWasX = true;\r\n            }\r\n            prevX = x;\r\n        }\r\n        return { ins, outs, ioIdx };\r\n    };\r\n}\r\nexports.getXInOuts = getXInOuts;\r\n/**\r\n * Get zero times compensated roots and exact coefficents\r\n */\r\nfunction getXs0(ps1, ps2) {\r\n    let _coeffs = flo_bezier3_1.getIntersectionCoeffs(ps1, ps2);\r\n    if (_coeffs === undefined) {\r\n        return undefined;\r\n    }\r\n    let { coeffs, errBound, getPsExact } = _coeffs;\r\n    let ris = flo_poly_1.allRootsMultiWithErrBounds(coeffs, errBound, getPsExact);\r\n    if (ris.length === 0) {\r\n        return undefined;\r\n    }\r\n    return { ris: ris.map(flo_poly_1.rootIntervalToExp), getPsExact };\r\n}\r\nfunction rootIntervalToDouble(ri) {\r\n    return {\r\n        tS: flo_numerical_1.estimate(ri.tS),\r\n        tE: flo_numerical_1.estimate(ri.tE),\r\n        multiplicity: ri.multiplicity\r\n    };\r\n}\r\n/**\r\n * Robustly get matching intersections of ps (a bezier) that matches those of\r\n * side. ps and side can actually be any order 1, 2 or 3 bezier curve.\r\n * * **precondition** RootInterval[] contains no multiple roots\r\n * @param ps\r\n * @param side\r\n * @param risSide_\r\n */\r\nfunction getTs(ps, side) {\r\n    let xs0Side = getXs0(ps, side);\r\n    if (xs0Side === undefined) {\r\n        return [];\r\n    }\r\n    let { ris: risSide, getPsExact: getPsExactSide } = xs0Side;\r\n    let xs0Ps = getXs0(side, ps);\r\n    if (xs0Ps === undefined) {\r\n        return [];\r\n    }\r\n    let { ris: risPs, getPsExact: getPsExactPs } = xs0Ps;\r\n    //---- Make sure no boxesPs overlap. \r\n    // If any two boxes do operlap we cannot match the t value of a ps box to \r\n    // that of a side box, else we can definitively match them.\r\n    // Note: multiplicity > 1 intersections will result in an infinite loop. \r\n    // It is assumed (as a precondition) the code is such that a multiple \r\n    // intersection is node possible here\r\n    let maxIter;\r\n    // currently we only go up to once compensated (quad precision roots)\r\n    maxIter = 1;\r\n    /** number of compensations for ps */\r\n    let cPs = 0;\r\n    let boxesPs;\r\n    loop: while ( true && cPs < maxIter) {\r\n        // update boxes to new tighter versions\r\n        boxesPs = risPs.map(ri => flo_bezier3_1.getIntervalBoxQuad(ps, [ri.tS, ri.tE]));\r\n        for (let i = 0; i < risPs.length; i++) {\r\n            let boxPsI = boxesPs[i];\r\n            for (let j = i + 1; j < risPs.length; j++) {\r\n                let boxPsJ = boxesPs[j];\r\n                if (are_boxes_intersecting_1.areBoxesIntersectingQuad(true)(boxPsI, boxPsJ)) {\r\n                    let _risPs = [];\r\n                    for (let riPs of risPs) {\r\n                        _risPs.push(...flo_poly_1.refineK1(riPs.tS[1], getPsExactPs));\r\n                    }\r\n                    risPs = _risPs;\r\n                    cPs++;\r\n                    continue loop;\r\n                }\r\n            }\r\n        }\r\n        break loop;\r\n    }\r\n    //---- Make sure no boxesSides overlap - this should be rare as we are \r\n    // already roughly once compensated on that (due to small length of the sides).\r\n    // currently we only go up to once compensated (quad precision roots)\r\n    maxIter = 1;\r\n    /** number of compensations for sides */\r\n    let cSide = 0;\r\n    let boxesSide;\r\n    loop: while ( true && cSide < maxIter) {\r\n        boxesSide = risSide.map(ri => flo_bezier3_1.getIntervalBoxQuad(side, [ri.tS, ri.tE]));\r\n        for (let i = 0; i < risSide.length; i++) {\r\n            let boxSideI = boxesSide[i];\r\n            for (let j = i + 1; j < risSide.length; j++) {\r\n                let boxSideJ = boxesSide[j];\r\n                if (are_boxes_intersecting_1.areBoxesIntersectingQuad(true)(boxSideI, boxSideJ)) {\r\n                    let _risSide = [];\r\n                    for (let riSide of risSide) {\r\n                        _risSide.push(...flo_poly_1.refineK1(riSide.tS[1], getPsExactSide));\r\n                    }\r\n                    risSide = _risSide;\r\n                    cSide++;\r\n                    continue loop;\r\n                }\r\n            }\r\n        }\r\n        break loop;\r\n    }\r\n    let xPairs = [];\r\n    for (let i = 0; i < risPs.length; i++) {\r\n        let boxPs = boxesPs[i];\r\n        for (let j = 0; j < risSide.length; j++) {\r\n            let boxSide = boxesSide[j];\r\n            // TODO - investigate if below commented code would improve algorithm\r\n            //let box = intersectBoxes(boxPs,boxSide);\r\n            //if (box !== undefined) {\r\n            if (are_boxes_intersecting_1.areBoxesIntersectingQuad(true)(boxPs, boxSide)) {\r\n                let psX = {\r\n                    compensated: cPs,\r\n                    ri: rootIntervalToDouble(risPs[i]),\r\n                    riExp: cPs ? risPs[i] : undefined,\r\n                    getPsExact: cPs ? undefined : getPsExactPs,\r\n                    kind: 1,\r\n                    box: boxExpToBox(boxPs)\r\n                };\r\n                let sideX = {\r\n                    compensated: cSide,\r\n                    ri: rootIntervalToDouble(risSide[j]),\r\n                    riExp: cSide ? risSide[j] : undefined,\r\n                    getPsExact: cSide ? undefined : getPsExactSide,\r\n                    kind: 1,\r\n                    box: boxExpToBox(boxSide)\r\n                };\r\n                xPairs.push({ psX, sideX });\r\n            }\r\n        }\r\n    }\r\n    return xPairs;\r\n}\r\n/**\r\n * Converts a box with expansion coordinates into one with double coordinates.\r\n */\r\nfunction boxExpToBox(boxExp) {\r\n    return boxExp.map(p => p.map(c => flo_numerical_1.estimate(c)));\r\n}\r\n//# sourceMappingURL=get-x-in-outs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-containers.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-containers.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst are_containers_intersecting_1 = __webpack_require__(/*! ./are-containers-intersecting */ \"./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js\");\r\nconst get_connected_components_1 = __webpack_require__(/*! ../graph/get-connected-components */ \"./node_modules/flo-boolean/node/graph/get-connected-components.js\");\r\nconst get_isolated_containers_1 = __webpack_require__(/*! ./get-isolated-containers */ \"./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js\");\r\nconst merge_containers_1 = __webpack_require__(/*! ./merge-containers */ \"./node_modules/flo-boolean/node/calc-containers/merge-containers.js\");\r\nconst get_container_in_outs_1 = __webpack_require__(/*! ./get-container-in-outs/get-container-in-outs */ \"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js\");\r\nconst get_intersections_1 = __webpack_require__(/*! ../get-critical-points/get-intersections */ \"./node_modules/flo-boolean/node/get-critical-points/get-intersections.js\");\r\nconst set_intersection_next_values_1 = __webpack_require__(/*! ../get-critical-points/set-intersection-next-values */ \"./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js\");\r\nconst sweep_line_1 = __webpack_require__(/*! ../sweep-line/sweep-line */ \"./node_modules/flo-boolean/node/sweep-line/sweep-line.js\");\r\nconst get_self_intersections_1 = __webpack_require__(/*! ../get-critical-points/get-self-intersections */ \"./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js\");\r\nconst get_interface_intersections_1 = __webpack_require__(/*! ../get-critical-points/get-interface-intersections */ \"./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js\");\r\nconst get_extremes_1 = __webpack_require__(/*! ../get-critical-points/get-extremes */ \"./node_modules/flo-boolean/node/get-critical-points/get-extremes.js\");\r\nconst send_containers_to_grid_1 = __webpack_require__(/*! ./send-containers-to-grid */ \"./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js\");\r\n/**\r\n *\r\n * @param containerDim\r\n */\r\nfunction getContainers(loops, containerDim, expMax) {\r\n    //let t0 = performance.now();\r\n    let xs1 = get_intersections_1.getIntersections(loops, expMax);\r\n    //let t1 = performance.now();\r\n    //console.log(\"intersections took \" + ((t1 - t0)).toFixed(3) + \" milliseconds.\");\r\n    let xs2 = get_self_intersections_1.getSelfIntersections(loops);\r\n    let xs3 = get_interface_intersections_1.getInterfaceIntersections(loops);\r\n    let { extremes, xs: xs4 } = get_extremes_1.getExtremes(loops);\r\n    let xPairs = [...xs1, ...xs2, ...xs3, ...xs4];\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let xPair of xs1) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n        for (let xPair of xs2) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n        // TODO - are interface intersections really necessary?\r\n        for (let xPair of xs3) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n        for (let xPair of xs4) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n    }\r\n    //console.log('general  ', xs1);\r\n    //console.log('self     ', xs2);\r\n    //console.log('interface', xs3);\r\n    //console.log('topmost  ', xs4);\r\n    // initialize the containers with one of the one-sided intersections\r\n    let containers = xPairs.map(xPair => ({\r\n        xs: xPair,\r\n        box: [\r\n            // TODO xs[0].box -> combine xs[0] and xs[1] boxes\r\n            [xPair[0].x.box[0][0] - containerDim, xPair[0].x.box[0][1] - containerDim],\r\n            [xPair[0].x.box[1][0] + containerDim, xPair[0].x.box[1][1] + containerDim]\r\n        ],\r\n        inOuts: undefined // to be set later\r\n    }));\r\n    // iterate, combining containers that overlap on each iteration \r\n    while (true) {\r\n        /** container intersections as an array of Container pairs */\r\n        let is = sweep_line_1.sweepLine(containers, getLeftMost, getRightMost, are_containers_intersecting_1.areContainersIntersecting);\r\n        // if there are no more intersections between containers we're done\r\n        if (!is.length) {\r\n            break;\r\n        }\r\n        let graph = new Map();\r\n        get_connected_components_1.addEdges(graph, is);\r\n        let connectedContainers = get_connected_components_1.getConnectedComponents(graph);\r\n        let isolatedContainers = get_isolated_containers_1.getIsolatedComponents(containers, connectedContainers);\r\n        containers = [\r\n            ...merge_containers_1.mergeContainers(connectedContainers),\r\n            ...isolatedContainers\r\n        ];\r\n    }\r\n    containers = filterContainers(containers);\r\n    containers = send_containers_to_grid_1.sendContainersToGrid(containers, expMax, containerDim);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.container = containers;\r\n    }\r\n    // Add the other half of the intersections too - all intersections has \r\n    // exactly one opposite curve intersection (t values come in pairs)\r\n    // Also, set inOuts on each container, and debugging idx\r\n    let ioIdx = 0;\r\n    //containers.reverse();  // TODO - REMOVE THIS LINE !!! <---\r\n    for (let container of containers) {\r\n        for (let x of container.xs) {\r\n            x.container = container;\r\n        }\r\n        let inOuts;\r\n        ({ inOuts, ioIdx } = get_container_in_outs_1.getContainerInOuts(container, ioIdx));\r\n        container.inOuts = inOuts;\r\n    }\r\n    // remove xs not belonging to a container (caused by filterContainers)\r\n    xPairs = xPairs.filter(x => x[0].container);\r\n    set_intersection_next_values_1.setIntersectionNextValues(xPairs);\r\n    // Connect container ins and outs\r\n    for (let container of containers) {\r\n        for (let out of container.inOuts) {\r\n            if (out.dir === -1) {\r\n                continue;\r\n            }\r\n            let x = out._x_;\r\n            // move to next 'in' X\r\n            while (true) {\r\n                x = x.next;\r\n                if (x.in_) {\r\n                    break;\r\n                }\r\n            }\r\n            out.next = x.in_;\r\n            out.idx = out.next.idx;\r\n        }\r\n    }\r\n    // set next and prev around container for each inout for each container\r\n    for (let container of containers) {\r\n        let inOuts = container.inOuts;\r\n        let prevInOut = inOuts[inOuts.length - 1];\r\n        for (let i = 0; i < inOuts.length; i++) {\r\n            let inOut = inOuts[i];\r\n            inOut.prevAround = prevInOut;\r\n            prevInOut.nextAround = inOut;\r\n            prevInOut = inOut;\r\n        }\r\n    }\r\n    return { extremes, containers };\r\n}\r\nexports.getContainers = getContainers;\r\n/**\r\n * Returns the containers that is the given containers filtered so that those\r\n * having only interface intersections or only a single (giben as a pair) even\r\n * multiple intersection are not included.\r\n * @param containers\r\n */\r\nfunction filterContainers(containers) {\r\n    let containers_ = containers.filter(container => {\r\n        let xs = container.xs;\r\n        if (container.xs.length === 2) {\r\n            let _x_ = xs[0];\r\n            if (_x_.x.kind === 1 && _x_.x.ri.multiplicity % 2 === 0) {\r\n                // multiple even intersection - exclude\r\n                return false;\r\n            }\r\n        }\r\n        for (let x of container.xs) {\r\n            if (x.x.kind !== 4) {\r\n                // include container if any X is not an interface\r\n                return true;\r\n            }\r\n        }\r\n        return false; // exclude container\r\n    });\r\n    return containers_;\r\n}\r\nfunction getLeftMost(container) {\r\n    return container.box[0][0];\r\n}\r\nfunction getRightMost(container) {\r\n    return container.box[1][0];\r\n}\r\n//# sourceMappingURL=get-containers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @param containers all containers\r\n * @param connectedContainers\r\n */\r\nfunction getIsolatedComponents(containers, connectedContainers) {\r\n    let connectedContainers_ = new Set();\r\n    for (let cs of connectedContainers) {\r\n        for (let c of cs) {\r\n            connectedContainers_.add(c);\r\n        }\r\n    }\r\n    let res = [];\r\n    for (let i = 0; i < containers.length; i++) {\r\n        let container = containers[i];\r\n        if (!connectedContainers_.has(container)) {\r\n            res.push(container);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.getIsolatedComponents = getIsolatedComponents;\r\n//# sourceMappingURL=get-isolated-containers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/merge-containers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/merge-containers.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction mergeContainers(ccs) {\r\n    let containers = [];\r\n    for (let cc of ccs) {\r\n        let minLeft = Number.POSITIVE_INFINITY;\r\n        let minTop = Number.POSITIVE_INFINITY;\r\n        let maxRight = Number.NEGATIVE_INFINITY;\r\n        let maxBottom = Number.NEGATIVE_INFINITY;\r\n        let xs = [];\r\n        for (let c of cc) {\r\n            let [[left, top], [right, bottom]] = c.box;\r\n            if (left < minLeft) {\r\n                minLeft = left;\r\n            }\r\n            if (top < minTop) {\r\n                minTop = top;\r\n            }\r\n            if (right > maxRight) {\r\n                maxRight = right;\r\n            }\r\n            if (bottom > maxBottom) {\r\n                maxBottom = bottom;\r\n            }\r\n            xs.push(...c.xs);\r\n        }\r\n        let container = {\r\n            box: [[minLeft, minTop], [maxRight, maxBottom]],\r\n            xs: xs,\r\n            inOuts: undefined\r\n        };\r\n        containers.push(container);\r\n    }\r\n    return containers;\r\n}\r\nexports.mergeContainers = mergeContainers;\r\n//# sourceMappingURL=merge-containers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/merge-containers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst to_grid_1 = __webpack_require__(/*! ../loop/normalize/to-grid */ \"./node_modules/flo-boolean/node/loop/normalize/to-grid.js\");\r\n/**\r\n * Returns the containers from the given containers by sending their boxes to a\r\n * grid with a smaller bitlength.\r\n * @param containers\r\n * @param expMax\r\n * @param containerDim\r\n */\r\nfunction sendContainersToGrid(containers, expMax, containerDim) {\r\n    /**\r\n     * The exponent difference between expMax and the distance of critical\r\n     * points from the sides of the containers. This value cannot be higher\r\n     * than ⌈sqrt(n)⌉ where n is the number of intersections in a container.\r\n     * Assume n < 100 - this is a (mild) limitation of the algorithm\r\n     */\r\n    let expContainer = Math.log2(containerDim);\r\n    let expContainerAdj = expContainer - 3; // 2**-3 === 1/8 of container\r\n    let containers_ = containers.map(container => {\r\n        let box = container.box;\r\n        box = box.map(p => p.map(c => {\r\n            return to_grid_1.toGrid(c, expMax, expMax - expContainerAdj);\r\n        }));\r\n        return Object.assign(Object.assign({}, container), { box });\r\n    });\r\n    return containers_;\r\n}\r\nexports.sendContainersToGrid = sendContainersToGrid;\r\n//# sourceMappingURL=send-containers-to-grid.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/complete-loop.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/complete-loop.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_next_exit_1 = __webpack_require__(/*! ./get-next-exit */ \"./node_modules/flo-boolean/node/calc-paths/get-next-exit.js\");\r\nconst get_beziers_to_next_container_1 = __webpack_require__(/*! ./get-beziers-to-next-container */ \"./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * Completes a loop for a specific intersection point entry curve.\r\n * @param takenOuts\r\n * @param out\r\n * @param g\r\n */\r\nfunction completeLoop(expMax, takenOuts, out) {\r\n    let additionalOutsToCheck = [];\r\n    let beziers = [];\r\n    // Move immediately to the outgoing start of the loop\r\n    let out_ = out;\r\n    let additionalBezier;\r\n    do {\r\n        takenOuts.add(out_); // Mark this intersection as taken\r\n        let { beziers: additionalBeziers, in_, inBez } = get_beziers_to_next_container_1.getBeziersToNextContainer(expMax, out_);\r\n        // TODO - it will probably better to remove additionalBeziers and just\r\n        // connect the endpoints of adjacent beziers - even if we had near\r\n        // exact coordinates (think quad or better precision) of intersections\r\n        // they are still not returned as algebraic numbers so we can never have\r\n        // a perfect algorithm anyway without returning algebraic numbers as \r\n        // intersection coordinates, hence we might as well remove \r\n        // additionalBeziers whose length is about a trillionth of the max\r\n        // coordinate of loops\r\n        beziers.push(...additionalBeziers);\r\n        ({ out_, additionalBezier } = get_next_exit_1.getNextExit(expMax, in_, out, additionalOutsToCheck, takenOuts));\r\n        if (additionalBezier) {\r\n            let t = flo_bezier3_1.closestPointOnBezierPrecise(inBez, additionalBezier[0]).t;\r\n            let inBez_ = flo_bezier3_1.fromTo(inBez)(0, t);\r\n            beziers.push(inBez_);\r\n            beziers.push(additionalBezier);\r\n        }\r\n        else {\r\n            beziers.push(inBez);\r\n        }\r\n    } while (out_ !== out);\r\n    return { beziers, additionalOutsToCheck };\r\n}\r\nexports.completeLoop = completeLoop;\r\n//# sourceMappingURL=complete-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/complete-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/complete-path.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/complete-path.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst complete_loop_1 = __webpack_require__(/*! ./complete-loop */ \"./node_modules/flo-boolean/node/calc-paths/complete-loop.js\");\r\n/**\r\n * Completes the path of a disjoint set of loops, i.e. this function is called\r\n * for each disjoint set of paths.\r\n * @param intersections\r\n * @param takenLoops\r\n * @param parent\r\n * @param loop\r\n */\r\nfunction completePath(expMax, initialOut, takenLoops, takenOuts, parent) {\r\n    // Each loop generated will give rise to one componentLoop. \r\n    initialOut.parent = parent;\r\n    initialOut.windingNum = parent.windingNum + initialOut.orientation;\r\n    initialOut.children = new Set();\r\n    let outStack = [initialOut];\r\n    while (outStack.length) {\r\n        let out = outStack.pop();\r\n        takenLoops.add(out._x_.curve.loop);\r\n        if (takenOuts.has(out)) {\r\n            continue;\r\n        }\r\n        out.children = new Set();\r\n        let { beziers, additionalOutsToCheck } = complete_loop_1.completeLoop(expMax, takenOuts, out);\r\n        out.beziers = beziers;\r\n        out.parent.children = out.parent.children || new Set();\r\n        out.parent.children.add(out);\r\n        outStack.push(...additionalOutsToCheck);\r\n    }\r\n}\r\nexports.completePath = completePath;\r\n//# sourceMappingURL=complete-path.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/complete-path.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst container_1 = __webpack_require__(/*! ../container */ \"./node_modules/flo-boolean/node/container.js\");\r\nfunction getBeziersToNextContainer(expMax, out) {\r\n    let in_ = out.next;\r\n    let endCurve = in_._x_.curve;\r\n    let endT = in_._x_.x.ri.tS;\r\n    let curCurve = out._x_.curve;\r\n    let curT = out._x_.x.ri.tS;\r\n    if (!container_1.containerIsBasic(expMax, out.container)) {\r\n        // we must clip the outgoing curve\r\n        curT = flo_bezier3_1.closestPointOnBezierPrecise(curCurve.ps, out.p).t;\r\n    }\r\n    let beziers = [];\r\n    let inBez;\r\n    while (true) {\r\n        if (curCurve === endCurve &&\r\n            (curT < endT || (curT === endT && beziers.length))) {\r\n            inBez = flo_bezier3_1.fromTo(curCurve.ps)(curT, endT);\r\n            return { beziers, in_, inBez };\r\n        }\r\n        else {\r\n            let ps = flo_bezier3_1.fromTo(curCurve.ps)(curT, 1);\r\n            beziers.push(ps);\r\n        }\r\n        curT = 0;\r\n        curCurve = curCurve.next;\r\n    }\r\n}\r\nexports.getBeziersToNextContainer = getBeziersToNextContainer;\r\n//# sourceMappingURL=get-beziers-to-next-container.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an array of LoopTrees from the given LoopTree where each returned\r\n * LoopTree is one of the nodes of the tree. Nodes with winding number absolute\r\n * value > 1 are not returned.\r\n * @param root\r\n */\r\nfunction getLoopsFromTree(root) {\r\n    let trees = [root];\r\n    let stack = Array.from(root.children);\r\n    while (stack.length) {\r\n        let tree = stack.pop();\r\n        if (tree.windingNum === 0) {\r\n            trees.push(tree);\r\n        }\r\n        for (let child of tree.children) {\r\n            stack.push(child);\r\n        }\r\n    }\r\n    return trees;\r\n}\r\nexports.getLoopsFromTree = getLoopsFromTree;\r\n//# sourceMappingURL=get-loops-from-tree.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-next-exit.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-next-exit.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst container_1 = __webpack_require__(/*! ../container */ \"./node_modules/flo-boolean/node/container.js\");\r\n/**\r\n *\r\n * @param in_ the in for which the next exit should be found\r\n * @param additionalOutsToCheck\r\n */\r\nfunction getNextExit(expMax, in_, originalOut, additionalOutsToCheck, takenOuts) {\r\n    let markOutForChecking_ = markOutForChecking(originalOut, takenOuts, additionalOutsToCheck);\r\n    let additionalBezier = undefined;\r\n    let fromCount = 0;\r\n    let toCount = 1;\r\n    let next = in_;\r\n    let outToUse = undefined;\r\n    do {\r\n        next = originalOut.orientation === +1\r\n            ? next.nextAround\r\n            : next.prevAround;\r\n        if (next === in_) {\r\n            break;\r\n        }\r\n        fromCount = toCount;\r\n        toCount = toCount - next.dir;\r\n        if (next.dir === -1) {\r\n            continue;\r\n        }\r\n        if (!outToUse) {\r\n            // we are still rotating on the inside of the loop\r\n            if (toCount === 0) {\r\n                outToUse = next;\r\n            }\r\n            else if (toCount === 1) {\r\n                // the outermost inner loop must have the same orientation\r\n                markOutForChecking_(next, +1, originalOut);\r\n            }\r\n        }\r\n        else {\r\n            // else we are rotating on the outside of the loop\r\n            if (fromCount === 1 && toCount === 0) {\r\n                markOutForChecking_(next, +1, originalOut.parent);\r\n            }\r\n            else if (fromCount === 0 && toCount === -1) {\r\n                markOutForChecking_(next, -1, originalOut.parent);\r\n            }\r\n        }\r\n    } while (true);\r\n    if (!container_1.containerIsBasic(expMax, in_.container)) {\r\n        // if there is multiple intersection pairs then add an additional bezier\r\n        additionalBezier = [in_.p, outToUse.p];\r\n    }\r\n    return { out_: outToUse, additionalBezier };\r\n}\r\nexports.getNextExit = getNextExit;\r\nfunction markOutForChecking(originalOut, takenOuts, additionalOutsToCheck) {\r\n    return (out, parity, parent) => {\r\n        if (!takenOuts.has(out) && !out.orientation) {\r\n            out.orientation = parity * originalOut.orientation;\r\n            out.parent = parent;\r\n            out.windingNum = parent.windingNum + out.orientation;\r\n            additionalOutsToCheck.push(out);\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=get-next-exit.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/get-next-exit.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Get initial an intersection for the given loop. The loop must be such that\r\n * an extreme point on the loop forms part of an outermost loop that is outside\r\n * all other component loops that is formed by this loop and all other loops it\r\n * may intersect. This extreme point is guaranteed by the initial ordering of\r\n * the loops by their minimum y value.\r\n * @param loop\r\n * @param parent\r\n */\r\nfunction getOutermostInAndOut(container) {\r\n    let inOuts = container.inOuts;\r\n    let firstInOut = inOuts[0];\r\n    let lastInOut = inOuts[inOuts.length - 1];\r\n    // set 'loop' direction\r\n    if (firstInOut.dir === 1) {\r\n        firstInOut.orientation = -1; // anti-clockwise\r\n        return firstInOut;\r\n    }\r\n    else {\r\n        lastInOut.orientation = +1;\r\n        return lastInOut;\r\n    }\r\n}\r\nexports.getOutermostInAndOut = getOutermostInAndOut;\r\n//# sourceMappingURL=get-outermost-in-and-out.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_loop_in_loop_1 = __webpack_require__(/*! ./is-loop-in-loop */ \"./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js\");\r\n/**\r\n * @param root\r\n * @param loop\r\n */\r\nfunction getTightestContainingLoop(root, loop) {\r\n    let containingLoop = undefined;\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let inOut = stack.pop();\r\n        f(inOut);\r\n    }\r\n    return containingLoop;\r\n    function f(parent) {\r\n        if (parent === root || is_loop_in_loop_1.isLoopInLoop(loop.beziers, parent.beziers)) {\r\n            containingLoop = parent;\r\n            for (let child of parent.children) {\r\n                stack.push(child);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.getTightestContainingLoop = getTightestContainingLoop;\r\n//# sourceMappingURL=get-tightest-containing-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n// TODO - remove delta by basing isLoopInLoop on a solid numerical analytic \r\n// basis - isLoopInLoop is the only sub-algorithm left having a DELTA.\r\nconst DELTA = 1e-6;\r\n/**\r\n * Returns true if the first loop is wholly contained within the second loop's\r\n * boundary.\r\n *\r\n * Precondition: the loop is either wholly contained inside the loop or is wholly outside.\r\n * @param loops\r\n */\r\nfunction isLoopInLoop(loop1, loop2) {\r\n    let i = 0;\r\n    let seed = 1231; // Just some value\r\n    do {\r\n        i++;\r\n        // This gets us a predictable random number between 0 and 1;\r\n        let rand1 = flo_poly_1.flatCoefficients(1, 0, 1, seed);\r\n        let t = rand1.p[0];\r\n        seed = rand1.seed; // Get next seed.\r\n        // This gets us a predictable random number roughly between 0 and the \r\n        // number of curves in the loop.\r\n        let curveCount = loop1.length;\r\n        let rand2 = flo_poly_1.flatCoefficients(1, 0, curveCount, seed);\r\n        let idx = Math.floor(rand2.p[0]);\r\n        seed = rand2.seed; // Get next seed.\r\n        let ps = loop1[idx];\r\n        let p = flo_bezier3_1.evalDeCasteljau(ps, t);\r\n        let res = f(loop1, loop2, p);\r\n        if (res !== undefined) {\r\n            return res;\r\n        }\r\n    } while (i < 100);\r\n    return undefined; // There's no chance we'll get up to this point.\r\n    function f(loop1, loop2, p) {\r\n        if (isLoopNotInLoop(loop1, loop2)) {\r\n            return false;\r\n        }\r\n        let count = getAxisAlignedRayLoopIntersections(loop2, p, 'left');\r\n        if (count !== undefined) {\r\n            return count % 2 !== 0;\r\n        }\r\n    }\r\n}\r\nexports.isLoopInLoop = isLoopInLoop;\r\n/**\r\n * Returns true if the first loop is not wholly within the second. The converse\r\n * is not necessarily true. It is assumed the loops don't intersect.\r\n * @param loops\r\n */\r\nfunction isLoopNotInLoop(loop1, loop2) {\r\n    let boundss = [loop1, loop2].map(getLoopBounds);\r\n    return (boundss[0].minX < boundss[1].minX ||\r\n        boundss[0].maxX > boundss[1].maxX ||\r\n        boundss[0].minY < boundss[1].minY ||\r\n        boundss[0].maxY > boundss[1].maxY);\r\n}\r\nfunction getLoopBounds(pss) {\r\n    let bounds = pss.map(ps => flo_bezier3_1.getBounds(ps));\r\n    return {\r\n        minX: Math.min(...bounds.map(bound => bound.box[0][0])),\r\n        maxX: Math.max(...bounds.map(bound => bound.box[1][0])),\r\n        minY: Math.min(...bounds.map(bound => bound.box[0][1])),\r\n        maxY: Math.max(...bounds.map(bound => bound.box[1][1])),\r\n    };\r\n}\r\n/**\r\n * @param p The point where the horizontal ray starts\r\n * @param toLeft The ray to the left of this point (else right)\r\n * @param loop A loop of curves\r\n */\r\nfunction getAxisAlignedRayLoopIntersections(loop, p, dir) {\r\n    let [x, y] = p;\r\n    let count = 0;\r\n    for (let i = 0; i < loop.length; i++) {\r\n        let ps = loop[i];\r\n        //------------------------------------------------------/\r\n        //---- Check if ray intersects bezier bounding box -----/\r\n        //------------------------------------------------------/\r\n        let [[minX, minY], [maxX, maxY]] = flo_bezier3_1.getBoundingBox(ps);\r\n        let notIntersecting = ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||\r\n            ((dir === 'up' || dir === 'down') && (minX > x || maxX < x));\r\n        notIntersecting = notIntersecting ||\r\n            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||\r\n            (dir === 'down' && minY > y) || (dir === 'up' && maxY < y);\r\n        if (notIntersecting) {\r\n            continue;\r\n        } // No intersection with bezier\r\n        //------------------------------------------------------/\r\n        //----------- Get intersection ts on bezier ------------/\r\n        //------------------------------------------------------/\r\n        // Get the bezier's x-coordinate power representation.\r\n        let ts = [];\r\n        let f;\r\n        let offset;\r\n        let axis;\r\n        let dirIsDecreasing = (dir === 'left' || dir === 'up');\r\n        if (dir === 'left' || dir === 'right') {\r\n            f = flo_bezier3_1.getY;\r\n            offset = [0, -y];\r\n            axis = 0;\r\n        }\r\n        else {\r\n            f = flo_bezier3_1.getX;\r\n            offset = [-x, 0];\r\n            axis = 1;\r\n        }\r\n        let translatedPs = flo_bezier3_1.translate(offset, ps);\r\n        let poly = f(translatedPs);\r\n        //let ev = evalDeCasteljau(translatedPs);\r\n        let ts_ = flo_poly_1.allRoots(poly, 0 - DELTA, 1 + DELTA);\r\n        for (let i = 0; i < ts_.length; i++) {\r\n            let t = ts_[i];\r\n            if (Math.abs(t) < DELTA || Math.abs(t - 1) < DELTA) {\r\n                // We don't know the exact number of intersections due to\r\n                // floating point arithmetic. \r\n                return undefined;\r\n            }\r\n            //let p_ = ev(t);\r\n            let p_ = flo_bezier3_1.evalDeCasteljau(translatedPs, t);\r\n            if ((dirIsDecreasing && p[axis] >= p_[axis]) ||\r\n                (!dirIsDecreasing && p[axis] <= p_[axis])) {\r\n                ts.push(t);\r\n            }\r\n        }\r\n        //------------------------------------------------------/\r\n        //----- Check if line is tangent to intersections ------/\r\n        //------------------------------------------------------/\r\n        // We only care if there were 1 or 3 intersections.\r\n        if (ts.length === 1 || ts.length === 3) {\r\n            for (let t of ts) {\r\n                let tan = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(ps, t));\r\n                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||\r\n                    ((dir === 'down' || dir === 'up') && Math.abs(tan[0]) < DELTA)) {\r\n                    // We don't know the exact number of intersections due to\r\n                    // floating point arithmetic\r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n        count += ts.length;\r\n    }\r\n    return count;\r\n}\r\n//# sourceMappingURL=is-loop-in-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * Returns < 0 if loopA's topmost point is higher (i.e. smaller) than that of\r\n * loopB. Using this function in a sort will sort from highest topmost (smallest\r\n * y) point loops to lowest in a left-handed coordinate system.\r\n * @param loopA\r\n * @param loopB\r\n */\r\nfunction orderLoopAscendingByMinY(loopA, loopB) {\r\n    return getMinY(loopA) - getMinY(loopB);\r\n}\r\nexports.orderLoopAscendingByMinY = orderLoopAscendingByMinY;\r\nfunction getMinY(pss) {\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    for (let ps of pss) {\r\n        let y = flo_bezier3_1.getBounds(ps).box[0][1];\r\n        if (y < minY) {\r\n            minY = y;\r\n        }\r\n    }\r\n    return minY;\r\n}\r\n//# sourceMappingURL=order-loop-ascending-by-min-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/simplify-paths.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/simplify-paths.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst complete_path_1 = __webpack_require__(/*! ./complete-path */ \"./node_modules/flo-boolean/node/calc-paths/complete-path.js\");\r\nconst get_tightest_containing_loop_1 = __webpack_require__(/*! ./get-tightest-containing-loop */ \"./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js\");\r\nconst order_loop_ascending_by_min_y_1 = __webpack_require__(/*! ./order-loop-ascending-by-min-y */ \"./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js\");\r\nconst split_loop_trees_1 = __webpack_require__(/*! ./split-loop-trees */ \"./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js\");\r\nconst get_loops_from_tree_1 = __webpack_require__(/*! ./get-loops-from-tree */ \"./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js\");\r\nconst get_containers_1 = __webpack_require__(/*! ../calc-containers/get-containers */ \"./node_modules/flo-boolean/node/calc-containers/get-containers.js\");\r\nconst get_outermost_in_and_out_1 = __webpack_require__(/*! ./get-outermost-in-and-out */ \"./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js\");\r\nconst reverse_orientation_1 = __webpack_require__(/*! ../loop/reverse-orientation */ \"./node_modules/flo-boolean/node/loop/reverse-orientation.js\");\r\nconst loop_1 = __webpack_require__(/*! ../loop/loop */ \"./node_modules/flo-boolean/node/loop/loop.js\");\r\nconst normalize_loop_1 = __webpack_require__(/*! ../loop/normalize/normalize-loop */ \"./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js\");\r\nconst get_max_coordinate_1 = __webpack_require__(/*! ../loop/normalize/get-max-coordinate */ \"./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js\");\r\nconst get_loop_area_1 = __webpack_require__(/*! ../loop/get-loop-area */ \"./node_modules/flo-boolean/node/loop/get-loop-area.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst loops_to_svg_path_str_1 = __webpack_require__(/*! ../svg/loops-to-svg-path-str */ \"./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js\");\r\n/**\r\n * Uses the algorithm of Lavanya Subramaniam: PARTITION OF A NON-SIMPLE POLYGON\r\n * INTO SIMPLE POLYGONS;\r\n * see http://www.cis.southalabama.edu/~hain/general/Theses/Subramaniam_thesis.pdf\r\n * but modified to use bezier curves (as opposed to polygons) and to additionally\r\n * take care of paths with multiple subpaths, i.e. such as disjoint nested paths.\r\n * Also takes care of all special cases.\r\n * @param loops an array of possibly intersecting paths\r\n * @param maxCoordinate optional - if not provided, it will be calculated - a\r\n * wrong value could cause the algorithm to fail\r\n */\r\nfunction simplifyPaths(bezierLoops, maxCoordinate) {\r\n    /**\r\n     * All bezier coordinates will be truncated to this (bit-aligned) bitlength.\r\n     * Higher bitlengths would increase the running time of the algorithm\r\n     * considerably.\r\n     */\r\n    let maxBitLength = 46;\r\n    maxCoordinate = maxCoordinate || get_max_coordinate_1.getMaxCoordinate(bezierLoops);\r\n    /** The exponent, e, such that 2**e >= all bezier coordinate points. */\r\n    let expMax = Math.ceil(Math.log2(maxCoordinate));\r\n    let gridSpacing = Math.pow(2, expMax) * Math.pow(2, (-maxBitLength));\r\n    /**\r\n     * A size (based on the max value of the tangent) for the containers holding\r\n     * critical points.\r\n     */\r\n    const containerSizeMultiplier = Math.pow(2, 4);\r\n    //const containerSizeMultiplier = 2**39;\r\n    let containerDim = gridSpacing * containerSizeMultiplier;\r\n    bezierLoops = normalize_loop_1.normalizeLoops(bezierLoops, maxBitLength, expMax, false, true);\r\n    addDebugInfo1(bezierLoops);\r\n    bezierLoops.sort(order_loop_ascending_by_min_y_1.orderLoopAscendingByMinY);\r\n    let loops = bezierLoops.map(loop => loop_1.loopFromBeziers(loop));\r\n    let { extremes } = get_containers_1.getContainers(loops, containerDim, expMax);\r\n    let root = createRootInOut();\r\n    let takenLoops = new Set();\r\n    let takenOuts = new Set(); // Taken intersections\r\n    for (let loop of loops) {\r\n        if (takenLoops.has(loop)) {\r\n            continue;\r\n        }\r\n        takenLoops.add(loop);\r\n        let parent = get_tightest_containing_loop_1.getTightestContainingLoop(root, loop);\r\n        let container = extremes.get(loop)[0].container;\r\n        if (!container.inOuts.length) {\r\n            continue;\r\n        }\r\n        complete_path_1.completePath(expMax, get_outermost_in_and_out_1.getOutermostInAndOut(container), takenLoops, takenOuts, parent);\r\n    }\r\n    let loopTrees = split_loop_trees_1.splitLoopTrees(root);\r\n    let outSets = loopTrees.map(get_loops_from_tree_1.getLoopsFromTree);\r\n    let loopss = outSets.map(outSet => outSet.map(out => loopFromOut(out, outSet[0].orientation)));\r\n    /**\r\n     * Arbitrarily choose min. loop area to be equal to one square pixel on a\r\n     * 4096 x 4096 grid.\r\n     */\r\n    let minLoopArea = Math.pow((Math.pow(2, expMax) * Math.pow(2, (-12))), 2);\r\n    let loopss_ = [];\r\n    for (let i = 0; i < loopss.length; i++) {\r\n        let loops = loopss[i].filter((loop) => Math.abs(get_loop_area_1.getLoopArea(loop)) > minLoopArea);\r\n        if (loops.length) {\r\n            loops.sort((loopA, loopB) => {\r\n                return order_loop_ascending_by_min_y_1.orderLoopAscendingByMinY(loopA.beziers, loopB.beziers);\r\n            });\r\n            loopss_.push(loops);\r\n        }\r\n    }\r\n    addDebugInfo2(loopss_);\r\n    return loopss_;\r\n}\r\nexports.simplifyPaths = simplifyPaths;\r\nfunction loopFromOut(out, orientation) {\r\n    let loop = orientation < 0\r\n        ? loop_1.loopFromBeziers(out.beziers)\r\n        : reverse_orientation_1.reverseOrientation(loop_1.loopFromBeziers(out.beziers));\r\n    return loop;\r\n}\r\nfunction addDebugInfo2(loopss) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    for (let loops of loopss) {\r\n        _debug_.generated.elems.loop.push(...loops);\r\n        _debug_.generated.elems.loops.push(loops);\r\n        //console.log(loopsToSvgPathStr(loops.map(loop => loop.beziers)));\r\n    }\r\n    // below is used for test generation purposes\r\n    if (typeof document === 'undefined') {\r\n        return;\r\n    }\r\n    // Don't delete below commented lines - it is for creating test cases.\r\n    //let g = document.getElementsByTagName('g')[0];\r\n    //let invariants = loopss.map(loops => {\r\n    //    return loops.map(loop => {\r\n    //        let centroid = getLoopCentroid(loop);\r\n    //        let area     = getLoopArea(loop);\r\n    //        let bounds   = simplifyBounds(getLoopBounds(loop));\r\n    //        //drawFs.crossHair(g, centroid, 'thin10 red nofill', 1, 0);\r\n    //        return { centroid, area, bounds };\r\n    //    });\r\n    //});\r\n    //console.log(JSON.stringify(invariants, undefined, '    '));\r\n}\r\nfunction addDebugInfo1(loops) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    //for (let loop of loops) { console.log(beziersToSvgPathStr(loop.beziers)); }\r\n    if (typeof document !== 'undefined') {\r\n        //let pathStr = loopsToSvgPathStr(loops.map(loop => loop.beziers)); \r\n        let pathStr = loops_to_svg_path_str_1.loopsToSvgPathStr(loops);\r\n        let $svg = document.getElementsByClassName('shape')[0];\r\n        $svg.setAttributeNS(null, 'd', pathStr);\r\n        //console.log(pathStr); \r\n    }\r\n    for (let loop of loops) {\r\n        for (let bez of loop) {\r\n            let lbb = flo_bezier3_1.getBoundingBox(bez);\r\n            let tbb = flo_bezier3_1.getBoundingBoxTight(bez);\r\n            let bhull = flo_bezier3_1.getBoundingHull(bez);\r\n            _debug_.generated.elems.bezier_.push(bez);\r\n            _debug_.generated.elems.looseBoundingBox_.push(lbb);\r\n            _debug_.generated.elems.tightBoundingBox_.push(tbb);\r\n            _debug_.generated.elems.boundingHull_.push(bhull);\r\n        }\r\n    }\r\n}\r\nfunction createRootInOut() {\r\n    return {\r\n        dir: undefined,\r\n        idx: 0,\r\n        parent: undefined,\r\n        children: new Set(),\r\n        windingNum: 0,\r\n        p: undefined,\r\n        _x_: undefined,\r\n        container: undefined\r\n    };\r\n}\r\n// TODO - Handle case where bezier tangentially touches container edge. \r\n// Simply move the container boundary 1/8th or 1/16th inward and try again. \r\n// This case is truly extremely rare and not hard to fix completely.\r\n//# sourceMappingURL=simplify-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/simplify-paths.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Take the forest of trees, create a new root making it a tree and snip\r\n * branches such that each branch determines a new set of loops each\r\n * representing an individual independent shape (possibly with holes).\r\n * @param root\r\n */\r\nfunction splitLoopTrees(root) {\r\n    let iLoopTrees = [];\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let tree = stack.pop();\r\n        tree.children = tree.children || new Set();\r\n        for (let child of tree.children) {\r\n            if (tree.windingNum === 0) {\r\n                iLoopTrees.push(child);\r\n            }\r\n            stack.push(child);\r\n        }\r\n        if (tree.windingNum === 0) {\r\n            tree.children = new Set(); // Make it a leaf\r\n        }\r\n    }\r\n    return iLoopTrees;\r\n}\r\nexports.splitLoopTrees = splitLoopTrees;\r\n//# sourceMappingURL=split-loop-trees.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/container.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-boolean/node/container.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if the container is basic, i.e. contains only 1 interface\r\n * intersection or contains only 1 general, extreme or loop intersection\r\n * (not cusp, or endpoint overlap), false otherwise.\r\n *\r\n * @param container\r\n */\r\nfunction containerIsBasic(expMax, container) {\r\n    let xs = container.xs;\r\n    if (xs.length <= 2) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.containerIsBasic = containerIsBasic;\r\n//# sourceMappingURL=container.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/container.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/debug.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/debug.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_elem_1 = __webpack_require__(/*! ./draw-elem/draw-elem */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js\");\r\n/**\r\n * Returns a new debug object by spreading boolean operation debug information\r\n * onto the given (possibly undefined) debug object.\r\n * @param debug a (possibly undefined) debug object\r\n */\r\nfunction enableDebugForBooleanOp(debugOn) {\r\n    var _a, _b, _c;\r\n    if (!debugOn) {\r\n        window._debug_ = undefined;\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = Object.assign(Object.assign({}, debug), { generated: Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.generated), { elems: Object.assign(Object.assign({}, (_a = debug === null || debug === void 0 ? void 0 : debug.generated) === null || _a === void 0 ? void 0 : _a.elems), { minY: [], loop: [], loops: [], intersection: [], container: [], bezier_: [], looseBoundingBox_: [], tightBoundingBox_: [], boundingHull_: [] }), timing: Object.assign(Object.assign({}, (_b = debug === null || debug === void 0 ? void 0 : debug.generated) === null || _b === void 0 ? void 0 : _b.timing), { normalize: 0, simplifyPaths: 0 }) }), fs: Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.fs), { drawElem: Object.assign(Object.assign({}, (_c = debug === null || debug === void 0 ? void 0 : debug.fs) === null || _c === void 0 ? void 0 : _c.drawElem), draw_elem_1.drawElemFunctions) }) });\r\n    window._debug_ = debug;\r\n}\r\nexports.enableDebugForBooleanOp = enableDebugForBooleanOp;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction drawBoundingHull(g, hull, classes = 'thin5 black nofill', delay = 0) {\r\n    let $polygon = flo_draw_1.drawFs.polygon(g, hull, classes, delay);\r\n    return $polygon;\r\n}\r\nexports.drawBoundingHull = drawBoundingHull;\r\n//# sourceMappingURL=draw-bounding-hull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\nexports.drawCirclePercent = drawCirclePercent;\r\n//# sourceMappingURL=draw-circle-percent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction drawContainer(g, container, classes, delay = 0) {\r\n    let rect = container.box;\r\n    let xs = container.xs;\r\n    let scale = 0.025;\r\n    // intersections\r\n    let $circles = [];\r\n    for (let i = 0; i < xs.length; i++) {\r\n        let x = xs[i];\r\n        $circles.push(...flo_draw_1.drawFs.circle(g, { center: x.x.box[0], radius: scale }, 'thin2 red nofill', delay));\r\n    }\r\n    // text showing intersection ordering\r\n    let $texts = [];\r\n    let inOuts = container.inOuts;\r\n    for (let i = 0; i < inOuts.length; i++) {\r\n        let inOut = inOuts[i];\r\n        let C = 3;\r\n        let p = inOut.p.slice();\r\n        //if (inOut.order) {\r\n        //    if (inOut.order[0] === 3) { p[0] += C; }\r\n        //    if (inOut.order[0] === 0) { p[1] -= C; }\r\n        //    if (inOut.order[0] === 1) { p[0] -= 2*C; }\r\n        //    if (inOut.order[0] === 2) { p[1] += 2*C; }\r\n        //}\r\n        let color = inOut.dir === -1 ? 'red' : 'blue';\r\n        //let size = scale * (inOut.dir === -1 ? 0.75 : 1);\r\n        let size = scale * (inOut.dir === -1 ? 0.5 : 0.5);\r\n        //$texts.push(...drawFs.text(g, p, i.toString(), 4, color, delay));\r\n        $circles.push(...flo_draw_1.drawFs.dot(g, inOut.p, size, `thin2 ${color}`, delay));\r\n    }\r\n    // container rect\r\n    let $outline = flo_draw_1.drawFs.rect(g, rect, 'thin2 blue nofill', delay);\r\n    return [...$outline, ...$circles, ...$texts];\r\n}\r\nexports.drawContainer = drawContainer;\r\n//# sourceMappingURL=draw-container.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_min_y_1 = __webpack_require__(/*! ./draw-min-y */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js\");\r\nconst draw_loop_1 = __webpack_require__(/*! ./draw-loop */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js\");\r\nconst draw_loops_1 = __webpack_require__(/*! ./draw-loops */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js\");\r\nconst draw_intersection_1 = __webpack_require__(/*! ./draw-intersection */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js\");\r\nconst draw_container_1 = __webpack_require__(/*! ./draw-container */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js\");\r\nconst draw_loose_bounding_box_1 = __webpack_require__(/*! ./draw-loose-bounding-box */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js\");\r\nconst draw_tight_bounding_box_1 = __webpack_require__(/*! ./draw-tight-bounding-box */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js\");\r\nconst draw_bounding_hull_1 = __webpack_require__(/*! ./draw-bounding-hull */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nlet drawElemFunctions = {\r\n    minY: draw_min_y_1.drawMinY,\r\n    loop: draw_loop_1.drawLoop,\r\n    loops: draw_loops_1.drawLoops,\r\n    intersection: draw_intersection_1.drawIntersection,\r\n    container: draw_container_1.drawContainer,\r\n    bezier_: flo_draw_1.drawFs.bezier,\r\n    looseBoundingBox_: draw_loose_bounding_box_1.drawLooseBoundingBox,\r\n    tightBoundingBox_: draw_tight_bounding_box_1.drawTightBoundingBox,\r\n    boundingHull_: draw_bounding_hull_1.drawBoundingHull\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js\");\r\nfunction drawIntersection(g, x) {\r\n    return [draw_circle_percent_1.drawCirclePercent(g, x.x.box[0], 0.7, 'purple thin5 nofill')];\r\n}\r\nexports.drawIntersection = drawIntersection;\r\n//# sourceMappingURL=draw-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO - finish\r\nfunction drawLoop(g, loop) {\r\n    /*\r\n    for (let curve of loop.curves) {\r\n        drawFs.bezier(g, curve.ps, undefined, 1000);\r\n    }\r\n    */\r\n    return [];\r\n}\r\nexports.drawLoop = drawLoop;\r\n//# sourceMappingURL=draw-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO - finish\r\nfunction drawLoops(g, loops) {\r\n    return [];\r\n}\r\nexports.drawLoops = drawLoops;\r\n//# sourceMappingURL=draw-loops.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction drawLooseBoundingBox(g, box, classes = 'thin5 brown nofill', delay = 0) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    box = [[x0, y0], [x1, y0], [x1, y1], [x0, y1]];\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, classes, delay);\r\n    return $box;\r\n}\r\nexports.drawLooseBoundingBox = drawLooseBoundingBox;\r\n//# sourceMappingURL=draw-loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction drawMinY(g, pos) {\r\n    let p = flo_bezier3_1.evalDeCasteljau(pos.curve.ps, pos.t);\r\n    let ps = flo_bezier3_1.toCubic(pos.curve.ps);\r\n    console.log('x: ', flo_bezier3_1.getX(ps));\r\n    console.log('y: ', flo_bezier3_1.getY(ps));\r\n    console.log('t: ', pos.t);\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, p, 'red thin10 nofill');\r\n    return $elems;\r\n}\r\nexports.drawMinY = drawMinY;\r\n//# sourceMappingURL=draw-min-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction drawTightBoundingBox(g, box, classes = 'thin5 pinker nofill', delay = 0) {\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, classes, delay);\r\n    return $box;\r\n}\r\nexports.drawTightBoundingBox = drawTightBoundingBox;\r\n//# sourceMappingURL=draw-tight-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adapted from https://stackoverflow.com/a/12414951/2010061.\r\n * Returns true if there is any intersection between the 2 polygons, false otherwise\r\n * Uses the Separating Axis Theorem.\r\n *\r\n * @param polygonA an array of connected points that form a closed polygon\r\n * @param polygonB an array of connected points that form a closed polygon\r\n * @param closed set to false to compare open polygons (not containing their\r\n * boundary) or true to compare closed polygons\r\n */\r\nfunction doConvexPolygonsIntersect(polygonA, polygonB, closed) {\r\n    // for each polygon, look at each edge of the polygon, and determine if \r\n    // it separates the two shapes\r\n    for (let polygon of [polygonA, polygonB]) {\r\n        let len = polygon.length;\r\n        for (let i = 1; i < len + 1; i++) {\r\n            // grab 2 consecutive vertices to create an edge\r\n            let p1 = polygon[i - 1];\r\n            let p2 = polygon[i % len];\r\n            // find the vector perpendicular to this edge\r\n            let normal = [p2[1] - p1[1], p1[0] - p2[0]];\r\n            let minA = Number.POSITIVE_INFINITY;\r\n            let maxA = Number.NEGATIVE_INFINITY;\r\n            // for each vertex in the first shape, project it onto the line \r\n            // perpendicular to the edge and keep track of the min and max of \r\n            // these values\r\n            for (let k = 0; k < polygonA.length; k++) {\r\n                let projected = normal[0] * polygonA[k][0] +\r\n                    normal[1] * polygonA[k][1];\r\n                if (projected < minA) {\r\n                    minA = projected;\r\n                }\r\n                if (projected > maxA) {\r\n                    maxA = projected;\r\n                }\r\n            }\r\n            // for each vertex in the second shape, project it onto the line \r\n            // perpendicular to the edge and keep track of the min and max of \r\n            // these values\r\n            let minB = Number.POSITIVE_INFINITY;\r\n            let maxB = Number.NEGATIVE_INFINITY;\r\n            for (let k = 0; k < polygonB.length; k++) {\r\n                let projected = normal[0] * polygonB[k][0] +\r\n                    normal[1] * polygonB[k][1];\r\n                if (projected < minB) {\r\n                    minB = projected;\r\n                }\r\n                if (projected > maxB) {\r\n                    maxB = projected;\r\n                }\r\n            }\r\n            // if there is no overlap between the projections, the edge we are \r\n            // looking at separates the two polygons, and we know there is no \r\n            // overlap\r\n            if (closed) {\r\n                if (maxA < minB || maxB < minA) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!closed) {\r\n                if (maxA <= minB || maxB <= minA) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.doConvexPolygonsIntersect = doConvexPolygonsIntersect;\r\n//# sourceMappingURL=do-convex-polygons-intersect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_bezier3_2 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst are_boxes_intersecting_1 = __webpack_require__(/*! ../sweep-line/are-boxes-intersecting */ \"./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js\");\r\nconst do_convex_polygons_intersect_1 = __webpack_require__(/*! ../geometry/do-convex-polygons-intersect */ \"./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js\");\r\nconst get_intersection_1 = __webpack_require__(/*! ./get-intersection */ \"./node_modules/flo-boolean/node/get-critical-points/get-intersection.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst make_simple_x_1 = __webpack_require__(/*! ./make-simple-x */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\r\n/** function that returns true if *open* axis aligned boxes intersect, false otherwise */\r\nlet areBoxesIntersectingOpen = are_boxes_intersecting_1.areBoxesIntersecting(false);\r\n/** function that returns true if *closed* axis aligned boxes intersect, false otherwise */\r\nlet areBoxesIntersectingClosed = are_boxes_intersecting_1.areBoxesIntersecting(true);\r\n/**\r\n * Returns the pairs of intersection t values between the curves. Interface\r\n * intersections may not be returned - they should already be caught.\r\n * @param curveA\r\n * @param curveB\r\n */\r\nfunction getCurvesIntersections(expMax) {\r\n    return (curveA, curveB) => {\r\n        let psA = curveA.ps;\r\n        let psB = curveB.ps;\r\n        if (psA.length === 2 && psB.length === 2) {\r\n            return getLineLineIntersections(curveA, curveB, expMax);\r\n        }\r\n        if (curveA.next === curveB || curveB.next === curveA) {\r\n            // curves are connected at endpoints\r\n            // closed bounding boxes are guaranteed to intersect - don't check\r\n            // check open bounding boxes\r\n            let aabbsIntersectOpen = areBoxesIntersectingOpen(flo_bezier3_1.getBoundingBox(psA), flo_bezier3_1.getBoundingBox(psB));\r\n            if (!aabbsIntersectOpen) {\r\n                return checkEndpoints(curveA, curveB);\r\n            }\r\n            // check open bounding hulls\r\n            let bbHullA = flo_bezier3_1.getBoundingHull(psA);\r\n            let bbHullB = flo_bezier3_1.getBoundingHull(psB);\r\n            let hullsIntersectOpen = do_convex_polygons_intersect_1.doConvexPolygonsIntersect(bbHullA, bbHullB, false);\r\n            if (!hullsIntersectOpen) {\r\n                return checkEndpoints(curveA, curveB);\r\n            }\r\n            // neither aabbs nor hulls can split the curves\r\n            return curveB.next === curveA\r\n                ? get_intersection_1.getIntersection(curveB, curveA, expMax, true) // B-->A\r\n                : get_intersection_1.getIntersection(curveA, curveB, expMax, true); // A-->B\r\n        }\r\n        // curves are not connected at endpoints\r\n        // check closed bounding boxes\r\n        let possiblyIntersecting = areBoxesIntersectingClosed(flo_bezier3_1.getBoundingBox(psA), flo_bezier3_1.getBoundingBox(psB));\r\n        if (!possiblyIntersecting) {\r\n            return undefined;\r\n        }\r\n        // check closed bounding hulls\r\n        let bbHullA = flo_bezier3_1.getBoundingHull(psA);\r\n        let bbHullB = flo_bezier3_1.getBoundingHull(psB);\r\n        possiblyIntersecting = do_convex_polygons_intersect_1.doConvexPolygonsIntersect(bbHullA, bbHullB, true);\r\n        if (!possiblyIntersecting) {\r\n            return undefined;\r\n        }\r\n        return get_intersection_1.getIntersection(curveA, curveB, expMax, false);\r\n    };\r\n}\r\nexports.getCurvesIntersections = getCurvesIntersections;\r\n/**\r\n * Returns an un-ordered pair of intersections (excluding interface intersections,\r\n * in which case undefined is returned) between curveA and curveB.\r\n * * **precondition**: curveA.next === curveB || curveB.next === curveA\r\n * * **precondition**: every intersection will be at an endpoint of at least\r\n * one of the curves\r\n * @param curveA\r\n * @param curveB\r\n */\r\nfunction checkEndpoints(curveA, curveB) {\r\n    let _x_s = [];\r\n    //let swapped = false;\r\n    if (curveB.next === curveA) {\r\n        if (curveA.next === curveB) {\r\n            // if this is a very simple loop with only 2 beziers in it\r\n            return undefined;\r\n        }\r\n        // else swap the curves to make the algorithm simpler\r\n        //swapped = true;\r\n        [curveA, curveB] = [curveB, curveA];\r\n    }\r\n    // At this point A-->B (curveA's next === curveB)\r\n    // There is thus an intersection at curveA(t=1) and curveB(t=0)\r\n    let psA = curveA.ps;\r\n    let psB = curveB.ps;\r\n    // Is last point of curveB on curveA?\r\n    if (isPointOnBezier(psA, psB[psB.length - 1])) {\r\n        let xPair = flo_bezier3_2.getOtherTs(psA, psB, [flo_poly_1.createRootExact(1)])[0];\r\n        if (!xPair) {\r\n            return undefined;\r\n        }\r\n        return [[\r\n                { x: xPair[0], curve: curveA },\r\n                make_simple_x_1.makeSimpleX(1, curveB, 1)\r\n            ]];\r\n    }\r\n}\r\nfunction isPointOnBezier(ps, p) {\r\n    // TODO - isPointOnBezierExtension not same as isPointOnBezier ???\r\n    return flo_bezier3_2.isPointOnBezierExtension(ps, p);\r\n}\r\nfunction getLineLineIntersections(curveA, curveB, expMax) {\r\n    let psA = curveA.ps;\r\n    let psB = curveB.ps;\r\n    let bbA = flo_bezier3_1.getBoundingBox(psA);\r\n    let bbB = flo_bezier3_1.getBoundingBox(psB);\r\n    if (curveA.next !== curveB && curveB.next !== curveA) {\r\n        // the two lines are not connected at their endpoints\r\n        if (areBoxesIntersectingClosed(bbA, bbB)) {\r\n            let xs = get_intersection_1.getIntersection(curveA, curveB, expMax, false);\r\n            return xs.length ? xs : undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n    // the two lines are connected at their endpoints\r\n    let swap = curveB.next === curveA;\r\n    if (swap) {\r\n        [curveA, curveB] = [curveB, curveA];\r\n        [psA, psB] = [psB, psA];\r\n    }\r\n    let orientation = flo_numerical_1.orient2d(psA[0], psA[1], psB[1]);\r\n    if (orientation !== 0) {\r\n        // they cannot intersect\r\n        return undefined;\r\n    }\r\n    // they are in the same k family - they can either go in the\r\n    // same direction or go back on top of each other\r\n    // if going in same direction\r\n    if (!areBoxesIntersectingOpen(bbA, bbB)) {\r\n        // they cannot intersect\r\n        return undefined;\r\n    }\r\n    // it is a line going back on itself \r\n    // - return endpoint intersections\r\n    let lenCurve1 = flo_vector2d_1.squaredDistanceBetween(psA[0], psA[1]);\r\n    let lenCurve2 = flo_vector2d_1.squaredDistanceBetween(psB[0], psB[1]);\r\n    let tPair;\r\n    if (lenCurve1 > lenCurve2) {\r\n        tPair = [flo_bezier3_1.inversion1_BL52_1ULP(psA, psB[1]), 1];\r\n    }\r\n    else {\r\n        tPair = [0, flo_bezier3_1.inversion1_BL52_1ULP(psB, psA[0])];\r\n    }\r\n    return [[\r\n            make_simple_x_1.makeSimpleX(1, curveA, 5),\r\n            make_simple_x_1.makeSimpleX(0, curveB, 5),\r\n        ], [\r\n            make_simple_x_1.makeSimpleX(tPair[0], curveA, 5),\r\n            make_simple_x_1.makeSimpleX(tPair[1], curveB, 5) // exact overlap endpoint\r\n        ]];\r\n}\r\n// tight bounding boxes\r\n/*\r\nlet bbTightA = getBoundingBoxTight(psA);\r\nlet bbTightB = getBoundingBoxTight(psB);\r\npossiblyIntersecting =\r\n    doConvexPolygonsIntersect(bbTightA, bbTightB, closed);\r\n    //doConvexPolygonsIntersect(bbTightA, bbTightB, false);\r\n//if (!possiblyIntersecting) { return false; }\r\nif (!possiblyIntersecting) { return checkEndpoints(curveA, curveB); }\r\n*/ \r\n//# sourceMappingURL=get-curves-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-extreme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-extreme.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_min_y_1 = __webpack_require__(/*! ../loop/get-min-y */ \"./node_modules/flo-boolean/node/loop/get-min-y.js\");\r\nconst make_simple_x_1 = __webpack_require__(/*! ./make-simple-x */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\r\n/**\r\n * Get an extreme point (point with minimum y value) of the given loop.\r\n * @param loop\r\n */\r\nfunction getExtreme(loop) {\r\n    let { curve, y } = get_min_y_1.getMinY(loop);\r\n    let ts = y.ts;\r\n    if (ts[0] <= 0) {\r\n        return [\r\n            make_simple_x_1.makeSimpleX(0, curve, 0),\r\n            make_simple_x_1.makeSimpleX(1, curve.prev, 0) // extreme\r\n        ];\r\n    }\r\n    if (ts[1] >= 1) {\r\n        return [\r\n            make_simple_x_1.makeSimpleX(1, curve, 0),\r\n            make_simple_x_1.makeSimpleX(0, curve.next, 0) // extreme\r\n        ];\r\n    }\r\n    return [\r\n        // TODO - should multiplicity be undefined in these cases?\r\n        // TODO - do we need 2 intersections???\r\n        { x: { ri: { tS: ts[0], tE: ts[1], multiplicity: 1 }, kind: 0, box: y.box }, curve },\r\n        { x: { ri: { tS: ts[0], tE: ts[1], multiplicity: 1 }, kind: 0, box: y.box }, curve } // extreme\r\n    ];\r\n}\r\nexports.getExtreme = getExtreme;\r\n//# sourceMappingURL=get-extreme.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-extreme.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-extremes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-extremes.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_extreme_1 = __webpack_require__(/*! ./get-extreme */ \"./node_modules/flo-boolean/node/get-critical-points/get-extreme.js\");\r\n// TODO - include all interface points close to the extreme - they are the only\r\n// important interface points - or are they??\r\n/**\r\n *\r\n * @param loops\r\n */\r\nfunction getExtremes(loops) {\r\n    let extremes = new Map();\r\n    let xs = [];\r\n    for (let loop of loops) {\r\n        let xPair = get_extreme_1.getExtreme(loop);\r\n        xs.push(xPair);\r\n        extremes.set(loop, xPair);\r\n    }\r\n    return { extremes, xs };\r\n}\r\nexports.getExtremes = getExtremes;\r\n//# sourceMappingURL=get-extremes.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-extremes.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst make_simple_x_1 = __webpack_require__(/*! ./make-simple-x */ \"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js\");\r\nfunction getInterfaceIntersections(loops) {\r\n    /** all one-sided Xs from */\r\n    let xs = [];\r\n    // Get interface points\r\n    for (let loop of loops) {\r\n        for (let curve of loop.curves) {\r\n            xs.push([\r\n                make_simple_x_1.makeSimpleX(1, curve, 4),\r\n                make_simple_x_1.makeSimpleX(0, curve.next, 4),\r\n            ]);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\nexports.getInterfaceIntersections = getInterfaceIntersections;\r\n//# sourceMappingURL=get-interface-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-intersection.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-intersection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n *\r\n * @param curveA\r\n * @param curveB\r\n * @param expMax\r\n * @param isANextB is curveB the next curve after curveA, i.e. is A's next B\r\n */\r\nfunction getIntersection(curveA, curveB, expMax, isANextB) {\r\n    let ps1 = curveA.ps;\r\n    let ps2 = curveB.ps;\r\n    let xs = [];\r\n    let ts2 = flo_bezier3_1.bezierBezierIntersectionImplicit(ps1, ps2);\r\n    if (ts2 === undefined) {\r\n        // the curves are in the same k-family\r\n        // some reasonable error bound -> to be fine-tuned, but cannot\r\n        // break the algorithm (unless its too small), only make it run slower.\r\n        let errBound = Math.pow(2, (expMax - 48));\r\n        let riPairs = flo_bezier3_1.getEndpointIntersections(ps1, ps2, errBound);\r\n        for (let riPair of riPairs) {\r\n            //let p1 = evalDeCasteljau(ps1, mid(riPair[0]));\r\n            let p1 = flo_bezier3_1.evalDeCasteljau(ps1, riPair[0].tS);\r\n            let box = [\r\n                [p1[0] - errBound, p1[1] - errBound],\r\n                [p1[0] + errBound, p1[1] + errBound],\r\n            ];\r\n            let ri1 = { x: { ri: riPair[0], kind: 5, box }, curve: curveA }; // exact overlap endpoint\r\n            let ri2 = { x: { ri: riPair[1], kind: 5, box }, curve: curveB }; // exact overlap endpoint\r\n            xs.push([ri1, ri2]);\r\n        }\r\n    }\r\n    else {\r\n        if (isANextB) {\r\n            // we are not interested in zero t values (they are interface points)\r\n            ts2 = ts2.filter(t => t.tS > 0);\r\n        }\r\n        let xPairs = flo_bezier3_1.getOtherTs(ps1, ps2, ts2);\r\n        for (let xPair of xPairs) {\r\n            let x1 = { x: xPair[0], curve: curveA };\r\n            let x2 = { x: xPair[1], curve: curveB };\r\n            xs.push([x1, x2]);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\nexports.getIntersection = getIntersection;\r\n//# sourceMappingURL=get-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-intersection.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-intersections.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-intersections.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst sweep_line_1 = __webpack_require__(/*! ../sweep-line/sweep-line */ \"./node_modules/flo-boolean/node/sweep-line/sweep-line.js\");\r\nconst get_curves_intersections_1 = __webpack_require__(/*! ./get-curves-intersections */ \"./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js\");\r\n/**\r\n * Find and return all one-sided intersections on all given loops as a map from\r\n * each curve to an array of intersections on the curve, ordered by t value.\r\n * @param loops\r\n */\r\nfunction getIntersections(loops, expMax) {\r\n    let curves = [];\r\n    for (let loop of loops) {\r\n        for (let curve of loop.curves) {\r\n            curves.push(curve);\r\n        }\r\n    }\r\n    ;\r\n    // Filter curves so that we eliminate those that can definitely not intersect\r\n    let _xs = sweep_line_1.sweepLine(curves, curve => flo_bezier3_1.getBoundingBox(curve.ps)[0][0], curve => flo_bezier3_1.getBoundingBox(curve.ps)[1][0], get_curves_intersections_1.getCurvesIntersections(expMax));\r\n    let xs = [];\r\n    for (let _x of _xs) {\r\n        for (let x of _x.u) {\r\n            xs.push(x);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\nexports.getIntersections = getIntersections;\r\n//# sourceMappingURL=get-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst eps = Number.EPSILON;\r\n/**\r\n * @param loops\r\n */\r\nfunction getSelfIntersections(loops) {\r\n    let xs = [];\r\n    for (let loop of loops) {\r\n        for (let curve of loop.curves) {\r\n            let ps = curve.ps;\r\n            let ts = flo_bezier3_1.bezierSelfIntersection(ps);\r\n            if (ts === undefined) {\r\n                continue;\r\n            } // there is no self-intersection\r\n            // if a cusp (or extremely close to it)\r\n            let kind = ts[0] === ts[1]\r\n                ? 3 /*cusp*/\r\n                : 2 /*self-intersection*/;\r\n            // TODO - fix box - must combine 2 boxes and bezierSelfIntersection must return intervals\r\n            let t0S = ts[0] - eps;\r\n            let t0E = ts[0] + eps;\r\n            let t1S = ts[1] - eps;\r\n            let t1E = ts[1] + eps;\r\n            let box0 = flo_bezier3_1.getIntervalBox(ps, [t0S, t0E]); // ts are within 1 upls accurate\r\n            let box1 = flo_bezier3_1.getIntervalBox(ps, [t1S, t1E]); // ts are within 1 upls accurate\r\n            xs.push([\r\n                // TODO - multiplicity relevant??\r\n                { x: { ri: { tS: t0S, tE: t0E, multiplicity: 1 }, box: box0, kind }, curve },\r\n                { x: { ri: { tS: t1S, tE: t1E, multiplicity: 1 }, box: box1, kind }, curve }\r\n            ]);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\nexports.getSelfIntersections = getSelfIntersections;\r\n//# sourceMappingURL=get-self-intersections.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n *\r\n * @param t\r\n * @param curve\r\n * @param kind\r\n */\r\nfunction makeSimpleX(t, curve, kind) {\r\n    let ps = curve.ps;\r\n    if (t === 0) {\r\n        // we have the exact point\r\n        let pS = ps[0];\r\n        let box = [ps[0], ps[0]];\r\n        return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\r\n    }\r\n    else if (t === 1) {\r\n        // we have the exact point\r\n        let pE = ps[ps.length - 1];\r\n        let box = [pE, pE];\r\n        return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\r\n    }\r\n    // there will be some error in calculating the point\r\n    let { p, pE } = flo_bezier3_1.evalDeCasteljauWithErr(ps, t);\r\n    let box = [\r\n        [p[0] - pE[0], p[1] - pE[1]],\r\n        [p[0] + pE[0], p[1] + pE[1]]\r\n    ];\r\n    return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\r\n}\r\nexports.makeSimpleX = makeSimpleX;\r\n//# sourceMappingURL=make-simple-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Set each intersection on the given original loop's next and prev value\r\n * @param loops\r\n * @param xMap\r\n */\r\nfunction setIntersectionNextValues(xPairs) {\r\n    let xsByLoop = new Map();\r\n    for (let xPair of xPairs) {\r\n        for (let x_ of xPair) {\r\n            let loop = x_.curve.loop;\r\n            let xs_ = xsByLoop.get(loop) || [];\r\n            if (!xs_.length) {\r\n                xsByLoop.set(loop, xs_);\r\n            }\r\n            xs_.push(x_);\r\n        }\r\n    }\r\n    for (let item of xsByLoop) {\r\n        let xs = item[1];\r\n        if (!xs || !xs.length) {\r\n            continue;\r\n        }\r\n        xs.sort((xA, xB) => {\r\n            let res = xA.curve.idx - xB.curve.idx;\r\n            if (res !== 0) {\r\n                return res;\r\n            }\r\n            res = xA.x.ri.tS - xB.x.ri.tS;\r\n            if (res !== 0) {\r\n                return res;\r\n            }\r\n            return xA.in_ ? -1 : +1;\r\n        });\r\n        for (let i = 1; i < xs.length; i++) {\r\n            xs[i - 1].next = xs[i];\r\n        }\r\n        xs[xs.length - 1].next = xs[0];\r\n    }\r\n}\r\nexports.setIntersectionNextValues = setIntersectionNextValues;\r\n//# sourceMappingURL=set-intersection-next-values.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/graph/get-connected-components.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/graph/get-connected-components.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction addEdges(graph, edges) {\r\n    for (let i = 0; i < edges.length; i++) {\r\n        let edge = edges[i];\r\n        addEdge(graph, [edge.a, edge.b]);\r\n    }\r\n}\r\nexports.addEdges = addEdges;\r\n/**\r\n * Adds an edge to an undirected graph.\r\n */\r\nfunction addEdge(graph, vertices) {\r\n    let [src, dest] = vertices;\r\n    let srcList = graph.get(src);\r\n    if (!srcList) {\r\n        srcList = [];\r\n        graph.set(src, srcList);\r\n    }\r\n    let destList = graph.get(dest);\r\n    if (!destList) {\r\n        destList = [];\r\n        graph.set(dest, destList);\r\n    }\r\n    srcList.push(dest);\r\n    destList.push(src);\r\n}\r\nexports.addEdge = addEdge;\r\nfunction DFSUtil(graph, v, visited, component) {\r\n    // Mark the current node as visited and print it \r\n    visited.add(v);\r\n    component.push(v);\r\n    // Recur for all the vertices adjacent to this vertex \r\n    let list = graph.get(v);\r\n    for (let i = 0; i < list.length; i++) {\r\n        let x = list[i];\r\n        if (!visited.has(x)) {\r\n            DFSUtil(graph, x, visited, component);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns connected components for the given undirected graph\r\n */\r\nfunction getConnectedComponents(graph) {\r\n    // Mark all the vertices as not visited \r\n    let components = [];\r\n    let visited = new Set();\r\n    for (let item of graph) {\r\n        let node = item[0];\r\n        if (!visited.has(node)) {\r\n            // print all reachable vertices from v \r\n            components.push([]);\r\n            DFSUtil(graph, node, visited, components[components.length - 1]);\r\n        }\r\n    }\r\n    return components;\r\n}\r\nexports.getConnectedComponents = getConnectedComponents;\r\n//# sourceMappingURL=get-connected-components.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/graph/get-connected-components.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-boolean/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst simplify_paths_1 = __webpack_require__(/*! ./calc-paths/simplify-paths */ \"./node_modules/flo-boolean/node/calc-paths/simplify-paths.js\");\r\nexports.simplifyPaths = simplify_paths_1.simplifyPaths;\r\nconst get_loop_area_1 = __webpack_require__(/*! ./loop/get-loop-area */ \"./node_modules/flo-boolean/node/loop/get-loop-area.js\");\r\nexports.getLoopArea = get_loop_area_1.getLoopArea;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-boolean/node/debug/debug.js\");\r\nexports.enableDebugForBooleanOp = debug_1.enableDebugForBooleanOp;\r\nconst get_paths_from_str_1 = __webpack_require__(/*! ./svg/get-paths-from-str */ \"./node_modules/flo-boolean/node/svg/get-paths-from-str.js\");\r\nexports.getPathsFromStr = get_paths_from_str_1.getPathsFromStr;\r\nconst beziers_to_svg_path_str_1 = __webpack_require__(/*! ./svg/beziers-to-svg-path-str */ \"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js\");\r\nexports.beziersToSvgPathStr = beziers_to_svg_path_str_1.beziersToSvgPathStr;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/get-loop-area.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/get-loop-area.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_gauss_quadrature_1 = __webpack_require__(/*! flo-gauss-quadrature */ \"./node_modules/flo-gauss-quadrature/node/index.js\");\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\n/**\r\n * Returns the area of the given Loop.\r\n * * see e.g. https://mathinsight.org/greens_theorem_find_area\r\n */\r\nfunction getLoopArea(loop) {\r\n    let totalArea = 0;\r\n    for (let curve of loop.curves) {\r\n        let ps = curve.ps;\r\n        let x = flo_bezier3_1.getX(ps);\r\n        let y = flo_bezier3_1.getY(ps);\r\n        let dx = flo_bezier3_1.getDx(ps);\r\n        let dy = flo_bezier3_1.getDy(ps);\r\n        // xy' named as xy_\r\n        let xy_ = flo_poly_1.multiply(x, dy);\r\n        let yx_ = flo_poly_1.negate(flo_poly_1.multiply(y, dx));\r\n        let poly = flo_poly_1.add(xy_, yx_);\r\n        let f = flo_poly_1.evaluate(poly);\r\n        let area = flo_gauss_quadrature_1.gaussQuadrature(f, [0, 1], 16);\r\n        totalArea += area;\r\n    }\r\n    return -totalArea / 2;\r\n}\r\nexports.getLoopArea = getLoopArea;\r\n//# sourceMappingURL=get-loop-area.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/get-loop-area.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/get-min-y.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/get-min-y.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/**\r\n *\r\n */\r\nlet getMinY = flo_memoize_1.memoize(function getMinY(loop) {\r\n    let curves = loop.curves;\r\n    let bestY = flo_bezier3_1.getYBoundsTight(curves[0].ps).minY;\r\n    let bestCurve = curves[0];\r\n    for (let i = 1; i < curves.length; i++) {\r\n        let ps = loop.curves[i].ps;\r\n        let minY = flo_bezier3_1.getYBoundsTight(ps).minY;\r\n        let v = minY.box[0][1];\r\n        let x = bestY.box[0][1];\r\n        if (v < x || (v === x && minY.ts[0] > bestY.ts[0])) {\r\n            bestY = minY;\r\n            bestCurve = loop.curves[i];\r\n        }\r\n    }\r\n    return { curve: bestCurve, y: bestY };\r\n});\r\nexports.getMinY = getMinY;\r\n//# sourceMappingURL=get-min-y.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/get-min-y.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/loop.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/loop.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isPoint(ps) {\r\n    if (ps.length === 2) {\r\n        return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] // p[0] === p[1]\r\n        );\r\n    }\r\n    if (ps.length === 3) {\r\n        return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] && // p[0] === p[1]\r\n            ps[1][1] === ps[2][1] && ps[1][1] === ps[2][1] // p[1] === p[2]\r\n        );\r\n    }\r\n    return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] && // p[0] === p[1]\r\n        ps[1][1] === ps[2][1] && ps[1][1] === ps[2][1] && // p[1] === p[2]\r\n        ps[2][1] === ps[3][1] && ps[2][1] === ps[3][1] // p[2] === p[3]\r\n    );\r\n}\r\n/**\r\n * @param beziers A pre-ordered array of bezier curves to add initially.\r\n */\r\nfunction loopFromBeziers(beziers = []) {\r\n    let curves = [];\r\n    let loop = { beziers, curves };\r\n    if (!beziers.length) {\r\n        return loop;\r\n    }\r\n    let prev;\r\n    let j = 0;\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        if (isPoint(beziers[i])) {\r\n            continue;\r\n        }\r\n        let curve = {\r\n            loop,\r\n            ps: beziers[i],\r\n            prev,\r\n            next: undefined,\r\n            idx: j\r\n        };\r\n        if (prev) {\r\n            prev.next = curve;\r\n        }\r\n        prev = curve;\r\n        curves.push(curve);\r\n        j++;\r\n    }\r\n    // close loop\r\n    let lastCurve = curves[curves.length - 1];\r\n    curves[0].prev = lastCurve;\r\n    lastCurve.next = curves[0];\r\n    // TODO - remove this eventually\r\n    lastCurve.ps[lastCurve.ps.length - 1] = curves[0].ps[0];\r\n    return loop;\r\n}\r\nexports.loopFromBeziers = loopFromBeziers;\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if all points in the given array are different, false otherwise.\r\n * @param ps An array of points.\r\n */\r\nfunction areAllPointsDifferent(ps) {\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        for (let j = i + 1; j < ps.length; j++) {\r\n            if (ps[i][0] === ps[j][0] && ps[i][1] === ps[j][1]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.areAllPointsDifferent = areAllPointsDifferent;\r\n//# sourceMappingURL=are-all-points-different.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst are_all_points_different_1 = __webpack_require__(/*! ./are-all-points-different */ \"./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js\");\r\n// TODO - consider importing only specific functions from flo-vector2d\r\n// We currently import the entire library since we're importing from index.ts\r\n// This will reduce file size - at last check it was only 26kB minified though\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns the same bezier if its points are well-spaced, e.g. all points not\r\n * coincident, etc., else fix it, if possible, and return the fixed bezier,\r\n * else return undefined.\r\n * @param ps A bezier\r\n */\r\nfunction fixBezierByPointSpacing(ps, gridSpacing, sendToGrid) {\r\n    // Early filter - if all points coincide, we're done - degenerate to point\r\n    if (flo_bezier3_1.lengthSquaredUpperBound(ps) === 0) {\r\n        return undefined; // Cannot fix\r\n    }\r\n    if (ps.length === 2) {\r\n        // obviously no need to fix a line (that is not degenerate to a point)\r\n        return ps;\r\n    }\r\n    if (ps.length === 3) {\r\n        // Early filter - if no points coincide, we're done - well spaced\r\n        if (are_all_points_different_1.areAllPointsDifferent(ps)) {\r\n            // but if it s a line masquerading as a quadratic or cubic bezier\r\n            // then make it line\r\n            return flo_bezier3_1.isLine(ps) ? [ps[0], ps[2]] : ps;\r\n        }\r\n        // Is the quadratic bezier overlapping onto itself? \r\n        if (arePsEqual(ps[0], ps[2])) {\r\n            // a quadratic with equal endpoints (and not degenerate to a point)\r\n            // The overlap is of no consequence to the algorithm so make it a\r\n            // line\r\n            return [ps[0], ps[1]];\r\n        }\r\n        // At this point not all points same and not all points different and \r\n        // not endpoints coincide, so either:\r\n        // * point 0 and 1 coincide\r\n        // * point 1 and 2 coincide\r\n        // but in that case we simply have a line\r\n        return [ps[0], ps[2]];\r\n    }\r\n    // ---- at this point we must have a cubic\r\n    // Early filter - if no points coincide, we're done - well spaced\r\n    if (are_all_points_different_1.areAllPointsDifferent(ps)) {\r\n        return checkCubicForLineOrQuad(ps);\r\n    }\r\n    if (arePsEqual(ps[0], ps[3])) {\r\n        // we should simply handle this case for cubics - lines and quadratics \r\n        // degenerate into a point and a self-overlapping curve respectively.\r\n        if (arePsEqual(ps[1], ps[2])) {\r\n            // it is a cubic degenerated to a line\r\n            return [ps[0], ps[2]];\r\n        }\r\n        // no need to fix anything - it is a loop - it cannot be a line or a\r\n        // quadratic (they don't make loops)\r\n        return ps;\r\n    }\r\n    // At this point, either:\r\n    // * point 0, 1 and 2 coincide\r\n    // * point 1, 2 and 3 coincide\r\n    // * points 0,1 AND points 2,3 coincide\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 0 and point 2 coincides        \r\n    // * only point 1 and point 2 coincides\r\n    // * only point 1 and point 3 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // If point 0, 1 and 2 coincide OR point 1, 2 and 3 coincide OR\r\n    // points 0,1 AND points 2,3 coincide we have a line\r\n    if ((arePsEqual(ps[0], ps[1]) &&\r\n        arePsEqual(ps[1], ps[2])) ||\r\n        (arePsEqual(ps[1], ps[2]) &&\r\n            arePsEqual(ps[2], ps[3])) ||\r\n        (arePsEqual(ps[0], ps[1]) &&\r\n            arePsEqual(ps[2], ps[3]))) {\r\n        // Check if first and last point are sufficiently far apart to split\r\n        // the bezier into a line so that all points differ.\r\n        if (ps[0][0] - ps[3][0] > (3 + 1) * gridSpacing ||\r\n            ps[0][1] - ps[3][1] > (3 + 1) * gridSpacing) {\r\n            return [ps[0], ps[ps.length - 1]];\r\n        }\r\n        else {\r\n            // Points are not sufficiently far apart to resolve onto grid -\r\n            // cannot fix it - it is basically a point.\r\n            return undefined;\r\n        }\r\n    }\r\n    // At this point, either:\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 0 and point 2 coincides        \r\n    // * only point 1 and point 2 coincides\r\n    // * only point 1 and point 3 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // If points 0,2 OR points 1,3 OR points 1,2 coincide we're done - they\r\n    // are not problematic\r\n    if (arePsEqual(ps[0], ps[2]) ||\r\n        arePsEqual(ps[1], ps[3]) ||\r\n        arePsEqual(ps[1], ps[2])) {\r\n        // these kinds of cubics cannot be quadratics and the case for a line\r\n        // has already been checked - we're done\r\n        return ps;\r\n    }\r\n    // At this point, either:\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // it is a cubic with a cusp at an endpoint - these are fine for our\r\n    // algorithm but lets move them a little apart for later alogorithms \r\n    // operating on our returned result.\r\n    if (arePsEqual(ps[0], ps[1])) {\r\n        // Move point 1 towards point 2 without surpassing it and ensuring it\r\n        // will be on a new grid point\r\n        // If squared distance between the points < 4 * gridSpacing just \r\n        // move them onto each other - this shouldn't affect the overall \r\n        // accuracy of the algorithm and it ensures the move > gridSpacing.\r\n        if (flo_vector2d_1.squaredDistanceBetween(ps[1], ps[2]) < 4 * gridSpacing) {\r\n            return [\r\n                ps[0],\r\n                ps[2],\r\n                ps[2],\r\n                ps[3]\r\n            ]; // cannot be a line or quad\r\n        }\r\n        else {\r\n            let v = flo_vector2d_1.toLength(flo_vector2d_1.fromTo(ps[1], ps[2]), 2 * gridSpacing);\r\n            let p1 = flo_vector2d_1.translate(ps[1], v);\r\n            return checkCubicForLineOrQuad([\r\n                ps[0],\r\n                sendToGrid(p1),\r\n                ps[2],\r\n                ps[3]\r\n            ]);\r\n        }\r\n    }\r\n    if (arePsEqual(ps[2], ps[3])) {\r\n        // Move point 2 towards point 1 without surpassing it and ensuring it\r\n        // will be on a new grid point\r\n        // If squared distance between the points < 4 * gridSpacing just \r\n        // move them onto each other - this shouldn't affect the overall \r\n        // accuracy of the algorithm and it ensures the move > gridSpacing.\r\n        if (flo_vector2d_1.squaredDistanceBetween(ps[2], ps[1]) < 4 * gridSpacing) {\r\n            return [\r\n                ps[0],\r\n                ps[1],\r\n                ps[1],\r\n                ps[3]\r\n            ]; // cannot be a line or quad\r\n        }\r\n        else {\r\n            let v = flo_vector2d_1.toLength(flo_vector2d_1.fromTo(ps[2], ps[1]), 2 * gridSpacing);\r\n            let p2 = flo_vector2d_1.translate(ps[2], v);\r\n            return checkCubicForLineOrQuad([\r\n                ps[0],\r\n                ps[1],\r\n                sendToGrid(p2),\r\n                ps[3]\r\n            ]);\r\n        }\r\n    }\r\n}\r\nexports.fixBezierByPointSpacing = fixBezierByPointSpacing;\r\nfunction checkCubicForLineOrQuad(ps) {\r\n    return flo_bezier3_1.isLine(ps)\r\n        ? [ps[0], ps[3]]\r\n        : flo_bezier3_1.isCubicReallyQuad(ps)\r\n            ? flo_bezier3_1.toQuadraticFromCubic(ps)\r\n            : ps;\r\n}\r\n/** Returns true if the points are the same */\r\nfunction arePsEqual(p1, p2) {\r\n    return p1[0] === p2[0] && p1[1] === p2[1];\r\n}\r\n//# sourceMappingURL=fix-bezier-by-point-spacing.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst to_grid_1 = __webpack_require__(/*! ./to-grid */ \"./node_modules/flo-boolean/node/loop/normalize/to-grid.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst fix_bezier_by_point_spacing_1 = __webpack_require__(/*! ./fix-bezier-by-point-spacing */ \"./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js\");\r\nfunction sendToGrid(expMax, maxBitLength) {\r\n    return (p) => [\r\n        to_grid_1.toGrid(p[0], expMax, maxBitLength),\r\n        to_grid_1.toGrid(p[1], expMax, maxBitLength)\r\n    ];\r\n}\r\nfunction sendToGridNoop(p) { return p; }\r\n/**\r\n * Returns the grid-aligned loop derived from the given input loop.\r\n *\r\n * Also ensures that:\r\n * * All points are coerced onto a grid.\r\n * * All bezier points of a single curve are seperated.\r\n * @param expMax The exponent, e, such that 2^e > all bezier coordinate points.\r\n * @param maxBitLength\r\n */\r\nfunction fixBeziers(expMax, maxBitLength, doSendToGrid = true) {\r\n    /** The actual control point grid spacing */\r\n    let gridSpacing = Math.pow(2, expMax) * Math.pow(2, (-maxBitLength));\r\n    let sendToGrid_ = doSendToGrid\r\n        ? sendToGrid(expMax, maxBitLength)\r\n        : sendToGridNoop;\r\n    return (loop) => {\r\n        let newPss = [];\r\n        for (let i = 0; i < loop.length; i++) {\r\n            let ps = loop[i].slice();\r\n            // Get endpoint of last good bezier or else the original start point\r\n            let len = newPss.length;\r\n            let prevGoodBezier = newPss[len - 1];\r\n            let prevGoodBezierEndpoint = prevGoodBezier\r\n                ? prevGoodBezier[prevGoodBezier.length - 1]\r\n                : sendToGrid_(loop[0][0]); // Bit-align original start point\r\n            // Set the start point to the previous good bezier's endpoint\r\n            ps[0] = prevGoodBezierEndpoint;\r\n            // Align to grid before doing any further checks\r\n            ps = ps.map(p => sendToGrid_(p));\r\n            // Check if ps degenerates into a self-overlapping line\r\n            if (flo_bezier3_1.isSelfOverlapping(ps)) {\r\n                // Change into a line with endponts that of the original bezier\r\n                ps = [ps[0], ps[ps.length - 1]];\r\n            }\r\n            ps = fix_bezier_by_point_spacing_1.fixBezierByPointSpacing(ps, gridSpacing, sendToGrid_);\r\n            if (ps) {\r\n                newPss.push(ps);\r\n            }\r\n        }\r\n        let len = newPss.length;\r\n        if (!len) {\r\n            return [];\r\n        }\r\n        // Connect the last bezier end-point to the first bezier start-point.\r\n        let ps = newPss[len - 1];\r\n        ps[ps.length - 1] = newPss[0][0];\r\n        return newPss;\r\n    };\r\n}\r\nexports.fixBeziers = fixBeziers;\r\n//# sourceMappingURL=fix-beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/**\r\n * Returns the maximum control point coordinate value (x or y) within any loop.\r\n * @param loops The array of loops\r\n */\r\nlet getMaxCoordinate = flo_memoize_1.memoize((loops) => {\r\n    let max = 0;\r\n    for (let loop of loops) {\r\n        for (let ps of loop) {\r\n            for (let p of ps) {\r\n                for (let c of p) {\r\n                    let c_ = Math.abs(c);\r\n                    if (c_ > max) {\r\n                        max = c_;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return max;\r\n});\r\nexports.getMaxCoordinate = getMaxCoordinate;\r\n//# sourceMappingURL=get-max-coordinate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst fix_beziers_1 = __webpack_require__(/*! ./fix-beziers */ \"./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js\");\r\nconst to_grid_1 = __webpack_require__(/*! ./to-grid */ \"./node_modules/flo-boolean/node/loop/normalize/to-grid.js\");\r\n/**\r\n * Returns new loops from the given loops by aligning the 53-bit double\r\n * precision coordinates to 46-bit coordinates. This speeds up the algorithm\r\n * considerably.\r\n *\r\n * The following guarantees are put in place for the returned loops:\r\n * * All points are coerced onto a grid. In other words, such that the\r\n *   significand of all coordinates are reduced to a specified number of bits\r\n *   and the significant bits of all points 'overlap'.\r\n *\r\n * * No curves are disguised as higher order curves (this includes the case\r\n *   that no bezier is of zero length and the case where there are an infinite\r\n *   number of self-intersections). The curves are simply deflated exactly.\r\n *\r\n * * No cusps (this includes the case that all bezier end-points of each curve\r\n *   are seperated. (this prevents infinite curvature at the endpoints, etc).\r\n *   (this condition is not necessary for this algorithm but may help algorithms\r\n *    down the line that needs such guarantees)\r\n * @param loop\r\n * @param maxBitLength\r\n * @param expMax\r\n */\r\nfunction normalizeLoops(bezierLoops, maxBitLength, expMax, doScramble = false, doSendToGrid = true) {\r\n    let fixBeziers_ = fix_beziers_1.fixBeziers(expMax, maxBitLength, doSendToGrid);\r\n    let loops = bezierLoops.slice();\r\n    // just for testing purposes\r\n    loops = doScramble ? scrambleLoops(loops, maxBitLength, expMax, 1) : loops;\r\n    loops = loops.map(fixBeziers_);\r\n    loops = loops.filter(loop => loop.length > 0);\r\n    return loops;\r\n}\r\nexports.normalizeLoops = normalizeLoops;\r\n/** Just for testing purposes - not used in the actual algorithm */\r\nfunction scrambleLoops(loops, maxBitLength, expMax, mult = 0.02) {\r\n    let loops_ = [];\r\n    for (let loop of loops) {\r\n        let loop_ = [];\r\n        for (let bez of loop) {\r\n            let bez_ = bez.map(v => v.map(c => {\r\n                let c_ = 0;\r\n                let ii = 0;\r\n                let bl = 0;\r\n                let mblc;\r\n                let mbl = 0;\r\n                while (true) {\r\n                    if (++ii > 10) {\r\n                        break;\r\n                    }\r\n                    c_ = (c + Math.random()) * (1 + ((Math.random() - 0.7) * mult));\r\n                    c_ = to_grid_1.toGrid(c_, expMax, maxBitLength);\r\n                    let bl = flo_numerical_1.bitLength(c_);\r\n                    if (bl > mbl) {\r\n                        mbl = bl;\r\n                        mblc = c_;\r\n                    }\r\n                }\r\n                return mblc;\r\n            }));\r\n            loop_.push(bez_);\r\n        }\r\n        loops_.push(loop_);\r\n    }\r\n    return loops_;\r\n}\r\n//# sourceMappingURL=normalize-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/normalize/to-grid.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/normalize/to-grid.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Sends a onto a fixed-spacing grid with 2**significantFigures divisions. Each\r\n * division is 2**maxExp / 2**significantFigures wide.\r\n * @param a\r\n * @param expMax log2(max extent of grid in positive and negative directions)\r\n *\r\n * @param significantFigures\r\n */\r\nfunction toGrid(a, expMax, significantFigures) {\r\n    let expA = Math.floor(Math.log2(Math.abs(a)));\r\n    let expDif = expMax - expA;\r\n    let newSig = significantFigures - expDif + 1;\r\n    if (newSig <= 0) {\r\n        return 0;\r\n    }\r\n    if (significantFigures >= 53) {\r\n        return a;\r\n    }\r\n    return flo_numerical_1.reduceSignificand(a, newSig);\r\n}\r\nexports.toGrid = toGrid;\r\n//# sourceMappingURL=to-grid.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/normalize/to-grid.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/loop/reverse-orientation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/loop/reverse-orientation.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-boolean/node/loop/loop.js\");\r\n/**\r\n * Returns a completely reversed loop of the given bezier loop.\r\n * @param loop\r\n */\r\nfunction reverseOrientation(loop) {\r\n    let beziers = [];\r\n    let curves = loop.curves;\r\n    for (let i = curves.length - 1; i >= 0; i--) {\r\n        let curve = flo_bezier3_1.reverse(curves[i].ps);\r\n        beziers.push(curve);\r\n    }\r\n    return loop_1.loopFromBeziers(beziers);\r\n}\r\nexports.reverseOrientation = reverseOrientation;\r\n//# sourceMappingURL=reverse-orientation.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/loop/reverse-orientation.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// TODO - a work in progress - currently using a different (less accurate?) \r\n// function.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * Get an array of corresponding cubic bezier curve parameters for given arc\r\n * curve paramters.\r\n */\r\nfunction arcToCubicCurves(\r\n/** the start point */\r\npS, \r\n/** radius x */\r\nrx, \r\n/** radius y */\r\nry, \r\n/** x-axis rotation - in degrees */\r\nrotationAngle, largeArcFlag, sweepFlag, pE) {\r\n    return [[\r\n            pS,\r\n            pE\r\n        ]];\r\n}\r\nexports.arcToCubicCurves = arcToCubicCurves;\r\n/**\r\n * @param x\r\n * @param y\r\n * @param angleRad\r\n */\r\nfunction rotate(x, y, angleRad) {\r\n    let X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\r\n    let Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\r\n    return { x: X, y: Y };\r\n}\r\n/**\r\n * @param degrees\r\n */\r\nfunction degToRad(degrees) {\r\n    return (Math.PI * degrees) / 180;\r\n}\r\n//# sourceMappingURL=arc-to-cubic-curves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an SVG path string representation of the given bezier loop.\r\n * @param beziers An array of bezier curves each given as an array of\r\n * control points.\r\n */\r\nfunction beziersToSvgPathStr(beziers) {\r\n    let str = '';\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        if (i === 0) {\r\n            str = 'M ' +\r\n                ps[0][0].toString() + ' ' +\r\n                ps[0][1].toString() + '\\n';\r\n        }\r\n        if (ps.length === 4) {\r\n            str += 'C ' +\r\n                ps[1][0].toString() + ' ' +\r\n                ps[1][1].toString() + ' ' +\r\n                ps[2][0].toString() + ' ' +\r\n                ps[2][1].toString() + ' ' +\r\n                ps[3][0].toString() + ' ' +\r\n                ps[3][1].toString() + ' ' + '\\n';\r\n        }\r\n        else if (ps.length === 3) {\r\n            str += 'Q ' +\r\n                ps[1][0].toString() + ' ' +\r\n                ps[1][1].toString() + ' ' +\r\n                ps[2][0].toString() + ' ' +\r\n                ps[2][1].toString() + ' ' + '\\n';\r\n        }\r\n        else if (ps.length === 2) {\r\n            str += 'L ' +\r\n                ps[1][0].toString() + ' ' +\r\n                ps[1][1].toString() + ' ' + '\\n';\r\n        }\r\n    }\r\n    return str + ' z' + '\\n';\r\n}\r\nexports.beziersToSvgPathStr = beziersToSvgPathStr;\r\n//# sourceMappingURL=beziers-to-svg-path-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_state_1 = __webpack_require__(/*! ./path-state */ \"./node_modules/flo-boolean/node/svg/path-state.js\");\r\nconst z_1 = __webpack_require__(/*! ./path-segment/z */ \"./node_modules/flo-boolean/node/svg/path-segment/z.js\");\r\nconst c_1 = __webpack_require__(/*! ./path-segment/c */ \"./node_modules/flo-boolean/node/svg/path-segment/c.js\");\r\nconst s_1 = __webpack_require__(/*! ./path-segment/s */ \"./node_modules/flo-boolean/node/svg/path-segment/s.js\");\r\nconst l_1 = __webpack_require__(/*! ./path-segment/l */ \"./node_modules/flo-boolean/node/svg/path-segment/l.js\");\r\nconst h_1 = __webpack_require__(/*! ./path-segment/h */ \"./node_modules/flo-boolean/node/svg/path-segment/h.js\");\r\nconst v_1 = __webpack_require__(/*! ./path-segment/v */ \"./node_modules/flo-boolean/node/svg/path-segment/v.js\");\r\nconst q_1 = __webpack_require__(/*! ./path-segment/q */ \"./node_modules/flo-boolean/node/svg/path-segment/q.js\");\r\nconst t_1 = __webpack_require__(/*! ./path-segment/t */ \"./node_modules/flo-boolean/node/svg/path-segment/t.js\");\r\nconst a_1 = __webpack_require__(/*! ./path-segment/a */ \"./node_modules/flo-boolean/node/svg/path-segment/a.js\");\r\nconst pathFs = {\r\n    //a, // elliptical arc\r\n    c: c_1.c,\r\n    h: // cubic bezier\r\n    h_1.h,\r\n    l: // horizontal line\r\n    l_1.l,\r\n    q: // line\r\n    q_1.q,\r\n    s: // quadratic bezier\r\n    s_1.s,\r\n    t: // cubic bezier (smooth)\r\n    t_1.t,\r\n    v: // quadratic bezier (smooth)\r\n    v_1.v,\r\n    z: // vertical line\r\n    z_1.z // close path\r\n};\r\n/**\r\n * Returns order 1, 2 and 3 beziers from the given SVG DOM element. If a path\r\n * data tag is not \"C, Q or L, etc\", i.e. if it is not an absolute bezier\r\n * coordinate then it is converted into one.\r\n * @param paths An SVG element\r\n */\r\nfunction getBeziersFromRawPaths(paths) {\r\n    if (paths.length === 0) {\r\n        return []; // A shape is not described   \r\n    }\r\n    if (paths[0].type.toLowerCase() !== 'm') {\r\n        throw new Error('Invalid SVG - every new path must start with an M or m.');\r\n    }\r\n    let s = new path_state_1.PathState();\r\n    let beziersArrays = [];\r\n    let beziers = [];\r\n    let prevType;\r\n    for (let i = 0; i < paths.length; i++) {\r\n        let pathSeg = paths[i];\r\n        let type = pathSeg.type.toLowerCase();\r\n        s.vals = pathSeg.values;\r\n        // If pathSeg was lowercase, it is relative - make absolute\r\n        if (pathSeg.type === type) {\r\n            if (type === 'v') {\r\n                s.vals[0] += s.p[1];\r\n            }\r\n            else if (type === 'a') {\r\n                s.vals[5] += s.p[0];\r\n                s.vals[6] += s.p[1];\r\n            }\r\n            else {\r\n                for (let i = 0; i < s.vals.length; i++) {\r\n                    s.vals[i] += s.p[i % 2];\r\n                }\r\n            }\r\n        }\r\n        if (type === 'm') {\r\n            if (beziers.length) {\r\n                // This is a subpath, close as if the previous command was a \r\n                // Z or z.\r\n                if (prevType !== 'z') {\r\n                    beziers.push(z_1.z(s));\r\n                }\r\n                // Start new path\r\n                beziersArrays.push(beziers);\r\n                beziers = [];\r\n            }\r\n            s.initialPoint = s.p = s.vals;\r\n            prevType = type;\r\n            continue;\r\n        }\r\n        if (type === 'a') {\r\n            beziers.push(...a_1.a(s));\r\n        }\r\n        else {\r\n            let f = pathFs[type];\r\n            if (!f) {\r\n                throw new Error('Invalid SVG - command not recognized.');\r\n            }\r\n            let ps = f(s);\r\n            s.p = ps[ps.length - 1]; // Update current point\r\n            beziers.push(ps);\r\n        }\r\n        prevType = type;\r\n    }\r\n    if (beziers.length) {\r\n        // This is a subpath, close as if the previous command was a Z or z.\r\n        if (prevType !== 'z') {\r\n            beziers.push(z_1.z(s));\r\n        }\r\n        // Start new path\r\n        beziersArrays.push(beziers);\r\n    }\r\n    return beziersArrays;\r\n}\r\nexports.getBeziersFromRawPaths = getBeziersFromRawPaths;\r\n//# sourceMappingURL=get-beziers-from-raw-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/get-paths-from-str.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/get-paths-from-str.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_beziers_from_raw_paths_1 = __webpack_require__(/*! ./get-beziers-from-raw-paths */ \"./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js\");\r\nconst parse_path_data_string_1 = __webpack_require__(/*! ./path-data-polyfill/parse-path-data-string */ \"./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js\");\r\n/**\r\n * Returns an array of loops with each loop consisting of an array of beziers\r\n * and each bezier in turn consisting of an array of control points from the\r\n * given SVG path string. An array of loops are returned (as opposed to a single\r\n * loop) since an SVG path may have sub-paths.\r\n * @param str The SVG path string, e.g. 'M1 1 C 5 1 5 2 4 2 C 3 3 1 3 1 1 z'\r\n */\r\nfunction getPathsFromStr(str) {\r\n    return get_beziers_from_raw_paths_1.getBeziersFromRawPaths(parse_path_data_string_1.parsePathDataString(str));\r\n}\r\nexports.getPathsFromStr = getPathsFromStr;\r\n//# sourceMappingURL=get-paths-from-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/get-paths-from-str.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst beziers_to_svg_path_str_1 = __webpack_require__(/*! ./beziers-to-svg-path-str */ \"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js\");\r\n/**\r\n * Returns an SVG path string representation of the given bezier loops.\r\n * @param loops An array of loops having an array of bezier curves each given as\r\n * an array of control points.\r\n */\r\nfunction loopsToSvgPathStr(loops) {\r\n    let str = '';\r\n    for (let loop of loops) {\r\n        str = str + beziers_to_svg_path_str_1.beziersToSvgPathStr(loop) + '\\n';\r\n    }\r\n    return str;\r\n}\r\nexports.loopsToSvgPathStr = loopsToSvgPathStr;\r\n//# sourceMappingURL=loops-to-svg-path-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\r\n * Source/core/svg/SVGParserUtilities.cpp.\r\n * Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\r\n * @param source\r\n */\r\nfunction parseNumber(source) {\r\n    var exponent = 0;\r\n    var integer = 0;\r\n    var frac = 1;\r\n    var decimal = 0;\r\n    var sign = 1;\r\n    var expsign = 1;\r\n    var startIndex = source._currentIndex;\r\n    source._skipOptionalSpaces();\r\n    // Read the sign.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"+\") {\r\n        source._currentIndex += 1;\r\n    }\r\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \"-\") {\r\n        source._currentIndex += 1;\r\n        sign = -1;\r\n    }\r\n    if (source._currentIndex === source._endIndex ||\r\n        ((source._string[source._currentIndex] < \"0\" || source._string[source._currentIndex] > \"9\") &&\r\n            source._string[source._currentIndex] !== \".\")) {\r\n        // The first character of a number must be one of [0-9+-.].\r\n        return null;\r\n    }\r\n    // Read the integer part, build right-to-left.\r\n    var startIntPartIndex = source._currentIndex;\r\n    while (source._currentIndex < source._endIndex &&\r\n        source._string[source._currentIndex] >= \"0\" &&\r\n        source._string[source._currentIndex] <= \"9\") {\r\n        source._currentIndex += 1; // Advance to first non-digit.\r\n    }\r\n    if (source._currentIndex !== startIntPartIndex) {\r\n        var scanIntPartIndex = source._currentIndex - 1;\r\n        var multiplier = 1;\r\n        while (scanIntPartIndex >= startIntPartIndex) {\r\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\r\n            scanIntPartIndex -= 1;\r\n            multiplier *= 10;\r\n        }\r\n    }\r\n    // Read the decimals.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === \".\") {\r\n        source._currentIndex += 1;\r\n        // There must be a least one digit following the .\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < \"0\" ||\r\n            source._string[source._currentIndex] > \"9\") {\r\n            return null;\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= \"0\" &&\r\n            source._string[source._currentIndex] <= \"9\") {\r\n            frac *= 10;\r\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    // Read the exponent part.\r\n    if (source._currentIndex !== startIndex &&\r\n        source._currentIndex + 1 < source._endIndex &&\r\n        (source._string[source._currentIndex] === \"e\" || source._string[source._currentIndex] === \"E\") &&\r\n        (source._string[source._currentIndex + 1] !== \"x\" && source._string[source._currentIndex + 1] !== \"m\")) {\r\n        source._currentIndex += 1;\r\n        // Read the sign of the exponent.\r\n        if (source._string[source._currentIndex] === \"+\") {\r\n            source._currentIndex += 1;\r\n        }\r\n        else if (source._string[source._currentIndex] === \"-\") {\r\n            source._currentIndex += 1;\r\n            expsign = -1;\r\n        }\r\n        // There must be an exponent.\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < \"0\" ||\r\n            source._string[source._currentIndex] > \"9\") {\r\n            return null;\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= \"0\" &&\r\n            source._string[source._currentIndex] <= \"9\") {\r\n            exponent *= 10;\r\n            exponent += (Number(source._string[source._currentIndex]));\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    var number = integer + decimal;\r\n    number *= sign;\r\n    if (exponent) {\r\n        number *= Math.pow(10, expsign * exponent);\r\n    }\r\n    if (startIndex === source._currentIndex) {\r\n        return null;\r\n    }\r\n    source._skipOptionalSpacesOrDelimiter();\r\n    return number;\r\n}\r\nexports.parseNumber = parseNumber;\r\n//# sourceMappingURL=parse-number.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst source_1 = __webpack_require__(/*! ./source */ \"./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js\");\r\n/**\r\n * @hidden\r\n * @param string\r\n */\r\nfunction parsePathDataString(string) {\r\n    if (!string.length)\r\n        return [];\r\n    let source = new source_1.Source(string);\r\n    let pathData = [];\r\n    if (!source.initialCommandIsMoveTo()) {\r\n        return [];\r\n    }\r\n    while (source.hasMoreData()) {\r\n        let pathSeg = source.parseSegment();\r\n        if (pathSeg === null) {\r\n            break;\r\n        }\r\n        else {\r\n            pathData.push(pathSeg);\r\n        }\r\n    }\r\n    return pathData;\r\n}\r\nexports.parsePathDataString = parsePathDataString;\r\n//# sourceMappingURL=parse-path-data-string.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_number_1 = __webpack_require__(/*! ./parse-number */ \"./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js\");\r\n/** @hidden */\r\nconst COMMAND_MAP = {\r\n    \"Z\": \"Z\", \"M\": \"M\", \"L\": \"L\", \"C\": \"C\", \"Q\": \"Q\", \"A\": \"A\", \"H\": \"H\", \"V\": \"V\", \"S\": \"S\", \"T\": \"T\",\r\n    \"z\": \"Z\", \"m\": \"m\", \"l\": \"l\", \"c\": \"c\", \"q\": \"q\", \"a\": \"a\", \"h\": \"h\", \"v\": \"v\", \"s\": \"s\", \"t\": \"t\"\r\n};\r\n/** @hidden */\r\nclass Source {\r\n    constructor(string) {\r\n        this._string = string;\r\n        this._currentIndex = 0;\r\n        this._endIndex = this._string.length;\r\n        this._prevCommand = null;\r\n        this._skipOptionalSpaces();\r\n    }\r\n    parseSegment() {\r\n        var char = this._string[this._currentIndex];\r\n        var command = COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\r\n        if (command === null) {\r\n            // Possibly an implicit command. Not allowed if this is the first command.\r\n            if (this._prevCommand === null) {\r\n                return null;\r\n            }\r\n            // Check for remaining coordinates in the current command.\r\n            if ((char === \"+\" || char === \"-\" || char === \".\" || (char >= \"0\" && char <= \"9\")) && this._prevCommand !== \"Z\") {\r\n                if (this._prevCommand === \"M\") {\r\n                    command = \"L\";\r\n                }\r\n                else if (this._prevCommand === \"m\") {\r\n                    command = \"l\";\r\n                }\r\n                else {\r\n                    command = this._prevCommand;\r\n                }\r\n            }\r\n            else {\r\n                command = null;\r\n            }\r\n            if (command === null) {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            this._currentIndex += 1;\r\n        }\r\n        this._prevCommand = command;\r\n        var values = null;\r\n        var cmd = command.toUpperCase();\r\n        if (cmd === \"H\" || cmd === \"V\") {\r\n            values = [parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\r\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"S\" || cmd === \"Q\") {\r\n            values = [parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this), parse_number_1.parseNumber(this)];\r\n        }\r\n        else if (cmd === \"C\") {\r\n            values = [\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this)\r\n            ];\r\n        }\r\n        else if (cmd === \"A\") {\r\n            values = [\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this),\r\n                this._parseArcFlag(),\r\n                this._parseArcFlag(),\r\n                parse_number_1.parseNumber(this),\r\n                parse_number_1.parseNumber(this)\r\n            ];\r\n        }\r\n        else if (cmd === \"Z\") {\r\n            this._skipOptionalSpaces();\r\n            values = [];\r\n        }\r\n        if (values === null || values.indexOf(null) >= 0) {\r\n            // Unknown command or known command with invalid values\r\n            return null;\r\n        }\r\n        else {\r\n            return { type: command, values };\r\n        }\r\n    }\r\n    hasMoreData() {\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    peekSegmentType() {\r\n        var char = this._string[this._currentIndex];\r\n        return COMMAND_MAP[char] ? COMMAND_MAP[char] : null;\r\n    }\r\n    initialCommandIsMoveTo() {\r\n        // If the path is empty it is still valid, so return true.\r\n        if (!this.hasMoreData()) {\r\n            return true;\r\n        }\r\n        var command = this.peekSegmentType();\r\n        // Path must start with moveTo.\r\n        return command === \"M\" || command === \"m\";\r\n    }\r\n    _isCurrentSpace() {\r\n        var char = this._string[this._currentIndex];\r\n        return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\r\n    }\r\n    _skipOptionalSpaces() {\r\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\r\n            this._currentIndex += 1;\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _skipOptionalSpacesOrDelimiter() {\r\n        if (this._currentIndex < this._endIndex &&\r\n            !this._isCurrentSpace() &&\r\n            this._string[this._currentIndex] !== \",\") {\r\n            return false;\r\n        }\r\n        if (this._skipOptionalSpaces()) {\r\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\r\n                this._currentIndex += 1;\r\n                this._skipOptionalSpaces();\r\n            }\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _parseArcFlag() {\r\n        if (this._currentIndex >= this._endIndex) {\r\n            return null;\r\n        }\r\n        var flag = null;\r\n        var flagChar = this._string[this._currentIndex];\r\n        this._currentIndex += 1;\r\n        if (flagChar === \"0\") {\r\n            flag = 0;\r\n        }\r\n        else if (flagChar === \"1\") {\r\n            flag = 1;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n        this._skipOptionalSpacesOrDelimiter();\r\n        return flag;\r\n    }\r\n}\r\nexports.Source = Source;\r\n//# sourceMappingURL=source.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/a.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/a.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst arc_to_cubic_curves_1 = __webpack_require__(/*! ../arc-to-cubic-curves */ \"./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js\");\r\n/**\r\n * @hidden\r\n * A and a: (from www.w3.org)\r\n *\r\n * params: rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n *\r\n * Draws an elliptical arc from the current point to (x, y). The size and\r\n * orientation of the ellipse are defined by two radii (rx, ry) and an\r\n * x-axis-rotation, which indicates how the ellipse as a whole is rotated\r\n * relative to the current coordinate system. The center (cx, cy) of the ellipse\r\n * is calculated automatically to satisfy the constraints imposed by the other\r\n * parameters. large-arc-flag and sweep-flag contribute to the automatic\r\n * calculations and help determine how the arc is drawn.\r\n */\r\nfunction a(s) {\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    let curves = arc_to_cubic_curves_1.arcToCubicCurves(s.p, s.vals[0], s.vals[1], s.vals[2], s.vals[3], s.vals[4], [s.vals[5], s.vals[6]]);\r\n    let lastPs = curves[curves.length - 1];\r\n    s.p = lastPs[lastPs.length - 1]; // Update current point\r\n    return curves;\r\n}\r\nexports.a = a;\r\n//# sourceMappingURL=a.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/a.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/c.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/c.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * C and c: (from www.w3.org)\r\n *\r\n * params: x1 y1 x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y)\r\n * using (x1,y1) as the control point at the beginning of the\r\n * curve and (x2,y2) as the control point at the end of the\r\n * curve. C (uppercase) indicates that absolute coordinates\r\n * will follow; c (lowercase) indicates that relative\r\n * coordinates will follow. Multiple sets of coordinates may\r\n * be specified to draw a polybézier. At the end of the\r\n * command, the new current point becomes the final (x,y)\r\n * coordinate pair used in the polybézier.\r\n */\r\nfunction c(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]],\r\n        [s.vals[4], s.vals[5]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.c = c;\r\n//# sourceMappingURL=c.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/c.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/h.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/h.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * H and h: (from www.w3.org)\r\n *\r\n * params: x\r\n *\r\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\r\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\r\n * indicates that relative coordinates will follow. Multiple x values can be\r\n * provided (although usually this doesn't make sense). At the end of the\r\n * command, the new current point becomes (x, cpy) for the final value of x.\r\n */\r\nfunction h(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.vals[0], s.p[1]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.h = h;\r\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/h.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/l.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/l.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * L and l: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draw a line from the current point to the given (x,y) coordinate which\r\n * becomes the new current point. L (uppercase) indicates that absolute\r\n * coordinates will follow; l (lowercase) indicates that relative coordinates\r\n * will follow. A number of coordinates pairs may be specified to draw a\r\n * polyline. At the end of the command, the new current point is set to the\r\n * final set of coordinates provided.\r\n */\r\nfunction l(s) {\r\n    let ps = [\r\n        s.p,\r\n        s.vals\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.l = l;\r\n//# sourceMappingURL=l.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/l.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/q.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/q.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * Q and q: (from www.w3.org)\r\n *\r\n * params: x1 y1 x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\r\n * as the control point. Q (uppercase) indicates that absolute coordinates will\r\n * follow; q (lowercase) indicates that relative coordinates will follow.\r\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\r\n * end of the command, the new current point becomes the final (x,y) coordinate\r\n * pair used in the polybézier.\r\n */\r\nfunction q(s) {\r\n    let QP1 = [s.vals[0], s.vals[1]];\r\n    let QP2 = [s.vals[2], s.vals[3]];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    let ps = [s.p, QP1, QP2];\r\n    return ps;\r\n}\r\nexports.q = q;\r\n//# sourceMappingURL=q.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/q.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/s.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/s.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * S and s: (from www.w3.org)\r\n *\r\n * params: x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\r\n * point is assumed to be the reflection of the second control point on the\r\n * previous command relative to the current point. (If there is no previous\r\n * command or if the previous command was not an C, c, S or s, assume the first\r\n * control point is coincident with the current point.) (x2,y2) is the second\r\n * control point (i.e., the control point at the end of the curve). S\r\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\r\n * indicates that relative coordinates will follow. Multiple sets of coordinates\r\n * may be specified to draw a polybézier. At the end of the command, the new\r\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction s(s) {\r\n    let p = [undefined, undefined];\r\n    if (s.prev2ndCubicControlPoint) {\r\n        p[0] = (s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0];\r\n        p[1] = (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1];\r\n    }\r\n    else {\r\n        p = s.p;\r\n    }\r\n    let ps = [\r\n        s.p,\r\n        p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.s = s;\r\n//# sourceMappingURL=s.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/s.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/t.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/t.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * T and t: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\r\n * point is assumed to be the reflection of the control point on the previous\r\n * command relative to the current point. (If there is no previous command or if\r\n * the previous command was not a Q, q, T or t, assume the control point is\r\n * coincident with the current point.) T (uppercase) indicates that absolute\r\n * coordinates will follow; t (lowercase) indicates that relative coordinates\r\n * will follow. At the end of the command, the new current point becomes the\r\n * final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction t(s) {\r\n    let p = [undefined, undefined];\r\n    if (s.prev2ndQuadraticControlPoint) {\r\n        p[0] = (s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0];\r\n        p[1] = (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1];\r\n    }\r\n    else {\r\n        p = s.p;\r\n    }\r\n    let QP1 = p;\r\n    let QP2 = [s.vals[0], s.vals[1]];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    return [s.p, QP1, QP2];\r\n}\r\nexports.t = t;\r\n//# sourceMappingURL=t.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/t.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/v.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/v.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * V and v: (from www.w3.org)\r\n *\r\n * params: y\r\n *\r\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\r\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\r\n * indicates that relative coordinates will follow. Multiple y values can be\r\n * provided (although usually this doesn't make sense). At the end of the\r\n * command, the new current point becomes (cpx, y) for the final value of y.\r\n */\r\nfunction v(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0], s.vals[0]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.v = v;\r\n//# sourceMappingURL=v.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/v.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-segment/z.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-segment/z.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * Z and z: (from www.w3.org)\r\n *\r\n * params: (none)\r\n *\r\n * Close the current subpath by drawing a straight line from the current point\r\n * to current subpath's initial point. Since the Z and z commands take no\r\n * parameters, they have an identical effect.\r\n */\r\nfunction z(s) {\r\n    let ps = [\r\n        s.p,\r\n        s.initialPoint\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\nexports.z = z;\r\n//# sourceMappingURL=z.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-segment/z.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/svg/path-state.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-boolean/node/svg/path-state.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nclass PathState {\r\n    constructor() {\r\n        this.initialPoint = undefined;\r\n        // Used in conjunction with \"S\", \"s\"\r\n        this.prev2ndCubicControlPoint = undefined;\r\n        // Used in conjunction with \"T\", \"t\"\r\n        this.prev2ndQuadraticControlPoint = undefined;\r\n        this.p = [0, 0];\r\n    }\r\n}\r\nexports.PathState = PathState;\r\n//# sourceMappingURL=path-state.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/svg/path-state.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if the 2 given axis-aligned rectangular boxes intersect.\r\n * @param a An axis-aligned rectangular box\r\n * @param b Another axis-aligned rectangular box\r\n * @param closed (defaults to false) Interpret boxes as being closed (i.e. they\r\n * contain their border) or open. If open then if both boxes have zero area\r\n * then they are both considered close.\r\n */\r\nfunction areBoxesIntersecting(closed) {\r\n    return (a, b) => {\r\n        let [[ax0, ay0], [ax1, ay1]] = a;\r\n        let [[bx0, by0], [bx1, by1]] = b;\r\n        // If open then if both boxes have zero area then they are both \r\n        // considered closed.\r\n        /*if ((ax0 === ax1 || ay0 === ay1) && (bx0 === bx1 || by0 === by1)) {\r\n            closed = true;\r\n        }*/\r\n        // Swap so smaller coordinate comes first\r\n        if (ay0 > ay1) {\r\n            [ay0, ay1] = [ay1, ay0];\r\n        }\r\n        ;\r\n        if (by0 > by1) {\r\n            [by0, by1] = [by1, by0];\r\n        }\r\n        ;\r\n        if (ax0 > ax1) {\r\n            [ax0, ax1] = [ax1, ax0];\r\n        }\r\n        ;\r\n        if (bx0 > bx1) {\r\n            [bx0, bx1] = [bx1, bx0];\r\n        }\r\n        ;\r\n        return closed\r\n            ? (ax0 <= bx1 && ax1 >= bx0 &&\r\n                by0 <= ay1 && by1 >= ay0)\r\n            : (ax0 < bx1 && ax1 > bx0 &&\r\n                by0 < ay1 && by1 > ay0);\r\n    };\r\n}\r\nexports.areBoxesIntersecting = areBoxesIntersecting;\r\n/**\r\n * Returns true if the 2 given axis-aligned rectangular boxes intersect.\r\n * @param a An axis-aligned rectangular box\r\n * @param b Another axis-aligned rectangular box\r\n * @param closed (defaults to false) Interpret boxes as being closed (i.e. they\r\n * contain their border) or open. If open then if both boxes have zero area\r\n * then they are both considered close.\r\n */\r\nfunction areBoxesIntersectingQuad(closed) {\r\n    return (a, b) => {\r\n        let [[ax0, ay0], [ax1, ay1]] = a;\r\n        let [[bx0, by0], [bx1, by1]] = b;\r\n        // If open then if both boxes have zero area then they are both \r\n        // considered closed.\r\n        /*if ((ax0 === ax1 || ay0 === ay1) && (bx0 === bx1 || by0 === by1)) {\r\n            closed = true;\r\n        }*/\r\n        // Swap so smaller coordinate comes first\r\n        if (ay0[1] > ay1[1] || ay0[1] === ay1[1] && ay0[0] > ay1[0]) {\r\n            [ay0, ay1] = [ay1, ay0];\r\n        }\r\n        ;\r\n        if (by0[1] > by1[1] || by0[1] === by1[1] && by0[0] > by1[0]) {\r\n            [by0, by1] = [by1, by0];\r\n        }\r\n        ;\r\n        if (ax0[1] > ax1[1] || ax0[1] === ax1[1] && ax0[0] > ax1[0]) {\r\n            [ax0, ax1] = [ax1, ax0];\r\n        }\r\n        ;\r\n        if (bx0[1] > bx1[1] || bx0[1] === bx1[1] && bx0[0] > bx1[0]) {\r\n            [bx0, bx1] = [bx1, bx0];\r\n        }\r\n        ;\r\n        return closed\r\n            ? (\r\n            //ax0 <= bx1 && ax1 >= bx0 && \r\n            //by0 <= ay1 && by1 >= ay0\r\n            (ax0[1] < bx1[1] || (ax0[1] === bx1[1] && ax0[0] <= bx1[0])) &&\r\n                (ax1[1] > bx0[1] || (ax1[1] === bx0[1] && ax1[0] >= bx0[0])) &&\r\n                (by0[1] < ay1[1] || (by0[1] === ay1[1] && by0[0] <= ay1[0])) &&\r\n                (by1[1] > ay0[1] || (by1[1] === ay0[1] && by1[0] >= ay0[0])))\r\n            : (\r\n            //ax0 < bx1 && ax1 > bx0 && \r\n            //by0 < ay1 && by1 > ay0\r\n            (ax0[1] < bx1[1] || (ax0[1] === bx1[1] && ax0[0] < bx1[0])) &&\r\n                (ax1[1] > bx0[1] || (ax1[1] === bx0[1] && ax1[0] > bx0[0])) &&\r\n                (by0[1] < ay1[1] || (by0[1] === ay1[1] && by0[0] < ay1[0])) &&\r\n                (by1[1] > ay0[1] || (by1[1] === ay0[1] && by1[0] > ay0[0])));\r\n    };\r\n}\r\nexports.areBoxesIntersectingQuad = areBoxesIntersectingQuad;\r\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-boolean/node/sweep-line/sweep-line.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-boolean/node/sweep-line/sweep-line.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst EVENT_LEFT = -1;\r\nconst EVENT_RIGHT = +1;\r\n/**\r\n * Generalized sweepline algorithm.\r\n *\r\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\r\n *\r\n * @param items An array of items that are to be compared. Items should\r\n * typically be geometric objects in 2d space with well-defined left and right\r\n * endpoints.\r\n * @param getLeftmostPoint A function that returns the leftmost point of the\r\n * geometric object of interest.\r\n * @param getRightmostPoint A function that returns the rightmost point of the\r\n * geometric object of interest.\r\n * @param predicate A predicate that takes two geometric objects and returns\r\n * truthy (of some specific type) if they are of interest or falsey otherwise.\r\n */\r\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\r\n    // Initialize event queue to contain all endpoints.\r\n    let events = [];\r\n    for (let item of items) {\r\n        events.push({\r\n            type: EVENT_LEFT,\r\n            item,\r\n            x: getLeftmost(item)\r\n        });\r\n        events.push({\r\n            type: EVENT_RIGHT,\r\n            item,\r\n            x: getRightmost(item)\r\n        });\r\n    }\r\n    events.sort(compare);\r\n    let activeItems = new Set();\r\n    /** A list of pairs of items that passed the predicate */\r\n    let pairedItems = [];\r\n    for (let event of events) {\r\n        let item = event.item;\r\n        if (event.type === EVENT_LEFT) {\r\n            for (let activeItem of activeItems.values()) {\r\n                //(window as any).ii++;\r\n                let result = predicate(item, activeItem);\r\n                if (result) {\r\n                    //(window as any).jj++;\r\n                    //console.log(result)\r\n                    pairedItems.push({\r\n                        a: item,\r\n                        b: activeItem,\r\n                        u: result\r\n                    });\r\n                }\r\n            }\r\n            activeItems.add(item);\r\n        }\r\n        else if (event.type === EVENT_RIGHT) {\r\n            activeItems.delete(event.item);\r\n        }\r\n    }\r\n    return pairedItems;\r\n}\r\nexports.sweepLine = sweepLine;\r\n/**\r\n * Compare two Events by their x-axis and then by their type.\r\n * @param a An event\r\n * @param b Another event\r\n */\r\nfunction compare(a, b) {\r\n    let res = a.x - b.x;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Alwys put left events before right ones.\r\n    return a.type;\r\n}\r\n//# sourceMappingURL=sweep-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-boolean/node/sweep-line/sweep-line.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/debug/debug.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/debug/debug.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_fs_1 = __webpack_require__(/*! ../draw-fs */ \"./node_modules/flo-draw/node/draw-fs.js\");\r\n/**\r\n * Returns a new debug object by spreading boolean operation debug information\r\n * onto the given (possibly undefined) debug object.\r\n * @param debug a (possibly undefined) debug object\r\n */\r\nfunction enableDebugDrawFs(debugOn) {\r\n    if (!debugOn) {\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = Object.assign(Object.assign({}, debug), { fs: Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.fs), { draw: Object.assign({}, draw_fs_1.drawFs) }) });\r\n    window._debug_ = debug;\r\n}\r\nexports.enableDebugDrawFs = enableDebugDrawFs;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw-fs.js":
/*!***********************************************!*\
  !*** ./node_modules/flo-draw/node/draw-fs.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ./draw/circle */ \"./node_modules/flo-draw/node/draw/circle.js\");\r\nconst cross_hair_1 = __webpack_require__(/*! ./draw/cross-hair */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\r\nconst dot_1 = __webpack_require__(/*! ./draw/dot */ \"./node_modules/flo-draw/node/draw/dot.js\");\r\nconst line_1 = __webpack_require__(/*! ./draw/line */ \"./node_modules/flo-draw/node/draw/line.js\");\r\nconst rect_1 = __webpack_require__(/*! ./draw/rect */ \"./node_modules/flo-draw/node/draw/rect.js\");\r\nconst polygon_1 = __webpack_require__(/*! ./draw/polygon */ \"./node_modules/flo-draw/node/draw/polygon.js\");\r\nconst loop_1 = __webpack_require__(/*! ./draw/loop */ \"./node_modules/flo-draw/node/draw/loop.js\");\r\nconst polyline_1 = __webpack_require__(/*! ./draw/polyline */ \"./node_modules/flo-draw/node/draw/polyline.js\");\r\nconst beziers_1 = __webpack_require__(/*! ./draw/beziers */ \"./node_modules/flo-draw/node/draw/beziers.js\");\r\nconst cubic_bezier_1 = __webpack_require__(/*! ./draw/cubic-bezier */ \"./node_modules/flo-draw/node/draw/cubic-bezier.js\");\r\nconst bezier_1 = __webpack_require__(/*! ./draw/bezier */ \"./node_modules/flo-draw/node/draw/bezier.js\");\r\nconst bezier_piece_1 = __webpack_require__(/*! ./draw/bezier-piece */ \"./node_modules/flo-draw/node/draw/bezier-piece.js\");\r\nconst quad_bezier_1 = __webpack_require__(/*! ./draw/quad-bezier */ \"./node_modules/flo-draw/node/draw/quad-bezier.js\");\r\nconst text_1 = __webpack_require__(/*! ./draw/text */ \"./node_modules/flo-draw/node/draw/text.js\");\r\nlet drawFs = {\r\n    circle: circle_1.circle,\r\n    crossHair: cross_hair_1.crossHair,\r\n    dot: dot_1.dot,\r\n    line: line_1.line,\r\n    rect: rect_1.rect,\r\n    beziers: beziers_1.beziers,\r\n    bezier: bezier_1.bezier,\r\n    bezierPiece: bezier_piece_1.bezierPiece,\r\n    quadBezier: quad_bezier_1.quadBezier,\r\n    cubicBezier: cubic_bezier_1.cubicBezier,\r\n    polygon: polygon_1.polygon,\r\n    loop: loop_1.loop,\r\n    polyline: polyline_1.polyline,\r\n    text: text_1.text\r\n};\r\nexports.drawFs = drawFs;\r\n//# sourceMappingURL=draw-fs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw-fs.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst evaluate_bezier_1 = __webpack_require__(/*! ./evaluate-bezier */ \"./node_modules/flo-draw/node/draw/evaluate-bezier.js\");\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ \"./node_modules/flo-draw/node/draw/split-at.js\");\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Duplicated here so we don't circularly depend on flo-bezier.\r\n *\r\n * Uses de Casteljau's algorithm.\r\n *\r\n * @param ps a bezier\r\n * @param tRange a t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_bezier_1.evaluateBezier(ps, tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return split_at_1.splitAt(ps, tRange[1])[0];\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return split_at_1.splitAt(ps, tRange[0])[1];\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return split_at_1.splitAt(split_at_1.splitAt(ps, tRange[0])[1], (tRange[1] - tRange[0]) / (1 - tRange[0]))[0];\r\n}\r\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\r\n//# sourceMappingURL=bezier-from-bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier-piece.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier-piece.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst cross_hair_1 = __webpack_require__(/*! ./cross-hair */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\r\nconst bezier_1 = __webpack_require__(/*! ./bezier */ \"./node_modules/flo-draw/node/draw/bezier.js\");\r\nconst evaluate_bezier_1 = __webpack_require__(/*! ./evaluate-bezier */ \"./node_modules/flo-draw/node/draw/evaluate-bezier.js\");\r\nconst bezier_from_bezier_piece_1 = __webpack_require__(/*! ./bezier-from-bezier-piece */ \"./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js\");\r\n/**\r\n * Draws a bezier piece, i.e. a bezier within a specified t range.\r\n * @param snap\r\n * @param bezierPiece\r\n * @param class\r\n * @param delay\r\n */\r\nfunction bezierPiece(g, ps_, tRange, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $elems = [];\r\n    // Draw crosshair if t range bounds are equal.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_bezier_1.evaluateBezier(ps_, tRange[0]);\r\n        $elems = cross_hair_1.crossHair(g, p, class_, 1.5);\r\n    }\r\n    else {\r\n        let ps = bezier_from_bezier_piece_1.bezierFromBezierPiece(ps_, tRange);\r\n        $elems = bezier_1.bezier(g, ps, class_);\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $elems.forEach(e => e.remove()), delay);\r\n    }\r\n    return $elems;\r\n}\r\nexports.bezierPiece = bezierPiece;\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/bezier-piece.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/bezier.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/bezier.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst line_1 = __webpack_require__(/*! ./line */ \"./node_modules/flo-draw/node/draw/line.js\");\r\nconst quad_bezier_1 = __webpack_require__(/*! ./quad-bezier */ \"./node_modules/flo-draw/node/draw/quad-bezier.js\");\r\nconst cubic_bezier_1 = __webpack_require__(/*! ./cubic-bezier */ \"./node_modules/flo-draw/node/draw/cubic-bezier.js\");\r\nfunction bezier(g, bezier, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (bezier.length === 2) {\r\n        return line_1.line(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 3) {\r\n        return quad_bezier_1.quadBezier(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 4) {\r\n        return cubic_bezier_1.cubicBezier(g, bezier, class_, delay);\r\n    }\r\n    return [];\r\n}\r\nexports.bezier = bezier;\r\n//# sourceMappingURL=bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/beziers.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/beziers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bezier_1 = __webpack_require__(/*! ./bezier */ \"./node_modules/flo-draw/node/draw/bezier.js\");\r\nconst COLORS = ['red', 'green', 'cyan', 'blue'];\r\n/**\r\n * Draws beziers.\r\n * @param snap\r\n * @param beziers\r\n * @param delay\r\n */\r\nfunction beziers(g, beziers, classes, delay) {\r\n    let alternateColors = classes === undefined;\r\n    let $beziers = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        let color = COLORS[i % COLORS.length];\r\n        let class_ = alternateColors\r\n            ? 'thin5 nofill ' + color\r\n            : classes;\r\n        $beziers.push(...bezier_1.bezier(g, ps, class_));\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $beziers.forEach(e => e.remove()), delay);\r\n    }\r\n    return $beziers;\r\n}\r\nexports.beziers = beziers;\r\n//# sourceMappingURL=beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/beziers.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/circle.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/circle.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\n/**\r\n * Draws a circle\r\n * @param g An SVG group element wherein to draw the circle.\r\n * @param circle\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction circle(g, circle, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let $circle = document.createElementNS(xmlns_1.XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", c[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", c[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", r.toString());\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    if (delay) {\r\n        setTimeout(() => $circle.remove(), delay);\r\n    }\r\n    return [$circle];\r\n}\r\nexports.circle = circle;\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/circle.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/cross-hair.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/cross-hair.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-draw/node/draw/circle.js\");\r\nconst line_1 = __webpack_require__(/*! ./line */ \"./node_modules/flo-draw/node/draw/line.js\");\r\n/**\r\n * Draws a crosshair.\r\n */\r\nfunction crossHair(g, p, classes = default_class_1.DEFAULT_CLASS, r = 3, delay) {\r\n    let circle_ = { center: p, radius: r };\r\n    let $circle = circle_1.circle(g, circle_, classes);\r\n    let l1 = [[p[0] - r, p[1]], [p[0] + r, p[1]]];\r\n    let l2 = [[p[0], p[1] - r], [p[0], p[1] + r]];\r\n    let $l1 = line_1.line(g, l1, classes);\r\n    let $l2 = line_1.line(g, l2, classes);\r\n    if (delay) {\r\n        setTimeout(() => {\r\n            $circle.forEach(e => e.remove());\r\n            $l1.forEach(e => e.remove());\r\n            $l2.forEach(e => e.remove());\r\n        }, delay);\r\n    }\r\n    return [...$circle, ...$l1, ...$l2];\r\n}\r\nexports.crossHair = crossHair;\r\n//# sourceMappingURL=cross-hair.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/cross-hair.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/cubic-bezier.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/cubic-bezier.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nconst cross_hair_1 = __webpack_require__(/*! ./cross-hair */ \"./node_modules/flo-draw/node/draw/cross-hair.js\");\r\nfunction cubicBezier(g, bezier, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = bezier;\r\n    if (x0 === x3 && x1 === x3 && x2 === x3 &&\r\n        y0 === y3 && y1 === y3 && y2 === y3) {\r\n        return cross_hair_1.crossHair(g, [x0, y0], class_, 0.2, delay);\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    $path.setAttributeNS(null, \"d\", `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`);\r\n    $path.setAttributeNS(null, \"class\", class_);\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.cubicBezier = cubicBezier;\r\n//# sourceMappingURL=cubic-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/cubic-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/default-class.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/default-class.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DEFAULT_CLASS = 'red thin10 nofill ';\r\nexports.DEFAULT_CLASS = DEFAULT_CLASS;\r\n//# sourceMappingURL=default-class.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/default-class.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/dot.js":
/*!************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/dot.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-draw/node/draw/circle.js\");\r\n/**\r\n * Draws a dot.\r\n */\r\nfunction dot(g, p, r = 3, color = 'red', delay) {\r\n    let [$dot] = circle_1.circle(g, { center: p, radius: r }, 'dot ' + color, delay);\r\n    if (delay) {\r\n        setTimeout(() => $dot.remove(), delay);\r\n    }\r\n    return [$dot];\r\n}\r\nexports.dot = dot;\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/dot.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/evaluate-bezier.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/evaluate-bezier.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns an estimate of evaluating the given bezier at the given t value.\r\n * @param ps An order 1, 2 or bezier\r\n * @param t The parameter ∈ [0,1]\r\n */\r\nfunction evaluateBezier(ps, t) {\r\n    let s = 1 - t;\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let x = x0 * Math.pow(s, 3) + 3 * x1 * Math.pow(s, 2) * t + 3 * x2 * s * Math.pow(t, 2) + x3 * Math.pow(t, 3);\r\n        let y = y0 * Math.pow(s, 3) + 3 * y1 * Math.pow(s, 2) * t + 3 * y2 * s * Math.pow(t, 2) + y3 * Math.pow(t, 3);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let x = x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2);\r\n        let y = y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        let x = x0 * s + x1 * t;\r\n        let y = y0 * s + y1 * t;\r\n        return [x, y];\r\n    }\r\n    return [NaN, NaN];\r\n}\r\nexports.evaluateBezier = evaluateBezier;\r\n//# sourceMappingURL=evaluate-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/evaluate-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/line.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/line.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\n/**\r\n *\r\n * @param snap\r\n * @param l\r\n * @param classes\r\n */\r\nfunction line(g, l, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $line = document.createElementNS(xmlns_1.XMLNS, 'line');\r\n    $line.setAttributeNS(null, \"x1\", l[0][0].toString());\r\n    $line.setAttributeNS(null, \"y1\", l[0][1].toString());\r\n    $line.setAttributeNS(null, \"x2\", l[1][0].toString());\r\n    $line.setAttributeNS(null, \"y2\", l[1][1].toString());\r\n    $line.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($line);\r\n    if (delay) {\r\n        setTimeout(() => $line.remove(), delay);\r\n    }\r\n    return [$line];\r\n}\r\nexports.line = line;\r\n//# sourceMappingURL=line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/line.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/loop.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/loop.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction loop(g, curves, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (!curves.length) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${curves[0][0][0]} ${curves[0][0][1]} `;\r\n    for (let i = 0; i < curves.length; i++) {\r\n        let curve = curves[i];\r\n        d += `${getType(curve.length)} `;\r\n        for (let j = 1; j < curve.length; j++) {\r\n            d += `${curve[j][0]} ${curve[j][1]} `;\r\n        }\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.loop = loop;\r\nfunction getType(len) {\r\n    if (len === 2) {\r\n        return 'L';\r\n    }\r\n    if (len === 3) {\r\n        return 'Q';\r\n    }\r\n    if (len === 4) {\r\n        return 'C';\r\n    }\r\n}\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/loop.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/polygon.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/polygon.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\n/**\r\n * Draws a polygon\r\n * @param g\r\n * @param poly the polygon specified as an array of points - the last point does\r\n * not have to be specified\r\n * @param class_\r\n * @param delay\r\n */\r\nfunction polygon(g, poly, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.polygon = polygon;\r\n//# sourceMappingURL=polygon.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/polygon.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/polyline.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/polyline.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction polyline(g, poly, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (poly.length < 2) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.polyline = polyline;\r\n//# sourceMappingURL=polyline.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/polyline.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/quad-bezier.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/quad-bezier.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction quadBezier(g, ps, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    $path.setAttributeNS(null, \"d\", `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.quadBezier = quadBezier;\r\n//# sourceMappingURL=quad-bezier.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/quad-bezier.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/rect.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/rect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction rect(g, rect, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1]] = rect;\r\n    let x = x0 < x1 ? x0 : x1;\r\n    let y = y0 < y1 ? y0 : y1;\r\n    let width = Math.abs(x0 - x1);\r\n    let height = Math.abs(y0 - y1);\r\n    let $rect = document.createElementNS(xmlns_1.XMLNS, 'rect');\r\n    $rect.setAttributeNS(null, \"x\", x.toString());\r\n    $rect.setAttributeNS(null, \"y\", y.toString());\r\n    $rect.setAttributeNS(null, \"width\", width.toString());\r\n    $rect.setAttributeNS(null, \"height\", height.toString());\r\n    if (classes) {\r\n        $rect.setAttributeNS(null, \"class\", classes);\r\n    }\r\n    g.appendChild($rect);\r\n    if (delay) {\r\n        setTimeout(() => $rect.remove(), delay);\r\n    }\r\n    return [$rect];\r\n}\r\nexports.rect = rect;\r\n//# sourceMappingURL=rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/rect.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/split-at.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/split-at.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitAt(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAt(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAt(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAt(ps, t);\r\n    }\r\n    return [];\r\n}\r\nexports.splitAt = splitAt;\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    /** The split point */\r\n    let p = [\r\n        t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n        t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [t * x1 + s * x0,\r\n            t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0,\r\n            t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1,\r\n            t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2,\r\n            t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * s * x0 + 2 * s * t * x1 + t * t * x2,\r\n        s * s * y0 + 2 * s * t * y1 + t * t * y2\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [s * x0 + t * x1,\r\n            s * y0 + t * y1],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [s * x1 + t * x2,\r\n            s * y1 + t * y2],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/split-at.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/text.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/text.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\r\n/**\r\n * Draws text\r\n * @param g a SVG group element wherein to draw\r\n * @param p\r\n * @param str\r\n * @param fontSize\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction text(g, p, str, fontSize, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $text = document.createElementNS(xmlns_1.XMLNS, 'text');\r\n    $text.setAttributeNS(null, \"x\", p[0].toString());\r\n    $text.setAttributeNS(null, \"y\", p[1].toString());\r\n    $text.setAttributeNS(null, \"font-size\", fontSize.toString());\r\n    $text.setAttributeNS(null, \"class\", classes);\r\n    $text.textContent = str;\r\n    g.appendChild($text);\r\n    if (delay) {\r\n        setTimeout(() => $text.remove(), delay);\r\n    }\r\n    return [$text];\r\n}\r\nexports.text = text;\r\n//# sourceMappingURL=text.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/text.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/draw/xmlns.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-draw/node/draw/xmlns.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst XMLNS = 'http://www.w3.org/2000/svg';\r\nexports.XMLNS = XMLNS;\r\n//# sourceMappingURL=xmlns.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/draw/xmlns.js?");

/***/ }),

/***/ "./node_modules/flo-draw/node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-draw/node/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_fs_1 = __webpack_require__(/*! ./draw-fs */ \"./node_modules/flo-draw/node/draw-fs.js\");\r\nexports.drawFs = draw_fs_1.drawFs;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-draw/node/debug/debug.js\");\r\nexports.enableDebugDrawFs = debug_1.enableDebugDrawFs;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-draw/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-gauss-quadrature/node/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-gauss-quadrature/node/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// TODO A future improvement can be to use the Gauss–Kronrod rules\r\n// to estimate the error and thus choose a number of constants based\r\n// on the error.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// TODO In future, the constants can be calculated and cached so we can\r\n// choose any value for the order.\r\n/**\r\n * Numerically integrates the given function using the Gaussian Quadrature\r\n * method.\r\n *\r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * @param f The univariate function to be integrated\r\n * @param interval The integration interval\r\n * @param order Can be 2, 4, 8, or 16. Higher values give more accurate results\r\n * but is slower - defaults to 16.\r\n */\r\nfunction gaussQuadrature(f, interval, order = 16) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let { weights, abscissas } = GAUSS_CONSTANTS[order];\r\n    let [a, b] = interval;\r\n    let result = 0;\r\n    let m1 = (b - a) / 2;\r\n    let m2 = (b + a) / 2;\r\n    for (let i = 0; i <= order - 1; i++) {\r\n        result += weights[i] * f(m1 * abscissas[i] + m2);\r\n    }\r\n    return m1 * result;\r\n}\r\nexports.gaussQuadrature = gaussQuadrature;\r\n// The Gaussian Legendre Quadrature method constants. \r\nconst GAUSS_CONSTANTS = {\r\n    2: {\r\n        weights: [1, 1],\r\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\r\n    },\r\n    4: {\r\n        weights: [0.6521451548625461, 0.6521451548625461,\r\n            0.3478548451374538, 0.3478548451374538],\r\n        abscissas: [-0.3399810435848563, 0.3399810435848563,\r\n            -0.8611363115940526, 0.8611363115940526]\r\n    },\r\n    8: {\r\n        weights: [0.3626837833783620, 0.3626837833783620,\r\n            0.3137066458778873, 0.3137066458778873,\r\n            0.2223810344533745, 0.2223810344533745,\r\n            0.1012285362903763, 0.1012285362903763],\r\n        abscissas: [-0.1834346424956498, 0.1834346424956498,\r\n            -0.5255324099163290, 0.5255324099163290,\r\n            -0.7966664774136267, 0.7966664774136267,\r\n            -0.9602898564975363, 0.9602898564975363]\r\n    },\r\n    // Taken from http://keisan.casio.com/exec/system/1330940731\r\n    16: {\r\n        abscissas: [-0.989400934991649932596,\r\n            -0.944575023073232576078,\r\n            -0.86563120238783174388,\r\n            -0.7554044083550030338951,\r\n            -0.6178762444026437484467,\r\n            -0.4580167776572273863424,\r\n            -0.28160355077925891323,\r\n            -0.0950125098376374401853,\r\n            0.0950125098376374401853,\r\n            0.28160355077925891323,\r\n            0.4580167776572273863424,\r\n            0.617876244402643748447,\r\n            0.755404408355003033895,\r\n            0.8656312023878317438805,\r\n            0.944575023073232576078,\r\n            0.989400934991649932596\r\n        ],\r\n        weights: [\r\n            0.0271524594117540948518,\r\n            0.062253523938647892863,\r\n            0.0951585116824927848099,\r\n            0.1246289712555338720525,\r\n            0.1495959888165767320815,\r\n            0.169156519395002538189,\r\n            0.182603415044923588867,\r\n            0.189450610455068496285,\r\n            0.1894506104550684962854,\r\n            0.182603415044923588867,\r\n            0.1691565193950025381893,\r\n            0.149595988816576732081,\r\n            0.124628971255533872053,\r\n            0.095158511682492784809,\r\n            0.062253523938647892863,\r\n            0.027152459411754094852\r\n        ]\r\n    }\r\n};\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-gauss-quadrature/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @private\r\n */\r\nfunction getSmallestIndxYThenX(ps) {\r\n    let smallest = [\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY\r\n    ];\r\n    let smallestI = undefined;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let y = ps[i][1];\r\n        if ((y < smallest[1]) ||\r\n            (y === smallest[1] && ps[i][0] < smallest[0])) {\r\n            smallestI = i;\r\n            smallest = ps[i];\r\n        }\r\n    }\r\n    return smallestI;\r\n}\r\nexports.getSmallestIndxYThenX = getSmallestIndxYThenX;\r\n//# sourceMappingURL=get-smallest-indx-y-then-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/index.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst get_smallest_indx_y_then_x_1 = __webpack_require__(/*! ./get-smallest-indx-y-then-x */ \"./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js\");\r\nconst swap_1 = __webpack_require__(/*! ./swap */ \"./node_modules/flo-graham-scan/node/swap.js\");\r\n/**\r\n * Finds the convex hull of the given set of 2d points using the\r\n * Graham Scan algorithm and returns the hull as an array of points.\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n *\r\n * Robust: This algorithm is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n * @param ps A set of points\r\n * @param includeAllBoundaryPoints Set this to true to if all boundary points\r\n * should be returned, even redundant ones - defaults to false\r\n */\r\nfunction grahamScan(ps, includeAllBoundaryPoints = false) {\r\n    if (!ps.length) {\r\n        return undefined;\r\n    }\r\n    function fail(p1, p2, p3) {\r\n        let res = flo_numerical_1.orient2d(p1, p2, p3);\r\n        return includeAllBoundaryPoints\r\n            ? res < 0\r\n            : res <= 0;\r\n    }\r\n    let ps_ = ps.slice();\r\n    let n = ps_.length;\r\n    let idx = get_smallest_indx_y_then_x_1.getSmallestIndxYThenX(ps_);\r\n    let [p] = ps_.splice(idx, 1);\r\n    ps_.sort((a, b) => {\r\n        let res = -flo_numerical_1.orient2d(p, a, b);\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        res = a[1] - b[1];\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        return a[0] - b[0];\r\n    });\r\n    ps_.unshift(p);\r\n    let m = 1;\r\n    for (let i = 2; i < n; i++) {\r\n        while (fail(ps_[m - 1], ps_[m], ps_[i])) {\r\n            if (m > 1) {\r\n                m -= 1;\r\n                continue;\r\n            }\r\n            else if (i === n - 1) {\r\n                m -= 1;\r\n                break;\r\n            }\r\n            else {\r\n                i += 1;\r\n            }\r\n        }\r\n        m += 1;\r\n        swap_1.swap(ps_, m, i);\r\n    }\r\n    return ps_.slice(0, m + 1);\r\n}\r\nexports.grahamScan = grahamScan;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-graham-scan/node/swap.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-graham-scan/node/swap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * In-place swap two elements in the given array.\r\n * @ignore\r\n */\r\nfunction swap(arr, a, b) {\r\n    if (a === b) {\r\n        return;\r\n    }\r\n    let temp = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = temp;\r\n}\r\nexports.swap = swap;\r\n//# sourceMappingURL=swap.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-graham-scan/node/swap.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/index.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Concise, Destructive, Left Leaning Red Black Tree implementation.\r\n// See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\r\n// See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\r\n// See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html \r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tree_node_1 = __webpack_require__(/*! ./tree-node */ \"./node_modules/flo-ll-rb-tree/node/tree-node.js\");\r\nconst tree_node_color_1 = __webpack_require__(/*! ./tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/tree-node-color.js\");\r\nconst tree_node_direction_1 = __webpack_require__(/*! ./tree-node-direction */ \"./node_modules/flo-ll-rb-tree/node/tree-node-direction.js\");\r\nfunction isRed(node) {\r\n    return node && node.color === tree_node_color_1.default.RED;\r\n}\r\nclass LlRbTree {\r\n    /**\r\n     * @param compare\r\n     * @param datas\r\n     * @param replaceDups - If true then if a duplicate is inserted (as per the\r\n     * equivalence relation induced by the compare) then replace it. If false\r\n     * then instead keep an array of values at the relevant node.\r\n     */\r\n    constructor(compare, datas, replaceDups) {\r\n        this.getMinNode = this.getMinOrMaxNode(tree_node_direction_1.default.LEFT);\r\n        this.getMaxNode = this.getMinOrMaxNode(tree_node_direction_1.default.RIGHT);\r\n        const tree = this;\r\n        tree.setComparator(compare, replaceDups);\r\n        tree.replaceDups = replaceDups;\r\n        tree.root = null;\r\n        if (!datas) {\r\n            return;\r\n        }\r\n        for (let data of datas) {\r\n            tree.insert(data);\r\n        }\r\n    }\r\n    /**\r\n     * Destructively sets the tree compare. This function can be used for for\r\n     * e.g.the Bentley Ottmann algorithm.\r\n     */\r\n    setComparator(compare, replaceDups) {\r\n        if (replaceDups) {\r\n            this.compare = compare;\r\n        }\r\n        else {\r\n            this.compare = (a, b) => compare(a, b[0]);\r\n        }\r\n    }\r\n    isEmpty() { return !this.root; }\r\n    /**\r\n     * Find the node in the tree with the given data using the tree compare\r\n     * function.\r\n     * @returns {Node} node or null if not found.\r\n     */\r\n    find(data) {\r\n        const tree = this;\r\n        let node = this.root;\r\n        while (node) {\r\n            let c = tree.compare(data, node.data);\r\n            if (c === 0) {\r\n                return node;\r\n            }\r\n            else {\r\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * .\r\n     */\r\n    toArrayInOrder() {\r\n        let nodes = [];\r\n        f(this.root);\r\n        function f(node) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            f(node[tree_node_direction_1.default.LEFT]);\r\n            nodes.push(node);\r\n            f(node[tree_node_direction_1.default.RIGHT]);\r\n        }\r\n        return nodes;\r\n    }\r\n    /**\r\n     * Inserts a node with the given data into the tree.\r\n     */\r\n    insert(data) {\r\n        const tree = this;\r\n        tree.root = f(tree.root, data);\r\n        tree.root.color = tree_node_color_1.default.BLACK;\r\n        tree.root.parent = undefined;\r\n        function f(h, data) {\r\n            if (!h) {\r\n                return new tree_node_1.default(data, !tree.replaceDups);\r\n            }\r\n            let c = tree.compare(data, h.data);\r\n            if (c === 0) {\r\n                if (tree.replaceDups) {\r\n                    h.data = data;\r\n                }\r\n                else {\r\n                    h.data.push(data);\r\n                }\r\n            }\r\n            else {\r\n                let dir = c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT;\r\n                h[dir] = f(h[dir], data);\r\n                h[dir].parent = h;\r\n            }\r\n            if (isRed(h[tree_node_direction_1.default.RIGHT]) &&\r\n                !isRed(h[tree_node_direction_1.default.LEFT])) {\r\n                h = rotate(tree_node_direction_1.default.LEFT, h);\r\n            }\r\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\r\n                isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\r\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\r\n            }\r\n            if (isRed(h[tree_node_direction_1.default.LEFT]) &&\r\n                isRed(h[tree_node_direction_1.default.RIGHT])) {\r\n                flipColors(h);\r\n            }\r\n            return h;\r\n        }\r\n    }\r\n    /**\r\n     * Removes an item from the tree based on the given data.\r\n     * @param {LlRbTree} tree\r\n     * @param {*} data\r\n     * @param {boolean} all - If the data is an array, remove all.\r\n     */\r\n    remove(data, all) {\r\n        const tree = this;\r\n        tree.root = f(tree.root, data);\r\n        if (tree.root) {\r\n            tree.root.color = tree_node_color_1.default.BLACK;\r\n            tree.root.parent = undefined;\r\n        }\r\n        function f(h, data) {\r\n            //let h = h_;\r\n            let c = tree.compare(data, h.data);\r\n            if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\r\n                removeFromArray(data, h.data);\r\n                return h;\r\n            }\r\n            if (c < 0 && !h[tree_node_direction_1.default.LEFT] || c > 0 && !h[tree_node_direction_1.default.RIGHT]) {\r\n                return h;\r\n            }\r\n            if (c < 0) {\r\n                if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\r\n                    !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\r\n                    h = moveRedLeft(h);\r\n                }\r\n                h[tree_node_direction_1.default.LEFT] = f(h[tree_node_direction_1.default.LEFT], data);\r\n                if (h[tree_node_direction_1.default.LEFT]) {\r\n                    h[tree_node_direction_1.default.LEFT].parent = h;\r\n                }\r\n                return fixUp(h);\r\n            }\r\n            if (isRed(h[tree_node_direction_1.default.LEFT])) {\r\n                h = rotate(tree_node_direction_1.default.RIGHT, h);\r\n                c = tree.compare(data, h.data);\r\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\r\n                    removeFromArray(data, h.data);\r\n                    return h;\r\n                }\r\n            }\r\n            if (c === 0 && !h[tree_node_direction_1.default.RIGHT]) {\r\n                return null;\r\n            }\r\n            if (!isRed(h[tree_node_direction_1.default.RIGHT]) &&\r\n                !isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\r\n                h = moveRedRight(h);\r\n                c = tree.compare(data, h.data);\r\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\r\n                    removeFromArray(data, h.data);\r\n                    return h;\r\n                }\r\n            }\r\n            if (c === 0) {\r\n                h.data = tree.min(h[tree_node_direction_1.default.RIGHT]);\r\n                h[tree_node_direction_1.default.RIGHT] = removeMin(h[tree_node_direction_1.default.RIGHT]);\r\n            }\r\n            else {\r\n                h[tree_node_direction_1.default.RIGHT] = f(h[tree_node_direction_1.default.RIGHT], data);\r\n            }\r\n            if (h[tree_node_direction_1.default.RIGHT]) {\r\n                h[tree_node_direction_1.default.RIGHT].parent = h;\r\n            }\r\n            return fixUp(h);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the two ordered nodes bounding the data. If the\r\n     * data falls on a node, that node and the next (to the right) is\r\n     * returned.\r\n     * @returns {Node[]}\r\n     */\r\n    findBounds(data) {\r\n        const tree = this;\r\n        let node = tree.root;\r\n        let bounds = [undefined, undefined];\r\n        if (node === null) {\r\n            return bounds;\r\n        }\r\n        while (node) {\r\n            const c = tree.compare(data, node.data);\r\n            if (c >= 0) {\r\n                bounds[0] = node;\r\n            }\r\n            else {\r\n                bounds[1] = node;\r\n            }\r\n            node = node[c >= 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * @param tree\r\n     * @param data\r\n     * @returns The two ordered nodes bounding the data. If the\r\n     * data falls on a node, returns the nodes before and after this one.\r\n     */\r\n    findBoundsExcl(data) {\r\n        const tree = this;\r\n        let node = tree.root;\r\n        let bounds = [undefined, undefined];\r\n        if (node === null) {\r\n            return bounds;\r\n        }\r\n        f(node);\r\n        function f(node) {\r\n            while (node) {\r\n                let c = tree.compare(data, node.data);\r\n                if (c === 0) {\r\n                    // Search on both sides\r\n                    f(node[tree_node_direction_1.default.LEFT]);\r\n                    f(node[tree_node_direction_1.default.RIGHT]);\r\n                    return;\r\n                }\r\n                if (c > 0) {\r\n                    bounds[0] = node;\r\n                }\r\n                else if (c < 0) {\r\n                    bounds[1] = node;\r\n                }\r\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\r\n            }\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    findAllInOrder(data) {\r\n        const tree = this;\r\n        let nodes = [];\r\n        f(tree.root);\r\n        function f(node) {\r\n            while (node) {\r\n                let c = tree.compare(data, node.data);\r\n                if (c === 0) {\r\n                    f(node[tree_node_direction_1.default.LEFT]);\r\n                    nodes.push(node);\r\n                    f(node[tree_node_direction_1.default.RIGHT]);\r\n                    return;\r\n                }\r\n                node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n    getMinOrMaxNode(dir) {\r\n        return function (node) {\r\n            if (!node) {\r\n                return undefined;\r\n            }\r\n            while (node[dir]) {\r\n                node = node[dir];\r\n            }\r\n            return node;\r\n        };\r\n    }\r\n    min(node) {\r\n        return this.getMinNode(node).data;\r\n    }\r\n    max(node) {\r\n        return this.getMaxNode(node).data;\r\n    }\r\n}\r\n/**\r\n * Removes the data from the tuple using ===.\r\n * Note this function uses === and not the compare function!\r\n */\r\nfunction removeFromArray(elem, arr) {\r\n    let index = arr.indexOf(elem);\r\n    if (index !== -1) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n/**\r\n * Destructively rotates the given node, say h, in the\r\n * given direction as far as tree rotations go.\r\n * @param {boolean} dir true -> right, false -> left\r\n * @param {Node} h\r\n * @returns The node that is at the top after the rotation.\r\n */\r\nfunction rotate(dir, h) {\r\n    const otherDir = dir ? tree_node_direction_1.default.LEFT : tree_node_direction_1.default.RIGHT;\r\n    const x = h[otherDir];\r\n    h[otherDir] = x[dir];\r\n    if (x[dir]) {\r\n        x[dir].parent = h;\r\n    }\r\n    x[dir] = h;\r\n    h.parent = x;\r\n    x.color = h.color;\r\n    h.color = tree_node_color_1.default.RED;\r\n    return x;\r\n}\r\nfunction removeMin(h) {\r\n    if (!h[tree_node_direction_1.default.LEFT]) {\r\n        return null;\r\n    }\r\n    if (!isRed(h[tree_node_direction_1.default.LEFT]) &&\r\n        !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\r\n        h = moveRedLeft(h);\r\n    }\r\n    h[tree_node_direction_1.default.LEFT] = removeMin(h[tree_node_direction_1.default.LEFT]);\r\n    if (h[tree_node_direction_1.default.LEFT]) {\r\n        h[tree_node_direction_1.default.LEFT].parent = h;\r\n    }\r\n    return fixUp(h);\r\n}\r\nfunction flipColor(color) {\r\n    return color === tree_node_color_1.default.RED ? tree_node_color_1.default.BLACK : tree_node_color_1.default.RED;\r\n}\r\n/**\r\n * Destructively flips the color of the given node and both\r\n * it's childrens' colors.\r\n * @param {Node} h\r\n */\r\nfunction flipColors(h) {\r\n    h.color = flipColor(h.color);\r\n    h[tree_node_direction_1.default.LEFT].color = flipColor(h[tree_node_direction_1.default.LEFT].color);\r\n    h[tree_node_direction_1.default.RIGHT].color = flipColor(h[tree_node_direction_1.default.RIGHT].color);\r\n}\r\n/**\r\n * @description\r\n * @param h\r\n * @returns The node that is at the top after the move.\r\n */\r\nfunction moveRedLeft(h) {\r\n    flipColors(h);\r\n    if (isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\r\n        let a = rotate(tree_node_direction_1.default.RIGHT, h[tree_node_direction_1.default.RIGHT]);\r\n        h[tree_node_direction_1.default.RIGHT] = a;\r\n        a.parent = h;\r\n        h = rotate(tree_node_direction_1.default.LEFT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * @description\r\n * @param h\r\n * @returns The node that is at the top after the move.\r\n */\r\nfunction moveRedRight(h) {\r\n    flipColors(h);\r\n    if (isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\r\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * @description Fix right-leaning red nodes.\r\n * @returns The node that is at the top after the fix.\r\n */\r\nfunction fixUp(h) {\r\n    if (isRed(h[tree_node_direction_1.default.RIGHT])) {\r\n        h = rotate(tree_node_direction_1.default.LEFT, h);\r\n    }\r\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\r\n        isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\r\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\r\n    }\r\n    // Split 4-nodes.\r\n    if (isRed(h[tree_node_direction_1.default.LEFT]) &&\r\n        isRed(h[tree_node_direction_1.default.RIGHT])) {\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\nexports.default = LlRbTree;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/tree-node-color.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/tree-node-color.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TreeNodeColor;\r\n(function (TreeNodeColor) {\r\n    TreeNodeColor[TreeNodeColor[\"BLACK\"] = 0] = \"BLACK\";\r\n    TreeNodeColor[TreeNodeColor[\"RED\"] = 1] = \"RED\";\r\n})(TreeNodeColor || (TreeNodeColor = {}));\r\nexports.default = TreeNodeColor;\r\n//# sourceMappingURL=tree-node-color.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/tree-node-color.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/tree-node-direction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/tree-node-direction.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TreeNodeDirection;\r\n(function (TreeNodeDirection) {\r\n    TreeNodeDirection[TreeNodeDirection[\"LEFT\"] = 0] = \"LEFT\";\r\n    TreeNodeDirection[TreeNodeDirection[\"RIGHT\"] = 1] = \"RIGHT\";\r\n})(TreeNodeDirection || (TreeNodeDirection = {}));\r\nexports.default = TreeNodeDirection;\r\n//# sourceMappingURL=tree-node-direction.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/tree-node-direction.js?");

/***/ }),

/***/ "./node_modules/flo-ll-rb-tree/node/tree-node.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-ll-rb-tree/node/tree-node.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tree_node_color_1 = __webpack_require__(/*! ./tree-node-color */ \"./node_modules/flo-ll-rb-tree/node/tree-node-color.js\");\r\n/**\r\n * Red Black Tree node.\r\n */\r\nclass TreeNode {\r\n    constructor(data, asArray) {\r\n        if (asArray) {\r\n            this.data = [data];\r\n        }\r\n        else {\r\n            this.data = data;\r\n        }\r\n        this.color = tree_node_color_1.default.RED;\r\n    }\r\n}\r\nexports.default = TreeNode;\r\n//# sourceMappingURL=tree-node.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-ll-rb-tree/node/tree-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/circle.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-mat/node/circle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * Returns a scaled version of the given circle without changing its center.\r\n * @param circle\r\n * @param s multiplier\r\n */\r\nfunction scaleCircle(circle, s) {\r\n    return { center: circle.center, radius: s * circle.radius };\r\n}\r\nexports.scaleCircle = scaleCircle;\r\n/**\r\n * Returns true if the first circle engulfs the second.\r\n * @param c1\r\n * @param c2\r\n */\r\nfunction engulfsCircle(c1, c2) {\r\n    if (c1.radius <= c2.radius) {\r\n        return false;\r\n    }\r\n    let d = flo_vector2d_1.squaredDistanceBetween(c1.center, c2.center);\r\n    let dr = c1.radius - c2.radius;\r\n    let δ = dr * dr;\r\n    return δ > d;\r\n}\r\nexports.engulfsCircle = engulfsCircle;\r\n/**\r\n * Returns a human-readable string description of the given circle.\r\n * @param circle\r\n */\r\nfunction toString(circle) {\r\n    return 'c: ' + circle.center + ' r: ' + circle.radius;\r\n}\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/circle.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/contact-point.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/contact-point.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * Primarily for internal use.\r\n *\r\n * Compares the two contact points according to their order along the shape\r\n * boundary. Returns > 0 if a > b, < 0 if a < b or 0 if a === b.\r\n * @param a The first contact point.\r\n * @param b The second contact point.\r\n */\r\nfunction compareCps(a, b) {\r\n    //let res = PointOnShape.compare(a.pointOnShape, b.pointOnShape);\r\n    let res = point_on_shape_1.comparePoss(a.pointOnShape, b.pointOnShape);\r\n    if (res === undefined) {\r\n        return undefined;\r\n    }\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = a.order - b.order;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    return a.order2 - b.order2;\r\n}\r\nexports.compareCps = compareCps;\r\n//# sourceMappingURL=contact-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/contact-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node.js":
/*!**********************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst contact_point_1 = __webpack_require__(/*! ./contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\nconst remove_1 = __webpack_require__(/*! ./cp-node/remove */ \"./node_modules/flo-mat/node/cp-node/remove.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ./get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\n/**\r\n * The primary class of the library.\r\n *\r\n * Since the MAT is a full representation of the shape boundary an instance of\r\n * this class contains both the information of a boundary point and a medial\r\n * axis point (and edge to the next point(s)). It also contains edges to other\r\n * [[CpNode]]s which allows for traversal of the MAT and thus implictly\r\n * represents the entire MAT.\r\n *\r\n * To get the maximal disk circle (of which the center is on the medial axis)\r\n * use [[cp]].circle.\r\n *\r\n * To get the boundary point, use [[cp]].pointOnShape.\r\n *\r\n * The edge [[next]] (resp. [[prev]]) allows one to move anti-clockwise (resp.\r\n * clockwise) on the shape boundary to the next [[CpNode]]. This also imposes a\r\n * direction of traversal of the MAT edges and vertices.\r\n *\r\n * The edge [[nextOnCircle]] (resp. [[prevOnCircle]]) allows one to go\r\n * anti-clockwise (resp. clockwise) around the maximal disks implied by\r\n * the CpNode to the next maximal disk contact point. This is equivalent to\r\n * following other branches on the MAT.\r\n *\r\n * Call [[getCurveBetween]](cpNodeFrom, cpNodeTo) or getCurveToNext(cpNode)\r\n * (replacing the older CpNode.[[matCurveToNextVertex]]) to get a bezier curve\r\n * from the maximal disk of this [[CpNode]] to the next [[CpNode]]'s\r\n * maximal disk and thus directly representing a piece of the medial axis.\r\n *\r\n * The function, [[getChildren]], returns the children of this [[CpNode]] when\r\n * seen as a MAT edge. Only children in a 'forward' direction are returned. These\r\n * include all edges except the 'backward' edge given by [[prevOnCircle]]. For\r\n * [[CpNode]]s having a maximal disk with 2 contact points (a 2-prong, the usual\r\n * case) the children will be the single edge [[next]]. For a 3-prong this will\r\n * be the edges [[next]] and [[nextOnCircle]], etc. [[getChildren]] allows one to\r\n * easily traverse the MAT tree - see e.g. the implementation of [[traverseEdges]].\r\n *\r\n * The getter, [[vertexChildren]], is similar to [[getChildren]] but returns the\r\n * child nodes of the tree when [[CpNode]] is seen as a MAT vertex point (as\r\n * opposed to edge). In this way the dual graph of the tree can easily be\r\n * traversed - see e.g. [[traverseVertices]]. Generally, however, traversing the\r\n * edges is preferred as it returns the entire Medial Axis (by utilizing\r\n * [[getCurveToNext]] on each returned edge).\r\n *\r\n * It may be worth mentioning that by traversing from the CpNode by following\r\n * [[next]] repeatedly until one is back at the same CpNode allows one\r\n * to 'go around' the shape boundary and at the same time traverse the MAT twice\r\n * in opposite directions.\r\n */\r\nclass CpNode {\r\n    /**\r\n     * Primarily for internal use.\r\n     * @param cp The shape boundary contact point, i.e. a [[CpNode]] without its\r\n     * edges.\r\n     * @param isHoleClosing If true, this [[CpNode]] belongs to a hole-closing\r\n     * maximal disk.\r\n     * @param isIntersection true if this cpNode is at a shape boundary\r\n     * intersection point, false otherwise\r\n     * @param prev The previous (going clockwise around the boundary) contact\r\n     * point ([[CpNode]]).\r\n     * @param next The next (going anti-clockwise around the boundary) contact\r\n     * point ([[CpNode]]).\r\n     * @param prevOnCircle The previous [[CpNode]] (going clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     * @param nextOnCircle The next [[CpNode]] (going anti-clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     */\r\n    constructor(cp, isHoleClosing, isIntersection, prev = undefined, next = undefined, prevOnCircle = undefined, nextOnCircle = undefined) {\r\n        this.cp = cp;\r\n        this.isHoleClosing = isHoleClosing;\r\n        this.isIntersection = isIntersection;\r\n        this.prev = prev;\r\n        this.next = next;\r\n        this.prevOnCircle = prevOnCircle;\r\n        this.nextOnCircle = nextOnCircle;\r\n    }\r\n    /**\r\n     * Returns the bezier curve from the maximal disk of this [[CpNode]] to the\r\n     * next [[CpNode]]'s maximal disk and thus directly represents a piece of the\r\n     * medial axis.\r\n     * @deprecated Use [[getCurveToNext]] instead\r\n     * @param cpNode\r\n     */\r\n    get matCurveToNextVertex() {\r\n        return get_curve_to_next_1.getCurveToNext(this);\r\n    }\r\n    /**\r\n     * Returns the children of this [[CpNode]] when seen as a MAT edge. Only\r\n     * children in a 'forward' direction are returned. These include all edges\r\n     * except the 'backward' edge given by [[prevOnCircle]], even terminating\r\n     * edges.\r\n     */\r\n    getChildren() {\r\n        let children = [];\r\n        let cp = this.next;\r\n        let cp_ = cp;\r\n        do {\r\n            children.push(cp_);\r\n            cp_ = cp_.nextOnCircle;\r\n        } while (cp_.nextOnCircle !== cp);\r\n        return children;\r\n    }\r\n    /**\r\n     * Similar to [[getChildren]] but returns the child nodes of the tree when\r\n     * [[CpNode]] is seen as a MAT vertex point (as opposed to edge). In this\r\n     * way the dual graph of the tree can easily be traversed - see e.g.\r\n     * [[traverseVertices]]. Generally, however, traversing the edges is\r\n     * preferred as it returns the entire Medial Axis (by utilizing\r\n     * [[getCurveToNext]] on each returned edge).\r\n     */\r\n    get vertexChildren() {\r\n        if (this.isTerminating()) {\r\n            return [];\r\n        }\r\n        let cp = this;\r\n        let children = [];\r\n        let cp_ = cp;\r\n        while (cp_ !== cp.prevOnCircle) {\r\n            if (!cp_.isTerminating()) {\r\n                children.push(cp_.next);\r\n            }\r\n            cp_ = cp_.nextOnCircle;\r\n        }\r\n        return children;\r\n    }\r\n    /**\r\n     * Returns all [[CpNode]]s on the MAT that this [[CpNode]] is part of\r\n     * starting from the current one and going anti-clockwise around the shape.\r\n     */\r\n    getAllOnLoop() {\r\n        let cpStart = this;\r\n        let cps = [cpStart];\r\n        let cp = this.next;\r\n        while (cp !== cpStart) {\r\n            cps.push(cp);\r\n            cp = cp.next;\r\n        }\r\n        return cps;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * Insert a [[CpNode]] into the MAT tree graph after the specified point\r\n     * and returns the freshly inserted [[CpNode]].\r\n     * @param isHoleClosing True if this is a hole closing contact point.\r\n     * @param isIntersection True if this is a contact point at a shape boundary\r\n     * intersection point.\r\n     * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n     * @param cp [[ContactPoint]] defining the [[CpNode]].\r\n     * @param prev_ Inserts the new [[CpNode]] right after this item if the\r\n     * loop is not empty, else insert the new [[CpNode]] as the only item in the\r\n     * loop.\r\n     */\r\n    static insert(isHoleClosing, isIntersection, cpTree, cp, prev_) {\r\n        let cpNode = new CpNode(cp, isHoleClosing, isIntersection);\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.cpNode.push({\r\n                generated: _debug_.generated,\r\n                cpNode\r\n            });\r\n        }\r\n        let prev;\r\n        let next;\r\n        if (!prev_) {\r\n            prev = cpNode;\r\n            next = cpNode;\r\n        }\r\n        else {\r\n            prev = prev_;\r\n            next = prev.next;\r\n        }\r\n        next.prev = cpNode;\r\n        prev.next = cpNode;\r\n        cpNode.prev = prev;\r\n        cpNode.next = next;\r\n        cpTree.insert(cpNode);\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Return this (except if exclThis is truthy) and the the other CpNodes\r\n     * around the maximal disk vertex circle in an anti-clockwise order.\r\n     * @param exclThis If true the returned array does not include this\r\n     * [[CpNode]].\r\n     */\r\n    getCpNodesOnCircle(exclThis = false) {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let cps = [];\r\n        do {\r\n            if (exclThis) {\r\n                exclThis = false;\r\n            }\r\n            else {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return cps;\r\n    }\r\n    /**\r\n     * Returns true if the 2 given [[CpNode]]s are on the same maximal disk\r\n     * circle.\r\n     * @param cpNode1 A [[CpNode]].\r\n     * @param cpNode2 Another [[CpNode]]\r\n     */\r\n    static isOnSameCircle(cpNode1, cpNode2) {\r\n        let cpNodes = cpNode1.getCpNodesOnCircle(true);\r\n        return cpNodes.indexOf(cpNode2) >= 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] is terminating, i.e. implies a leaf MAT\r\n     * vertex.\r\n     *\r\n     * This is always the case for sharp corners and maximal disks with\r\n     * a single contact point. Note, however, that even in these cases there are\r\n     * two contact points stored (s\r\n     * itting 'on top' of each other) for the\r\n     * maximal disk. It can be seen as a limiting case of a two-prong where the\r\n     * distance between two of the contact points tend to zero. One point\r\n     * (represented by a [[CpNode]] of course) will be terminating with the\r\n     * other point being its [[next]], whereas the other point will *not* be\r\n     * terminating and 'points' back into the shape.\r\n     */\r\n    isTerminating() {\r\n        return this === this.next.prevOnCircle;\r\n    }\r\n    /**\r\n     * Like isTerminating() but only returns true if all cpNodes on the circle\r\n     * (except this.prevOnCircle) is terminating.\r\n     */\r\n    isFullyTerminating() {\r\n        let otherOnCircle = this.prevOnCircle.getCpNodesOnCircle(true);\r\n        let isFullyTerminating = otherOnCircle.every(cpNode => cpNode.isTerminating());\r\n        return isFullyTerminating;\r\n    }\r\n    /**\r\n     * Returns the first [[CpNode]] (from this one by successively applying\r\n     * .nextOnCircle) that exits the circle.\r\n     */\r\n    getFirstExit() {\r\n        let startNode = this;\r\n        let cpNode = startNode;\r\n        while (cpNode.next === cpNode.prevOnCircle) {\r\n            cpNode = cpNode.next;\r\n            if (cpNode === startNode) {\r\n                // The very special case the MAT is a single point.\r\n                return undefined;\r\n            }\r\n        }\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] represents a sharp corner, i.e. the\r\n     * limiting case of a two-prong having zero radius.\r\n     *\r\n     * Note that two [[CpNode]]s are stored for each sharp corner, one being\r\n     * terminating and one not. See [[isTerminating]] for more details.\r\n     */\r\n    isSharp() {\r\n        return this.cp.circle.radius === 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]]'s maximal disk has only one contact point\r\n     * on the shape boundary (up to planar coordinates). These includes sharp\r\n     * corners.\r\n     *\r\n     * Note, however, that two [[CpNode]]s are stored for each such point to\r\n     * preserve symmetry - see [[isTerminating]] for more details.\r\n     */\r\n    isOneProng() {\r\n        let cp1 = this;\r\n        if (cp1.cp.circle.radius === 0) {\r\n            return true;\r\n        }\r\n        let cp2 = cp1.nextOnCircle;\r\n        let p1 = cp1.cp.pointOnShape.p;\r\n        let p2 = cp2.cp.pointOnShape.p;\r\n        return (p1[0] === p2[0] && p1[1] === p2[1]);\r\n    }\r\n    /**\r\n     * Returns the number of contact points on the maximal disk circle implied\r\n     * by this [[CpNode]].\r\n     *\r\n     * Note, however, that even one-prongs and sharp corners will return 2 (see\r\n     * [[isTerminating]] for more details); if this is not desired use\r\n     * [[getRealProngCount]] instead which will return 1 in these cases.\r\n     */\r\n    getProngCount() {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let i = 0;\r\n        do {\r\n            i++;\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return i;\r\n    }\r\n    /**\r\n     * Returns the number of contact points (up to planar coordinates) on the\r\n     * maximal disk circle implied by this [[CpNode]].\r\n     *\r\n     * See also [[getProngCount]].\r\n     */\r\n    getRealProngCount() {\r\n        if (this.isOneProng()) {\r\n            return 1;\r\n        }\r\n        return this.getProngCount();\r\n    }\r\n}\r\nexports.CpNode = CpNode;\r\n/**\r\n * Primarily for internal use.\r\n *\r\n * Compares the order of two [[CpNode]]s. The order is cyclic and depends\r\n * on a [[CpNode]]'s relative position along the shape boundary.\r\n */\r\nCpNode.comparator = (a, b) => contact_point_1.compareCps(a.cp, b.cp);\r\nCpNode.remove = remove_1.removeCpNode;\r\n//# sourceMappingURL=cp-node.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/clone.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/clone.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/** @hidden */\r\nconst EDGES = ['prev', 'next', 'prevOnCircle', 'nextOnCircle'];\r\n/**\r\n * Returns a deep clone of this [[CpNode]]. Can be used to copy the MAT\r\n * since cloning a single [[CpNode]] necessarily implies cloning all\r\n * [[CpNode]]s on the same MAT tree.\r\n */\r\nfunction clone(cpNode) {\r\n    // Don't change this function to be recursive, the call stack may \r\n    // overflow if there are too many CpNodes.\r\n    let nodeMap = new Map();\r\n    let newCpNode = new cp_node_1.CpNode(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\r\n    nodeMap.set(cpNode, newCpNode);\r\n    let cpStack = [{ cpNode, newCpNode }];\r\n    while (cpStack.length) {\r\n        let { cpNode, newCpNode } = cpStack.pop();\r\n        for (let edge of EDGES) {\r\n            let node = cpNode[edge];\r\n            let newNode = nodeMap.get(node);\r\n            if (!newNode) {\r\n                newNode = new cp_node_1.CpNode(node.cp, node.isHoleClosing, node.isIntersection);\r\n                nodeMap.set(node, newNode);\r\n                cpStack.push({ cpNode: node, newCpNode: newNode });\r\n            }\r\n            newCpNode[edge] = newNode;\r\n        }\r\n    }\r\n    return newCpNode;\r\n}\r\nexports.clone = clone;\r\n//# sourceMappingURL=clone.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node/clone.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/cp-node/remove.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/cp-node/remove.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Removes a cpNode from the MAT.\r\n * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n * @param cpNode The [[CpNode]] to remove.\r\n */\r\nfunction removeCpNode(cpNode, cpTree) {\r\n    let prev = cpNode.prev;\r\n    let next = cpNode.next;\r\n    prev.next = next;\r\n    next.prev = prev;\r\n    let nextOpposite = next.prevOnCircle;\r\n    let prevOpposite = prev.nextOnCircle;\r\n    nextOpposite.next = prevOpposite;\r\n    prevOpposite.prev = nextOpposite;\r\n    if (cpTree) {\r\n        cpTree.remove(cpNode, false);\r\n    }\r\n}\r\nexports.removeCpNode = removeCpNode;\r\n//# sourceMappingURL=remove.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/cp-node/remove.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/curve.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/curve.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * @hidden\r\n * Angle in degrees to radians.\r\n */\r\nconst DEGREES = {\r\n    //'0'    : 0.0000,\r\n    0.25: 0.0050,\r\n    1: 0.0167,\r\n    4: 0.0698,\r\n    16: 0.2756,\r\n};\r\n/** @hidden */\r\n//const DEGREE_LIMIT = DEGREES[1];\r\nconst DEGREE_LIMIT = DEGREES[4];\r\n//const DEGREE_LIMIT = DEGREES[16]; \r\n/**\r\n * @hidden\r\n * Returns a new corner with properties.\r\n *\r\n * PRECONDITION: The beziers has control points with max bit-length of 26 and\r\n * aligned to a 'grid' to have the same exponent. This is so the vectors between\r\n * control points can be calculated exactly without resorting to adaptive\r\n * infinite precision floating point operations.\r\n *\r\n * @param psI The incoming bezier that ends in the corner\r\n * @param psO The outgoing bezier that starts at the corner\r\n */\r\nfunction getCorner(psI, psO) {\r\n    // getInterfaceCcw must return a number !== 0 if psI and psO are not the\r\n    // same as seen as a curve extension with t ∈ [-∞,+∞]\r\n    let ccw = flo_bezier3_1.getInterfaceCcw(psI, psO);\r\n    let isSharp = ccw < 0;\r\n    let isDull = ccw > 0;\r\n    // Find (non-normalized) tangent of curve.ps at t === 1\r\n    let p0E = psI[psI.length - 2];\r\n    let p1E = psI[psI.length - 1];\r\n    let xE = p1E[0] - p0E[0];\r\n    let yE = p1E[1] - p0E[1];\r\n    let tangentAtEnd = [xE, yE];\r\n    // Find (non-normalized) tangent of curve.next.ps at t === 0\r\n    let p0S = psO[0];\r\n    let p1S = psO[1];\r\n    let xS = p1S[0] - p0S[0];\r\n    let yS = p1S[1] - p0S[1];\r\n    let tangentAtStart = [xS, yS];\r\n    // These use square root and are thus not exact\r\n    let tangents_ = [\r\n        flo_vector2d_1.toUnitVector(tangentAtEnd),\r\n        flo_vector2d_1.toUnitVector(tangentAtStart),\r\n    ];\r\n    // The cross calculated below should be exact due to beziers having been\r\n    // normalized!\r\n    let crossTangents = flo_vector2d_1.cross(tangents_[0], tangents_[1]);\r\n    let isQuiteSharp;\r\n    let isQuiteDull;\r\n    let dotTangents = flo_vector2d_1.dot(tangentAtEnd, tangentAtStart);\r\n    if (dotTangents > 0) {\r\n        // Curves go in same direction\r\n        isQuiteSharp = crossTangents < -DEGREE_LIMIT;\r\n        isQuiteDull = crossTangents > +DEGREE_LIMIT;\r\n    }\r\n    else {\r\n        isQuiteSharp = isSharp;\r\n        isQuiteDull = isDull;\r\n    }\r\n    return {\r\n        tangents: tangents_,\r\n        crossTangents,\r\n        isSharp,\r\n        isDull,\r\n        isQuiteSharp,\r\n        isQuiteDull\r\n    };\r\n}\r\nexports.getCorner = getCorner;\r\n/**\r\n * @hidden\r\n * Returns information about the corner created at the end of this curve\r\n * (at t === 1) and the start of the next curve (at t === 0).\r\n */\r\nlet getCornerAtEnd = flo_memoize_1.memoize(function (curve) {\r\n    let psE = curve.ps;\r\n    let psS = curve.next.ps;\r\n    return getCorner(psE, psS);\r\n});\r\nexports.getCornerAtEnd = getCornerAtEnd;\r\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/debug.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/debug.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst general_1 = __webpack_require__(/*! ./functions/general */ \"./node_modules/flo-mat/node/debug/functions/general.js\");\r\nconst two_prong_1 = __webpack_require__(/*! ./functions/two-prong */ \"./node_modules/flo-mat/node/debug/functions/two-prong.js\");\r\nconst three_prong_1 = __webpack_require__(/*! ./functions/three-prong */ \"./node_modules/flo-mat/node/debug/functions/three-prong.js\");\r\nconst draw_elem_1 = __webpack_require__(/*! ./functions/draw-elem/draw-elem */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\r\nfunction enableDebugForMat(debugOn) {\r\n    var _a, _b, _c;\r\n    if (!debugOn) {\r\n        window._debug_ = undefined;\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = Object.assign(Object.assign({}, debug), { generated: Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.generated), { elems: Object.assign(Object.assign({}, (_a = debug === null || debug === void 0 ? void 0 : debug.generated) === null || _a === void 0 ? void 0 : _a.elems), { twoProng_regular: [], twoProng_failed: [], twoProng_notAdded: [], twoProng_deleted: [], twoProng_holeClosing: [], looseBoundingBox: [], tightBoundingBox: [], oneProng: [], oneProngAtDullCorner: [], sharpCorner: [], dullCorner: [], vertex: [], threeProng: [], boundingHull: [], mat: [], sat: [], cpNode: [], maxVertex: [], leaves: [], culls: [] }), timing: Object.assign(Object.assign({}, (_b = debug === null || debug === void 0 ? void 0 : debug.generated) === null || _b === void 0 ? void 0 : _b.timing), { holeClosers: 0, oneAnd2Prongs: 0, threeProngs: 0, sats: 0, simplifyMat: 0 }) }), fs: Object.assign(Object.assign(Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.fs), { drawElem: Object.assign(Object.assign({}, (_c = debug === null || debug === void 0 ? void 0 : debug.fs) === null || _c === void 0 ? void 0 : _c.drawElem), draw_elem_1.drawElemFunctions) }), general_1.generalDebugFunctions), { twoProng: two_prong_1.twoProngDebugFunctions, threeProng: three_prong_1.threeProngDebugFunctions }), directives: Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.directives), { stopAfterHoleClosers: false, stopAfterHoleClosersNum: undefined, stopAfterTwoProngs: false, stopAfterTwoProngsNum: undefined, stopAfterThreeProngs: false, stopAfterThreeProngsNum: undefined }) });\r\n    window._debug_ = debug;\r\n}\r\nexports.enableDebugForMat = enableDebugForMat;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction boundingHull(g, hull, style = 'thin5 black nofill') {\r\n    let $polygon = flo_draw_1.drawFs.polygon(g, hull, style);\r\n    return $polygon;\r\n}\r\nexports.boundingHull = boundingHull;\r\n//# sourceMappingURL=bounding-hull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ../../../get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\n/** @hidden */\r\nfunction drawBranch(g, branch, delay) {\r\n    let classes = 'thin5 purple nofill';\r\n    let $svgs = [];\r\n    let i = 0;\r\n    for (let cpNode of branch) {\r\n        if (cpNode.isTerminating()) {\r\n            continue;\r\n        }\r\n        //let bezier = cpNode.matCurveToNextVertex;\r\n        let bezier = get_curve_to_next_1.getCurveToNext(cpNode);\r\n        if (!bezier) {\r\n            continue;\r\n        }\r\n        i++;\r\n        $svgs.push(...flo_draw_1.drawFs.bezier(g, bezier, classes, delay));\r\n    }\r\n    return $svgs;\r\n}\r\nexports.drawBranch = drawBranch;\r\n//# sourceMappingURL=branch.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nfunction culls(g, culls) {\r\n    let $elems = [];\r\n    for (let circle of culls) {\r\n        let p = circle.center;\r\n        $elems.push(drawCircle(g, p, 0.4, 'cyan thin5 nofill'));\r\n    }\r\n    return $elems;\r\n}\r\nexports.culls = culls;\r\n/** @hidden */\r\nfunction drawCircle(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\n//# sourceMappingURL=culls.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\r\n    const XMLNS = 'http://www.w3.org/2000/svg';\r\n    let $circle = document.createElementNS(XMLNS, 'circle');\r\n    $circle.setAttributeNS(null, \"cx\", center[0].toString());\r\n    $circle.setAttributeNS(null, \"cy\", center[1].toString());\r\n    $circle.setAttributeNS(null, \"r\", radiusPercent.toString() + '%');\r\n    $circle.setAttributeNS(null, \"class\", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\nexports.drawCirclePercent = drawCirclePercent;\r\n//# sourceMappingURL=draw-circle-percent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst one_prong_1 = __webpack_require__(/*! ./one-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js\");\r\nconst two_prong_1 = __webpack_require__(/*! ./two-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js\");\r\nconst three_prong_1 = __webpack_require__(/*! ./three-prong */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js\");\r\nconst vertex_1 = __webpack_require__(/*! ./vertex */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js\");\r\nconst bounding_hull_1 = __webpack_require__(/*! ./bounding-hull */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/bounding-hull.js\");\r\nconst loose_bounding_box_1 = __webpack_require__(/*! ./loose-bounding-box */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js\");\r\nconst tight_bounding_box_1 = __webpack_require__(/*! ./tight-bounding-box */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js\");\r\nconst sharp_corner_1 = __webpack_require__(/*! ./sharp-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js\");\r\nconst dull_corner_1 = __webpack_require__(/*! ./dull-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js\");\r\nconst mat_1 = __webpack_require__(/*! ./mat */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\r\nconst max_vertex_1 = __webpack_require__(/*! ./max-vertex */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js\");\r\nconst leaves_1 = __webpack_require__(/*! ./leaves */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js\");\r\nconst culls_1 = __webpack_require__(/*! ./culls */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/culls.js\");\r\nconst one_prong_at_dull_corner_1 = __webpack_require__(/*! ./one-prong-at-dull-corner */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js\");\r\n/** @hidden */\r\nfunction notImplementedYet(g, elem) {\r\n    return []; // TODO - implement relevant drawing function\r\n}\r\n/** @hidden */\r\nlet drawElemFunctions = {\r\n    oneProng: one_prong_1.drawOneProng,\r\n    oneProngAtDullCorner: one_prong_at_dull_corner_1.oneProngAtDullCorner,\r\n    twoProng_regular: two_prong_1.twoProng,\r\n    twoProng_failed: two_prong_1.twoProng,\r\n    twoProng_notAdded: two_prong_1.twoProng,\r\n    twoProng_deleted: two_prong_1.twoProng,\r\n    twoProng_holeClosing: two_prong_1.twoProng,\r\n    threeProng: three_prong_1.threeProng,\r\n    //minY,\r\n    boundingHull: bounding_hull_1.boundingHull,\r\n    looseBoundingBox: loose_bounding_box_1.looseBoundingBox,\r\n    tightBoundingBox: tight_bounding_box_1.tightBoundingBox,\r\n    sharpCorner: sharp_corner_1.sharpCorner,\r\n    dullCorner: dull_corner_1.dullCorner,\r\n    vertex: vertex_1.vertex,\r\n    mat: mat_1.drawMat('mat'),\r\n    sat: mat_1.drawMat('sat'),\r\n    //loop,\r\n    //loops,\r\n    maxVertex: max_vertex_1.maxVertex,\r\n    leaves: leaves_1.leaves,\r\n    culls: culls_1.culls,\r\n    cpNode: notImplementedYet\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction dullCorner(g, curve) {\r\n    const scaleFactor = 1;\r\n    let p = curve.ps[3];\r\n    let $pos = flo_draw_1.drawFs.dot(g, p, 0.5 * scaleFactor, 'orange');\r\n    return $pos;\r\n}\r\nexports.dullCorner = dullCorner;\r\n//# sourceMappingURL=dull-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_circle_percent_1 = __webpack_require__(/*! ./draw-circle-percent */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-circle-percent.js\");\r\n/** @hidden */\r\nfunction leaves(g, leaves) {\r\n    let $elems = [];\r\n    for (let cpNode of leaves) {\r\n        let cp = cpNode.cp;\r\n        let p = cp.circle.center;\r\n        $elems.push(draw_circle_percent_1.drawCirclePercent(g, p, 0.5, 'pinker thin5 nofill'));\r\n    }\r\n    return $elems;\r\n}\r\nexports.leaves = leaves;\r\n//# sourceMappingURL=leaves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction looseBoundingBox(g, box) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    box = [[x0, y0], [x1, y0], [x1, y1], [x0, y1]];\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, 'thin5 brown nofill');\r\n    return $box;\r\n}\r\nexports.looseBoundingBox = looseBoundingBox;\r\n//# sourceMappingURL=loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst traverse_edges_1 = __webpack_require__(/*! ../../../traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ../../../get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\n/** @hidden */\r\nfunction drawMat(type) {\r\n    let classes = type === 'mat'\r\n        ? 'thin5 purple nofill'\r\n        : 'thin10 red nofill';\r\n    return (g, mat) => {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return undefined;\r\n        }\r\n        let $svgs = [];\r\n        let i = 0;\r\n        traverse_edges_1.traverseEdges(cpNode, cpNode => {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            let bezier = get_curve_to_next_1.getCurveToNext(cpNode);\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            i++;\r\n            $svgs.push(...flo_draw_1.drawFs.bezier(g, bezier, classes /*, i*500*/));\r\n        });\r\n        return $svgs;\r\n    };\r\n}\r\nexports.drawMat = drawMat;\r\n//# sourceMappingURL=mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction maxVertex(g, cpNode) {\r\n    let circle = cpNode.cp.circle;\r\n    let $elems = flo_draw_1.drawFs.circle(g, circle, 'brown thin10 nofill');\r\n    return $elems;\r\n}\r\nexports.maxVertex = maxVertex;\r\n//# sourceMappingURL=max-vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/max-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction oneProngAtDullCorner(g, pos) {\r\n    //let oCircle = PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\r\n    let oCircle = point_on_shape_1.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\r\n    let $center = flo_draw_1.drawFs.dot(g, pos.p, 0.1, 'orange');\r\n    let $circle = flo_draw_1.drawFs.dot(g, oCircle.center, 0.25, 'orange');\r\n    let $pos = flo_draw_1.drawFs.circle(g, oCircle, 'orange thin10 nofill');\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\nexports.oneProngAtDullCorner = oneProngAtDullCorner;\r\n//# sourceMappingURL=one-prong-at-dull-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong-at-dull-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nconst scaleFactor = 0.5;\r\n/** @hidden */\r\nfunction drawOneProng(g, pos, classes, delay = 0) {\r\n    let circle = circle_1.scaleCircle(\r\n    //PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos),\r\n    point_on_shape_1.getOsculatingCircle(Number.POSITIVE_INFINITY, pos), 1);\r\n    let $center = flo_draw_1.drawFs.dot(g, pos.p, 0.1 * scaleFactor, 'gray', delay);\r\n    let $circle = flo_draw_1.drawFs.dot(g, circle.center, 0.25 * scaleFactor, 'gray', delay);\r\n    let $pos = flo_draw_1.drawFs.circle(g, circle, 'gray thin10 nofill', delay);\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\nexports.drawOneProng = drawOneProng;\r\n//# sourceMappingURL=one-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/one-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction sharpCorner(g, curve) {\r\n    const scaleFactor = 1;\r\n    let p = curve.ps[curve.ps.length - 1];\r\n    let $pos = flo_draw_1.drawFs.dot(g, p, 0.6 * scaleFactor, 'green');\r\n    return $pos;\r\n}\r\nexports.sharpCorner = sharpCorner;\r\n//# sourceMappingURL=sharp-corner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/sharp-corner.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst circle_1 = __webpack_require__(/*! ../../../circle */ \"./node_modules/flo-mat/node/circle.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nconst scaleFactor = 0.3;\r\n/** @hidden */\r\nfunction threeProng(g, threeProng) {\r\n    let circle = circle_1.scaleCircle(threeProng.circle, 1);\r\n    let poss = threeProng.poss;\r\n    let $cp1 = flo_draw_1.drawFs.dot(g, poss[0].p, 0.1 * 1 * scaleFactor, 'blue');\r\n    let $cp2 = flo_draw_1.drawFs.dot(g, poss[1].p, 0.1 * 2 * scaleFactor, 'blue');\r\n    let $cp3 = flo_draw_1.drawFs.dot(g, poss[2].p, 0.1 * 3 * scaleFactor, 'blue');\r\n    let $center = flo_draw_1.drawFs.dot(g, circle.center, 0.3 * scaleFactor, 'blue');\r\n    let $circle = flo_draw_1.drawFs.circle(g, circle, 'blue thin2 nofill');\r\n    return [...$center, ...$cp1, ...$cp2, ...$cp3, ...$circle];\r\n}\r\nexports.threeProng = threeProng;\r\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = flo_draw_1.drawFs.polygon(g, box, 'thin5 pinker nofill');\r\n    return $box;\r\n}\r\nexports.tightBoundingBox = tightBoundingBox;\r\n//# sourceMappingURL=tight-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/tight-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../../mat/get-two-prong-type */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction twoProng(g, twoProng) {\r\n    let scaleFactor = 0.3;\r\n    let $failedDot = [];\r\n    let $center = [];\r\n    let $circle = [];\r\n    let $cp1 = [];\r\n    let $cp2 = [];\r\n    let color;\r\n    let thin;\r\n    switch (get_two_prong_type_1.getTwoProngType(twoProng)) {\r\n        case 'twoProng_regular': {\r\n            color = 'red ';\r\n            thin = '2';\r\n            break;\r\n        }\r\n        case 'twoProng_holeClosing': {\r\n            color = 'cyan ';\r\n            thin = '10';\r\n            break;\r\n        }\r\n    }\r\n    if (twoProng.failed) {\r\n        $failedDot = flo_draw_1.drawFs.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black');\r\n    }\r\n    else if (!twoProng.failed) {\r\n        $center = flo_draw_1.drawFs.dot(g, twoProng.circle.center, 1 * scaleFactor, 'yellow');\r\n        $circle = flo_draw_1.drawFs.circle(g, twoProng.circle, color + 'thin' + thin + ' nofill');\r\n        $cp1 = flo_draw_1.drawFs.dot(g, twoProng.pos.p, 0.035 * scaleFactor, color);\r\n        $cp2 = flo_draw_1.drawFs.dot(g, twoProng.z, 0.07 * scaleFactor, color);\r\n    }\r\n    return [...$failedDot, ...$center, ...$circle, ...$cp1, ...$cp2];\r\n}\r\nexports.twoProng = twoProng;\r\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/** @hidden */\r\nfunction vertex(g, cpNode, classes, delay, visible = true) {\r\n    let visibleClass = visible ? '' : ' invisible';\r\n    let circle = cpNode.cp.circle;\r\n    const THIN = 'thin20';\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    console.log(cps);\r\n    let $svgs = [];\r\n    let $circle = flo_draw_1.drawFs.circle(g, circle, 'red ' + THIN + ' nofill ' + visibleClass, delay);\r\n    let $crossHair = flo_draw_1.drawFs.crossHair(g, circle.center, 'red ' + THIN + ' nofill ' + visibleClass, 3, delay);\r\n    $svgs = [...$circle, ...$crossHair];\r\n    for (let i = 0; i < cps.length; i++) {\r\n        let cp = cps[i];\r\n        let edgeCircle = cp.next.cp.circle;\r\n        let $circle = flo_draw_1.drawFs.circle(g, edgeCircle, 'pink ' + THIN + ' nofill ' + visibleClass, delay);\r\n        let $crossHair = flo_draw_1.drawFs.crossHair(g, edgeCircle.center, 'pink ' + THIN + ' nofill ' + visibleClass, 3, delay);\r\n        $svgs.push(...$circle, ...$crossHair);\r\n        let p1 = circle.center;\r\n        let p2 = edgeCircle.center;\r\n        let thin = i === 0 ? 'thin10' : (i === 1 ? 'thin20' : 'thin35');\r\n        let $line = flo_draw_1.drawFs.line(g, [p1, p2], 'yellow ' + thin + ' nofill ' + visibleClass, delay);\r\n        $svgs.push(...$line);\r\n    }\r\n    return $svgs;\r\n}\r\nexports.vertex = vertex;\r\n//# sourceMappingURL=vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/draw-elem/vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/general.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/general.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/** @hidden */\r\nlet i = 0;\r\n/**\r\n * @hidden\r\n * Name the given object - for debugging purposes only\r\n */\r\nfunction nameObj(o, pre = '') {\r\n    o.name = '' + pre + i++;\r\n}\r\n/**\r\n * @hidden\r\n * Transforms a boundary piece (δ) into a human readable string.\r\n * @param cpNodes A boundary piece given by two CpNodes.\r\n */\r\nfunction δToString(cpNodes) {\r\n    return cpNodes.map(cpNode => point_on_shape_1.posToHumanString(cpNode.cp.pointOnShape));\r\n}\r\n/**\r\n * @hidden\r\n * Transforms an array of boundary pieces (δs) into a human readable string.\r\n * @param cpNodes An array of boundary pieces.\r\n */\r\nfunction δsToString(cpNodes) {\r\n    return cpNodes.map(δToString);\r\n}\r\n/**\r\n * @hidden\r\n * Convert the given points into a human readable string.\r\n * @param ps\r\n */\r\nfunction pointsToStr(ps, decimalPlaces = 3) {\r\n    return ps.map(p => pointToStr(p, decimalPlaces));\r\n}\r\n/**\r\n * @hidden\r\n * Converts the given point into a human readable string.\r\n * @param p The point\r\n * @param decimalPlaces number of decimal places\r\n */\r\nfunction pointToStr(p, decimalPlaces = 3) {\r\n    return p[0].toFixed(decimalPlaces) + ', ' + p[1].toFixed(decimalPlaces);\r\n}\r\n/** @hidden */\r\nlet generalDebugFunctions /*: IGeneralDebugFunctions*/ = {\r\n    δToString,\r\n    δsToString,\r\n    pointToStr,\r\n    pointsToStr,\r\n    nameObj,\r\n};\r\nexports.generalDebugFunctions = generalDebugFunctions;\r\n//# sourceMappingURL=general.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/general.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/three-prong.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/three-prong.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\n/**\r\n * @hidden\r\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\r\n * @param n - The 3-prong's zero-based index.\r\n */\r\nfunction drawSpokes(g, n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    //let g = threeProng.generated.g;\r\n    let cc = threeProng.circle.center;\r\n    let poss = threeProng.poss;\r\n    //_debug_.fs.draw.line(g, [poss[0].p, cc], 'thin5 red');\r\n    //_debug_.fs.draw.line(g, [poss[1].p, cc], 'thin5 red');\r\n    //_debug_.fs.draw.line(g, [poss[2].p, cc], 'thin5 red');\r\n    flo_draw_1.drawFs.line(g, [poss[0].p, cc], 'thin5 red');\r\n    flo_draw_1.drawFs.line(g, [poss[1].p, cc], 'thin5 red');\r\n    flo_draw_1.drawFs.line(g, [poss[2].p, cc], 'thin5 red');\r\n}\r\n/**\r\n * @hidden\r\n * Shows the circle for each boundary iteration.\r\n * @param n_ - The 3-prong's zero-based index. If ommitted, all will be shown.\r\n * @param idx - The specific boundary iteration index to view. If ommitted, all\r\n * will be shown.\r\n */\r\nfunction traceConvergence(g, n_, idx) {\r\n    let sIndx;\r\n    let eIndx;\r\n    if (n_ === undefined) {\r\n        sIndx = 0;\r\n        eIndx = _debug_.generated.elems.threeProng.length;\r\n    }\r\n    else {\r\n        sIndx = n_;\r\n        eIndx = n_ + 1;\r\n    }\r\n    for (let n = sIndx; n < eIndx; n++) {\r\n        let forDebugging = _debug_.generated.elems.threeProng[n];\r\n        //let g = forDebugging.generated.g;\r\n        console.log(forDebugging);\r\n        let candidateThreeProngs = forDebugging.candidateThreeProngs;\r\n        //-----------------------------\r\n        //---- Get start and end index\r\n        //-----------------------------\r\n        let startIndx;\r\n        let endIndx;\r\n        if (n_ === undefined || idx === -1) {\r\n            startIndx = forDebugging.bestIndx;\r\n            endIndx = forDebugging.bestIndx + 1;\r\n        }\r\n        else {\r\n            if (idx === undefined) {\r\n                startIndx = 0;\r\n                endIndx = candidateThreeProngs.length;\r\n            }\r\n            else {\r\n                startIndx = idx;\r\n                endIndx = idx + 1;\r\n            }\r\n        }\r\n        //---------------------------------\r\n        //---- Draw candidate three-prongs\r\n        //---------------------------------\r\n        for (let i = startIndx; i < endIndx; i++) {\r\n            let circle = candidateThreeProngs[i].circle;\r\n            if (forDebugging.bestIndx === i) {\r\n                flo_draw_1.drawFs.dot(g, circle.center, 0.2, 'green');\r\n                flo_draw_1.drawFs.circle(g, circle, 'black thin10 nofill');\r\n            }\r\n            else {\r\n                flo_draw_1.drawFs.dot(g, circle.center, 0.2, 'cyan');\r\n                flo_draw_1.drawFs.circle(g, circle, 'cyan thin5 nofill');\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * Shows the actual boundary for each iteration.\r\n * @param n The 3-prong's zero-based index.\r\n * @param idx The specific boundary iteration index to view. If ommitted will\r\n * show all.\r\n */\r\nfunction showBoundary(g, n, idx) {\r\n    let debugInfo = _debug_.generated.elems.threeProng[n];\r\n    //let g = debugInfo.generated.g;\r\n    let candidateThreeProngs = debugInfo.candidateThreeProngs;\r\n    let startIndx = idx === undefined ? 0 : idx;\r\n    let endIndx = idx === undefined ? candidateThreeProngs.length : idx;\r\n    // Draw relevant δs\r\n    let cpss = debugInfo.cpss;\r\n    let j = 0;\r\n    // For each iteration of δ3s (indexed by j)\r\n    for (let idx = 1; idx < cpss.length - 1; idx++) {\r\n        if (!(j >= startIndx && j <= endIndx)) {\r\n            j++;\r\n            continue;\r\n        }\r\n        let δ3s = [\r\n            cpss[0],\r\n            cpss[idx],\r\n            cpss[cpss.length - 1]\r\n        ];\r\n        // For each of the 3 δs\r\n        for (let i = 0; i < 3; i++) {\r\n            let δ = δ3s[i];\r\n            let δS = δ[0]; // Delta Start\r\n            let δE = δ[1]; // Delta End\r\n            let posS = δS.cp.pointOnShape;\r\n            let posE = δE.cp.pointOnShape;\r\n            let pS = posS.p;\r\n            let pE = posE.p;\r\n            let r = 1 + (i * 0.5);\r\n            if (flo_vector2d_1.equal(pS, pE)) {\r\n                flo_draw_1.drawFs.crossHair(g, pS, 'red thin10 nofill', r);\r\n            }\r\n            else {\r\n                flo_draw_1.drawFs.crossHair(g, pS, 'green thin10 nofill', r);\r\n                flo_draw_1.drawFs.crossHair(g, pE, 'blue thin10 nofill', r);\r\n            }\r\n        }\r\n        j++;\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * @param n The 3-prong's zero-based index.\r\n */\r\nfunction logδs(n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    console.log(threeProng.cpss);\r\n}\r\n/**\r\n * @hidden\r\n * @param p\r\n */\r\nfunction logNearest(showSpokes = true, showTrace = true, showBoundaries = true) {\r\n    return function (g, p, showDelay = 1000) {\r\n        let generated = _debug_.generated;\r\n        let threeProng = flo_vector2d_1.getObjClosestTo(p, generated.elems.threeProng, threeProng => threeProng.circle ? threeProng.circle.center : [0, 0]);\r\n        let circle = threeProng.circle;\r\n        //let g = threeProng.generated.g;\r\n        console.log(threeProng);\r\n        let circle2 = {\r\n            center: circle.center,\r\n            radius: circle.radius || 1\r\n        };\r\n        //let draw = _debug_.fs.draw;\r\n        flo_draw_1.drawFs.circle(g, circle2, 'blue thin10 nofill', showDelay);\r\n        flo_draw_1.drawFs.crossHair(g, circle.center, 'red thin2 nofill', 2, showDelay);\r\n        if (showSpokes) {\r\n            flo_draw_1.drawFs.line(g, [threeProng.poss[0].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            flo_draw_1.drawFs.line(g, [threeProng.poss[1].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            flo_draw_1.drawFs.line(g, [threeProng.poss[2].p, circle.center], 'blue thin5 nofill', showDelay);\r\n        }\r\n        if (showBoundaries) {\r\n            let boundaries = threeProng.boundaries;\r\n            let boundaryS = boundaries[0];\r\n            let boundaryE = boundaries[boundaries.length - 1];\r\n            flo_draw_1.drawFs.beziers(g, boundaryS, 'red thin20 nofill', showDelay);\r\n            for (let i = 1; i < boundaries.length - 1; i++) {\r\n                let boundary = boundaries[i];\r\n                flo_draw_1.drawFs.beziers(g, boundary, 'green thin20 nofill', showDelay);\r\n            }\r\n            flo_draw_1.drawFs.beziers(g, boundaryE, 'blue thin20 nofill', showDelay);\r\n        }\r\n        if (showTrace) {\r\n            let traces = threeProng.traces;\r\n            for (let trace of traces) {\r\n                flo_draw_1.drawFs.polyline(g, trace, 'red thin5 nofill', showDelay);\r\n            }\r\n        }\r\n    };\r\n}\r\n/** @hidden */\r\nlet threeProngDebugFunctions = {\r\n    drawSpokes,\r\n    traceConvergence,\r\n    showBoundary,\r\n    logδs,\r\n    logNearest\r\n};\r\nexports.threeProngDebugFunctions = threeProngDebugFunctions;\r\n//# sourceMappingURL=three-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/three-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/functions/two-prong.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/functions/two-prong.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * @hidden\r\n */\r\nfunction logδ(n, type = 'twoProng_regular') {\r\n    let δ = _debug_.generated.elems[type][n].δ;\r\n    console.log(δ);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction log(n, type = 'twoProng_regular') {\r\n    let twoProng = _debug_.generated.elems[type][n];\r\n    console.log(twoProng);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction drawNormal(g, n, showDelay = 1000, type = 'twoProng_regular') {\r\n    let twoProngs = _debug_.generated.elems[type];\r\n    // If not specified which, draw all\r\n    if (n === undefined) {\r\n        for (let i = 0; i < twoProngs.length; i++) {\r\n            drawNormal(g, i);\r\n        }\r\n    }\r\n    let twoProng = twoProngs[n];\r\n    //let g = twoProng.generated.g;\r\n    if (!twoProng) {\r\n        return;\r\n    }\r\n    flo_draw_1.drawFs.line(g, [twoProng.pos.p, twoProng.circle.center], 'thin10 blue', showDelay);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction logδBasic(n, type = 'twoProng_regular') {\r\n    let delta = _debug_.generated.elems[type][n].δ;\r\n    function f(x) {\r\n        let pos = x.cp.pointOnShape;\r\n        return {\r\n            bez: pos.curve.ps,\r\n            t: pos.t\r\n        };\r\n    }\r\n    console.log(f(delta[0]));\r\n    console.log(f(delta[1]));\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction logNearest(g, p, showDelay = 1000, type = 'twoProng_regular') {\r\n    let closestPerLoops = [];\r\n    let generated = _debug_.generated;\r\n    let twoProng = flo_vector2d_1.getObjClosestTo(p, generated.elems[type], twoProng => twoProng.circle.center);\r\n    closestPerLoops.push(twoProng);\r\n    console.log(twoProng);\r\n    let n;\r\n    for (let i = 0; i < _debug_.generated.elems[type].length; i++) {\r\n        let twoProng_ = _debug_.generated.elems[type][i];\r\n        if (twoProng_ === twoProng) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n !== undefined) {\r\n        traceConvergence(g, n, true, showDelay);\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * @param n - The 2-prong's zero-based index.\r\n * @param range\r\n */\r\nfunction traceConvergence(g, n, finalOnly, showDelay = 1000, range = undefined, type = 'twoProng_regular') {\r\n    if (n === undefined) {\r\n        return;\r\n    }\r\n    let twoProngInfo = _debug_.generated.elems[type][n];\r\n    let xs = twoProngInfo.xs;\r\n    //let g = twoProngInfo.generated.g;\r\n    console.log(twoProngInfo);\r\n    console.log(twoProngInfo.xs.map(x => ({\r\n        x: x.x,\r\n        y: x.y,\r\n        z: x.z,\r\n        d: x.z ? flo_vector2d_1.squaredDistanceBetween(x.y.p, x.z.p) : 0,\r\n        t: x.t,\r\n    })));\r\n    for (let i = 0; i < xs.length; i++) {\r\n        if (range && (i < range[0] || i >= range[1])) {\r\n            continue;\r\n        }\r\n        if (finalOnly && i !== xs.length - 1) {\r\n            continue;\r\n        }\r\n        let x = twoProngInfo.xs[i];\r\n        let circle = { center: x.x, radius: flo_vector2d_1.distanceBetween(x.x, x.y.p) };\r\n        flo_draw_1.drawFs.crossHair(g, x.x, 'red thin10 nofill', undefined, showDelay);\r\n        flo_draw_1.drawFs.circle(g, circle, 'blue thin10 nofill', showDelay);\r\n        if (x.z !== undefined) {\r\n            flo_draw_1.drawFs.crossHair(g, x.z.p, 'yellow thin10 nofill', 2, showDelay);\r\n        }\r\n    }\r\n    twoProngDebugFunctions.drawNormal(g, n, showDelay);\r\n}\r\n/** @hidden */\r\nlet twoProngDebugFunctions = {\r\n    logδ,\r\n    log,\r\n    drawNormal,\r\n    logδBasic,\r\n    traceConvergence,\r\n    logNearest,\r\n};\r\nexports.twoProngDebugFunctions = twoProngDebugFunctions;\r\n//# sourceMappingURL=two-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/functions/two-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/debug/three-prong-for-debugging.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-mat/node/debug/three-prong-for-debugging.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nfunction createEmptyThreeProngForDebugging() {\r\n    return {\r\n        generated: undefined,\r\n        circle: undefined,\r\n        poss: undefined,\r\n        cp3ss: undefined,\r\n        cpss: undefined,\r\n        bestIndx: undefined,\r\n        candidateThreeProngs: undefined,\r\n        visitedCps: undefined,\r\n        boundaries: undefined,\r\n        traces: undefined,\r\n    };\r\n}\r\nexports.createEmptyThreeProngForDebugging = createEmptyThreeProngForDebugging;\r\nfunction cpsSimple(threeProngForDebugging) {\r\n    return threeProngForDebugging.cpss.map(δ => [point_on_shape_1.posToHumanString(δ[0].cp.pointOnShape),\r\n        point_on_shape_1.posToHumanString(δ[1].cp.pointOnShape)]);\r\n}\r\n//# sourceMappingURL=three-prong-for-debugging.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/debug/three-prong-for-debugging.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/find-mats.js":
/*!************************************************!*\
  !*** ./node_modules/flo-mat/node/find-mats.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_boolean_1 = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/index.js\");\r\nconst find_and_add_3_prongs_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-3-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js\");\r\nconst create_initial_cp_graph_1 = __webpack_require__(/*! ./mat/find-mat/create-initial-cp-graph */ \"./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js\");\r\n;\r\nconst add_debug_info_1 = __webpack_require__(/*! ./mat/find-mat/add-debug-info */ \"./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js\");\r\nconst get_potential_2_prongs_1 = __webpack_require__(/*! ./mat/find-mat/get-potential-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js\");\r\nconst get_sharp_corners_1 = __webpack_require__(/*! ./mat/find-mat/get-sharp-corners */ \"./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js\");\r\nconst find_and_add_2_prongs_on_all_paths_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-2-prongs-on-all-paths */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js\");\r\nconst create_get_interesting_points_on_loop_1 = __webpack_require__(/*! ./mat/find-mat/create-get-interesting-points-on-loop */ \"./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js\");\r\nconst find_and_add_hole_closing_2_prongs_1 = __webpack_require__(/*! ./mat/find-mat/find-and-add-hole-closing-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js\");\r\nconst get_max_coordinate_1 = __webpack_require__(/*! ./loop/get-max-coordinate */ \"./node_modules/flo-mat/node/loop/get-max-coordinate.js\");\r\n/**\r\n * Finds and returns the Medial Axis Transforms (MATs) from the given array of\r\n * bezier loops representing shape boundaries.\r\n * @param bezierLoops An array of (possibly intersecting) loops with each loop\r\n * representing one or more piecewise smooth closed curves (i.e. shapes). Each\r\n * loop consists of an array of beziers represented by an array of control\r\n * points with 2,3 or 4 elements corresponding to linear, quadratic and cubic\r\n * beziers respectively. Each point is a two-element array (ordered pair), the\r\n * first of which is the x-coordinate and the second the y-coordinate.\r\n * @param maxFlatness The maximum value the flatness of a curve can have before\r\n * an additional MAT point is added in between. Defaults to 1.01. (Flatness is\r\n * measured as the total distance between control points of a curve divided by\r\n * the length of the curve.) The is clipped in [1.001,2]..\r\n * @param maxLength The maximum length a curve can have before an additional MAT\r\n * point is added in between. This value is scaled to a reference 1024 x 1024\r\n * grid (e.g. if the shape fits in a 512 x 512 axis-aligned box the will be\r\n * halved, e.g. from 10 to 5). Together with maxFlatness it represents a\r\n * tolerance for the accuracy of the MAT. Defaults to 4. The value is clipped\r\n * in [1,100].\r\n */\r\nfunction findMats(bezierLoops, maxFlatness = 1.01, maxLength = 4) {\r\n    if (typeof _debug_ !== 'undefined') {\r\n        var timingStart = performance.now();\r\n    }\r\n    let maxCoordinate;\r\n    let minBezLength;\r\n    ({ maxFlatness, maxLength, maxCoordinate, minBezLength } =\r\n        getSizeParams(bezierLoops, maxFlatness, maxLength));\r\n    let loopss = flo_boolean_1.simplifyPaths(bezierLoops, maxCoordinate);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let timing = _debug_.generated.timing;\r\n        timing.simplifyPaths = performance.now() - timingStart;\r\n    }\r\n    let mats = [];\r\n    for (let loops of loopss) {\r\n        let mat = findMat(loops, minBezLength, maxFlatness, maxLength, maxCoordinate);\r\n        if (mat) {\r\n            mats.push(mat);\r\n        }\r\n    }\r\n    return mats;\r\n}\r\nexports.findMats = findMats;\r\nfunction getSizeParams(bezierLoops, maxFlatness, maxLength) {\r\n    // Gather some shape metrics\r\n    let { maxCoordinate, maxRadius } = get_max_coordinate_1.getLoopsMetrics(bezierLoops);\r\n    let expMax = Math.ceil(Math.log2(maxCoordinate));\r\n    let minBezLengthSigBits = 14;\r\n    /**\r\n     * If a curve is shorter than this value then no points on it will be\r\n     * selected for the purpose of finding the MAT.\r\n     */\r\n    let minBezLength = Math.pow(2, expMax) * Math.pow(2, (-minBezLengthSigBits));\r\n    // Limit the tolerance to a reasonable level\r\n    if (maxFlatness < 1.001) {\r\n        maxFlatness = 1.001;\r\n    }\r\n    if (maxFlatness > 2) {\r\n        maxFlatness = 2;\r\n    }\r\n    // Limit the tolerance to a reasonable level\r\n    if (maxLength < 0.1) {\r\n        maxLength = 0.1;\r\n    }\r\n    if (maxLength > 100) {\r\n        maxLength = 100;\r\n    }\r\n    // Adjust length tolerance according to a reference max coordinate\r\n    let expMaxRadius = Math.ceil(Math.log2(maxRadius));\r\n    let maxLengthSigBits = 10; // 1024 x 1024\r\n    maxLength = maxLength * (Math.pow(2, expMaxRadius) * Math.pow(2, (-maxLengthSigBits)));\r\n    return { maxFlatness, maxLength, maxCoordinate, minBezLength };\r\n}\r\n/**\r\n * @hidden\r\n * Find the MAT of the given loops.\r\n * @param loops The loops (that as a precondition must be ordered from highest\r\n * (i.e. smallest y-value) topmost point loops to lowest)\r\n * @param xMap Intersection point map.\r\n * @param additionalPointCount\r\n */\r\nfunction findMat(loops, minBezLength, maxFlatness, maxLength, maxCoordinate) {\r\n    add_debug_info_1.addDebugInfo1(loops);\r\n    // Gets interesting points on the shape, i.e. those that makes sense to use \r\n    // for the 2-prong procedure.\r\n    let pointsPerLoop = loops.map(create_get_interesting_points_on_loop_1.getInterestingPointsOnLoop(minBezLength, maxFlatness, maxLength));\r\n    let for2ProngsPerLoop = get_potential_2_prongs_1.getPotential2Prongs(pointsPerLoop);\r\n    let sharpCornersPerLoop = get_sharp_corners_1.getSharpCorners(pointsPerLoop);\r\n    let cpTrees = new Map();\r\n    let cpNode = create_initial_cp_graph_1.createInitialCpGraph(loops, cpTrees, sharpCornersPerLoop);\r\n    find_and_add_hole_closing_2_prongs_1.findAndAddHoleClosing2Prongs(loops, cpTrees, maxCoordinate);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterHoleClosers) {\r\n            return undefined;\r\n        }\r\n    }\r\n    add_debug_info_1.addDebugInfo2();\r\n    cpNode = find_and_add_2_prongs_on_all_paths_1.findAndAdd2ProngsOnAllPaths(loops, cpTrees, for2ProngsPerLoop, maxCoordinate);\r\n    add_debug_info_1.addDebugInfo3();\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterTwoProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    if (cpNode === undefined) {\r\n        return undefined;\r\n    }\r\n    find_and_add_3_prongs_1.findAndAddAll3Prongs(cpTrees, cpNode, maxCoordinate);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        if (_debug_.directives.stopAfterThreeProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    let mat = { cpNode, cpTrees };\r\n    add_debug_info_1.addDebugInfo4(mat);\r\n    return mat;\r\n}\r\n//# sourceMappingURL=find-mats.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/find-mats.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the ordered bezier curves from this CpNode to the next CpNode\r\n * on the boundary.\r\n * @param cpNode\r\n */\r\nfunction getBoundaryBezierPartsToNext(cpNode) {\r\n    let cpThis = cpNode;\r\n    let cpNext = cpNode.next;\r\n    let posThis = cpThis.cp.pointOnShape;\r\n    let posNext = cpNext.cp.pointOnShape;\r\n    let curveThis = posThis.curve;\r\n    let curveNext = posNext.curve;\r\n    if (curveThis.loop !== curveNext.loop) {\r\n        // It is a hole-closer going over to the other loop - a kind of terminal\r\n        // CpNode.\r\n        return undefined;\r\n    }\r\n    let bezierParts = [];\r\n    if (curveNext === curveThis) {\r\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, posNext.t] });\r\n    }\r\n    else {\r\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, 1] });\r\n        addSkippedBeziers(bezierParts, posThis.curve, posNext.curve, posNext.t);\r\n    }\r\n    return bezierParts;\r\n}\r\nexports.getBoundaryBezierPartsToNext = getBoundaryBezierPartsToNext;\r\n/**\r\n * @hidden\r\n * Adds pieces of skipped beziers.\r\n */\r\nfunction addSkippedBeziers(bezierParts, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let bezierPart = curveThis === curveEnd\r\n            ? { ps: curveThis.ps, ts: [0, t1] }\r\n            : { ps: curveThis.ps, ts: [0, 1] };\r\n        bezierParts.push(bezierPart);\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-bezier-parts-to-next.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-boundary-beziers-to-next.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-boundary-beziers-to-next.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * Returns the ordered bezier curves from this CpNode to the next CpNode\r\n * on the boundary.\r\n * @param cpNode\r\n */\r\nfunction getBoundaryBeziersToNext(cpNode) {\r\n    let cpThis = cpNode;\r\n    let cpNext = cpNode.next;\r\n    let posThis = cpThis.cp.pointOnShape;\r\n    let posNext = cpNext.cp.pointOnShape;\r\n    let curveThis = posThis.curve;\r\n    let curveNext = posNext.curve;\r\n    if (curveThis.loop !== curveNext.loop) {\r\n        // It is a hole-closer going over to the other loop - a kind of terminal\r\n        // CpNode.\r\n        return undefined;\r\n    }\r\n    let beziers = [];\r\n    if (curveNext === curveThis) {\r\n        beziers.push(flo_bezier3_1.fromTo(posThis.curve.ps)(posThis.t, posNext.t));\r\n    }\r\n    else {\r\n        beziers.push(flo_bezier3_1.fromTTo1(posThis.curve.ps, posThis.t));\r\n        addSkippedBeziers(beziers, posThis.curve, posNext.curve, posNext.t);\r\n    }\r\n    return beziers;\r\n}\r\nexports.getBoundaryBeziersToNext = getBoundaryBeziersToNext;\r\n/**\r\n * Adds pieces of skipped beziers.\r\n * @hidden\r\n */\r\nfunction addSkippedBeziers(beziers, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        beziers.push(flo_bezier3_1.from0ToT(curveThis.ps, tEnd));\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-beziers-to-next.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-boundary-beziers-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-branches.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/get-branches.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ./get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\n/** @hidden */\r\nconst defaultTolerance = 1; // 1 degree\r\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]). Returns the result as an array of\r\n * smooth branches, where smoothness is total or within a given tolerance.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param tolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required.\r\n */\r\nfunction getBranches(cpNode, tolerance = defaultTolerance) {\r\n    // Start from a leaf\r\n    while (!cpNode.isFullyTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = [];\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = [cpNode.prevOnCircle];\r\n    let branchCpNodes = [];\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        branchCpNodes.push(cp);\r\n        let children = cp.getChildren();\r\n        if (cp.isFullyTerminating()) {\r\n            if (branchCpNodes.length > 1) {\r\n                branches.push(branchCpNodes);\r\n            }\r\n            branchCpNodes = [];\r\n            continue;\r\n        }\r\n        if (children.length === 1) {\r\n            cps.push(children[0]);\r\n            continue;\r\n        }\r\n        children = children.filter(cpNode => !cpNode.isTerminating());\r\n        if (children.length === 0) {\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n            continue;\r\n        }\r\n        if (children.length > 1) {\r\n            // More than one branch comes together\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n            cps.push(...children);\r\n            continue;\r\n        }\r\n        let backPointingTan = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(get_curve_to_next_1.getCurveToNext(cp.next.prevOnCircle), 0));\r\n        let forwardPointingTan = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(get_curve_to_next_1.getCurveToNext(children[0]), 0));\r\n        let cross_ = flo_vector2d_1.cross(backPointingTan, forwardPointingTan);\r\n        let angle = Math.abs(Math.asin(cross_) * (180 / Math.PI));\r\n        if (angle > tolerance) {\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n        }\r\n        cps.push(children[0]);\r\n    }\r\n    if (branchCpNodes.length) {\r\n        branches.push(branchCpNodes);\r\n    }\r\n    return branches;\r\n}\r\nexports.getBranches = getBranches;\r\n//# sourceMappingURL=get-branches.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-branches.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-curve-to-next.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/get-curve-to-next.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_curve_between_1 = __webpack_require__(/*! ./get-curve/get-curve-between */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\r\n/**\r\n * Returns the bezier curve from the maximal disk of the given [[CpNode]] to the\r\n * next [[CpNode]]'s maximal disk and thus directly represents a piece of the\r\n * medial axis.\r\n * @param cpNode\r\n */\r\nfunction getCurveToNext(cpNode) {\r\n    return get_curve_between_1.getCurveBetween(cpNode, cpNode.next);\r\n}\r\nexports.getCurveToNext = getCurveToNext;\r\n//# sourceMappingURL=get-curve-to-next.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-curve-to-next.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-curve/get-curve-between.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-curve/get-curve-between.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_edge_direction_1 = __webpack_require__(/*! ./get-edge-direction */ \"./node_modules/flo-mat/node/get-curve/get-edge-direction.js\");\r\n/** @hidden */\r\nconst TOLERANCE_ADD_2PRONG = 0.01;\r\n/** @hidden */\r\nconst TOLERANCE_USE_LINE = 0.0001; // else cubic\r\n/**\r\n * Returns the bezier curve from the maximal disk of one [[CpNode]] to another\r\n * [[CpNode]]'s maximal disk.\r\n * @param cpNodeFrom\r\n * @param cpNodeTo\r\n */\r\nfunction getCurveBetween(cpNodeFrom, cpNodeTo) {\r\n    let fromCc = cpNodeFrom.cp.circle.center;\r\n    let fromL = get_edge_direction_1.getEdgeDirection(cpNodeFrom);\r\n    let toCc = cpNodeTo.cp.circle.center;\r\n    let toL = get_edge_direction_1.getEdgeDirection(cpNodeTo.prevOnCircle);\r\n    let mid = flo_vector2d_1.lineLineIntersection(fromL, toL);\r\n    let c = flo_vector2d_1.fromTo(fromCc, toCc);\r\n    let twisted;\r\n    if (!mid) {\r\n        twisted = true;\r\n    }\r\n    else {\r\n        let a = flo_vector2d_1.fromTo(fromCc, mid);\r\n        let b = flo_vector2d_1.fromTo(toCc, mid);\r\n        twisted = flo_vector2d_1.dot(a, c) < 0 || flo_vector2d_1.dot(b, c) > 0;\r\n    }\r\n    if (!twisted) {\r\n        return [fromCc, mid, toCc];\r\n    }\r\n    let r = flo_vector2d_1.rotate90Degrees(c);\r\n    let w1 = flo_vector2d_1.fromTo(fromL[0], fromL[1]); // This is a unit vector\r\n    let w2 = flo_vector2d_1.fromTo(toL[0], toL[1]); // This is a unit vector\r\n    let d1 = Math.abs(flo_vector2d_1.cross(c, w1)) / (3 * 3);\r\n    let d2 = Math.abs(flo_vector2d_1.cross(c, w2)) / (3 * 3);\r\n    if (d1 > TOLERANCE_ADD_2PRONG || d2 > TOLERANCE_ADD_2PRONG) {\r\n        // TODO - not within tolerance - must add additional 2-prong\r\n        return [fromCc, toCc];\r\n    }\r\n    if (d1 > TOLERANCE_USE_LINE || d2 > TOLERANCE_USE_LINE) {\r\n        // approximate with cubic bezier\r\n        let m1 = flo_vector2d_1.interpolate(fromCc, toCc, 1 / 3);\r\n        let m2 = flo_vector2d_1.interpolate(fromCc, toCc, 2 / 3);\r\n        let v1 = flo_vector2d_1.translate(r, m1);\r\n        let v2 = flo_vector2d_1.translate(r, m2);\r\n        let l1 = [m1, v1];\r\n        let l2 = [m2, v2];\r\n        let mid1 = flo_vector2d_1.lineLineIntersection(fromL, l1);\r\n        let mid2 = flo_vector2d_1.lineLineIntersection(toL, l2);\r\n        return [fromCc, mid1, mid2, toCc];\r\n    }\r\n    // Within tolerance - approximate with a straight line.\r\n    return [fromCc, toCc];\r\n}\r\nexports.getCurveBetween = getCurveBetween;\r\n//# sourceMappingURL=get-curve-between.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-curve/get-curve-between.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/get-curve/get-edge-direction.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-mat/node/get-curve/get-edge-direction.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * @hidden\r\n * Returns a line segment of unit length starting in the given Vertex center and\r\n * pointing in the direction of the medial axis (viewed as a rooted tree).\r\n * @param cpNode\r\n */\r\nfunction getEdgeDirection(cpNode) {\r\n    let circleCenter = cpNode.cp.circle.center;\r\n    let cp1 = cpNode;\r\n    let cp2 = cpNode.nextOnCircle;\r\n    let pos1 = cp1.cp.pointOnShape;\r\n    let pos2 = cp2.cp.pointOnShape;\r\n    let p1 = pos1.p;\r\n    let p2 = pos2.p;\r\n    let vDir;\r\n    //if (!PointOnShape.isSharpCorner(pos1)) {\r\n    if (!point_on_shape_1.isPosSharpCorner(pos1)) {\r\n        if (p1[0] === p2[0] && p1[1] === p2[1]) {\r\n            vDir = flo_vector2d_1.fromTo(p1, circleCenter); // A 1-prong\r\n        }\r\n        else {\r\n            vDir = flo_vector2d_1.rotate90Degrees(flo_vector2d_1.fromTo(p1, p2)); // not a 1-prong.\r\n        }\r\n    }\r\n    else {\r\n        let curve1;\r\n        let curve2;\r\n        // TODO - test if pos1.t can ever be 0 - it is terminating\r\n        if (pos1.t === 0) {\r\n            curve1 = pos1.curve;\r\n            curve2 = pos1.curve.prev;\r\n        }\r\n        else if (pos1.t === 1) {\r\n            curve1 = pos1.curve.next;\r\n            curve2 = pos1.curve;\r\n        }\r\n        let tan1 = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(curve1.ps, 0));\r\n        let tan2 = flo_vector2d_1.reverse(flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(curve2.ps, 1)));\r\n        let x = flo_vector2d_1.dot(tan1, tan2);\r\n        // Recall the identities sin(acos(x)) = sqrt(1-x^2), etc. Also \r\n        // recall the half angle formulas. Then the rotation matrix, R, can \r\n        // be calculated.\r\n        let cosθ = Math.sqrt((1 + x) / 2);\r\n        let sinθ = Math.sqrt((1 - x) / 2);\r\n        vDir = flo_vector2d_1.rotate(sinθ, cosθ, tan2);\r\n    }\r\n    let v = flo_vector2d_1.translate(flo_vector2d_1.toUnitVector(vDir), circleCenter);\r\n    return [circleCenter, v];\r\n}\r\nexports.getEdgeDirection = getEdgeDirection;\r\n//# sourceMappingURL=get-edge-direction.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/get-curve/get-edge-direction.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/index.js":
/*!********************************************!*\
  !*** ./node_modules/flo-mat/node/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ./cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nexports.CpNode = cp_node_1.CpNode;\r\nconst point_on_shape_1 = __webpack_require__(/*! ./point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nexports.PointOnShape = point_on_shape_1.PointOnShape;\r\nconst find_mats_1 = __webpack_require__(/*! ./find-mats */ \"./node_modules/flo-mat/node/find-mats.js\");\r\nexports.findMats = find_mats_1.findMats;\r\nconst trim_mat_1 = __webpack_require__(/*! ./mat/trim-mat */ \"./node_modules/flo-mat/node/mat/trim-mat.js\");\r\nexports.trimMat = trim_mat_1.trimMat;\r\nconst to_scale_axis_1 = __webpack_require__(/*! ./to-scale-axis */ \"./node_modules/flo-mat/node/to-scale-axis.js\");\r\nexports.toScaleAxis = to_scale_axis_1.toScaleAxis;\r\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nexports.traverseEdges = traverse_edges_1.traverseEdges;\r\nconst get_branches_1 = __webpack_require__(/*! ./get-branches */ \"./node_modules/flo-mat/node/get-branches.js\");\r\nexports.getBranches = get_branches_1.getBranches;\r\nconst traverse_vertices_1 = __webpack_require__(/*! ./traverse-vertices */ \"./node_modules/flo-mat/node/traverse-vertices.js\");\r\nexports.traverseVertices = traverse_vertices_1.traverseVertices;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-mat/node/debug/debug.js\");\r\nexports.enableDebugForMat = debug_1.enableDebugForMat;\r\nconst branch_1 = __webpack_require__(/*! ./debug/functions/draw-elem/branch */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/branch.js\");\r\nexports.drawBranch = branch_1.drawBranch;\r\nconst mat_1 = __webpack_require__(/*! ./debug/functions/draw-elem/mat */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/mat.js\");\r\nexports.drawMat = mat_1.drawMat;\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ./mat/closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nexports.getClosestBoundaryPoint = get_closest_boundary_point_1.getClosestBoundaryPoint;\r\nconst flo_boolean_1 = __webpack_require__(/*! flo-boolean */ \"./node_modules/flo-boolean/node/index.js\");\r\nexports.beziersToSvgPathStr = flo_boolean_1.beziersToSvgPathStr;\r\nexports.getPathsFromStr = flo_boolean_1.getPathsFromStr;\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ./svg/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/get-shape-bounds.js\");\r\nexports.getShapeBounds = get_shape_bounds_1.getShapeBounds;\r\nconst get_boundary_beziers_to_next_1 = __webpack_require__(/*! ./get-boundary-beziers-to-next */ \"./node_modules/flo-mat/node/get-boundary-beziers-to-next.js\");\r\nexports.getBoundaryBeziersToNext = get_boundary_beziers_to_next_1.getBoundaryBeziersToNext;\r\nconst get_boundary_bezier_parts_to_next_1 = __webpack_require__(/*! ./get-boundary-bezier-parts-to-next */ \"./node_modules/flo-mat/node/get-boundary-bezier-parts-to-next.js\");\r\nexports.getBoundaryBezierPartsToNext = get_boundary_bezier_parts_to_next_1.getBoundaryBezierPartsToNext;\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ./mat/get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\nexports.getBoundaryPieceBeziers = get_boundary_piece_beziers_1.getBoundaryPieceBeziers;\r\nconst simplify_mat_1 = __webpack_require__(/*! ./simplify-mat */ \"./node_modules/flo-mat/node/simplify-mat.js\");\r\nexports.simplifyMat = simplify_mat_1.simplifyMat;\r\nconst simplify_mat_map_only_1 = __webpack_require__(/*! ./mat/simplify-mat-map-only */ \"./node_modules/flo-mat/node/mat/simplify-mat-map-only.js\");\r\nexports.simplifyMatMapOnly = simplify_mat_map_only_1.simplifyMatMapOnly;\r\nconst draw_elem_1 = __webpack_require__(/*! ./debug/functions/draw-elem/draw-elem */ \"./node_modules/flo-mat/node/debug/functions/draw-elem/draw-elem.js\");\r\nexports.drawElemFunctions = draw_elem_1.drawElemFunctions;\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ./get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\nexports.getCurveToNext = get_curve_to_next_1.getCurveToNext;\r\nconst get_curve_between_1 = __webpack_require__(/*! ./get-curve/get-curve-between */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\r\nexports.getCurveBetween = get_curve_between_1.getCurveBetween;\r\nconst sweep_line_1 = __webpack_require__(/*! ./sweep-line/sweep-line */ \"./node_modules/flo-mat/node/sweep-line/sweep-line.js\");\r\nexports.sweepLine = sweep_line_1.sweepLine;\r\nconst are_boxes_intersecting_1 = __webpack_require__(/*! ./sweep-line/are-boxes-intersecting */ \"./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js\");\r\nexports.areBoxesIntersecting = are_boxes_intersecting_1.areBoxesIntersecting;\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ./mat/geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\nexports.getClosestSquareDistanceToRect = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect;\r\nconst loop_1 = __webpack_require__(/*! ./loop */ \"./node_modules/flo-mat/node/loop.js\");\r\nexports.loopFromBeziers = loop_1.loopFromBeziers;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop.js":
/*!*******************************************!*\
  !*** ./node_modules/flo-mat/node/loop.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @param beziers A pre-ordered array of bezier curves to add initially.\r\n */\r\nfunction loopFromBeziers(beziers = []) {\r\n    let curves = [];\r\n    let loop = {\r\n        beziers,\r\n        curves\r\n    };\r\n    if (!beziers.length) {\r\n        return loop;\r\n    }\r\n    let prev;\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let curve = {\r\n            loop,\r\n            ps: beziers[i],\r\n            prev,\r\n            next: undefined,\r\n            idx: i\r\n        };\r\n        if (prev) {\r\n            prev.next = curve;\r\n        }\r\n        prev = curve;\r\n        curves.push(curve);\r\n    }\r\n    // close loop\r\n    let lastCurve = curves[curves.length - 1];\r\n    curves[0].prev = lastCurve;\r\n    lastCurve.next = curves[0];\r\n    return loop;\r\n}\r\nexports.loopFromBeziers = loopFromBeziers;\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/loop/get-max-coordinate.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/loop/get-max-coordinate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst max = Math.max;\r\nconst abs = Math.abs;\r\n/**\r\n * @hidden\r\n * Returns the maximum control point coordinate value (x or y) within any loop.\r\n * @param loops The array of loops\r\n */\r\nfunction getLoopsMetrics(loops) {\r\n    let maxCoordinate = 0;\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    for (let loop of loops) {\r\n        for (let ps of loop) {\r\n            for (let p of ps) {\r\n                let x = p[0];\r\n                let y = p[1];\r\n                let c = max(abs(x), abs(y));\r\n                if (c > maxCoordinate) {\r\n                    maxCoordinate = c;\r\n                }\r\n                if (x < minX) {\r\n                    minX = x;\r\n                }\r\n                if (x > maxX) {\r\n                    maxX = x;\r\n                }\r\n                if (y < minY) {\r\n                    minY = y;\r\n                }\r\n                if (y > maxY) {\r\n                    maxY = y;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    let width = maxX - minX;\r\n    let height = maxY - minY;\r\n    let maxRadius = max(width, height);\r\n    return { maxCoordinate, maxRadius };\r\n}\r\nexports.getLoopsMetrics = getLoopsMetrics;\r\n//# sourceMappingURL=get-max-coordinate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/loop/get-max-coordinate.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/add-to-cp-graph.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/add-to-cp-graph.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/**\r\n * @hidden\r\n * @param circle\r\n * @param orders\r\n * @param cpTrees\r\n * @param poss\r\n * @param neighbors\r\n * @hidden\r\n */\r\nfunction addToCpGraph(circle, orders, cpTrees, poss, neighbors) {\r\n    let newCps = poss.map((pos, i) => {\r\n        let cpTree = cpTrees.get(pos.curve.loop);\r\n        let newCp_ = { pointOnShape: pos, circle, order: orders[i], order2: 0 };\r\n        let neighboringCp = neighbors\r\n            ? neighbors[i]\r\n            : get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, orders[i], 0);\r\n        let newCp = cp_node_1.CpNode.insert(false, false, cpTree, newCp_, neighboringCp[0]);\r\n        return newCp;\r\n    });\r\n    let len = poss.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let indxPrev = i === 0 ? len - 1 : i - 1;\r\n        let indxNext = i === len - 1 ? 0 : i + 1;\r\n        newCps[i].prevOnCircle = newCps[indxPrev];\r\n        newCps[i].nextOnCircle = newCps[indxNext];\r\n    }\r\n}\r\nexports.addToCpGraph = addToCpGraph;\r\n//# sourceMappingURL=add-to-cp-graph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/add-to-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_poly_1 = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\n/**\r\n * @hidden\r\n * @param curve The curve\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointsOnCurve(curve, p, [tS, tE] = [0, 1], touchedCurve, t) {\r\n    let poly = flo_bezier3_1.getTangentPolyFromPointExact(curve.ps, p);\r\n    if (curve === touchedCurve) {\r\n        poly = flo_poly_1.deflateQuad(poly, t);\r\n    }\r\n    let roots = flo_poly_1.allRootsMultiWithErrBounds(poly, poly.map(c => 0), // because all coefficients are exact\r\n    undefined, // ...\r\n    tS, tE);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if ((t === 1 && curve === touchedCurve.next) ||\r\n        (t === 0 && curve === touchedCurve)) {\r\n        push0 = false;\r\n    }\r\n    if ((t === 0 && curve === touchedCurve.prev) ||\r\n        (t === 1 && curve === touchedCurve)) {\r\n        push1 = false;\r\n    }\r\n    if (tS === 0) {\r\n        if (push0) {\r\n            roots.push({ tS: 0, tE: 0 });\r\n        }\r\n    }\r\n    else if (tS === 1) {\r\n        if (push1) {\r\n            roots.push({ tS: 1, tE: 1 });\r\n        }\r\n    }\r\n    else {\r\n        roots.push({ tS: tS, tE: tS });\r\n    }\r\n    if (tE === 0) {\r\n        if (push0) {\r\n            roots.push({ tS: 0, tE: 0 });\r\n        }\r\n    }\r\n    else if (tE === 1) {\r\n        if (push1) {\r\n            roots.push({ tS: 1, tE: 1 });\r\n        }\r\n    }\r\n    else {\r\n        roots.push({ tS: tE, tE: tE });\r\n    }\r\n    let ps = roots.map(root => {\r\n        let tS = root.tS;\r\n        let tE = root.tE;\r\n        // TODO - tS, tE should always stay within [0,1] - modify findRootsMulti\r\n        let t = tS < 0\r\n            ? 0\r\n            : tE > 1 ? 1 : (tS + tE) / 2;\r\n        // TODO - why does evalDeCasteljau not work here?\r\n        return { p: flo_bezier3_1.evaluate(curve.ps, t), t };\r\n        //return { p: evalDeCasteljau(curve.ps,t), t }\r\n    });\r\n    return ps;\r\n}\r\nexports.closestPointsOnCurve = closestPointsOnCurve;\r\n//# sourceMappingURL=closest-points-on-curve.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_best_distance_squared_1 = __webpack_require__(/*! ./get-best-distance-squared */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js\");\r\nconst cull_by_loose_bounding_box_1 = __webpack_require__(/*! ./cull-by-loose-bounding-box */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js\");\r\nconst cull_by_tight_boundary_box_1 = __webpack_require__(/*! ./cull-by-tight-boundary-box */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js\");\r\n/**\r\n * @hidden\r\n * @param bezierPieces\r\n * @param p\r\n * @param extreme\r\n */\r\nfunction cullBezierPieces(bezierPieces, p) {\r\n    const CULL_THRESHOLD = 0;\r\n    if (bezierPieces.length > CULL_THRESHOLD) {\r\n        let bestSquaredDistance = get_best_distance_squared_1.getBestDistanceSquared(bezierPieces, p);\r\n        bezierPieces = cull_by_loose_bounding_box_1.cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\r\n        bezierPieces = cull_by_tight_boundary_box_1.cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\r\n    }\r\n    return bezierPieces;\r\n}\r\nexports.cullBezierPieces = cullBezierPieces;\r\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\n/**\r\n * @hidden\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than 'bestSquaredDistance', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param dSquared\r\n */\r\nfunction cullByLooseBoundingBox(bezierPieces, p, dSquared) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let boundingBox = flo_bezier3_1.getBoundingBox(ps);\r\n        let d = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(boundingBox, p);\r\n        if (d <= dSquared) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\nexports.cullByLooseBoundingBox = cullByLooseBoundingBox;\r\n//# sourceMappingURL=cull-by-loose-bounding-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-loose-bounding-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_squared_distance_to_rotated_rect_1 = __webpack_require__(/*! ../geometry/get-closest-squared-distance-to-rotated-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js\");\r\n/**\r\n * @hidden\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than 'bestSquaredDistance', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param bestSquaredDistance\r\n */\r\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\r\n        let d = get_closest_squared_distance_to_rotated_rect_1.getClosestSquaredDistanceToRotatedRect(tightBoundingBox, p);\r\n        if (d <= bestSquaredDistance) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\nexports.cullByTightBoundingBox = cullByTightBoundingBox;\r\n//# sourceMappingURL=cull-by-tight-boundary-box.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/cull-by-tight-boundary-box.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * @hidden\r\n * Finds an initial distance such that the closest point can not be further than\r\n * this distance away.\r\n */\r\nfunction getBestDistanceSquared(bezierPieces, p) {\r\n    let bestSquaredDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let p1 = flo_bezier3_1.evalDeCasteljau(ps, bezierPiece.ts[0]);\r\n        let p2 = flo_bezier3_1.evalDeCasteljau(ps, bezierPiece.ts[1]);\r\n        let d = Math.min(flo_vector2d_1.squaredDistanceBetween(p, p1), flo_vector2d_1.squaredDistanceBetween(p, p2));\r\n        if (d < bestSquaredDistance) {\r\n            bestSquaredDistance = d;\r\n        }\r\n    }\r\n    // The extra multiplier is to account for floating point precision.\r\n    // TODO - remove delta (or base it on theory)\r\n    return bestSquaredDistance * 1.01;\r\n}\r\nexports.getBestDistanceSquared = getBestDistanceSquared;\r\n//# sourceMappingURL=get-best-distance-squared.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-best-distance-squared.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js\");\r\nconst closest_points_on_curve_1 = __webpack_require__(/*! ./closest-points-on-curve */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js\");\r\n/**\r\n * @hidden\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getCloseBoundaryPoints(bezierPieces, point, y, distance) {\r\n    let touchedCurve = y.curve;\r\n    let t = y.t;\r\n    let p_ = y.p;\r\n    bezierPieces = cull_bezier_pieces_1.cullBezierPieces(bezierPieces, point);\r\n    // TODO - integrate with is-another-cp-closeby - we MUST check angle too!\r\n    let DISTANCE_TOLERANCE = 1e-9;\r\n    let posInfos = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        // TOOD - important - should be able to return multiple points\r\n        let ps = closest_points_on_curve_1.closestPointsOnCurve(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\r\n        //if (ps === undefined) { continue; }\r\n        for (let j = 0; j < ps.length; j++) {\r\n            let p = ps[j];\r\n            let d = flo_vector2d_1.distanceBetween(p.p, point);\r\n            let curve = bezierPiece.curve;\r\n            let t_ = p.t;\r\n            if (Math.abs(d - distance) < DISTANCE_TOLERANCE) {\r\n                if (t_ === 0) {\r\n                    t_ = 1;\r\n                    curve = bezierPiece.curve.prev;\r\n                }\r\n                posInfos.push({ pos: new point_on_shape_1.PointOnShape(curve, t_), d });\r\n            }\r\n        }\r\n    }\r\n    if (posInfos.length > 1) {\r\n        // Remove ones that are too close together.\r\n        // TODO - in future remove all these checks and join n-prongs when they\r\n        // are being added - much simpler and more symmetric. Remeber order when\r\n        // comparing closeness!\r\n        let indexesToCheck = [];\r\n        for (let i = 0; i < posInfos.length; i++) {\r\n            let pi = posInfos[i];\r\n            // Only check if they are close to the edges. Why??\r\n            //if (pi.pos.t < 1e-2 || 1-pi.pos.t < 1e-2) {\r\n            indexesToCheck.push(i);\r\n            //}\r\n        }\r\n        let indexesToRemove = [];\r\n        for (let i = 0; i < indexesToCheck.length; i++) {\r\n            for (let j = i + 1; j < indexesToCheck.length; j++) {\r\n                if (i === j) {\r\n                    continue;\r\n                }\r\n                let p1 = posInfos[indexesToCheck[i]].pos.p;\r\n                let p2 = posInfos[indexesToCheck[j]].pos.p;\r\n                // Below checks for source point too - similar to \r\n                // isAnotherCpCloseBy\r\n                let p3 = p_;\r\n                if ((Math.abs(p1[0] - p2[0]) < 1e-6 &&\r\n                    Math.abs(p1[1] - p2[1]) < 1e-6) ||\r\n                    (Math.abs(p1[0] - p3[0]) < 1e-6 &&\r\n                        Math.abs(p1[1] - p3[1]) < 1e-6)) {\r\n                    indexesToRemove.push(indexesToCheck[i]);\r\n                }\r\n            }\r\n        }\r\n        for (let i = indexesToRemove.length - 1; i >= 0; i--) {\r\n            posInfos.splice(indexesToRemove[i], 1);\r\n        }\r\n    }\r\n    return posInfos;\r\n}\r\nexports.getCloseBoundaryPoints = getCloseBoundaryPoints;\r\n//# sourceMappingURL=get-close-boundary-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/cull-bezier-pieces.js\");\r\nconst closest_points_on_curve_1 = __webpack_require__(/*! ./closest-points-on-curve */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/closest-points-on-curve.js\");\r\n/**\r\n * @hidden\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getClosestBoundaryPoint(bezierPieces, point, touchedCurve, t) {\r\n    bezierPieces = cull_bezier_pieces_1.cullBezierPieces(bezierPieces, point);\r\n    let bestDistance = Number.POSITIVE_INFINITY;\r\n    let posInfo;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = closest_points_on_curve_1.closestPointsOnCurve(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\r\n        let p = flo_vector2d_1.getObjClosestTo(point, ps, p => p.p);\r\n        if (p === undefined) {\r\n            continue;\r\n        }\r\n        let d = flo_vector2d_1.distanceBetween(p.p, point);\r\n        let curve = bezierPiece.curve;\r\n        let t_ = p.t;\r\n        if (d < bestDistance) {\r\n            if (t_ === 0) {\r\n                t_ = 1;\r\n                curve = bezierPiece.curve.prev;\r\n            }\r\n            posInfo = { pos: new point_on_shape_1.PointOnShape(curve, t_), d };\r\n            bestDistance = d;\r\n        }\r\n    }\r\n    return posInfo;\r\n}\r\nexports.getClosestBoundaryPoint = getClosestBoundaryPoint;\r\n//# sourceMappingURL=get-closest-boundary-point.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/create-new-cp-tree.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/create-new-cp-tree.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * @hidden\r\n * @param cpNode\r\n */\r\nfunction createNewCpTree(cpNode) {\r\n    let newCpTrees = new Map();\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(f);\r\n    function f(cpNode) {\r\n        let loop = cpNode.cp.pointOnShape.curve.loop;\r\n        let cpTree = newCpTrees.get(loop);\r\n        if (!cpTree) {\r\n            cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\r\n            newCpTrees.set(loop, cpTree);\r\n        }\r\n        cpTree.insert(cpNode);\r\n    }\r\n    return newCpTrees;\r\n}\r\nexports.createNewCpTree = createNewCpTree;\r\n//# sourceMappingURL=create-new-cp-tree.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/create-new-cp-tree.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\n/**\r\n * @hidden\r\n * Add a 1-prong to the MAT.\r\n * @param cpGraphs\r\n * @param pos\r\n */\r\nfunction add1Prong(maxOsculatingCircleRadius, cpGraphs, pos) {\r\n    //if (PointOnShape.isDullCorner(pos)) {\r\n    if (point_on_shape_1.isPosDullCorner(pos)) {\r\n        // This is a 1-prong at a dull corner.\r\n        // TODO IMPORTANT \r\n        // Remove this line, uncomment piece below it and implement the \r\n        // following strategy to find the 3-prongs: if deltas are conjoined due \r\n        // to dull corner, split the conjoinment by inserting successively \r\n        // closer (binary division) 2-prongs. If a 2-prong actually fails, \r\n        // simply remove the 1-prong at the dull corner. In this way **all** \r\n        // terminal points are found, e.g. zoom in on top left leg of ant.\r\n        // Afterthought: there is a better way - split points by two prongs.\r\n        //toRemove.push(posNode); // this!\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.oneProngAtDullCorner.push(pos);\r\n        }\r\n        return;\r\n    }\r\n    //let circle = PointOnShape.getOsculatingCircle(maxOsculatingCircleRadius, pos);\r\n    let circle = point_on_shape_1.getOsculatingCircle(maxOsculatingCircleRadius, pos);\r\n    //let order = PointOnShape.calcOrder(circle, pos);\r\n    let order = point_on_shape_1.calcPosOrder(circle, pos);\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, pos, circle, order, 0, 1000, 'magenta')) {\r\n        return;\r\n    }\r\n    add_to_cp_graph_1.addToCpGraph(circle, [-0.5, +0.5], cpGraphs, [pos, pos]);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.oneProng.push(pos);\r\n    }\r\n}\r\nexports.add1Prong = add1Prong;\r\n//# sourceMappingURL=add-1-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/**\r\n * @hidden\r\n * Adds a 2-prong contact circle to the shape.\r\n * @param cpGraphs\r\n * @param circle Circle containing the 2 contact points\r\n * @param posSource The source point on shape\r\n * @param posAntipode The found antipodal point on shape\r\n * @param holeClosing True if this is a hole-closing 2-prong, false otherwise\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction add2Prong(cpGraphs, circle, posSource, posAntipodes, holeClosing, extreme) {\r\n    //let orderSource   = PointOnShape.calcOrder(circle, posSource);\r\n    let orderSource = point_on_shape_1.calcPosOrder(circle, posSource);\r\n    let orderAntipodes = posAntipodes.map(posAntipode => {\r\n        //console.log(circle.center)\r\n        //return PointOnShape.calcOrder(circle, posAntipode.pos);\r\n        return point_on_shape_1.calcPosOrder(circle, posAntipode.pos);\r\n    });\r\n    let t_s = posSource.t;\r\n    let curve;\r\n    if (t_s === 0) {\r\n        t_s = 1;\r\n        curve = posSource.curve.prev;\r\n        posSource = new point_on_shape_1.PointOnShape(curve, t_s);\r\n    }\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    // TODO - possibly combine n-prongs in this case\r\n    let isCloseByAntipodes = false;\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posAntipode.pos, circle, orderAntipode, 0, extreme, 'red')) {\r\n            isCloseByAntipodes = true;\r\n            break;\r\n        }\r\n    }\r\n    if (is_another_cp_closeby_1.isAnotherCpCloseby(cpGraphs, posSource, circle, orderSource, 0, extreme, 'red') ||\r\n        isCloseByAntipodes) {\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (holeClosing) {\r\n                _debug_.generated.elems['twoProng_holeClosing'].pop();\r\n            }\r\n            else {\r\n                _debug_.generated.elems['twoProng_regular'].pop();\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    // Antipode\r\n    let newCpAntipodes = [];\r\n    let cpAntipodes = [];\r\n    let cpTreeAntipodes = [];\r\n    let deltaAntipodes = [];\r\n    let loopAntipodes = [];\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        let cpAntipode = { pointOnShape: posAntipode.pos, circle, order: orderAntipode, order2: 0 };\r\n        cpAntipodes.push(cpAntipode);\r\n        let loopAntipode = posAntipode.pos.curve.loop;\r\n        loopAntipodes.push(loopAntipode);\r\n        let cpTreeAntipode = cpGraphs.get(loopAntipode);\r\n        cpTreeAntipodes.push(cpTreeAntipode);\r\n        let deltaAntipode = get_neighboring_cps_1.getNeighbouringPoints(cpTreeAntipode, posAntipode.pos, orderAntipode, 0);\r\n        deltaAntipodes.push(deltaAntipode);\r\n        newCpAntipodes.push(cp_node_1.CpNode.insert(holeClosing, false, cpTreeAntipode, cpAntipode, deltaAntipode[0]));\r\n    }\r\n    // Source\r\n    let cpSource = { pointOnShape: posSource, circle, order: orderSource, order2: 0 };\r\n    let loopSource = posSource.curve.loop;\r\n    let cpTreeSource = cpGraphs.get(loopSource);\r\n    let deltaSource = get_neighboring_cps_1.getNeighbouringPoints(cpTreeSource, posSource, orderSource, 0);\r\n    let newCpSource = cp_node_1.CpNode.insert(holeClosing, false, cpTreeSource, cpSource, deltaSource[0]);\r\n    // Connect graph\r\n    if (newCpAntipodes.length === 1) {\r\n        newCpSource.prevOnCircle = newCpAntipodes[0];\r\n        newCpSource.nextOnCircle = newCpAntipodes[0];\r\n        newCpAntipodes[0].prevOnCircle = newCpSource;\r\n        newCpAntipodes[0].nextOnCircle = newCpSource;\r\n    }\r\n    else {\r\n        let cpNodes = newCpAntipodes.slice();\r\n        cpNodes.push(newCpSource);\r\n        // Order points according to their angle with the x-axis\r\n        cpNodes.sort(byAngle(circle));\r\n        for (let i = 0; i < cpNodes.length; i++) {\r\n            let iNext = (i + 1 === cpNodes.length) ? 0 : i + 1;\r\n            let iPrev = (i === 0) ? cpNodes.length - 1 : i - 1;\r\n            let cpNodeCurr = cpNodes[i];\r\n            let cpNodeNext = cpNodes[iNext];\r\n            let cpNodePrev = cpNodes[iPrev];\r\n            cpNodeCurr.nextOnCircle = cpNodeNext;\r\n            cpNodeCurr.prevOnCircle = cpNodePrev;\r\n        }\r\n    }\r\n    if (holeClosing) {\r\n        // TODO - important - take care of case where there are more than 1 antipode\r\n        // Duplicate ContactPoints\r\n        let cpB2 = { pointOnShape: posAntipodes[0].pos, circle, order: cpAntipodes[0].order, order2: +1 };\r\n        let newCpB2Node = cp_node_1.CpNode.insert(true, false, cpTreeAntipodes[0], cpB2, newCpAntipodes[0]);\r\n        let cpB1 = { pointOnShape: posSource, circle, order: cpSource.order, order2: -1 };\r\n        let newCpB1Node = cp_node_1.CpNode.insert(true, false, cpTreeSource, cpB1, newCpSource.prev);\r\n        // Connect graph\r\n        newCpB1Node.prevOnCircle = newCpB2Node;\r\n        newCpB1Node.nextOnCircle = newCpB2Node;\r\n        newCpB2Node.prevOnCircle = newCpB1Node;\r\n        newCpB2Node.nextOnCircle = newCpB1Node;\r\n        newCpAntipodes[0].next = newCpSource;\r\n        newCpSource.prev = newCpAntipodes[0];\r\n        newCpB1Node.next = newCpB2Node;\r\n        newCpB2Node.prev = newCpB1Node;\r\n    }\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let elems;\r\n        if (holeClosing) {\r\n            elems = _debug_.generated.elems['twoProng_holeClosing'];\r\n        }\r\n        else {\r\n            elems = _debug_.generated.elems['twoProng_regular'];\r\n        }\r\n        let elem = elems[elems.length - 1];\r\n        if (!newCpSource) {\r\n            console.log('asas');\r\n        }\r\n        elem.cpNode = newCpSource;\r\n    }\r\n    return newCpSource;\r\n}\r\nexports.add2Prong = add2Prong;\r\n/** @hidden */\r\nfunction scale(n, exp) {\r\n    return n * (Math.pow(2, -(exp + 1)));\r\n}\r\n/** @hidden */\r\nfunction getSize(x, y) {\r\n    // Get size of a\r\n    if (x > 0) {\r\n        if (x > 0.5) {\r\n            return y; // ~ -0.7 -> 0.7, i.e. -(sqrt(2)/2) -> +(sqrt(2)/2) \r\n        }\r\n        else {\r\n            if (y < 0) {\r\n                return x - 2; // ~ -2.0 -> -1.3\r\n            }\r\n            else {\r\n                return -x + 2; // ~ 1.3 -> 2.0\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (x < -0.5) {\r\n            return -y + 4; // ~ 3.3 -> 4.7\r\n        }\r\n        else {\r\n            if (y < 0) {\r\n                return x + 6; // ~ 5.3 -> 6.0\r\n            }\r\n            else {\r\n                return -x + 2; // ~ 2 -> 2.7\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @hidden */\r\nfunction byAngle(circle) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let exp = flo_numerical_1.exponent(r);\r\n    return function (_a, _b) {\r\n        let a = _a.cp.pointOnShape.p;\r\n        let b = _b.cp.pointOnShape.p;\r\n        // Move onto origin\r\n        a = [a[0] - c[0], a[1] - c[1]];\r\n        b = [b[0] - c[0], b[1] - c[1]];\r\n        // Scale\r\n        let ax = scale(a[0], exp);\r\n        let ay = scale(a[1], exp);\r\n        let bx = scale(b[0], exp);\r\n        let by = scale(b[1], exp);\r\n        // Get 'size'\r\n        let sa = getSize(ax, ay);\r\n        let sb = getSize(bx, by);\r\n        return sb - sa;\r\n    };\r\n}\r\n//# sourceMappingURL=add-2-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst add_to_cp_graph_1 = __webpack_require__(/*! ../add-to-cp-graph */ \"./node_modules/flo-mat/node/mat/add-to-cp-graph.js\");\r\nconst is_another_cp_closeby_1 = __webpack_require__(/*! ../is-another-cp-closeby */ \"./node_modules/flo-mat/node/mat/is-another-cp-closeby.js\");\r\n/**\r\n * @hidden\r\n * Adds a 3-prong MAT circle according to the 3 given (previously calculated)\r\n * points on the shape.\r\n * @param cpTrees\r\n * @param orders\r\n * @param threeProng\r\n */\r\nfunction add3Prong(cpTrees, orders, threeProng) {\r\n    let { circle, ps: poss, δ3s } = threeProng;\r\n    // Keep for possible future debugging.\t\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let i=0; i<3; i++) {\r\n            let cpBef = threeProng.δ3s[i][0].cp;\r\n            let cpAft = threeProng.δ3s[i][1].cp;\r\n            //let cmpBef = PointOnShape.compareInclOrder(cpBef.pointOnShape, ps[i], cpBef.order, orders[i]);\r\n            //let cmpAft = PointOnShape.compareInclOrder(cpAft.pointOnShape, ps[i], cpAft.order, orders[i]);\r\n\r\n            let cmpBef = PointOnShape.compare(cpBef.pointOnShape, ps[i]);\r\n            let cmpAft = PointOnShape.compare(cpAft.pointOnShape, ps[i]);\r\n\r\n            // len is used by debug functions to reference a particular\r\n            // three-prong.\r\n            let len = _debug_.generated.elems.threeProng.length-1;\r\n            if (cmpBef > 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n            if (cmpAft < 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n        }\r\n    }\r\n    */\r\n    // TODO - replace 1000 below with correct value\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, poss[0], circle, orders[0], 0, 1000, 'blue');\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, poss[1], circle, orders[1], 0, 1000, 'blue');\r\n    is_another_cp_closeby_1.isAnotherCpCloseby(cpTrees, poss[2], circle, orders[2], 0, 1000, 'blue');\r\n    add_to_cp_graph_1.addToCpGraph(circle, orders, cpTrees, poss, δ3s);\r\n    return circle;\r\n}\r\nexports.add3Prong = add3Prong;\r\n//# sourceMappingURL=add-3-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ../../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nif (typeof _debug_ !== 'undefined') {\r\n    var timingStart;\r\n}\r\n/** @hidden */\r\nfunction addDebugInfo1(loops) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    timingStart = performance.now();\r\n    for (let loop of loops) {\r\n        _debug_.fs.nameObj(loop, 'l|');\r\n    }\r\n    let generated = _debug_.generated;\r\n    //generated.elems.loop.push(...loops);\r\n    //generated.elems.loops.push(loops);\r\n    for (let loop of loops) {\r\n        let i = 0;\r\n        loop.curves.forEach(function (curve) {\r\n            let ps = curve.ps;\r\n            let hull = flo_bezier3_1.getBoundingHull(ps);\r\n            generated.elems.boundingHull.push(hull);\r\n            let looseBoundingBox = flo_bezier3_1.getBoundingBox(ps);\r\n            generated.elems.looseBoundingBox.push(looseBoundingBox);\r\n            let tightBoundingBox = flo_bezier3_1.getBoundingBoxTight(ps);\r\n            generated.elems.tightBoundingBox.push(tightBoundingBox);\r\n            let corner = curve_1.getCornerAtEnd(curve);\r\n            if (corner.isSharp) {\r\n                generated.elems.sharpCorner.push(curve);\r\n            }\r\n            else if (corner.isDull) {\r\n                generated.elems.dullCorner.push(curve);\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n}\r\nexports.addDebugInfo1 = addDebugInfo1;\r\n/** @hidden */\r\nfunction addDebugInfo2() {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let timing = _debug_.generated.timing;\r\n    let now = performance.now();\r\n    timing.holeClosers += now - timingStart;\r\n    timingStart = now;\r\n}\r\nexports.addDebugInfo2 = addDebugInfo2;\r\nfunction addDebugInfo3() {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    let now = performance.now();\r\n    timing.oneAnd2Prongs += now - timingStart;\r\n    timingStart = now;\r\n}\r\nexports.addDebugInfo3 = addDebugInfo3;\r\nfunction addDebugInfo4(mat) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    generated.elems.mat.push(mat);\r\n    timing.threeProngs += performance.now() - timingStart;\r\n}\r\nexports.addDebugInfo4 = addDebugInfo4;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_contact_circles_at_interface_1 = __webpack_require__(/*! ../get-contact-circles-at-interface */ \"./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * @hidden\r\n * Get useful points on the shape - these incude points of maximum curvature and\r\n * points at the bezier-bezier interfaces.\r\n * @param loop\r\n * @param additionalPointCount\r\n */\r\nfunction getInterestingPointsOnLoop(minBezLength, maxFlatness, maxLength) {\r\n    return function (loop) {\r\n        let allPoints = [];\r\n        for (let i = 0; i < loop.curves.length; i++) {\r\n            let curve = loop.curves[i];\r\n            if (flo_bezier3_1.lengthSquaredUpperBound(curve.ps) < minBezLength) {\r\n                continue;\r\n            }\r\n            let { maxCurvatureTs, maxNegativeCurvatureTs } = flo_bezier3_1.getCurvatureExtrema(curve.ps);\r\n            let maxCurvatures = maxCurvatureTs.map(t => new point_on_shape_1.PointOnShape(curve, t));\r\n            let maxNegativeCurvatures = maxNegativeCurvatureTs.map(t => new point_on_shape_1.PointOnShape(curve, t));\r\n            allPoints.push(...get_contact_circles_at_interface_1.getContactCirclesAtInterface(curve), ...maxCurvatures, ...maxNegativeCurvatures);\r\n            let ts = flo_bezier3_1.splitByCurvatureAndLength(curve.ps, maxFlatness, maxLength);\r\n            if (ts.length === 2) {\r\n                ts = [0, 0.5, 1];\r\n            }\r\n            for (let i = 1; i < ts.length - 1; i++) {\r\n                allPoints.push(new point_on_shape_1.PointOnShape(curve, ts[i]));\r\n            }\r\n        }\r\n        allPoints.sort(point_on_shape_1.comparePoss);\r\n        return allPoints;\r\n    };\r\n}\r\nexports.getInterestingPointsOnLoop = getInterestingPointsOnLoop;\r\n//# sourceMappingURL=create-get-interesting-points-on-loop.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/create-get-interesting-points-on-loop.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_ll_rb_tree_1 = __webpack_require__(/*! flo-ll-rb-tree */ \"./node_modules/flo-ll-rb-tree/node/index.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * @hidden\r\n * Creates the initial ContactPoint loops from the given sharp corners.\r\n * @param shape\r\n * @param sharpCornerss\r\n */\r\nfunction createInitialCpGraph(loops, cpTrees, sharpCornerss /*,\r\nxMap: Map<number[][],{ ps: number[][] }>*/) {\r\n    let cpNode;\r\n    for (let k = 0; k < sharpCornerss.length; k++) {\r\n        let sharpCorners = sharpCornerss[k];\r\n        let cpTree = new flo_ll_rb_tree_1.default(cp_node_1.CpNode.comparator, [], true);\r\n        let cpNode1 = undefined;\r\n        let cpNode2 = undefined;\r\n        for (let pos of sharpCorners) {\r\n            let ps = pos.curve.next.ps;\r\n            //let x = xMap.get(ps);\r\n            //let isIntersection = !!x;\r\n            let circle = { center: pos.p, radius: 0 };\r\n            let cp1 = { pointOnShape: pos, circle, order: -1, order2: 0 };\r\n            let cp2 = { pointOnShape: pos, circle, order: +1, order2: 0 };\r\n            cpNode1 = cp_node_1.CpNode.insert(false, /*isIntersection*/ false, cpTree, cp1, cpNode2);\r\n            cpNode2 = cp_node_1.CpNode.insert(false, /*isIntersection*/ false, cpTree, cp2, cpNode1);\r\n            cpNode1.prevOnCircle = cpNode2;\r\n            cpNode2.prevOnCircle = cpNode1;\r\n            cpNode1.nextOnCircle = cpNode2;\r\n            cpNode2.nextOnCircle = cpNode1;\r\n        }\r\n        if (!cpNode) {\r\n            cpNode = cpNode1;\r\n        }\r\n        let loop = loops[k];\r\n        cpTrees.set(loop, cpTree);\r\n    }\r\n    return cpNode;\r\n}\r\nexports.createInitialCpGraph = createInitialCpGraph;\r\n//# sourceMappingURL=create-initial-cp-graph.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/create-initial-cp-graph.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_two_prong_type_1 = __webpack_require__(/*! ../../get-two-prong-type */ \"./node_modules/flo-mat/node/mat/get-two-prong-type.js\");\r\n/** @hidden */\r\nfunction addDebugInfo(bezierPieces, failed, pos, circle, z, δ, xs, holeClosing) {\r\n    let twoProng = {\r\n        generated: _debug_.generated,\r\n        bezierPieces,\r\n        pos,\r\n        δ,\r\n        z: z ? z.p : undefined,\r\n        circle,\r\n        xs,\r\n        failed,\r\n        holeClosing,\r\n        notAdded: false,\r\n        deleted: false,\r\n        cpNode: undefined\r\n    };\r\n    let twoProngType = get_two_prong_type_1.getTwoProngType(twoProng);\r\n    _debug_.generated.elems[twoProngType].push(twoProng);\r\n}\r\nexports.addDebugInfo = addDebugInfo;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_square_distance_to_rect_1 = __webpack_require__(/*! ../../geometry/get-closest-square-distance-to-rect */ \"./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js\");\r\n/**\r\n * @hidden\r\n * Cull all bezierPieces not within given radius of a given point.\r\n * @param extreme\r\n * @param bezierPieces\r\n * @param p\r\n * @param rSquared\r\n */\r\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\r\n    const CULL_THRESHOLD = 5;\r\n    // TODO - base delta on theory\r\n    const TOLERANCE = 1 + 1e-3;\r\n    if (bezierPieces.length <= CULL_THRESHOLD) {\r\n        return bezierPieces;\r\n    }\r\n    let newPieces = [];\r\n    for (let bezierPiece of bezierPieces) {\r\n        let ps = bezierPiece.curve.ps;\r\n        let rect = flo_bezier3_1.getBoundingBox(ps);\r\n        let bd = get_closest_square_distance_to_rect_1.getClosestSquareDistanceToRect(rect, p);\r\n        if (bd <= rSquared * TOLERANCE) {\r\n            newPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return newPieces;\r\n}\r\nexports.cullBezierPieces = cullBezierPieces;\r\n//# sourceMappingURL=cull-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst add_1_prong_1 = __webpack_require__(/*! ../add-1-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-1-prong.js\");\r\nconst add_debug_info_1 = __webpack_require__(/*! ./add-debug-info */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/add-debug-info.js\");\r\nconst cull_bezier_pieces_1 = __webpack_require__(/*! ./cull-bezier-pieces */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/cull-bezier-pieces.js\");\r\nconst find_equidistant_point_on_line_1 = __webpack_require__(/*! ./find-equidistant-point-on-line */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js\");\r\nconst get_initial_bezier_pieces_1 = __webpack_require__(/*! ./get-initial-bezier-pieces */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js\");\r\nconst get_close_boundary_points_1 = __webpack_require__(/*! ../../closest-boundary-point/get-close-boundary-points */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-close-boundary-points.js\");\r\n/**\r\n * @hidden\r\n * Adds a 2-prong to the MAT. The first point on the shape boundary is given and\r\n * the second one is found by the algorithm.\r\n *\r\n * A 2-prong is defined as a MAT circle that touches the shape at exactly 2\r\n * points.\r\n *\r\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\r\n * reduce the boundary).\r\n *\r\n * As per the paper by Choi, Choi, Moon and Wee:\r\n *   \"The starting point of this algorithm is a choice of a circle Br(x)\r\n *    centered at an interior point x which contains two boundary portions c and\r\n *    d of dΩ as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\r\n * @param loops A shape represented by path loops\r\n * @param extreme The extreme coordinate value of the shape\r\n * @param squaredDiagonalLength The squared diagonal length of the shape\r\n * bounding box.\r\n * @param y The source point of the 2-prong to be found\r\n * @param isHoleClosing True if this is a hole-closing two-prong, false otherwise\r\n * @param k The loop array index\r\n */\r\nfunction find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, y, isHoleClosing, k) {\r\n    const MAX_ITERATIONS = 25;\r\n    const squaredSeperationTolerance = Math.pow((1e-6 * extreme), 2);\r\n    // TODO - base deltas on theory or remove\r\n    const oneProngTolerance = Math.pow((1e-4), 2);\r\n    const squaredErrorTolerance = 1e-2 * squaredSeperationTolerance;\r\n    const maxOsculatingCircleRadiusSquared = squaredDiagonalLength;\r\n    // The boundary piece that should contain the other point of \r\n    // the 2-prong circle. (Defined by start and end points).\r\n    let { bezierPieces, δ } = get_initial_bezier_pieces_1.getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y);\r\n    //console.log(bezierPieces.length)\r\n    /** The center of the two-prong (successively refined) */\r\n    let x;\r\n    let p;\r\n    let r;\r\n    if (isHoleClosing) {\r\n        p = [y.p[0], y.p[1]];\r\n        x = [p[0], p[1] - Math.sqrt(maxOsculatingCircleRadiusSquared)];\r\n        r = maxOsculatingCircleRadiusSquared;\r\n    }\r\n    else {\r\n        p = y.p;\r\n        //x = PointOnShape.getOsculatingCircle(maxOsculatingCircleRadiusSquared, y).center;\r\n        x = point_on_shape_1.getOsculatingCircle(maxOsculatingCircleRadiusSquared, y).center;\r\n        r = flo_vector2d_1.squaredDistanceBetween(p, x);\r\n    }\r\n    // The lines below is an optimization.\r\n    let r_ = reduceRadius(extreme, bezierPieces, p, x);\r\n    if (r > r_) {\r\n        x = flo_vector2d_1.interpolate(p, x, Math.sqrt(r_ / r));\r\n    }\r\n    /** Trace the convergence (for debugging). */\r\n    let xs = [];\r\n    /** The antipode of the two-prong (successively refined) */\r\n    let z;\r\n    let i = 0;\r\n    let done = 0;\r\n    let failed = false; // The failed flag is set if a 2-prong cannot be found.\r\n    let bezierPieces_ = bezierPieces;\r\n    // ---> for (let b of bezierPieces) { d.fs.draw.bezierPiece(document.getElementsByTagName('g')[0], b.curve.ps, b.ts, 'nofill thin10 red', 100); }\r\n    do {\r\n        i++;\r\n        /** squared distance between source boundary point and circle center */\r\n        let r = flo_vector2d_1.squaredDistanceBetween(x, y.p);\r\n        bezierPieces_ = cull_bezier_pieces_1.cullBezierPieces(bezierPieces_, x, r);\r\n        z = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces_, x, y.curve, y.t);\r\n        if (z === undefined) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular;\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                console.log('failed: no closest point - ' + elemStr);\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        if (typeof _debug_ !== 'undefined') {\r\n            xs.push({ x, y, z: z.pos, t: y.t });\r\n        }\r\n        /** squared distance between anti-pode boundary point and circle center */\r\n        let d = flo_vector2d_1.squaredDistanceBetween(x, z.pos.p);\r\n        //if (i === 1 && d*oneProngTolerance >= r) {\r\n        if (i === 1 && r < d + oneProngTolerance) {\r\n            // It is a 1-prong.\r\n            add_1_prong_1.add1Prong(Math.sqrt(maxOsculatingCircleRadiusSquared), cpTrees, y);\r\n            return undefined;\r\n        }\r\n        // TODO - squaredSeperationTolerance should in future be replaced with\r\n        // a relative error, i.e. distance between y (or z) / length(y (or z)).\r\n        if (!isHoleClosing && flo_vector2d_1.squaredDistanceBetween(y.p, z.pos.p) <= squaredSeperationTolerance) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                /*\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                console.log(\r\n                    'failed: two-prong radius too small - ' + elemStr\r\n                );\r\n                */\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        // TODO - Accuracy optimization: tolerance should not be between x and \r\n        // nextX, but rather (distance from x to y) - (distance from x to z)\r\n        // Find the point on the line connecting y with x that is  \r\n        // equidistant from y and z. This will be our next x.\r\n        let nextX = find_equidistant_point_on_line_1.findEquidistantPointOnLine(x, y.p, z.pos.p);\r\n        let squaredError = flo_vector2d_1.squaredDistanceBetween(x, nextX);\r\n        x = nextX;\r\n        if (squaredError < squaredErrorTolerance) {\r\n            done++; // Do one more iteration\r\n        }\r\n        else if (i === MAX_ITERATIONS) {\r\n            // Convergence was too slow.\r\n            failed = true;\r\n            break; // We're done\r\n        }\r\n    } while (done < 1);\r\n    // TODO - Optimization: only do this if second closest point is within the\r\n    // tolerance which can be checked in getClosestBoundaryPoint algorithm\r\n    let zs = [];\r\n    if (!failed) {\r\n        zs = get_close_boundary_points_1.getCloseBoundaryPoints(bezierPieces_, x, y, flo_vector2d_1.distanceBetween(x, z.pos.p));\r\n        if (!zs.length) {\r\n            // TODO - Numerical issue - fix\r\n            zs.push(z);\r\n        }\r\n    }\r\n    let circle;\r\n    if (z !== undefined) {\r\n        circle = { center: x, radius: flo_vector2d_1.distanceBetween(x, z.pos.p) };\r\n    }\r\n    if (typeof _debug_ !== 'undefined' && !failed) {\r\n        xs.push({ x, y, z: z.pos, t: y.t });\r\n        add_debug_info_1.addDebugInfo(bezierPieces, failed, y, circle, z.pos, δ, xs, isHoleClosing);\r\n    }\r\n    return failed ? undefined : { circle, zs };\r\n}\r\nexports.find2Prong = find2Prong;\r\n/**\r\n * @hidden\r\n * Reduces the circle radius initially as an optimization step.\r\n */\r\nfunction reduceRadius(extreme, bezierPieces, p, x) {\r\n    const TOLERANCE = extreme * 1e-3;\r\n    let prevP = undefined;\r\n    let minRadius = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let p1 = flo_bezier3_1.evalDeCasteljau(ps, bezierPiece.ts[0]);\r\n        let r1 = Number.POSITIVE_INFINITY;\r\n        // Prevent evaluating the same points twice\r\n        if (!prevP || prevP[0] !== p1[0] || prevP[1] !== p1[1]) {\r\n            let cc1 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1);\r\n            if (cc1) {\r\n                r1 = flo_vector2d_1.squaredDistanceBetween(p, cc1);\r\n            }\r\n        }\r\n        let r2 = Number.POSITIVE_INFINITY;\r\n        let p2 = flo_bezier3_1.evalDeCasteljau(ps, bezierPiece.ts[1]);\r\n        let cc2 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p2);\r\n        if (cc2) {\r\n            r2 = flo_vector2d_1.squaredDistanceBetween(p, cc2);\r\n        }\r\n        prevP = p2;\r\n        let d = Math.min(r1, r2);\r\n        if (d < minRadius) {\r\n            minRadius = d;\r\n        }\r\n    }\r\n    // The extra bit is to account for floating point precision.\r\n    // TODO - base delta on theory\r\n    return minRadius + TOLERANCE;\r\n}\r\n/**\r\n * @hidden\r\n * @param p A point on the circle with normal pointing to x towards the center\r\n * of the circle.\r\n * @param x\r\n * @param p1 Another point on the circle.\r\n */\r\nfunction getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1) {\r\n    // TODO - remove delta\r\n    let TOLERANCE = Math.pow((1e-4 * extreme), 2);\r\n    // Ignore if p and p1 are too close together\r\n    if (flo_vector2d_1.squaredDistanceBetween(p, p1) < TOLERANCE) {\r\n        return undefined;\r\n    }\r\n    /** The perpindicular bisector between the two given points on the circle */\r\n    let pb = [\r\n        (p[0] + p1[0]) / 2,\r\n        (p[1] + p1[1]) / 2,\r\n    ];\r\n    let tan = [p1[0] - p[0], p1[1] - p[1]];\r\n    let norm = [-tan[1], tan[0]]; // Rotate by 90 degrees\r\n    let pb2 = [pb[0] + norm[0], pb[1] + norm[1]];\r\n    let res = flo_vector2d_1.lineLineIntersection([p, x], [pb, pb2]);\r\n    if (!res) {\r\n        return undefined;\r\n    }\r\n    let resO = [res[0] - p[0], res[1] - p[1]];\r\n    let xO = [x[0] - p[0], x[1] - p[1]];\r\n    if (flo_vector2d_1.dot(resO, xO) < 0) {\r\n        return undefined;\r\n    }\r\n    return res;\r\n}\r\n//# sourceMappingURL=find-2-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from y and z.\r\n */\r\nfunction findEquidistantPointOnLine(x, y, z) {\r\n    // Some basic algebra (not shown) finds the required point.\r\n    // Swap axes if x and y are more aligned to y-axis than to x-axis.\r\n    let swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\r\n    // Cache\r\n    let x1, x2, y1, y2, z1, z2;\r\n    if (swapAxes) {\r\n        x1 = x[1];\r\n        x2 = x[0];\r\n        y1 = y[1];\r\n        y2 = y[0];\r\n        z1 = z[1];\r\n        z2 = z[0];\r\n    }\r\n    else {\r\n        x1 = x[0];\r\n        x2 = x[1];\r\n        y1 = y[0];\r\n        y2 = y[1];\r\n        z1 = z[0];\r\n        z2 = z[1];\r\n    }\r\n    // a <= 1 (due to swapped axes)\r\n    let a = (x2 - y2) / (x1 - y1);\r\n    let b = y2 - a * y1;\r\n    let c = (y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2) + 2 * b * (z2 - y2);\r\n    let d = y1 - z1 + a * (y2 - z2);\r\n    let t1 = c / (2 * d);\r\n    let t2 = a * t1 + b;\r\n    return swapAxes ? [t2, t1] : [t1, t2];\r\n}\r\nexports.findEquidistantPointOnLine = findEquidistantPointOnLine;\r\n//# sourceMappingURL=find-equidistant-point-on-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-equidistant-point-on-line.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ../../get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/** @hidden */\r\nfunction getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y) {\r\n    let bezierPieces;\r\n    let δ;\r\n    if (isHoleClosing) {\r\n        bezierPieces = [];\r\n        for (let k2 = 0; k2 < k; k2++) {\r\n            let pieces = loops[k2].curves\r\n                .map(curve => ({ curve, ts: [0, 1] }));\r\n            bezierPieces.push(...pieces);\r\n        }\r\n    }\r\n    else {\r\n        //let order = PointOnShape.isDullCorner(y)\r\n        let order = point_on_shape_1.isPosDullCorner(y)\r\n            ? y.t === 1 ? -1 : +1\r\n            : 0;\r\n        let loop = loops[k];\r\n        let cpNode = get_neighboring_cps_1.getNeighbouringPoints(cpTrees.get(loop), y, order, 0)[0];\r\n        δ = [cpNode, cpNode];\r\n        if (!cpNode ||\r\n            // The special case if there is only a single sharp corner or \r\n            // terminating 2-prong currently in the MAT. Don't remove!\r\n            (cpNode === cpNode.next.next)) {\r\n            bezierPieces = loop.curves\r\n                .map(curve => ({ curve, ts: [0, 1] }));\r\n        }\r\n        else {\r\n            bezierPieces = get_boundary_piece_beziers_1.getBoundaryPieceBeziers(δ);\r\n        }\r\n    }\r\n    return { bezierPieces, δ };\r\n}\r\nexports.getInitialBezierPieces = getInitialBezierPieces;\r\n//# sourceMappingURL=get-initial-bezier-pieces.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-2-prong/get-initial-bezier-pieces.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js\");\r\n/**\r\n * @hidden\r\n * Find new x and ps that are a better estimate of the 3-prong circle.\r\n * The potential function, V, is defined as the distance to the actual 3 prong\r\n * circle center.\r\n * @param bezierPiece3s The three boundary pieces, each of which should contain\r\n * a point of the 3-prong to be found.\r\n * @param x The currently best guess at the center of the 3-prong circle.\r\n * @param vectorToZeroV\r\n * @param extreme\r\n */\r\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\r\n    let V = flo_vector2d_1.len(vectorToZeroV);\r\n    let nu = 1;\r\n    let better;\r\n    let newX;\r\n    let newPs;\r\n    let newV;\r\n    let i = 0; // Safeguard\r\n    do {\r\n        let shift = flo_vector2d_1.scale(vectorToZeroV, nu);\r\n        newX = flo_vector2d_1.translate(shift, x);\r\n        newPs = get_closest_points_1.getClosestPoints(newX, bezierPiece3s);\r\n        // Point of zero V\r\n        let newCircleCenter = flo_vector2d_1.circumCenter(newPs.map(pos => pos.p));\r\n        let newVectorToZeroV = flo_vector2d_1.fromTo(newX, newCircleCenter);\r\n        newV = flo_vector2d_1.len(newVectorToZeroV);\r\n        better = newV < V;\r\n        nu = nu / 2;\r\n        i++;\r\n    } while (!better && i < 3);\r\n    return { newX, newV, newPs };\r\n}\r\nexports.calcBetterX = calcBetterX;\r\n//# sourceMappingURL=calc-better-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\n/**\r\n * @hidden\r\n * Finds an initial 3-prong circle center point from which to iterate. The point\r\n * must be within the shape.\r\n * @param δ3s - The three boundary pieces of which we need to find the three\r\n * 3-prong points.\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction calcInitial3ProngCenter(δ3s, bezierPiece3s) {\r\n    let twoProngCircleCenter = δ3s[0][0].cp.circle.center;\r\n    let posInfo = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiece3s[1], twoProngCircleCenter, undefined, // curve\r\n    undefined // t\r\n    );\r\n    let meanPoints = [\r\n        δ3s[0][0].cp.pointOnShape.p,\r\n        posInfo.pos.p,\r\n        δ3s[2][1].cp.pointOnShape.p,\r\n    ];\r\n    return flo_vector2d_1.circumCenter(meanPoints);\r\n}\r\nexports.calcInitial3ProngCenter = calcInitial3ProngCenter;\r\n//# sourceMappingURL=calc-initial-3-prong-center.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\nconst calc_initial_3_prong_center_1 = __webpack_require__(/*! ./calc-initial-3-prong-center */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-initial-3-prong-center.js\");\r\nconst get_closest_points_1 = __webpack_require__(/*! ./get-closest-points */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js\");\r\nconst calc_better_x_1 = __webpack_require__(/*! ./calc-better-x */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/calc-better-x.js\");\r\nconst curve_1 = __webpack_require__(/*! ../../../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\n/** @hidden */\r\nconst calcVectorToZeroV_StraightToIt = flo_vector2d_1.fromTo;\r\n/**\r\n * @hidden\r\n * Finds a 3-prong using only the 3 given δs.\r\n * @param δs The boundary pieces\r\n * @param idx δ identifier\r\n * @param bezierPiecess\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3ProngForDelta3s(δs, idx, k, bezierPiecess, extreme) {\r\n    const TOLERANCE = extreme * 1e-10;\r\n    const MAX_ITERATIONS = 10;\r\n    let δs_ = [\r\n        δs[0],\r\n        δs[idx],\r\n        δs[δs.length - 1]\r\n    ];\r\n    let bezierPieces_ = [\r\n        bezierPiecess[0],\r\n        bezierPiecess[idx],\r\n        bezierPiecess[δs.length - 1]\r\n    ];\r\n    let δ3ss = [\r\n        [δs_[0], δs_[1], δs_[2]],\r\n        [δs_[1], δs_[2], δs_[0]],\r\n        [δs_[2], δs_[0], δs_[1]],\r\n    ];\r\n    let bezierPiecess_ = [\r\n        [bezierPieces_[0], bezierPieces_[1], bezierPieces_[2]],\r\n        [bezierPieces_[1], bezierPieces_[2], bezierPieces_[0]],\r\n        [bezierPieces_[2], bezierPieces_[0], bezierPieces_[1]],\r\n    ];\r\n    let δ3s = δ3ss[k];\r\n    let bezierPiece3s = bezierPiecess_[k];\r\n    if (δ3s[0][0].isSharp()) {\r\n        return undefined;\r\n    }\r\n    let ps;\r\n    let circumCenter_;\r\n    let j = 0; // Safeguard for slow convergence\r\n    let x = calc_initial_3_prong_center_1.calcInitial3ProngCenter(δ3s, bezierPiece3s);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        let trace = d.traces[d.traces.length - 1];\r\n        trace.push(x);\r\n    }\r\n    let tolerance = Number.POSITIVE_INFINITY;\r\n    while (tolerance > TOLERANCE && j < MAX_ITERATIONS) {\r\n        j++;\r\n        ps = get_closest_points_1.getClosestPoints(x, bezierPiece3s);\r\n        if (!Number.isFinite(x[0]) || !Number.isFinite(x[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don't\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        circumCenter_ = flo_vector2d_1.circumCenter(ps.map(x => x.p));\r\n        let vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter_);\r\n        if (!Number.isFinite(vectorToZeroV[0]) || !Number.isFinite(vectorToZeroV[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don't\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        let upds = calc_better_x_1.calcBetterX(bezierPiece3s, x, vectorToZeroV);\r\n        x = upds.newX;\r\n        ps = upds.newPs;\r\n        if (typeof _debug_ !== 'undefined') {\r\n            let threeProngs = _debug_.generated.elems.threeProng;\r\n            let d = threeProngs[threeProngs.length - 1];\r\n            let trace = d.traces[d.traces.length - 1];\r\n            trace.push(x);\r\n        }\r\n        let V = flo_vector2d_1.len(vectorToZeroV); // The 'potential'\r\n        tolerance = Math.abs(V - upds.newV);\r\n    }\r\n    let radius = (flo_vector2d_1.distanceBetween(x, ps[0].p) +\r\n        flo_vector2d_1.distanceBetween(x, ps[1].p) +\r\n        flo_vector2d_1.distanceBetween(x, ps[2].p)) / 3;\r\n    let circle = { center: x, radius };\r\n    //-------------------------------------------------------------------------\r\n    // Calculate the unit tangent vector at 3-prong circle points - they should \r\n    // be very close to tangent to the boundary piece tangents at those points \r\n    // (up to sign). Sharp corners are a common special case.\r\n    //-------------------------------------------------------------------------\r\n    let totalAngleError = 0;\r\n    for (let i = 0; i < 3; i++) {\r\n        let p = ps[i];\r\n        //----------------------------\r\n        // Tangent of circle at point\r\n        //----------------------------\r\n        let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p.p, x));\r\n        let v1 = flo_vector2d_1.rotate90Degrees(v);\r\n        //-----------------------------------\r\n        // Check if point is on dull crorner\r\n        //-----------------------------------\r\n        //if (PointOnShape.isDullCorner(p)) {\r\n        if (point_on_shape_1.isPosDullCorner(p)) {\r\n            //let corner = Curve.getCornerAtEnd(p.curve);\r\n            let corner = curve_1.getCornerAtEnd(p.curve);\r\n            let tans = corner.tangents;\r\n            let perps = tans.map(flo_vector2d_1.rotate90Degrees);\r\n            let angleError1 = Math.asin(flo_vector2d_1.cross(perps[0], v));\r\n            let angleError2 = Math.asin(flo_vector2d_1.cross(v, perps[1]));\r\n            let angleError = 0;\r\n            if (angleError1 > 0) {\r\n                angleError += angleError1;\r\n            }\r\n            if (angleError2 > 0) {\r\n                angleError += angleError2;\r\n            }\r\n            totalAngleError += angleError;\r\n        }\r\n        else {\r\n            //---------------------------\r\n            // Tangent of curve at point\r\n            //---------------------------\r\n            let v2 = flo_vector2d_1.toUnitVector(flo_bezier3_1.tangent(p.curve.ps, p.t));\r\n            // Cross is more numerically stable than Vector.dot at angles a\r\n            // multiple of Math.PI **and** is close to the actual angle value\r\n            // and can thus just be added to cone method of looking at \r\n            // tolerance.\r\n            // Should be close to zero and is close to the actual angle.\r\n            let cross_ = Math.abs(Math.asin(flo_vector2d_1.cross(v1, v2)));\r\n            totalAngleError += cross_;\r\n        }\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    // Calculate radiusDelta, the difference between the radius and the closest\r\n    // point to the 3-prong. It should be around 0. If not, this is not a good \r\n    // candidate for the 3-prong.\r\n    //-------------------------------------------------------------------------\r\n    let closestDs = [];\r\n    for (let i = 0; i < bezierPiecess.length; i++) {\r\n        let p = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPiecess[i], x, undefined, undefined);\r\n        closestDs.push(flo_vector2d_1.distanceBetween(p.pos.p, x));\r\n    }\r\n    let closestD = Math.min(...closestDs);\r\n    let radiusDelta = Math.abs(radius - closestD);\r\n    // Weights below still need to be optimized.\r\n    let W1 = 1;\r\n    let W2 = 1;\r\n    let error = W1 * radiusDelta + W2 * totalAngleError;\r\n    return { ps, circle, error, δ3s };\r\n}\r\nexports.find3ProngForDelta3s = find3ProngForDelta3s;\r\n//# sourceMappingURL=find-3-prong-for-delta3s.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst three_prong_for_debugging_1 = __webpack_require__(/*! ../../../debug/three-prong-for-debugging */ \"./node_modules/flo-mat/node/debug/three-prong-for-debugging.js\");\r\nconst find_3_prong_for_delta3s_1 = __webpack_require__(/*! ./find-3-prong-for-delta3s */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.js\");\r\nconst get_boundary_piece_beziers_1 = __webpack_require__(/*! ../../get-boundary-piece-beziers */ \"./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js\");\r\n/**\r\n * @hidden\r\n * Find and return a 3-prong from the given boundary piece.\r\n * @param δs A boundary piece\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3Prong(δs, extreme) {\r\n    let bezierPiecess = δs.map(get_boundary_piece_beziers_1.getBoundaryPieceBeziers);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        threeProngs.push(three_prong_for_debugging_1.createEmptyThreeProngForDebugging());\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.boundaries = [];\r\n        for (let bezierPieces of bezierPiecess) {\r\n            let boundary = [];\r\n            d.boundaries.push(boundary);\r\n            for (let bezierPiece of bezierPieces) {\r\n                let bezier = flo_bezier3_1.fromTo(bezierPiece.curve.ps)(bezierPiece.ts[0], bezierPiece.ts[1]);\r\n                boundary.push(bezier);\r\n            }\r\n        }\r\n        d.traces = [];\r\n    }\r\n    let candidateThreeProngs = [];\r\n    // The best candidate amongst the different 'permutations' of the given δs.\r\n    let threeProng;\r\n    let bestIndx = undefined;\r\n    let smallestError = Number.POSITIVE_INFINITY;\r\n    for (let i = 1; i < δs.length - 1; i++) {\r\n        for (let k = 0; k < 3; k++) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let threeProngs = _debug_.generated.elems.threeProng;\r\n                let d = threeProngs[threeProngs.length - 1];\r\n                let trace = [];\r\n                d.traces.push(trace);\r\n            }\r\n            let threeProngInfo = find_3_prong_for_delta3s_1.find3ProngForDelta3s(δs, i, k, bezierPiecess, extreme);\r\n            if (!threeProngInfo) {\r\n                continue;\r\n            }\r\n            let { circle, ps, error, δ3s } = threeProngInfo;\r\n            if (typeof _debug_ !== 'undefined') {\r\n                candidateThreeProngs.push({ circle, ps });\r\n            }\r\n            if (error < smallestError) {\r\n                smallestError = error;\r\n                bestIndx = i - 1;\r\n                threeProng = { circle, ps, δ3s };\r\n            }\r\n        }\r\n    }\r\n    //threeProng.δ3s = [δs[0], δs[bestIndx+1], δs[δs.length-1]];\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.generated = _debug_.generated;\r\n        d.circle = threeProng.circle;\r\n        d.poss = threeProng.ps;\r\n        d.cp3ss = threeProng.δ3s;\r\n        d.cpss = δs;\r\n        d.bestIndx = bestIndx;\r\n        d.candidateThreeProngs = candidateThreeProngs;\r\n    }\r\n    return threeProng;\r\n}\r\nexports.find3Prong = find3Prong;\r\n//# sourceMappingURL=find-3-prong.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_closest_boundary_point_1 = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point */ \"./node_modules/flo-mat/node/mat/closest-boundary-point/get-closest-boundary-point.js\");\r\n/**\r\n * @hidden\r\n * @param x\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction getClosestPoints(x, bezierPiece3s) {\r\n    return bezierPiece3s.map(bezierPieces => {\r\n        let posInfo = get_closest_boundary_point_1.getClosestBoundaryPoint(bezierPieces, x, undefined, // curve\r\n        undefined // t\r\n        );\r\n        return posInfo ? posInfo.pos : undefined;\r\n    });\r\n}\r\nexports.getClosestPoints = getClosestPoints;\r\n//# sourceMappingURL=get-closest-points.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-3-prong/get-closest-points.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst find_and_add_2_prongs_1 = __webpack_require__(/*! ./find-and-add-2-prongs */ \"./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js\");\r\n/**\r\n * @hidden\r\n * Add 2 prongs. See comments on the add2Prong function.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param for2Prongss\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2ProngsOnAllPaths(loops, cpGraphs, for2Prongss, extreme) {\r\n    let cpNode;\r\n    for (let k = 0; k < for2Prongss.length; k++) {\r\n        let for2Prongs = for2Prongss[k];\r\n        let _cpNode = find_and_add_2_prongs_1.findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme);\r\n        cpNode = cpNode || _cpNode;\r\n    }\r\n    return cpNode;\r\n}\r\nexports.findAndAdd2ProngsOnAllPaths = findAndAdd2ProngsOnAllPaths;\r\n//# sourceMappingURL=find-and-add-2-prongs-on-all-paths.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs-on-all-paths.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ../../svg/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/get-shape-bounds.js\");\r\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js\");\r\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js\");\r\n/**\r\n * @hidden\r\n * Find and add two-prongs.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param k\r\n * @param for2Prongs\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme) {\r\n    let len = for2Prongs.length;\r\n    let index = indexLinear(len);\r\n    //let index = indexInterlaced(len); // Keep for possible future use.\r\n    let cpNode_;\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\r\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\r\n    for (let i = 0; i < len; i++) {\r\n        let pos = for2Prongs[index[i]];\r\n        let twoProngInfo;\r\n        twoProngInfo = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpGraphs, pos, false, k);\r\n        if (twoProngInfo) {\r\n            let { circle, zs } = twoProngInfo;\r\n            let cpNode = add_2_prong_1.add2Prong(cpGraphs, circle, pos, zs, false, extreme);\r\n            cpNode_ = cpNode_ || cpNode;\r\n        }\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (i + 1 === _debug_.directives.stopAfterTwoProngsNum) {\r\n                return undefined;\r\n            }\r\n        }\r\n    }\r\n    return cpNode_;\r\n}\r\nexports.findAndAdd2Prongs = findAndAdd2Prongs;\r\n/**\r\n * @hidden\r\n * Simple linear array indexing.\r\n * @param n\r\n */\r\nfunction indexLinear(n) {\r\n    let arr = [];\r\n    for (let i = 0; i < n; i++) {\r\n        arr.push(i);\r\n    }\r\n    return arr;\r\n}\r\n/**\r\n * @hidden\r\n * Creates a kind of interlaced index vector.\r\n * @param n\r\n*/\r\nfunction indexInterlaced(n) {\r\n    let source = {};\r\n    let arr = [];\r\n    // l is the lowest power of 2 so that 2^l > n\r\n    let l = Math.pow(2, Math.floor(Math.log2(n)));\r\n    while (l >= 1) {\r\n        let k = 0;\r\n        while (k < n) {\r\n            if (!source[k]) {\r\n                arr.push(k);\r\n                source[k] = true;\r\n            }\r\n            k = k + l;\r\n        }\r\n        l = l / 2;\r\n    }\r\n    return arr;\r\n}\r\n//# sourceMappingURL=find-and-add-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst find_3_prong_1 = __webpack_require__(/*! ./find-3-prong/find-3-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-3-prong/find-3-prong.js\");\r\nconst add_3_prong_1 = __webpack_require__(/*! ../find-mat/add-3-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-3-prong.js\");\r\n/**\r\n * @hidden\r\n * Finds and adds all 3-prongs.\r\n * @param cpGraphs\r\n * @param cpStart The CpNode to start traversing from.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddAll3Prongs(cpGraphs, cpStart, extreme) {\r\n    // Don't change this function to be recursive, the call stack may overflow \r\n    // if there are too many two-prongs.\r\n    let visitedEdges = new Map();\r\n    let edgesToCheck = [{ fromCpNode: undefined, cpStart }];\r\n    while (edgesToCheck.length) {\r\n        let { fromCpNode, cpStart } = edgesToCheck.shift();\r\n        markEdgeAsTaken(visitedEdges, fromCpNode, cpStart);\r\n        for (let cpNode of cpStart.getCpNodesOnCircle()) {\r\n            //if (!PointOnShape.isSharpCorner(cpNode.cp.pointOnShape)) {\r\n            if (!point_on_shape_1.isPosSharpCorner(cpNode.cp.pointOnShape)) {\r\n                if (findAndAdd3Prongs(cpGraphs, cpNode, extreme) === undefined) {\r\n                    return; // only for debugging purposes\r\n                }\r\n                ;\r\n            }\r\n            if (hasEdgeBeenTaken(visitedEdges, cpNode, cpNode.next)) {\r\n                continue; // We already visited this edge\r\n            }\r\n            edgesToCheck.push({ fromCpNode: cpStart, cpStart: cpNode.next });\r\n        }\r\n    }\r\n}\r\nexports.findAndAddAll3Prongs = findAndAddAll3Prongs;\r\n/**\r\n * @hidden\r\n * Marks the given edge as already taken.\r\n */\r\nfunction markEdgeAsTaken(visitedEdges, cp1, cp2) {\r\n    if (cp1 === undefined) {\r\n        return;\r\n    }\r\n    f(cp1, cp2);\r\n    f(cp2, cp1);\r\n    function f(cp1, cp2) {\r\n        let visited = visitedEdges.get(cp1);\r\n        if (!visited) {\r\n            visited = new Set();\r\n            visitedEdges.set(cp1, visited);\r\n        }\r\n        visited.add(cp2);\r\n    }\r\n}\r\n/** @hidden */\r\nfunction hasEdgeBeenTaken(visitedEdges, cp1, cp2) {\r\n    let cps;\r\n    cps = visitedEdges.get(cp1);\r\n    let takenForward = cps && cps.has(cp2);\r\n    cps = visitedEdges.get(cp2);\r\n    let takenBackwards = cps && cps.has(cp1);\r\n    return takenForward || takenBackwards;\r\n}\r\n/**\r\n * @hidden\r\n * Traverses the shape from the given ContactPoint going around contact circles\r\n * so that only a piece of the shape is traversed and returns the visited\r\n * CpNodes (starting from the given CpNode).\r\n * @param cpStart The ContactPoint from where to start the traversal.\r\n */\r\nfunction traverseShape(cpStart) {\r\n    let cpNode = cpStart;\r\n    if (cpNode === cpNode.next.prevOnCircle) {\r\n        return [cpNode];\r\n    }\r\n    let visitedCps = [];\r\n    do {\r\n        visitedCps.push(cpNode);\r\n        let next = cpNode.next.prevOnCircle;\r\n        cpNode = cpNode === next\r\n            ? cpNode = cpNode.next.next // Terminal vertex\r\n            : cpNode = next; // Take last exit\r\n    } while (cpNode !== cpStart);\r\n    return visitedCps;\r\n}\r\n/**\r\n * @hidden\r\n * Starting from some ContactPoint, traverses the shape going around Vertices\r\n * and if more than two Vertices have been visited in total then recursively\r\n * adds 3-prongs until only one or two Vertices have been visited.\r\n *\r\n * This process further subdivides the shape.\r\n * @param cpGraphs\r\n * @param cpStart The ContactPoint from where to start the process.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nlet ii = 0;\r\nfunction findAndAdd3Prongs(cpGraphs, cpStart, extreme) {\r\n    let visitedCps;\r\n    do {\r\n        visitedCps = traverseShape(cpStart);\r\n        if (visitedCps.length > 2) {\r\n            findAndAdd3Prong(cpGraphs, visitedCps, extreme);\r\n            ii++;\r\n        }\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (ii === _debug_.directives.stopAfterThreeProngsNum) {\r\n                return undefined;\r\n            }\r\n        }\r\n    } while (visitedCps.length > 2);\r\n    return visitedCps;\r\n}\r\n/**\r\n * @hidden\r\n * Finds and add a 3-prong MAT circle to the given shape.\r\n * @param cpGraphs\r\n * @param visitedCps\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd3Prong(cpGraphs, visitedCps, extreme) {\r\n    let δs = [];\r\n    for (let visitedCp of visitedCps) {\r\n        δs.push([visitedCp, visitedCp.next]);\r\n    }\r\n    let threeProng = find_3_prong_1.find3Prong(δs, extreme);\r\n    let orders = [];\r\n    for (let i = 0; i < 3; i++) {\r\n        orders.push(\r\n        //PointOnShape.calcOrder(threeProng.circle, threeProng.ps[i])\r\n        point_on_shape_1.calcPosOrder(threeProng.circle, threeProng.ps[i]));\r\n    }\r\n    let circle = add_3_prong_1.add3Prong(cpGraphs, orders, threeProng);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        add3ProngDebugInfo(circle, visitedCps);\r\n    }\r\n}\r\n/** @hidden */\r\nfunction add3ProngDebugInfo(circle, visitedCps) {\r\n    let threeProngs = _debug_.generated.elems.threeProng;\r\n    let len = threeProngs.length;\r\n    let data = threeProngs[len - 1];\r\n    data.visitedCps = visitedCps;\r\n    data.circle = circle;\r\n}\r\n//# sourceMappingURL=find-and-add-3-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-3-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_shape_bounds_1 = __webpack_require__(/*! ../../svg/get-shape-bounds */ \"./node_modules/flo-mat/node/svg/get-shape-bounds.js\");\r\nconst get_min_y_pos_1 = __webpack_require__(/*! ../../svg/get-min-y-pos */ \"./node_modules/flo-mat/node/svg/get-min-y-pos.js\");\r\nconst find_2_prong_1 = __webpack_require__(/*! ./find-2-prong/find-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/find-2-prong/find-2-prong.js\");\r\nconst add_2_prong_1 = __webpack_require__(/*! ./add-2-prong */ \"./node_modules/flo-mat/node/mat/find-mat/add-2-prong.js\");\r\n/**\r\n * @hidden\r\n * Find and add two-prongs that remove any holes in the shape.\r\n * @param loops The loops (that as a precondition must be ordered from\r\n * highest (i.e. smallest y-value) topmost point loops to lowest)\r\n * @param cpTrees\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddHoleClosing2Prongs(loops, cpTrees, extreme) {\r\n    let bounds = get_shape_bounds_1.getShapeBounds(loops);\r\n    let squaredDiagonalLength = Math.pow((bounds.maxX.p[0] - bounds.minX.p[0]), 2) +\r\n        Math.pow((bounds.maxY.p[1] - bounds.minY.p[1]), 2);\r\n    // Find the topmost points on each loop.\r\n    let minYs = loops.map(get_min_y_pos_1.getMinYPos);\r\n    // We start at 1 since 0 is the outer (root) loop\r\n    for (let k = 1; k < minYs.length; k++) {\r\n        let posSource = minYs[k];\r\n        let holeClosingTwoProng = find_2_prong_1.find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, posSource, true, k);\r\n        if (!holeClosingTwoProng) {\r\n            throw new Error(`Unable to find hole-closing 2-prong`);\r\n        }\r\n        // TODO important - handle case of n-prong, i.e. more than one antipode\r\n        // - currently we only handle case of single antipode (the general case)\r\n        let { circle, zs: posAntipodes } = holeClosingTwoProng;\r\n        add_2_prong_1.add2Prong(cpTrees, circle, posSource, [posAntipodes[0]], true, extreme);\r\n    }\r\n}\r\nexports.findAndAddHoleClosing2Prongs = findAndAddHoleClosing2Prongs;\r\n//# sourceMappingURL=find-and-add-hole-closing-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/find-and-add-hole-closing-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/** @hidden */\r\nfunction getPotential2Prongs(possPerLoop) {\r\n    let for2ProngsArray = [];\r\n    for (let poss of possPerLoop) {\r\n        let for2Prongs = [];\r\n        for (let pos of poss) {\r\n            if (!point_on_shape_1.isPosQuiteSharpCorner(pos)) {\r\n                for2Prongs.push(pos);\r\n            }\r\n        }\r\n        for2ProngsArray.push(for2Prongs);\r\n    }\r\n    return for2ProngsArray;\r\n}\r\nexports.getPotential2Prongs = getPotential2Prongs;\r\n//# sourceMappingURL=get-potential-2-prongs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/get-potential-2-prongs.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/** @hidden */\r\nfunction getSharpCorners(possPerLoop) {\r\n    let sharpCornersPerLoop = [];\r\n    for (let poss of possPerLoop) {\r\n        let sharpCorners = [];\r\n        for (let pos of poss) {\r\n            //if (PointOnShape.isQuiteSharpCorner(pos)) {\r\n            if (point_on_shape_1.isPosQuiteSharpCorner(pos)) {\r\n                sharpCorners.push(pos);\r\n            }\r\n        }\r\n        sharpCornersPerLoop.push(sharpCorners);\r\n    }\r\n    return sharpCornersPerLoop;\r\n}\r\nexports.getSharpCorners = getSharpCorners;\r\n//# sourceMappingURL=get-sharp-corners.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/find-mat/get-sharp-corners.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * @hidden\r\n */\r\nfunction getClosestSquareDistanceToRect(box, p) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    let [xp, yp] = p;\r\n    if (xp < x0) {\r\n        if (yp < y0) {\r\n            return flo_vector2d_1.squaredDistanceBetween(box[0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return flo_vector2d_1.squaredDistanceBetween([x0, y1], p);\r\n        }\r\n        else {\r\n            return Math.pow((x0 - xp), 2);\r\n        }\r\n    }\r\n    else if (xp > x1) {\r\n        if (yp < y0) {\r\n            return flo_vector2d_1.squaredDistanceBetween([x1, y0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return flo_vector2d_1.squaredDistanceBetween(box[1], p);\r\n        }\r\n        else {\r\n            return Math.pow((xp - x1), 2);\r\n        }\r\n    }\r\n    else {\r\n        if (yp < y0) {\r\n            return Math.pow((y0 - yp), 2);\r\n        }\r\n        else if (yp > y1) {\r\n            return Math.pow((yp - y1), 2);\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexports.getClosestSquareDistanceToRect = getClosestSquareDistanceToRect;\r\n//# sourceMappingURL=get-closest-square-distance-to-rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/get-closest-square-distance-to-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\n/**\r\n * @hidden\r\n */\r\nfunction getClosestSquaredDistanceToRotatedRect(ps, p) {\r\n    let ds = [0, 1, 2, 3].map(i => flo_vector2d_1.squaredDistanceBetweenPointAndLineSegment(p, [ps[i], ps[(i + 1) % 4]]));\r\n    let width = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[1]);\r\n    let height = flo_vector2d_1.squaredDistanceBetween(ps[0], ps[3]);\r\n    if (ds[0] <= height && ds[2] <= height &&\r\n        ds[1] <= width && ds[3] <= width) {\r\n        return 0; // Inside rotated rect\r\n    }\r\n    return Math.min(...ds);\r\n}\r\nexports.getClosestSquaredDistanceToRotatedRect = getClosestSquaredDistanceToRotatedRect;\r\n//# sourceMappingURL=get-closest-squared-distance-to-rotated-rect.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/geometry/get-closest-squared-distance-to-rotated-rect.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst contact_point_1 = __webpack_require__(/*! ../contact-point */ \"./node_modules/flo-mat/node/contact-point.js\");\r\n/**\r\n * @hidden\r\n * Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\r\n * from the given boundary piece.\r\n * @param cpNodes - An ordered pair that represents the start and end points of\r\n * the boundary piece\r\n */\r\nfunction getBoundaryPieceBeziers(cpNodes) {\r\n    let cpThis = cpNodes[0];\r\n    let cpEnd = cpNodes[1];\r\n    let bezierPieces = [];\r\n    // As opposed to going around the circle and taking the last exit\r\n    let goStraight = true;\r\n    do {\r\n        if (!goStraight) {\r\n            goStraight = true;\r\n            cpThis = cpThis.prevOnCircle; // take last exit\r\n            continue;\r\n        }\r\n        goStraight = false;\r\n        let posThis = cpThis.cp.pointOnShape;\r\n        let posNext = cpThis.next.cp.pointOnShape;\r\n        if (posNext.curve === posThis.curve &&\r\n            //PointOnShape.isQuiteSharpCorner(posThis) && \r\n            //PointOnShape.isQuiteSharpCorner(posNext)) {\r\n            point_on_shape_1.isPosQuiteSharpCorner(posThis) &&\r\n            point_on_shape_1.isPosQuiteSharpCorner(posNext)) {\r\n            // Do nothing\r\n        }\r\n        else if (posNext.curve === posThis.curve &&\r\n            contact_point_1.compareCps(cpThis.next.cp, cpThis.cp) > 0) {\r\n            bezierPieces.push({ curve: posThis.curve, ts: [posThis.t, posNext.t] });\r\n        }\r\n        else {\r\n            bezierPieces.push({ curve: posThis.curve, ts: [posThis.t, 1] });\r\n            if (cpThis.cp.pointOnShape.curve.loop === cpThis.next.cp.pointOnShape.curve.loop) {\r\n                addSkippedBeziers(bezierPieces, posThis.curve, posNext.curve, posNext.t);\r\n            }\r\n        }\r\n        cpThis = cpThis.next;\r\n    } while (cpThis !== cpEnd);\r\n    return bezierPieces;\r\n}\r\nexports.getBoundaryPieceBeziers = getBoundaryPieceBeziers;\r\n/**\r\n * @hidden\r\n * Adds pieces of skipped beziers\r\n */\r\nfunction addSkippedBeziers(bezierPieces, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        bezierPieces.push({ curve: curveThis, ts: [0, tEnd] });\r\n    } while (curveThis !== curveEnd);\r\n}\r\n//# sourceMappingURL=get-boundary-piece-beziers.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-boundary-piece-beziers.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst curve_1 = __webpack_require__(/*! ../curve */ \"./node_modules/flo-mat/node/curve.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\n/**\r\n * @hidden\r\n * @param curve\r\n */\r\nfunction getContactCirclesAtInterface(curve) {\r\n    let { isQuiteSharp, isQuiteDull } = curve_1.getCornerAtEnd(curve);\r\n    if (isQuiteSharp) {\r\n        return [new point_on_shape_1.PointOnShape(curve, 1)];\r\n    }\r\n    else if (isQuiteDull) {\r\n        return [\r\n            new point_on_shape_1.PointOnShape(curve, 1),\r\n            new point_on_shape_1.PointOnShape(curve.next, 0)\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nexports.getContactCirclesAtInterface = getContactCirclesAtInterface;\r\n//# sourceMappingURL=get-contact-circles-at-interface.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-contact-circles-at-interface.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-largest-vertex.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-largest-vertex.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nfunction getLargestVertex(cpNodes) {\r\n    return cpNodes.reduce(function (maxCpNode, cpNode) {\r\n        return maxCpNode.cp.circle.radius >= cpNode.cp.circle.radius\r\n            ? maxCpNode\r\n            : cpNode;\r\n    }, cpNodes[0]);\r\n}\r\nexports.getLargestVertex = getLargestVertex;\r\n//# sourceMappingURL=get-largest-vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-largest-vertex.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-leaves.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-leaves.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nfunction getLeaves(cpNode) {\r\n    let leaves = [];\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(function (cp) {\r\n        if (cp.isTerminating()) {\r\n            leaves.push(cp);\r\n        }\r\n    });\r\n    return leaves;\r\n}\r\nexports.getLeaves = getLeaves;\r\n//# sourceMappingURL=get-leaves.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-leaves.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-neighboring-cps.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-neighboring-cps.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * @hidden\r\n * Returns the boundary piece that starts at the immediate previous point on the\r\n * shape and ends at the immediate next point.\r\n * @param cpTree\r\n * @param pos\r\n * @param order\r\n * @param order2\r\n */\r\nfunction getNeighbouringPoints(cpTree, pos, order, order2) {\r\n    let cps = cpTree.findBounds(new cp_node_1.CpNode({ pointOnShape: pos, circle: undefined, order, order2 }, false, false));\r\n    if (!cps[0] && !cps[1]) {\r\n        // The tree is still empty\r\n        return [undefined, undefined];\r\n    }\r\n    if (!cps[0] || !cps[1]) {\r\n        // Smaller than all -> cptree.min() === cps[1].data OR\r\n        // Larger  than all -> cptree.max() === cps[0].data\r\n        return [\r\n            cpTree.max(cpTree.root),\r\n            cpTree.min(cpTree.root)\r\n        ];\r\n    }\r\n    return [\r\n        cps[0].data,\r\n        cps[1].data\r\n    ];\r\n}\r\nexports.getNeighbouringPoints = getNeighbouringPoints;\r\n//# sourceMappingURL=get-neighboring-cps.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-neighboring-cps.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/get-two-prong-type.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/get-two-prong-type.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nfunction getTwoProngType(e) {\r\n    if (e.holeClosing) {\r\n        return 'twoProng_holeClosing';\r\n    }\r\n    return 'twoProng_regular';\r\n}\r\nexports.getTwoProngType = getTwoProngType;\r\n//# sourceMappingURL=get-two-prong-type.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/get-two-prong-type.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/is-another-cp-closeby.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/is-another-cp-closeby.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst get_neighboring_cps_1 = __webpack_require__(/*! ./get-neighboring-cps */ \"./node_modules/flo-mat/node/mat/get-neighboring-cps.js\");\r\n/** @hidden */\r\n//const ANGLE_THRESHOLD = Math.cos(3 * (Math.PI / 180)); // 3 degrees\r\nconst ANGLE_THRESHOLD = 0.9986295347545738; // === Math.cos(3  degrees)\r\n//const ANGLE_THRESHOLD = 0.9848077530122080; // === Math.cos(10 degrees)\r\n//const ANGLE_THRESHOLD = 0.9998476951563913; // === Math.cos(1 degrees)\r\n//const ANGLE_THRESHOLD = 0.9999984769132877; // === Math.cos(0.1 degrees)   \r\n//const ANGLE_THRESHOLD = 0.9999999847691291  // === Math.cos(0.01 degrees)   \r\n/**\r\n * @hidden\r\n * Returns true if another CpNode is close to the given implied (via pos, order\r\n * and order2) CpNode.\r\n * @param cpTrees\r\n * @param pos\r\n * @param circle\r\n * @param order\r\n * @param order2\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n * @param color Used for debugging only\r\n */\r\nfunction isAnotherCpCloseby(cpTrees, pos, circle, order, order2, extreme, color) {\r\n    //console.log(extreme)\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1; \r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1;\r\n    const DISTANCE_THRESHOLD = extreme * 1e-4;\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-4; - was this\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-6;\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-12;\r\n    // It seems this can be zero else the ordering should be correct\r\n    //const DISTANCE_THRESHOLD = 0;\r\n    let cpTree = cpTrees.get(pos.curve.loop);\r\n    let cpNodes = get_neighboring_cps_1.getNeighbouringPoints(cpTree, pos, order, order2);\r\n    if (!cpNodes[0]) {\r\n        return false;\r\n    }\r\n    for (let cpNode of cpNodes) {\r\n        let pos2 = cpNode.cp.pointOnShape;\r\n        let p1 = pos.p;\r\n        let p2 = pos2.p;\r\n        if (flo_vector2d_1.distanceBetween(p1, p2) > DISTANCE_THRESHOLD) {\r\n            continue;\r\n        }\r\n        let v1 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(cpNode.cp.pointOnShape.p, cpNode.cp.circle.center));\r\n        let v2 = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(p1, circle.center));\r\n        let cosTheta = flo_vector2d_1.dot(v1, v2);\r\n        if (cosTheta > ANGLE_THRESHOLD) {\r\n            //console.log(`%c${cosTheta} - ${distanceBetween(p1,p2)}`, `color: ${color}`);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isAnotherCpCloseby = isAnotherCpCloseby;\r\n//# sourceMappingURL=is-another-cp-closeby.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/is-another-cp-closeby.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/simplify-mat-map-only.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/simplify-mat-map-only.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_branches_1 = __webpack_require__(/*! ../get-branches */ \"./node_modules/flo-mat/node/get-branches.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ../get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\nconst get_curve_between_1 = __webpack_require__(/*! ../get-curve/get-curve-between */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js\");\r\n/**\r\n * Simplifies the given MAT by replacing the piecewise quad beziers composing\r\n * the MAT with fewer ones to within a given tolerance. Returns the map of\r\n * to be deleted nodes only - does not actually delete them. Use simplifyMat\r\n * instead if you want to delete the nodes.\r\n * @param cpNode A representation of the MAT\r\n * @param anlgeTolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required - defaults to 15.\r\n * @param hausdorffTolerance The approximate maximum Hausdorff Distance tolerance -\r\n * defaults to 0.1\r\n * @param hausdorffSpacing The spacing on the curves used to calculate the Hausdorff\r\n * Distance - defaults to 1\r\n */\r\nfunction simplifyMatMapOnly(cpNode, anlgeTolerance = 15, hausdorffTolerance = 1e-1, hausdorffSpacing = 1e0) {\r\n    let simpleMap = new Map();\r\n    // Start from a leaf\r\n    while (!cpNode.isTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = get_branches_1.getBranches(cpNode, anlgeTolerance);\r\n    let canDeletes = [];\r\n    for (let k = 0; k < branches.length; k++) {\r\n        let branch = branches[k];\r\n        // Try to remove some\r\n        let j = 0;\r\n        while (j < branch.length) {\r\n            let i = j;\r\n            while (true) {\r\n                j++;\r\n                if (j === branch.length) {\r\n                    break;\r\n                }\r\n                let hd = getTotalHausdorffDistance(i, j, branch, hausdorffSpacing);\r\n                if (hd > hausdorffTolerance) {\r\n                    break;\r\n                }\r\n                else {\r\n                    canDeletes.push(branch[j]);\r\n                }\r\n            }\r\n            if (i + 1 === j) {\r\n                // no simplification occured\r\n            }\r\n            else {\r\n                let branStart = branch[i];\r\n                let branEnd = branch[j - 1];\r\n                let medial = flo_bezier3_1.toCubic(get_curve_between_1.getCurveBetween(branStart, branEnd.next));\r\n                let rev = medial.slice().reverse();\r\n                let curCpNode = branStart;\r\n                let prevT = 0;\r\n                while (curCpNode !== branEnd) {\r\n                    let t = closest_point_on_bezier_1.closestPointOnBezier(medial, curCpNode.next.cp.circle.center).t;\r\n                    simpleMap.set(curCpNode, { ps: medial, ts: [prevT, t] });\r\n                    let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                    simpleMap.set(oppositeCpNode, { ps: rev, ts: [1 - t, 1 - prevT] });\r\n                    prevT = t;\r\n                    curCpNode = curCpNode.next;\r\n                }\r\n                simpleMap.set(curCpNode, { ps: medial, ts: [prevT, 1] });\r\n                let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                simpleMap.set(oppositeCpNode, { ps: rev, ts: [0, 1 - prevT] });\r\n            }\r\n        }\r\n    }\r\n    return { simpleMap, cpNode };\r\n}\r\nexports.simplifyMatMapOnly = simplifyMatMapOnly;\r\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\r\n    let hds = [];\r\n    let longCurve = get_curve_between_1.getCurveBetween(branch[i], branch[j].next);\r\n    for (let m = i; m < j + 1; m++) {\r\n        hds.push(flo_bezier3_1.hausdorffDistance(get_curve_to_next_1.getCurveToNext(branch[m]), longCurve, hausdorffSpacing));\r\n    }\r\n    return Math.max(...hds);\r\n}\r\n//# sourceMappingURL=simplify-mat-map-only.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/simplify-mat-map-only.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * @param sat\r\n */\r\nfunction addDebugInfo(sat, timingStart) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    _debug_.generated.elems.sat.push(sat);\r\n    let timing = _debug_.generated.timing;\r\n    timing.sats = performance.now() - timingStart;\r\n}\r\nexports.addDebugInfo = addDebugInfo;\r\n//# sourceMappingURL=add-debug-info.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * @hidden\r\n * Cull all edges not part of a cycle in the MAT planar graph.\r\n * @param cpStart The start CpNode which must reprsesent the maximal 3-prong\r\n * vertex.\r\n */\r\nfunction cullNonCycles(cpStart) {\r\n    let cpNodeKept = cpStart;\r\n    let leaves = get_leaves_1.getLeaves(cpStart);\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology - keep cycles.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (cpNode.getProngCount() > 2) {\r\n                //let cp2 = cp1.prevOnCircle;\r\n                let cp2 = cpNode.nextOnCircle;\r\n                //if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\r\n                if (cp_node_1.CpNode.isOnSameCircle(cpNode, cpStart)) {\r\n                    cut = true; // We are at the max disk - cut whole edge\r\n                }\r\n                else if (cpNode.next === cp2) {\r\n                    cpNode = cp2;\r\n                }\r\n                else if (cp2.next !== cp1) {\r\n                    cut = true; // Cut whole edge\r\n                }\r\n            }\r\n            else if (cpNode.isTerminating() && !cpNode.isIntersection) {\r\n                cpNodeKept = cpNode;\r\n                return undefined;\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                cpNodeKept = cpNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return cpNodeKept;\r\n}\r\nexports.cullNonCycles = cullNonCycles;\r\n//# sourceMappingURL=cull-non-cycles.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/to-scale-axis/cull.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/to-scale-axis/cull.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_leaves_1 = __webpack_require__(/*! ../get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cp_node_1 = __webpack_require__(/*! ../../cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\n/**\r\n * @hidden\r\n * Returns the set of Vertices passing the following test: walk the MAT tree and\r\n * keep all Vertices not in the current cull set and any Vertices that have a\r\n * non-culled node further down the line toward the tree leaves.\r\n * @param culls The CpNodes (referred to by circles) that should be culled.\r\n * @param maxCpNode The start CpNode which must reprsesent the maximal vertex.\r\n */\r\nfunction cull(culls, maxCpNode) {\r\n    let leaves = get_leaves_1.getLeaves(maxCpNode);\r\n    function getNonTrivialEdges(cpStart) {\r\n        let cp = cpStart;\r\n        let cps = [];\r\n        do {\r\n            if (cp.next !== cp.nextOnCircle) {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== cpStart.prevOnCircle);\r\n        return cps;\r\n    }\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        if (!culls.has(leaf.cp.circle)) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (!culls.has(cpNode.cp.circle)) {\r\n                // Cut off the edge once a non-cull has been reached.\r\n                cut = true;\r\n            }\r\n            else if (cp_node_1.CpNode.isOnSameCircle(cpNode, maxCpNode)) {\r\n                cut = true; // We are at the max disk - cut whole edge\r\n            }\r\n            else {\r\n                let cps = getNonTrivialEdges(cpNode);\r\n                if (cps.length === 1) {\r\n                    cpNode = cps[0];\r\n                }\r\n                else {\r\n                    cut = true;\r\n                }\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.cull = cull;\r\n//# sourceMappingURL=cull.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/to-scale-axis/cull.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/mat/trim-mat.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/mat/trim-mat.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst create_new_cp_tree_1 = __webpack_require__(/*! ./create-new-cp-tree */ \"./node_modules/flo-mat/node/mat/create-new-cp-tree.js\");\r\nconst cull_non_cycles_1 = __webpack_require__(/*! ./to-scale-axis/cull-non-cycles */ \"./node_modules/flo-mat/node/mat/to-scale-axis/cull-non-cycles.js\");\r\nconst clone_1 = __webpack_require__(/*! ../cp-node/clone */ \"./node_modules/flo-mat/node/cp-node/clone.js\");\r\n/**\r\n * Trims the given Medial Axis Transform so that only cycles remain. Similar to\r\n * toScaleAxis(mat, Number.POSITIVE_INFINITY).\r\n * @param mat The MAT to trim.\r\n */\r\nfunction trimMat(mat) {\r\n    let cpNode = cull_non_cycles_1.cullNonCycles(clone_1.clone(mat.cpNode));\r\n    if (!cpNode) {\r\n        return undefined;\r\n    }\r\n    return { cpNode, cpTrees: create_new_cp_tree_1.createNewCpTree(cpNode) };\r\n}\r\nexports.trimMat = trimMat;\r\n//# sourceMappingURL=trim-mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/mat/trim-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/point-on-shape.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/point-on-shape.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_vector2d_1 = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst curve_1 = __webpack_require__(/*! ./curve */ \"./node_modules/flo-mat/node/curve.js\");\r\n/**\r\n * Represents a point on the shape boundary for which MAT vertex information\r\n * has not *necessarily* been calculated.\r\n */\r\nclass PointOnShape {\r\n    /**\r\n     * @param curve\tThe [[ICurve]] on the shape boundary this points belong to.\r\n     * @param t The bezier parameter value on the curve to identify the point\r\n     * coordinates.\r\n     */\r\n    constructor(curve, t) {\r\n        this.curve = curve;\r\n        this.t = t;\r\n        // Cache\r\n        this.p_ = undefined;\r\n    }\r\n    /**\r\n     * The planar point coordinates of this [[PointOnShape]].\r\n     */\r\n    get p() {\r\n        return this.p_ === undefined\r\n            ? this.p_ = flo_bezier3_1.evalDeCasteljau(this.curve.ps, this.t)\r\n            : this.p_;\r\n    }\r\n}\r\nexports.PointOnShape = PointOnShape;\r\n/**\r\n * @hidden\r\n */\r\nfunction isPosCorner(pos) {\r\n    return (pos.t === 0 || pos.t === 1);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction getPosCorner(pos) {\r\n    return curve_1.getCornerAtEnd(pos.t === 1 ? pos.curve : pos.curve.prev);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nlet isPosSharpCorner = flo_memoize_1.memoize((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isSharp;\r\n});\r\nexports.isPosSharpCorner = isPosSharpCorner;\r\n/**\r\n * @hidden\r\n */\r\nlet isPosDullCorner = flo_memoize_1.memoize((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isDull;\r\n});\r\nexports.isPosDullCorner = isPosDullCorner;\r\n/**\r\n * @hidden\r\n */\r\nlet isPosQuiteSharpCorner = flo_memoize_1.memoize((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isQuiteSharp;\r\n});\r\nexports.isPosQuiteSharpCorner = isPosQuiteSharpCorner;\r\n/**\r\n * @hidden\r\n */\r\nlet isPosQuiteDullCorner = flo_memoize_1.memoize((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isQuiteDull;\r\n});\r\nexports.isPosQuiteDullCorner = isPosQuiteDullCorner;\r\n/**\r\n * Returns a human-readable string of the given [[PointOnShape]].\r\n * For debugging only.\r\n * @hidden\r\n */\r\nfunction posToHumanString(pos) {\r\n    return '' + pos.p[0] + ', ' + pos.p[1] +\r\n        ' | bz: ' + pos.curve.idx +\r\n        ' | t: ' + pos.t;\r\n}\r\nexports.posToHumanString = posToHumanString;\r\n/**\r\n * @hidden\r\n * Calculates the order (to distinguish between points lying on top of each\r\n * other) of the contact point if it is a dull corner.\r\n * @param pos\r\n */\r\nfunction calcPosOrder(circle, pos) {\r\n    if (!isPosCorner(pos)) {\r\n        return 0;\r\n    }\r\n    if (!isPosDullCorner(pos)) {\r\n        return 0;\r\n    }\r\n    //if (!isPosDullCorner(pos)) { return 0; }\r\n    let corner = getPosCorner(pos);\r\n    let n = flo_vector2d_1.rotateNeg90Degrees(corner.tangents[0]);\r\n    let v = flo_vector2d_1.toUnitVector(flo_vector2d_1.fromTo(pos.p, circle.center));\r\n    return -flo_vector2d_1.dot(n, v);\r\n}\r\nexports.calcPosOrder = calcPosOrder;\r\n/**\r\n * Compares two [[PointOnShape]]s according to their cyclic ordering imposed\r\n * by their relative positions on the shape boundary.\r\n * @param a The first [[PointOnShape]].\r\n * @param b The second [[PointOnShape]].\r\n * @hidden\r\n */\r\nfunction comparePoss(a, b) {\r\n    if (a === undefined || b === undefined) {\r\n        return undefined;\r\n    }\r\n    let res;\r\n    res = a.curve.idx - b.curve.idx;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = a.t - b.t;\r\n    return res;\r\n}\r\nexports.comparePoss = comparePoss;\r\n/**\r\n * Calculates and returns the osculating circle radius of the bezier at a\r\n * specific t. If it is found to have negative or nearly zero radius\r\n * it is clipped to have positive radius so it can point into the shape.\r\n * @param ps\r\n * @param t\r\n * @hidden\r\n */\r\nlet calcOsculatingCircleRadius = flo_memoize_1.memoize((pos) => {\r\n    let ps = pos.curve.ps;\r\n    let t = pos.t;\r\n    let κ = -flo_bezier3_1.κ(ps, t);\r\n    // κ > 0 => bending inwards\r\n    return 1 / κ;\r\n});\r\n/**\r\n * Returns the osculating circle at this point of the curve.\r\n * @param maxOsculatingCircleRadius If not Number.POSITIVE_INFINITY then the\r\n * circle radius will be limited to this value.\r\n * @param pos The [[PointOnShape]] identifying the point.\r\n */\r\nfunction getOsculatingCircle(maxOsculatingCircleRadius, pos) {\r\n    //if (PointOnShape.isSharpCorner(pos)) {\r\n    if (isPosSharpCorner(pos)) {\r\n        return { center: pos.p, radius: 0 };\r\n    }\r\n    let radius = calcOsculatingCircleRadius(pos);\r\n    if (radius < 0) {\r\n        radius = Number.POSITIVE_INFINITY;\r\n    }\r\n    radius = Math.min(radius, maxOsculatingCircleRadius);\r\n    let ps = pos.curve.ps;\r\n    let t = pos.t;\r\n    let normal_ = flo_vector2d_1.toUnitVector(flo_bezier3_1.normal(ps, t));\r\n    let p = flo_bezier3_1.evalDeCasteljau(ps, t);\r\n    let circleCenter = [\r\n        p[0] + normal_[0] * radius,\r\n        p[1] + normal_[1] * radius\r\n    ];\r\n    return { center: circleCenter, radius };\r\n}\r\nexports.getOsculatingCircle = getOsculatingCircle;\r\n//# sourceMappingURL=point-on-shape.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/point-on-shape.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/simplify-mat.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-mat/node/simplify-mat.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp_node_1 = __webpack_require__(/*! ./cp-node */ \"./node_modules/flo-mat/node/cp-node.js\");\r\nconst get_branches_1 = __webpack_require__(/*! ./get-branches */ \"./node_modules/flo-mat/node/get-branches.js\");\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ./get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\nconst get_curve_between_1 = __webpack_require__(/*! ./get-curve/get-curve-between */ \"./node_modules/flo-mat/node/get-curve/get-curve-between.js\");\r\nconst closest_point_on_bezier_1 = __webpack_require__(/*! flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier */ \"./node_modules/flo-bezier3/node/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.js\");\r\n/**\r\n * Simplifies the given MAT by replacing the piecewise quad beziers composing\r\n * the MAT with fewer ones to within a given tolerance.\r\n * @param cpNode A representation of the MAT\r\n * @param anlgeTolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required - defaults to 15.\r\n * @param hausdorffTolerance The approximate maximum Hausdorff Distance tolerance -\r\n * defaults to 0.1\r\n * @param hausdorffSpacing The spacing on the curves used to calculate the Hausdorff\r\n * Distance - defaults to 1\r\n */\r\nfunction simplifyMat(mat, anlgeTolerance = 15, hausdorffTolerance = 1e-1, hausdorffSpacing = 1e0) {\r\n    let cpNode = mat.cpNode;\r\n    let simpleMap = new Map();\r\n    // Start from a leaf\r\n    while (!cpNode.isTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = get_branches_1.getBranches(cpNode, anlgeTolerance);\r\n    let canDeletes = [];\r\n    for (let k = 0; k < branches.length; k++) {\r\n        let branch = branches[k];\r\n        // Try to remove some\r\n        let j = 0;\r\n        while (j < branch.length) {\r\n            let i = j;\r\n            while (true) {\r\n                j++;\r\n                if (j === branch.length) {\r\n                    break;\r\n                }\r\n                let hd = getTotalHausdorffDistance(i, j, branch, hausdorffSpacing);\r\n                if (hd > hausdorffTolerance) {\r\n                    break;\r\n                }\r\n                else {\r\n                    canDeletes.push(branch[j]);\r\n                }\r\n            }\r\n            if (i + 1 === j) {\r\n                // no simplification occured\r\n            }\r\n            else {\r\n                let branStart = branch[i];\r\n                let branEnd = branch[j - 1];\r\n                let medial = flo_bezier3_1.toCubic(get_curve_between_1.getCurveBetween(branStart, branEnd.next));\r\n                let rev = medial.slice().reverse();\r\n                let curCpNode = branStart;\r\n                let prevT = 0;\r\n                while (curCpNode !== branEnd) {\r\n                    let t = closest_point_on_bezier_1.closestPointOnBezier(medial, curCpNode.next.cp.circle.center).t;\r\n                    simpleMap.set(curCpNode, { ps: medial, ts: [prevT, t] });\r\n                    let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                    simpleMap.set(oppositeCpNode, { ps: rev, ts: [1 - t, 1 - prevT] });\r\n                    prevT = t;\r\n                    curCpNode = curCpNode.next;\r\n                }\r\n                simpleMap.set(curCpNode, { ps: medial, ts: [prevT, 1] });\r\n                let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                simpleMap.set(oppositeCpNode, { ps: rev, ts: [0, 1 - prevT] });\r\n            }\r\n        }\r\n    }\r\n    for (let cpNode of canDeletes) {\r\n        let isTerminating = cpNode.isTerminating();\r\n        let onCircleCount = cpNode.getCpNodesOnCircle().length;\r\n        if (isTerminating || onCircleCount !== 2) {\r\n            continue;\r\n        }\r\n        cp_node_1.CpNode.remove(cpNode);\r\n    }\r\n    //return { cpNode, cpTrees: createNewCpTree(cpNode) }; \r\n    return { cpNode, cpTrees: undefined };\r\n}\r\nexports.simplifyMat = simplifyMat;\r\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\r\n    let hds = [];\r\n    let longCurve = get_curve_between_1.getCurveBetween(branch[i], branch[j].next);\r\n    for (let m = i; m < j + 1; m++) {\r\n        hds.push(flo_bezier3_1.hausdorffDistance(get_curve_to_next_1.getCurveToNext(branch[m]), longCurve, hausdorffSpacing));\r\n    }\r\n    return Math.max(...hds);\r\n}\r\n//# sourceMappingURL=simplify-mat.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/simplify-mat.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/get-loop-bounds.js":
/*!**********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/get-loop-bounds.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst point_on_shape_1 = __webpack_require__(/*! ../point-on-shape */ \"./node_modules/flo-mat/node/point-on-shape.js\");\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\n/** @hidden */\r\nconst INF = Number.POSITIVE_INFINITY;\r\n/**\r\n * @hidden\r\n */\r\nlet getLoopBounds = flo_memoize_1.memoize(function (loop) {\r\n    let extremes = [\r\n        [\r\n            { bezier: undefined, t: undefined, val: INF },\r\n            { bezier: undefined, t: undefined, val: INF }\r\n        ],\r\n        [\r\n            { bezier: undefined, t: undefined, val: -INF },\r\n            { bezier: undefined, t: undefined, val: -INF }\r\n        ]\r\n    ];\r\n    loop.curves.forEach(function (curve) {\r\n        let ps = curve.ps;\r\n        let bounds = flo_bezier3_1.getBounds(ps);\r\n        {\r\n            {\r\n                let v = bounds.box[0][0];\r\n                let x = extremes[0][0].val;\r\n                if (v < x || (v === x && bounds.ts[0][0] > extremes[0][0].t)) {\r\n                    extremes[0][0] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[0][0],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n            {\r\n                let v = bounds.box[0][1];\r\n                let x = extremes[0][1].val;\r\n                if (v < x || (v === x && bounds.ts[0][1] > extremes[0][1].t)) {\r\n                    extremes[0][1] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[0][1],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        {\r\n            {\r\n                let v = bounds.box[1][0];\r\n                let x = extremes[1][0].val;\r\n                if (v > x || (v === x && bounds.ts[1][0] > extremes[1][0].t)) {\r\n                    extremes[1][0] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[1][0],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n            {\r\n                let v = bounds.box[1][1];\r\n                let x = extremes[1][1].val;\r\n                if (v > x || (v === x && bounds.ts[1][1] > extremes[1][1].t)) {\r\n                    extremes[1][1] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[1][1],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        minX: new point_on_shape_1.PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\r\n        minY: new point_on_shape_1.PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\r\n        maxX: new point_on_shape_1.PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\r\n        maxY: new point_on_shape_1.PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\r\n    };\r\n});\r\nexports.getLoopBounds = getLoopBounds;\r\n//# sourceMappingURL=get-loop-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/get-loop-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/get-min-y-pos.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/get-min-y-pos.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/get-loop-bounds.js\");\r\n/**\r\n * @hidden\r\n * Get topmost PointOnShape of the given loop.\r\n */\r\nfunction getMinYPos(loop) {\r\n    return get_loop_bounds_1.getLoopBounds(loop).minY;\r\n}\r\nexports.getMinYPos = getMinYPos;\r\n//# sourceMappingURL=get-min-y-pos.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/get-min-y-pos.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/svg/get-shape-bounds.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-mat/node/svg/get-shape-bounds.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_memoize_1 = __webpack_require__(/*! flo-memoize */ \"./node_modules/flo-memoize/node/index.js\");\r\nconst get_loop_bounds_1 = __webpack_require__(/*! ./get-loop-bounds */ \"./node_modules/flo-mat/node/svg/get-loop-bounds.js\");\r\n// TODO - move to another library\r\n/** @hidden */\r\nlet getShapeBounds = flo_memoize_1.memoize(function (loops) {\r\n    let minX_ = Number.POSITIVE_INFINITY;\r\n    let maxX_ = Number.NEGATIVE_INFINITY;\r\n    let minY_ = Number.POSITIVE_INFINITY;\r\n    let maxY_ = Number.NEGATIVE_INFINITY;\r\n    let minX;\r\n    let maxX;\r\n    let minY;\r\n    let maxY;\r\n    for (let loop of loops) {\r\n        let bounds = get_loop_bounds_1.getLoopBounds(loop);\r\n        if (bounds.minX.p[0] < minX_) {\r\n            minX = bounds.minX;\r\n            minX_ = bounds.minX.p[0];\r\n        }\r\n        if (bounds.maxX.p[0] > maxX_) {\r\n            maxX = bounds.maxX;\r\n            maxX_ = bounds.maxX.p[0];\r\n        }\r\n        if (bounds.minY.p[1] < minY_) {\r\n            minY = bounds.minY;\r\n            minY_ = bounds.minY.p[1];\r\n        }\r\n        if (bounds.maxY.p[1] > maxY_) {\r\n            maxY = bounds.maxY;\r\n            maxY_ = bounds.maxY.p[1];\r\n        }\r\n    }\r\n    return { minX, minY, maxX, maxY };\r\n});\r\nexports.getShapeBounds = getShapeBounds;\r\n//# sourceMappingURL=get-shape-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/svg/get-shape-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @hidden\r\n * Returns true if the 2 given (closed) boxes intersect. At this stage we already\r\n * know their x-axis intersect.\r\n * @param a A rectangular box\r\n * @param a Another rectangular box\r\n * @param closed (defaults to true) Interpret boxes as being closed (i.e. they\r\n * contain their border) or open.\r\n */\r\nfunction areBoxesIntersecting(closed) {\r\n    return (a, b) => {\r\n        let [[ax0, ay0], [ax1, ay1]] = a;\r\n        let [[bx0, by0], [bx1, by1]] = b;\r\n        // Swap so smaller coordinate comes first\r\n        if (ay0 > ay1) {\r\n            [ay0, ay1] = [ay1, ay0];\r\n        }\r\n        ;\r\n        if (by0 > by1) {\r\n            [by0, by1] = [by1, by0];\r\n        }\r\n        ;\r\n        if (ax0 > ax1) {\r\n            [ax0, ax1] = [ax1, ax0];\r\n        }\r\n        ;\r\n        if (bx0 > bx1) {\r\n            [bx0, bx1] = [bx1, bx0];\r\n        }\r\n        ;\r\n        return closed\r\n            ? (ax0 <= bx1 && ax1 >= bx0 &&\r\n                by0 <= ay1 && by1 >= ay0)\r\n            : (ax0 < bx1 && ax1 > bx0 &&\r\n                by0 < ay1 && by1 > ay0);\r\n    };\r\n}\r\nexports.areBoxesIntersecting = areBoxesIntersecting;\r\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/sweep-line/are-boxes-intersecting.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/sweep-line/sweep-line.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-mat/node/sweep-line/sweep-line.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @hidden */\r\nconst EVENT_LEFT = 0;\r\n/** @hidden */\r\nconst EVENT_RIGHT = 1;\r\n/**\r\n * @hidden\r\n * Generalized sweepline algorithm.\r\n *\r\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\r\n *\r\n * @param items An array of items that are to be compared. Items should\r\n * typically be geometric objects in 2d space with well-defined left and right\r\n * endpoints.\r\n * @param getLeftmostPoint A function that returns the leftmost point of the\r\n * geometric object of interest.\r\n * @param getRightmostPoint A function that returns the rightmost point of the\r\n * geometric object of interest.\r\n * @param predicate A predicate that takes two geometric objects and returns\r\n * true if they are of interest or false otherwise.\r\n */\r\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\r\n    // Initialize event queue to contain all endpoints.\r\n    let events = [];\r\n    for (let item of items) {\r\n        events.push({\r\n            type: EVENT_LEFT,\r\n            item,\r\n            x: getLeftmost(item)\r\n        });\r\n        events.push({\r\n            type: EVENT_RIGHT,\r\n            item,\r\n            x: getRightmost(item)\r\n        });\r\n    }\r\n    events.sort(compare);\r\n    let activeItems = new Set();\r\n    /** A list of pairs of items that passed the predicate */\r\n    let pairedItems = [];\r\n    for (let event of events) {\r\n        let { item } = event;\r\n        if (event.type === EVENT_LEFT) {\r\n            for (let activeItem of activeItems.values()) {\r\n                if (predicate(item, activeItem)) {\r\n                    pairedItems.push([item, activeItem]);\r\n                }\r\n            }\r\n            activeItems.add(item);\r\n        }\r\n        else if (event.type === EVENT_RIGHT) {\r\n            activeItems.delete(event.item);\r\n        }\r\n    }\r\n    return pairedItems;\r\n}\r\nexports.sweepLine = sweepLine;\r\n/**\r\n * @hidden\r\n * Compare two Events by their x-axis and then by their type. Since it is\r\n * open boxes that are compared we must let the right endpoint type come\r\n * before the left.\r\n * @param a An event\r\n * @param b Another event\r\n */\r\nfunction compare(a, b) {\r\n    let res = a.x - b.x;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Alwys put left events before right ones.\r\n    return a.type === EVENT_LEFT ? -1 : +1;\r\n}\r\n//# sourceMappingURL=sweep-line.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/sweep-line/sweep-line.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/to-scale-axis.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-mat/node/to-scale-axis.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_bezier3_1 = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\r\nconst traverse_edges_1 = __webpack_require__(/*! ./traverse-edges */ \"./node_modules/flo-mat/node/traverse-edges.js\");\r\nconst traverse_vertices_1 = __webpack_require__(/*! ./traverse-vertices */ \"./node_modules/flo-mat/node/traverse-vertices.js\");\r\nconst get_largest_vertex_1 = __webpack_require__(/*! ./mat/get-largest-vertex */ \"./node_modules/flo-mat/node/mat/get-largest-vertex.js\");\r\nconst get_leaves_1 = __webpack_require__(/*! ./mat/get-leaves */ \"./node_modules/flo-mat/node/mat/get-leaves.js\");\r\nconst cull_1 = __webpack_require__(/*! ./mat/to-scale-axis/cull */ \"./node_modules/flo-mat/node/mat/to-scale-axis/cull.js\");\r\nconst add_debug_info_1 = __webpack_require__(/*! ./mat/to-scale-axis/add-debug-info */ \"./node_modules/flo-mat/node/mat/to-scale-axis/add-debug-info.js\");\r\nconst clone_1 = __webpack_require__(/*! ./cp-node/clone */ \"./node_modules/flo-mat/node/cp-node/clone.js\");\r\nconst get_curve_to_next_1 = __webpack_require__(/*! ./get-curve-to-next */ \"./node_modules/flo-mat/node/get-curve-to-next.js\");\r\nfunction linearScale(s) {\r\n    return function (r) {\r\n        return s * r;\r\n    };\r\n}\r\n/** @hidden */\r\nlet len = flo_bezier3_1.length([0, 1]);\r\n/**\r\n * Apply and returns an enhanced version of the Scale Axis Transform (SAT) to\r\n * the given MAT. The returned SAT is guaranteed to be a subset of the MAT and\r\n * preserves topology at any scale.\r\n *\r\n * Typically the MAT contains too many branches caused by minute details on the\r\n * boundary of the shape. The SAT is a simplification of the MAT that preserves\r\n * less detail the higher the applied scale factor. The severity at which noise\r\n * are removed depends on the local scale of the shape.\r\n * @param mat The Medial Axis Transform ([[Mat]]) on which to apply the SAT.\r\n * @param s The scale factor >= 1 (e.g. 1.3)\r\n */\r\nfunction toScaleAxis(mat, s, f = linearScale) {\r\n    if (typeof _debug_ !== 'undefined') {\r\n        var timingStart = performance.now();\r\n        let leaves = get_leaves_1.getLeaves(mat.cpNode);\r\n        _debug_.generated.elems.leaves.push(leaves);\r\n    }\r\n    /** The largest vertex (as measured by its inscribed disk) */\r\n    let cpNodes = [];\r\n    traverse_vertices_1.traverseVertices(clone_1.clone(mat.cpNode), cpNode => { cpNodes.push(cpNode); });\r\n    let cpNode = get_largest_vertex_1.getLargestVertex(cpNodes);\r\n    let f_ = f(s);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.maxVertex.push(cpNode);\r\n    }\r\n    /**\r\n     * All vertices that are set to be culled initially. This may change later\r\n     * in order to preserve topology.\r\n     */\r\n    let culls = new Set();\r\n    let rMap = new Map();\r\n    traverse_edges_1.traverseEdges(cpNode, function (cpNode) {\r\n        /** The occulating radius stored with this vertex. */\r\n        let R = rMap.get(cpNode) || f_(cpNode.cp.circle.radius);\r\n        let cpNode_ = cpNode.next;\r\n        let l = len(get_curve_to_next_1.getCurveToNext(cpNode));\r\n        let r = cpNode_.cp.circle.radius;\r\n        let r_ = f_(r);\r\n        if (R - l > r_) {\r\n            for (let cpNode of cpNode_.getCpNodesOnCircle()) {\r\n                rMap.set(cpNode, R - l); // Update osculating radii\r\n            }\r\n            culls.add(cpNode_.cp.circle);\r\n        }\r\n    });\r\n    cull_1.cull(culls, cpNode);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        _debug_.generated.elems.culls.push(Array.from(culls));\r\n    }\r\n    // TODO - put line below back - goes into infinite loop\r\n    //let sat: Mat = { cpNode, cpTrees: createNewCpTree(cpNode) };\r\n    let sat = { cpNode, cpTrees: undefined };\r\n    add_debug_info_1.addDebugInfo(sat, timingStart);\r\n    return sat;\r\n}\r\nexports.toScaleAxis = toScaleAxis;\r\n//# sourceMappingURL=to-scale-axis.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/to-scale-axis.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/traverse-edges.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-mat/node/traverse-edges.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]).\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function for each CpNode representing the vertex at the\r\n * start of an edge.\r\n  */\r\nfunction traverseEdges(cpNode, f) {\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        f(cp);\r\n        if (cp.isTerminating()) {\r\n            continue;\r\n        }\r\n        cps.push(...cp.getChildren());\r\n    }\r\n}\r\nexports.traverseEdges = traverseEdges;\r\n//# sourceMappingURL=traverse-edges.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/traverse-edges.js?");

/***/ }),

/***/ "./node_modules/flo-mat/node/traverse-vertices.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-mat/node/traverse-vertices.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Traverses the MAT tree and calls the given callback function for each vertex\r\n * (represented by a [[CpNode]]) on the MAT.\r\n *\r\n * It is usually preferable to use [[traverseEdges]] as it allows for the\r\n * traversal of all the smooth curves representing the MAT.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function taking a single [[CpNode]] as parameter.\r\n */\r\nfunction traverseVertices(cpNode, f) {\r\n    f(cpNode);\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given cpNode.\t\r\n    cpNode.getCpNodesOnCircle()\r\n        .filter(cpNode => !cpNode.isTerminating())\r\n        .map(cpNode => cpNode.next)\r\n        .forEach(f_);\r\n    function f_(cpNode) {\r\n        let cps = [cpNode];\r\n        while (cps.length) {\r\n            let cp = cps.pop();\r\n            f(cp);\r\n            cps.push(...cp.vertexChildren);\r\n        }\r\n    }\r\n}\r\nexports.traverseVertices = traverseVertices;\r\n//# sourceMappingURL=traverse-vertices.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-mat/node/traverse-vertices.js?");

/***/ }),

/***/ "./node_modules/flo-memoize/node/index.js":
/*!************************************************!*\
  !*** ./node_modules/flo-memoize/node/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst pair_map_1 = __webpack_require__(/*! ./pair-map */ \"./node_modules/flo-memoize/node/pair-map.js\");\r\nconst SUPPORTED = typeof WeakMap === 'function';\r\n/**\r\n * Memoize (by reference on the input parameter) the given arity 1 function.\r\n */\r\nfunction memoize(f) {\r\n    if (!SUPPORTED) {\r\n        return f;\r\n    }\r\n    let results = new WeakMap();\r\n    return function (a) {\r\n        let result = results.get(a);\r\n        if (result !== undefined) {\r\n            //console.log('cache hit');\r\n            return result;\r\n        }\r\n        //console.log('cache miss');\r\n        result = f(a);\r\n        results.set(a, result);\r\n        return result;\r\n    };\r\n}\r\nexports.memoize = memoize;\r\n/**\r\n * Memoize (by reference on the ordered input parameters) the given arity 2 function.\r\n */\r\nfunction memoize2(f) {\r\n    if (!SUPPORTED) {\r\n        return f;\r\n    }\r\n    let results = new WeakMap();\r\n    return function (a, b) {\r\n        let result = pair_map_1.pairMap_get(results, a, b);\r\n        if (result !== undefined) {\r\n            //console.log('cache hit');\r\n            return result;\r\n        }\r\n        //console.log('cache miss');\r\n        result = f(a, b);\r\n        pair_map_1.pairMap_set(results, a, b, result);\r\n        return result;\r\n    };\r\n}\r\nexports.memoize2 = memoize2;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-memoize/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-memoize/node/pair-map.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-memoize/node/pair-map.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds an ordered pair of values to the map\r\n * @param map The map representing the pairs.\r\n * @param vs The pair to add.\r\n */\r\nfunction pairMap_set(map, v1, v2, v3) {\r\n    let v1Map = map.get(v1);\r\n    if (!v1Map) {\r\n        v1Map = new Map();\r\n        map.set(v1, v1Map);\r\n    }\r\n    v1Map.set(v2, v3);\r\n}\r\nexports.pairMap_set = pairMap_set;\r\n/**\r\n * Returns true if the unordered pair is in the set of pairs (represented by a\r\n * map).\r\n * @param map The map representing the pairs.\r\n * @param vs The pair to check.\r\n */\r\nfunction pairMap_get(map, v1, v2) {\r\n    let v1Map = map.get(v1);\r\n    if (!v1Map) {\r\n        return undefined;\r\n    }\r\n    return v1Map.get(v2);\r\n}\r\nexports.pairMap_get = pairMap_get;\r\n//# sourceMappingURL=pair-map.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-memoize/node/pair-map.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/abs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/abs.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sign_1 = __webpack_require__(/*! ./sign */ \"./node_modules/flo-numerical/node/double-expansion/sign.js\");\r\nconst negative_of_1 = __webpack_require__(/*! ./negative-of */ \"./node_modules/flo-numerical/node/double-expansion/negative-of.js\");\r\n/**\r\n * Returns the absolute value of the given expansion.\r\n * @param a A floating point number expansion\r\n */\r\nfunction abs(a) {\r\n    if (sign_1.sign(a) < 0) {\r\n        return negative_of_1.negativeOf(a);\r\n    }\r\n    return a;\r\n}\r\nexports.abs = abs;\r\n//# sourceMappingURL=abs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/abs.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/calculate-product.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/calculate-product.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst expansion_product_1 = __webpack_require__(/*! ./expansion-product */ \"./node_modules/flo-numerical/node/double-expansion/expansion-product.js\");\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst scale_expansion_1 = __webpack_require__(/*! ./scale-expansion */ \"./node_modules/flo-numerical/node/double-expansion/scale-expansion.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Return the result of multiplying together an array of floating point\r\n * expansion numbers.\r\n *\r\n * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * @param terms an array of multiplicands\r\n */\r\nfunction calculateProduct(term) {\r\n    let product = term[0];\r\n    for (let j = 1; j < term.length; j++) {\r\n        let multiplicant = term[j];\r\n        if (multiplicant.length == 1) {\r\n            if (product.length === 1) {\r\n                product = two_product_1.twoProduct(product[0], multiplicant[0]);\r\n            }\r\n            else {\r\n                product = scale_expansion_1.scaleExpansion(product, multiplicant[0]);\r\n            }\r\n        }\r\n        else if (product.length === 1) {\r\n            product = scale_expansion_1.scaleExpansion(multiplicant, product[0]);\r\n        }\r\n        else {\r\n            product = expansion_product_1.expansionProduct(multiplicant, product);\r\n        }\r\n    }\r\n    return compress_1.compress(product);\r\n}\r\nexports.calculateProduct = calculateProduct;\r\n//# sourceMappingURL=calculate-product.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/calculate-product.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/calculate-sum.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/calculate-sum.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/double-expansion/two-sum.js\");\r\nconst grow_expansion_1 = __webpack_require__(/*! ./grow-expansion */ \"./node_modules/flo-numerical/node/double-expansion/grow-expansion.js\");\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js\");\r\n/**\r\n * Returns the result of summing an array of floating point expansions.\r\n *\r\n * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * @param terms An array of numbers to be summed; A term is represented by a\r\n * floating point expansion.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it's really worth it I am not sure.\r\nfunction calculateSum(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        let term = terms[i];\r\n        // add\r\n        if (term.length === 1) {\r\n            if (total.length === 1) {\r\n                total = two_sum_1.twoSum(total[0], term[0]);\r\n            }\r\n            else {\r\n                total = grow_expansion_1.growExpansion(total, term[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = grow_expansion_1.growExpansion(term, total[0]);\r\n            }\r\n            else {\r\n                total = fast_expansion_sum_1.fastExpansionSum(total, term);\r\n            }\r\n        }\r\n    }\r\n    return total;\r\n}\r\nexports.calculateSum = calculateSum;\r\n//# sourceMappingURL=calculate-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/calculate-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/calculate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/calculate.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst expansion_product_1 = __webpack_require__(/*! ./expansion-product */ \"./node_modules/flo-numerical/node/double-expansion/expansion-product.js\");\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst scale_expansion_1 = __webpack_require__(/*! ./scale-expansion */ \"./node_modules/flo-numerical/node/double-expansion/scale-expansion.js\");\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/double-expansion/two-sum.js\");\r\nconst grow_expansion_1 = __webpack_require__(/*! ./grow-expansion */ \"./node_modules/flo-numerical/node/double-expansion/grow-expansion.js\");\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Return the result of summing an array of terms, each term being an array of\r\n * floating point expansions to be multiplied together.\r\n *\r\n * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * @param terms An array of terms to be summed; A term consists of an\r\n * array of floating point expansions to be multiplied together.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it's really worth it I am not sure.\r\nfunction calculate(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        let term = terms[i];\r\n        let product = term[0];\r\n        for (let j = 1; j < term.length; j++) {\r\n            let multiplicant = term[j];\r\n            if (multiplicant.length == 1) {\r\n                if (product.length === 1) {\r\n                    product = two_product_1.twoProduct(product[0], multiplicant[0]);\r\n                }\r\n                else {\r\n                    product = scale_expansion_1.scaleExpansion(product, multiplicant[0]);\r\n                }\r\n            }\r\n            else if (product.length === 1) {\r\n                product = scale_expansion_1.scaleExpansion(multiplicant, product[0]);\r\n            }\r\n            else {\r\n                product = expansion_product_1.expansionProduct(multiplicant, product);\r\n            }\r\n        }\r\n        // add\r\n        if (product.length === 1) {\r\n            if (total.length === 1) {\r\n                total = two_sum_1.twoSum(total[0], product[0]);\r\n            }\r\n            else {\r\n                total = grow_expansion_1.growExpansion(total, product[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = grow_expansion_1.growExpansion(product, total[0]);\r\n            }\r\n            else {\r\n                total = fast_expansion_sum_1.fastExpansionSum(total, product);\r\n            }\r\n        }\r\n    }\r\n    return compress_1.compress(total);\r\n}\r\nexports.calculate = calculate;\r\n//# sourceMappingURL=calculate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/calculate.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/compare.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/compare.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst expansion_diff_1 = __webpack_require__(/*! ./expansion-diff */ \"./node_modules/flo-numerical/node/double-expansion/expansion-diff.js\");\r\nconst sign_1 = __webpack_require__(/*! ./sign */ \"./node_modules/flo-numerical/node/double-expansion/sign.js\");\r\n/**\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n *\r\n * \"The easiest way to compare two expansions is to subtract one from the other,\r\n * and test the sign of the result. An expansion’s sign can be easily tested\r\n * because of the nonoverlapping property; simply check the sign of the\r\n * expansion's most significant nonzero component...\"\r\n */\r\nfunction compare(a, b) {\r\n    return sign_1.sign(expansion_diff_1.expansionDiff(a, b));\r\n}\r\nexports.compare = compare;\r\n//# sourceMappingURL=compare.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/compare.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/compress.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/compress.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Theorem 23 (Shewchuck): Let e = sum_(i=1)^m(e_i) be a nonoverlapping\r\n * expansion of m p-bit components, where m >= 3. Suppose that the components of\r\n * e are sorted in order of increasing magnitude, except that any of the e_i may\r\n * be zero. Then the following algorithm will produce a nonoverlapping expansion\r\n * (nonadjacent if round-to even tiebreaking is used) such that\r\n * h = sum_(i=1)^n(h_i) = e, where the components h_i are in order of increasing\r\n * magnitude. If h != 0, none of the h_i will be zero. Furthermore, the largest\r\n * component h_n approximates h with an error smaller than ulp(h_n).\r\n */\r\nfunction compress(e) {\r\n    let e_ = e.slice();\r\n    let m = e_.length;\r\n    if (e_.length === 1) {\r\n        return e_;\r\n    }\r\n    let Q = e_[e_.length - 1];\r\n    let bottom = m;\r\n    for (let i = m - 2; i >= 0; --i) {\r\n        let a = Q;\r\n        let b = e_[i];\r\n        Q = a + b;\r\n        let bv = Q - a;\r\n        let q = b - bv;\r\n        if (q) {\r\n            e_[--bottom] = Q;\r\n            Q = q;\r\n        }\r\n    }\r\n    let top = 0;\r\n    for (let i = bottom; i < m; ++i) {\r\n        let a = e_[i];\r\n        let b = Q;\r\n        Q = a + b;\r\n        let bv = Q - a;\r\n        let q = b - bv;\r\n        if (q) {\r\n            e_[top++] = q;\r\n        }\r\n    }\r\n    e_[top++] = Q;\r\n    e_.length = top;\r\n    if (e_.length === 0) {\r\n        return [0];\r\n    }\r\n    return e_;\r\n}\r\nexports.compress = compress;\r\n//# sourceMappingURL=compress.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/compress.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/e-div-by-2.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/e-div-by-2.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Divide a floating point expansion by 2.\r\n * * **error free**\r\n * @param e\r\n */\r\nfunction eDivBy2(e) {\r\n    let e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(0.5 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\nexports.eDivBy2 = eDivBy2;\r\n//# sourceMappingURL=e-div-by-2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/e-div-by-2.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/e-mult-by-2.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/e-mult-by-2.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Multiply a floating point expansion by 2.\r\n * * **error free**\r\n * @param param0\r\n */\r\nfunction eMultBy2(e) {\r\n    let e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(2 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\nexports.eMultBy2 = eMultBy2;\r\n//# sourceMappingURL=e-mult-by-2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/e-mult-by-2.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/e-mult-by-neg-2.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/e-mult-by-neg-2.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Multiply a floating point expansion by -2.\r\n * * **error free**\r\n * @param param0\r\n */\r\nfunction eMultByNeg2(e) {\r\n    let e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(-2 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\nexports.eMultByNeg2 = eMultByNeg2;\r\n//# sourceMappingURL=e-mult-by-neg-2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/e-mult-by-neg-2.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/e-sqrt.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/e-sqrt.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_square_1 = __webpack_require__(/*! ./two-square */ \"./node_modules/flo-numerical/node/double-expansion/two-square.js\");\r\n//import { eDivBy2 } from \"./e-div-by-2\";\r\n//import { twoProduct } from \"./two-product\";\r\n//import { qDiffQuad } from \"../quad-precision/q-diff-quad\";\r\n//import { qMultDouble1 } from \"../quad-precision/q-mult-double\";\r\n//import { qDivQuad } from \"../quad-precision/q-div-quad\";\r\n//import { expansionProduct } from \"./expansion-product\";\r\n//import { compress } from \"./compress\";\r\n//import { expansionDiff } from \"./expansion-diff\";\r\n//import { growExpansion } from \"./grow-expansion\";\r\n//import { negativeOf } from \"./negative-of\";\r\n//import { qMultDouble2 } from \"..\";\r\n//import { qNegativeOf } from \"../quad-precision/q-negative-of\";\r\nconst sqrt = Math.sqrt;\r\n// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts\r\n// Unfortunately no error bound given\r\n/**\r\n * Returns the square root of a **double-double** as a **double-double**.\r\n * * **no error bound is returned**\r\n */\r\nfunction qSqrt([xl, xh]) {\r\n    let s = sqrt(xh);\r\n    let [tl, th] = two_square_1.twoSquare(s);\r\n    let e = (xh - th - tl + xl) * 0.5 / s;\r\n    xh = s + e;\r\n    xl = e - (xh - s);\r\n    return [xl, xh];\r\n}\r\nexports.qSqrt = qSqrt;\r\n//export { dSqrt2 }\r\n//# sourceMappingURL=e-sqrt.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/e-sqrt.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/estimate.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/estimate.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of the given floating point expansion rounded to a double\r\n * floating point number.\r\n *\r\n * The result is within 1 ulps of the actual value, e.g. imagine the worst case\r\n * situation where we add (in 4dot4) 1111.1000 + 0.000011111111... The result\r\n * will be 1111.1000 whereas as the correct result should be 1111.1001 and we\r\n * thus lost 1 ulp of accuracy. It does not matter that the expansion contain\r\n * several floats since none is overlapping.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n */\r\nfunction estimate(e) {\r\n    let Q = e[0];\r\n    for (let i = 1; i < e.length; i++) {\r\n        Q += e[i];\r\n    }\r\n    return Q;\r\n}\r\nexports.estimate = estimate;\r\n//# sourceMappingURL=estimate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/estimate.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/expansion-diff.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/expansion-diff.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js\");\r\nconst negative_of_1 = __webpack_require__(/*! ./negative-of */ \"./node_modules/flo-numerical/node/double-expansion/negative-of.js\");\r\n/**\r\n * Returns the difference between two floating point expansions, i.e. e - f.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param f Another floating point expansion\r\n */\r\nfunction expansionDiff(e, f) {\r\n    let g = negative_of_1.negativeOf(f);\r\n    return fast_expansion_sum_1.fastExpansionSum(e, g);\r\n}\r\nexports.expansionDiff = expansionDiff;\r\n//# sourceMappingURL=expansion-diff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/expansion-diff.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/expansion-div.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/expansion-div.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst estimate_1 = __webpack_require__(/*! ./estimate */ \"./node_modules/flo-numerical/node/double-expansion/estimate.js\");\r\nconst __1 = __webpack_require__(/*! .. */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst expansion_diff_1 = __webpack_require__(/*! ./expansion-diff */ \"./node_modules/flo-numerical/node/double-expansion/expansion-diff.js\");\r\nconst to_bit_length_1 = __webpack_require__(/*! ./to-bit-length */ \"./node_modules/flo-numerical/node/double-expansion/to-bit-length.js\");\r\n//import { compare } from \"./compare\";\r\nconst bit_length_1 = __webpack_require__(/*! ../double-representation/bit-length */ \"./node_modules/flo-numerical/node/double-representation/bit-length.js\");\r\n/**\r\n * Returns the result of a/b using Goldschmidt division.\r\n *\r\n * The result will only be exact if b|a, i.e. if b divides a, else the result\r\n * will be rounded to the longest bitlength between a and b.\r\n * @param a the numerator\r\n * @param b the denominator\r\n * @param expansionLength the bitlength/53 of the final result, e.g. 1 means\r\n * standard double precision, 2 means quad, etc up to a max of about 20 at\r\n * which point underflow cease precision improvement. If the division is known\r\n * to be exact beforehand (such as in the pseudo remainder sequence algorithm)\r\n * then set expansionLength === 0 and an exact division will be done.\r\n */\r\n// TODO - test this function properly or replace with a better one\r\nfunction expansionDiv(N, D, expansionLength) {\r\n    let D_ = D;\r\n    let N_ = N;\r\n    let exact = false;\r\n    let resultBitlengthUpperBound = 0;\r\n    if (!expansionLength) {\r\n        // TODO\r\n        //let expN = exponent(N_[N_.length-1]) - exponent(N_[0]) + 53;\r\n        //let expD = exponent(D_[D_.length-1]) - exponent(D_[0]) + 53;\r\n        //expansionLength = Math.max(N.length, D.length);\r\n        //console.log(exponent(N[0]));\r\n        //expansionLength = Math.max(expN, expD) / 53;\r\n        //console.log(expansionLength);\r\n        let bitlengthN = bit_length_1.expBitLength(N_);\r\n        let bitlengthD = bit_length_1.expBitLength(D_);\r\n        resultBitlengthUpperBound = bitlengthN - bitlengthD + 1;\r\n        //let resultBitlengthLowerBound = resultBitlengthUpperBound - 1; // <= true\r\n        expansionLength = (resultBitlengthUpperBound / 53) + 1;\r\n        //console.log('expansionLength', expansionLength);\r\n        //console.log('bitlengthN', bitlengthN);\r\n        //console.log('bitlengthD', bitlengthD);\r\n        //console.log('resultBitlengthUpperBound', resultBitlengthUpperBound)\r\n        exact = true;\r\n    }\r\n    let F = [1 / estimate_1.estimate(D_)]; // Initial guess - out by 1/2 upls\r\n    let i = 1;\r\n    //console.log('D ', estimate(D));\r\n    //console.log('F ', estimate(F));\r\n    //console.log('N ', N_);\r\n    //console.log('D ', D_);\r\n    //console.log('F ', F);\r\n    //console.log('---------');\r\n    while (true) {\r\n        N_ = __1.expansionProduct(N_, F);\r\n        //console.log('N ', N_);\r\n        // The precision bitlength doubles on each iteration\r\n        if (i > expansionLength) {\r\n            // we now have roughly double the needed precision - we actually \r\n            // only require about the precision and then round properly - this\r\n            // could be implemented in the future.\r\n            if (exact) {\r\n                // We must throw away bits known to be zero. \r\n                // Any bits > expansionLength * 53 must be thrown away as they\r\n                // are wrong - all other bits are exact.\r\n                N_ = to_bit_length_1.toBitlength(N_, resultBitlengthUpperBound);\r\n                // TODO - below is just for testing - remove later\r\n                //if (compare(expansionProduct(D, N_), N) !== 0) {\r\n                //    console.log(expansionProduct(D, N_))\r\n                //    throw new Error(`division in-exact - probably due to underflow, N: ${N}, D: ${D}, Result: ${N_}, product: ${expansionProduct(D, N_)}`); \r\n                //} \r\n                return N_;\r\n            }\r\n            // Returning only significant bits helps with sign determination later on.\r\n            return N_.slice(N_.length - expansionLength, N_.length);\r\n        }\r\n        D_ = __1.expansionProduct(D_, F);\r\n        //console.log('D ', estimate(D));\r\n        //console.log('D ', D_);\r\n        F = expansion_diff_1.expansionDiff([2], D_);\r\n        //console.log('F ', estimate(F));\r\n        //console.log('F ', F);\r\n        i *= 2;\r\n    }\r\n}\r\nexports.expansionDiv = expansionDiv;\r\n//# sourceMappingURL=expansion-div.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/expansion-div.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/expansion-product.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/expansion-product.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js\");\r\nconst scale_expansion_1 = __webpack_require__(/*! ./scale-expansion */ \"./node_modules/flo-numerical/node/double-expansion/scale-expansion.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Returns the product of two expansions.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * As per Shewchuk in the above paper: \"To find the product of two expansions\r\n * e and f, use SCALE-EXPANSION (with zero elimination) to form the expansions\r\n * ef_1, ef_2, ..., then sum these using a distillation tree.\"\r\n *\r\n * A distillation tree used with fastExpansionSum will give O(k*log k) vs O(k^2)\r\n * operations.\r\n *\r\n * Implemented naively and not as described by Shewchuk (i.e. the algorithm\r\n * takes O(k^2) operations).\r\n * @param e An expansion\r\n * @param f Another expansion\r\n */\r\nfunction expansionProduct(e, f) {\r\n    let sum = [0];\r\n    for (let i = 0; i < e.length; i++) {\r\n        sum = fast_expansion_sum_1.fastExpansionSum(sum, scale_expansion_1.scaleExpansion(f, e[i]));\r\n    }\r\n    return compress_1.compress(sum);\r\n}\r\nexports.expansionProduct = expansionProduct;\r\n//# sourceMappingURL=expansion-product.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/expansion-product.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst merge_1 = __webpack_require__(/*! ./merge */ \"./node_modules/flo-numerical/node/double-expansion/merge.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ./fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/double-expansion/two-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Returns the result of adding two expansions.\r\n *\r\n * Theorem 13: Let e = sum_(i=1)^m(e_i) and f = sum_(i=1)^n(f_i) be strongly\r\n * nonoverlapping expansions of m and n p-bit components, respectively, where\r\n * p >= 4. Suppose that the components of both e and f are sorted in order of\r\n * increasing magnitude, except that any of the e_i or f_i may be zero. On a\r\n * machine whose arithmetic uses the round-to-even rule, the following algorithm\r\n * will produce a strongly nonoverlapping expansion h such that\r\n * sum_(i=1)^(m+n)(e_i + f_i) = e + f, where the components of h are also in\r\n * order of increasing magnitude, except that any of the h_i may be zero.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastExpansionSum(e, f) {\r\n    let g = merge_1.merge(e, f);\r\n    let len = g.length;\r\n    if (len === 1) {\r\n        return g;\r\n    }\r\n    let h = new Array(len);\r\n    let q;\r\n    [h[0], q] = fast_two_sum_1.fastTwoSum(g[1], g[0]);\r\n    for (let i = 2; i < len; i++) {\r\n        [h[i - 1], q] = two_sum_1.twoSum(q, g[i]);\r\n    }\r\n    h[len - 1] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.fastExpansionSum = fastExpansionSum;\r\n//# sourceMappingURL=fast-expansion-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/fast-two-diff.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/fast-two-diff.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the difference and exact error of subtracting two floating point\r\n * numbers.\r\n * Uses an EFT (error-free transformation), i.e. a-b === x+y exactly.\r\n * The returned result is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoDiff(a, b) {\r\n    let x = a - b;\r\n    let y = (a - x) - b;\r\n    return [y, x];\r\n}\r\nexports.fastTwoDiff = fastTwoDiff;\r\n//# sourceMappingURL=fast-two-diff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/fast-two-diff.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the sum and exact error of adding two floating point numbers.\r\n * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.\r\n * The returned sum is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoSum(a, b) {\r\n    let x = a + b;\r\n    return [b - (x - a), x];\r\n}\r\nexports.fastTwoSum = fastTwoSum;\r\n//# sourceMappingURL=fast-two-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/grow-expansion.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/grow-expansion.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/double-expansion/two-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Returns the result of adding a double to an expansion.\r\n *\r\n * Let e be a nonoverlapping expansion of m p-bit components, and let b be a\r\n * p-bit value where p >= 3. Suppose that the components e_1, ..., e_m are\r\n * sorted in order of *increasing* magnitude, except that any of the ei may be\r\n * zero.\r\n * Then the following algorithm will produce a nonoverlapping expansion such\r\n * that h = sum_i(h_i) = e + b, where the components h_1, ..., h_(m+1) are also\r\n * in order of increasing magnitude, except that any of the h_i may be zero.\r\n * Furthermore, if e is nonadjacent and round-to-even tiebreaking is used, then\r\n * h is nonadjacent.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param b Another floating point expansion\r\n */\r\nfunction growExpansion(e, b) {\r\n    let m = e.length;\r\n    let q = b;\r\n    let h = new Array(m + 1);\r\n    for (let i = 0; i < m; i++) {\r\n        // Note the use of twoSum and not fastTwoSum.\r\n        [h[i], q] = two_sum_1.twoSum(q, e[i]);\r\n    }\r\n    h[m] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.growExpansion = growExpansion;\r\n//# sourceMappingURL=grow-expansion.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/grow-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/int-pow.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/int-pow.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst calculate_product_1 = __webpack_require__(/*! ./calculate-product */ \"./node_modules/flo-numerical/node/double-expansion/calculate-product.js\");\r\nconst expansion_product_1 = __webpack_require__(/*! ./expansion-product */ \"./node_modules/flo-numerical/node/double-expansion/expansion-product.js\");\r\n/**\r\n * Returns a**i, where i is a non-negative integer.\r\n * @param a a floating point expansion\r\n */\r\nfunction intPow(a, p) {\r\n    // a^0 === 1\r\n    if (p === 0) {\r\n        return [1];\r\n    }\r\n    // a^1 === a\r\n    if (p === 1) {\r\n        return a;\r\n    }\r\n    if (p === 2) {\r\n        return expansion_product_1.expansionProduct(a, a);\r\n    }\r\n    let as = [];\r\n    for (let i = 0; i < p; i++) {\r\n        as.push(a);\r\n    }\r\n    return calculate_product_1.calculateProduct(as);\r\n}\r\nexports.intPow = intPow;\r\n//# sourceMappingURL=int-pow.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/int-pow.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/is-adjacent.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/is-adjacent.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_overlapping_1 = __webpack_require__(/*! ./is-overlapping */ \"./node_modules/flo-numerical/node/double-expansion/is-overlapping.js\");\r\n/**\r\n * Returns true if x and y is adjacent, false otherwise.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param x A double floating point number\r\n * @param y Another double floating point number\r\n */\r\nfunction isAdjacent(x, y) {\r\n    return is_overlapping_1.isOverlapping(x, y) ||\r\n        is_overlapping_1.isOverlapping(x, 2 * y) ||\r\n        is_overlapping_1.isOverlapping(2 * x, y);\r\n}\r\nexports.isAdjacent = isAdjacent;\r\n//# sourceMappingURL=is-adjacent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/is-adjacent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/is-overlapping.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/is-overlapping.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ../double-representation/get-max-set-bit */ \"./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ../double-representation/exponent */ \"./node_modules/flo-numerical/node/double-representation/exponent.js\");\r\n/**\r\n * Returns true if a and b does not overlap, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Implemented for testing purposes.\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction isOverlapping(a, b) {\r\n    return !isNonOverlapping(a, b);\r\n}\r\nexports.isOverlapping = isOverlapping;\r\n/**\r\n * Returns true if a and b overlaps, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * Implemented for testing purposes.\r\n *\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction isNonOverlapping(a, b) {\r\n    if (a === 0 || b === 0) {\r\n        return true;\r\n    }\r\n    if (Math.abs(b) > Math.abs(a)) {\r\n        [a, b] = [b, a];\r\n    }\r\n    // At this point abs(a) > abs(b)\r\n    let l = get_max_set_bit_1.getLowestSetBit(a);\r\n    let h = get_max_set_bit_1.getHighestSetBit(b);\r\n    let shift = exponent_1.exponent(a) - exponent_1.exponent(b);\r\n    return (l + shift) > h;\r\n}\r\nexports.isNonOverlapping = isNonOverlapping;\r\n/**\r\n * Returns true if all components of the given expansion is non-overlapping,\r\n * false otherwise.\r\n * @param e An expansion\r\n */\r\nfunction isNonOverlappingAll(e) {\r\n    for (let i = 1; i < e.length; i++) {\r\n        if (isOverlapping(e[i - 1], e[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isNonOverlappingAll = isNonOverlappingAll;\r\n//# sourceMappingURL=is-overlapping.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/is-overlapping.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/merge.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/merge.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of merging an expansion e and f into a single expansion,\r\n * in order of nondecreasing magnitude (possibly with interspersed zeros).\r\n * (This function is zero-eliminating)\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param f Another floating point expansion\r\n */\r\nfunction merge(e, f) {\r\n    let lenE = e.length;\r\n    let lenF = f.length;\r\n    let i = 0;\r\n    let j = 0;\r\n    let merged = [];\r\n    while (i < lenE && j < lenF) {\r\n        if (e[i] === 0) {\r\n            i++;\r\n            continue;\r\n        }\r\n        if (f[j] === 0) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (Math.abs(e[i]) <= Math.abs(f[j])) {\r\n            merged.push(e[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            merged.push(f[j]);\r\n            j++;\r\n        }\r\n    }\r\n    while (i < lenE) {\r\n        merged.push(e[i]);\r\n        i++;\r\n    }\r\n    while (j < lenF) {\r\n        merged.push(f[j]);\r\n        j++;\r\n    }\r\n    if (merged.length === 0) {\r\n        return [0];\r\n    }\r\n    return merged;\r\n}\r\nexports.merge = merge;\r\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/merge.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/negative-of.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/negative-of.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the negative of the given floating point expansion.\r\n * @param e A floating point number expansion\r\n */\r\nfunction negativeOf(e) {\r\n    let m = e.length;\r\n    let h = new Array(m);\r\n    for (let i = 0; i < m; i++) {\r\n        h[i] = -e[i];\r\n    }\r\n    return h;\r\n}\r\nexports.negativeOf = negativeOf;\r\n//# sourceMappingURL=negative-of.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/negative-of.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/orient2d.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/orient2d.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst expansion_diff_1 = __webpack_require__(/*! ./expansion-diff */ \"./node_modules/flo-numerical/node/double-expansion/expansion-diff.js\");\r\nconst estimate_1 = __webpack_require__(/*! ./estimate */ \"./node_modules/flo-numerical/node/double-expansion/estimate.js\");\r\nconst two_diff_1 = __webpack_require__(/*! ./two-diff */ \"./node_modules/flo-numerical/node/double-expansion/two-diff.js\");\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./fast-expansion-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\nlet ccwerrboundA = 3.330669073875472e-16;\r\nlet ccwerrboundB = 2.220446049250315e-16;\r\nlet ccwerrboundC = 1.109335647967049e-31;\r\nlet resulterrbound = 3.330669073875471e-16;\r\n/**\r\n * Ported from (Shewchuk) http://docs.ros.org/kinetic/api/asr_approx_mvbb/html/Predicates_8cpp_source.html\r\n * See also https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * * Adaptive exact 2d orientation test.\r\n *\r\n * * Robust.\r\n *\r\n * Return a positive value if the points pa, pb, and pc occur in\r\n * counterclockwise order; a negative value if they occur in clockwise order;\r\n * and zero if they are collinear.  The result is also a rough approximation of\r\n * twice the signed area of the triangle defined by the three points.\r\n *\r\n * The result returned is the determinant of a matrix. This determinant is\r\n * computed adaptively, in the sense that exact arithmetic is used only to the\r\n * degree it is needed to ensure that the returned value has the correct sign.\r\n * Hence, orient2d() is usually quite fast, but will run more slowly when the\r\n * input points are collinear or nearly so.\r\n */\r\nfunction orient2d(A, B, C) {\r\n    let detleft = (A[0] - C[0]) * (B[1] - C[1]);\r\n    let detright = (A[1] - C[1]) * (B[0] - C[0]);\r\n    let det = detleft - detright;\r\n    let detsum;\r\n    if (detleft > 0) {\r\n        if (detright <= 0) {\r\n            // Anti-clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = detleft + detright;\r\n        }\r\n    }\r\n    else if (detleft < 0) {\r\n        if (detright >= 0) {\r\n            // Clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = -detleft - detright;\r\n        }\r\n    }\r\n    else {\r\n        // Anti-clockwise, clockwise or straight\r\n        return det;\r\n    }\r\n    if (Math.abs(det) >= ccwerrboundA * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    return orient2dAdapt(A, B, C, detsum);\r\n}\r\nexports.orient2d = orient2d;\r\nfunction orient2dAdapt(A, B, C, detsum) {\r\n    let acx = A[0] - C[0];\r\n    let bcx = B[0] - C[0];\r\n    let acy = A[1] - C[1];\r\n    let bcy = B[1] - C[1];\r\n    let b = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acx, bcy), two_product_1.twoProduct(acy, bcx));\r\n    let det = estimate_1.estimate(b);\r\n    if (Math.abs(det) >= ccwerrboundB * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    let acxtail = two_diff_1.twoDiff(A[0], C[0])[0];\r\n    let bcxtail = two_diff_1.twoDiff(B[0], C[0])[0];\r\n    let acytail = two_diff_1.twoDiff(A[1], C[1])[0];\r\n    let bcytail = two_diff_1.twoDiff(B[1], C[1])[0];\r\n    if (acxtail === 0 && acytail === 0 &&\r\n        bcxtail === 0 && bcytail === 0) {\r\n        // Straight\r\n        return det;\r\n    }\r\n    let errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\r\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\r\n    if (Math.abs(det) >= errbound) {\r\n        return det;\r\n    }\r\n    let a = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acxtail, bcy), two_product_1.twoProduct(acytail, bcx));\r\n    let c = fast_expansion_sum_1.fastExpansionSum(b, a);\r\n    let d = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acx, bcytail), two_product_1.twoProduct(acy, bcxtail));\r\n    let e = fast_expansion_sum_1.fastExpansionSum(c, d);\r\n    let f = expansion_diff_1.expansionDiff(two_product_1.twoProduct(acxtail, bcytail), two_product_1.twoProduct(acytail, bcxtail));\r\n    let D = fast_expansion_sum_1.fastExpansionSum(e, f);\r\n    D = compress_1.compress(D);\r\n    return D[D.length - 1];\r\n}\r\n//# sourceMappingURL=orient2d.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/orient2d.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/reduce-significand.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/reduce-significand.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Truncates a floating point value's significand. Similar to split, but with\r\n * the ability to specify the number of bits to keep.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a The number\r\n * @param bits The number of significand bits to leave intact.\r\n */\r\nfunction reduceSignificand(a, bits) {\r\n    let s = 53 - bits;\r\n    let f = Math.pow(2, s) + 1;\r\n    let c = f * a;\r\n    let r = c - (c - a);\r\n    return r;\r\n}\r\nexports.reduceSignificand = reduceSignificand;\r\n//# sourceMappingURL=reduce-significand.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/reduce-significand.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/scale-expansion.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/scale-expansion.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ./two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst two_sum_1 = __webpack_require__(/*! ./two-sum */ \"./node_modules/flo-numerical/node/double-expansion/two-sum.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ./fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and let b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e\r\n * @param b\r\n */\r\nfunction scaleExpansion(e, b) {\r\n    let m = e.length;\r\n    let h = new Array(2 * m);\r\n    let q;\r\n    let q_;\r\n    [h[0], q] = two_product_1.twoProduct(e[0], b);\r\n    for (let i = 1; i < m; i++) {\r\n        let [t, T] = two_product_1.twoProduct(e[i], b);\r\n        [h[2 * i - 1], q_] = two_sum_1.twoSum(q, t);\r\n        [h[2 * i], q] = fast_two_sum_1.fastTwoSum(T, q_);\r\n    }\r\n    h[2 * m - 1] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.scaleExpansion = scaleExpansion;\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and let b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e\r\n * @param b\r\n */\r\nfunction scaleExpansion2(b, e) {\r\n    let m = e.length;\r\n    let h = new Array(2 * m);\r\n    let q;\r\n    let q_;\r\n    [h[0], q] = two_product_1.twoProduct(e[0], b);\r\n    for (let i = 1; i < m; i++) {\r\n        let [t, T] = two_product_1.twoProduct(e[i], b);\r\n        [h[2 * i - 1], q_] = two_sum_1.twoSum(q, t);\r\n        [h[2 * i], q] = fast_two_sum_1.fastTwoSum(T, q_);\r\n    }\r\n    h[2 * m - 1] = q;\r\n    return compress_1.compress(h);\r\n}\r\nexports.scaleExpansion2 = scaleExpansion2;\r\n//# sourceMappingURL=scale-expansion.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/scale-expansion.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/sign.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/sign.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the sign of the given expansion. From Shewchuk: \"A nonoverlapping\r\n * expansion is desirable because it is easy to determine its sign (take the\r\n * sign of the largest component) ... \"\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion with zeroes eliminated.\r\n */\r\nfunction sign(e) {\r\n    if (e.length === 0) {\r\n        return 0;\r\n    }\r\n    //return Math.sign(e[e.length-1]);\r\n    return e[e.length - 1];\r\n}\r\nexports.sign = sign;\r\n//# sourceMappingURL=sign.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/sign.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/split.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/split.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * === Math.ceil(p/2) where p is the # of significand bits in a double === 53.\r\n */\r\nlet f = Math.pow(2, 27) + 1;\r\n/**\r\n * Returns the result of splitting a double into 2 26-bit doubles.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double floating point number\r\n */\r\nfunction split(a) {\r\n    let c = f * a;\r\n    let a_h = c - (c - a);\r\n    let a_l = a - a_h;\r\n    return [a_h, a_l];\r\n}\r\nexports.split = split;\r\n//# sourceMappingURL=split.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/split.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/to-bit-length.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/to-bit-length.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sign_1 = __webpack_require__(/*! ./sign */ \"./node_modules/flo-numerical/node/double-expansion/sign.js\");\r\nconst msb_exponent_1 = __webpack_require__(/*! ../double-representation/msb-exponent */ \"./node_modules/flo-numerical/node/double-representation/msb-exponent.js\");\r\nconst compress_1 = __webpack_require__(/*! ./compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\nconst reduce_significand_1 = __webpack_require__(/*! ./reduce-significand */ \"./node_modules/flo-numerical/node/double-expansion/reduce-significand.js\");\r\n/**\r\n * Returns a floating point expansion accurate to the given number of bits.\r\n * Extraneous bits are discarded.\r\n * @param a a floating point expansion\r\n * @param l the number of accurate bits to keep\r\n */\r\nfunction toBitlength(a, l) {\r\n    a = compress_1.compress(a);\r\n    if (sign_1.sign(a) === 0) {\r\n        return [0];\r\n    }\r\n    let maxMsb = msb_exponent_1.msbExponent(a[a.length - 1]);\r\n    let msb = maxMsb;\r\n    let i = a.length - 1; // start at most significant byte\r\n    while (i > 0) {\r\n        let msb_ = msb_exponent_1.msbExponent(a[i - 1]);\r\n        if (maxMsb - msb_ > l) {\r\n            break;\r\n        }\r\n        msb = msb_;\r\n        i--;\r\n    }\r\n    let keepBits = Math.min(l - (maxMsb - msb), 53);\r\n    let b = a[i];\r\n    b = reduce_significand_1.reduceSignificand(b, keepBits);\r\n    let result = a.slice(i);\r\n    result[0] = b;\r\n    return result;\r\n}\r\nexports.toBitlength = toBitlength;\r\n//# sourceMappingURL=to-bit-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/to-bit-length.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/two-diff.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/two-diff.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the exact result of subtracting b from a (as a floating point\r\n * expansion).\r\n * @param a\r\n * @param b\r\n */\r\nfunction twoDiff(a, b) {\r\n    let x = a - b;\r\n    let bvirt = a - x;\r\n    let y = (a - (x + bvirt)) + (bvirt - b);\r\n    return [y, x];\r\n}\r\nexports.twoDiff = twoDiff;\r\n//# sourceMappingURL=two-diff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/two-diff.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/two-product.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/two-product.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nlet f = Math.pow(2, 27) + 1;\r\n/**\r\n * Returns the exact result of multiplying two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction twoProduct(a, b) {\r\n    let x = a * b;\r\n    //let [ah, al] = split(a);\r\n    let c = f * a;\r\n    let ah = c - (c - a);\r\n    let al = a - ah;\r\n    //let [bh, bl] = split(b);\r\n    let d = f * b;\r\n    let bh = d - (d - b);\r\n    let bl = b - bh;\r\n    let y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //let err1 = x - (ah * bh);\r\n    //let err2 = err1 - (al * bh);\r\n    //let err3 = err2 - (ah * bl);\r\n    //let y = (al * bl) - err3;\r\n    return [y, x];\r\n}\r\nexports.twoProduct = twoProduct;\r\n//# sourceMappingURL=two-product.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/two-product.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/two-square.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/two-square.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nlet f = Math.pow(2, 27) + 1;\r\n/**\r\n * Returns the exact result of squaring a double.\r\n *\r\n * * the resulting expansion is least significant double first.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n */\r\nfunction twoSquare(a) {\r\n    let x = a * a;\r\n    //let [ah, al] = split(a);\r\n    let c = f * a;\r\n    let ah = c - (c - a);\r\n    let al = a - ah;\r\n    let y = (al * al) - ((x - (ah * ah)) - 2 * (ah * al));\r\n    return [y, x];\r\n}\r\nexports.twoSquare = twoSquare;\r\n//# sourceMappingURL=two-square.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/two-square.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/two-sum.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/two-sum.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the exact result of adding two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the\r\n * following algorithm will produce a nonoverlapping expansion x + y such that\r\n * a + b = x + y, where x is an approximation to a + b and y is the roundoff\r\n * error in the calculation of x.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction twoSum(a, b) {\r\n    let x = a + b;\r\n    let bv = x - a;\r\n    return [(a - (x - bv)) + (b - bv), x];\r\n}\r\nexports.twoSum = twoSum;\r\n//# sourceMappingURL=two-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/two-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-expansion/within.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-expansion/within.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if the second given value is within the first value by the given\r\n * number of ulps, false otherwise\r\n */\r\nfunction within(exactValue, estimate, ulps) {\r\n    // if exactValue === 0 the relative error is undefined, i.e. the condition\r\n    // number is infinite.\r\n    if (exactValue === 0) {\r\n        return estimate === 0;\r\n    }\r\n    // if the estimate is 0 the number of ulps can never be reached\r\n    if (estimate === 0) {\r\n        return false;\r\n    }\r\n    let c = exactValue - estimate;\r\n    return Math.abs(c / exactValue) <= ulps * Number.EPSILON;\r\n}\r\nexports.within = within;\r\n//# sourceMappingURL=within.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-expansion/within.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-float-with-err/div-with-err.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-float-with-err/div-with-err.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst abs = Math.abs;\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns the result of dividing two double floating point numbers\r\n * together with an absolute error bound where nE and dE are absolute error\r\n * bounds on the input values.\r\n * @param n numerator\r\n * @param d denominator\r\n * @param nE absolute value error bound in numerator\r\n * @param dE absolute value error bound in denominator\r\n */\r\nfunction divWithErr(n, d, nE, dE) {\r\n    // estimate the result of the division\r\n    let est = n / d;\r\n    let _n = abs(n);\r\n    let _d = abs(d);\r\n    // if the error in the denominator is too high the error can be \r\n    // arbitrarily high\r\n    let minD = _d - dE;\r\n    // maxErr is only valid if minD > 0\r\n    if (minD <= 0) {\r\n        // the error can be arbitrarily high; est is mostly irrelevant\r\n        return { est, err: Number.POSITIVE_INFINITY };\r\n    }\r\n    let err = ((_d * nE + _n * dE) / Math.pow(minD, 2)) + u * abs(_n / _d);\r\n    return { est, err };\r\n}\r\nexports.divWithErr = divWithErr;\r\n//# sourceMappingURL=div-with-err.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-float-with-err/div-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-float-with-err/sqrt-with-err.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-float-with-err/sqrt-with-err.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst abs = Math.abs;\r\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\nconst sqrt = Math.sqrt;\r\nconst min = Math.min;\r\nconst max = Math.max;\r\n/**\r\n * Returns the result of the square root of a double floating point number\r\n * together with an absolute error bound where x_ is an absolute error\r\n * bound on the input value.\r\n * * see also \"A Reduced Product of Absolute and Relative Error Bounds for Floating-point Analysis\"\r\n * by Maxime Jacquemin, Sylvie Putot, and Franck Vedrine\r\n * @param x numerator\r\n * @param x_ absolute value error bound in numerator\r\n */\r\nfunction sqrtWithErr(x, x_) {\r\n    // Note: it is assumed x + x_ >= 0, else the error in x_ was wrong in the\r\n    // first place (since we can't have a negative input to the square root)\r\n    // estimate the result of the square root\r\n    if (x - x_ <= 0) {\r\n        let est = x > 0 ? sqrt(x) : 0;\r\n        return {\r\n            est,\r\n            err: max(sqrt(x + x_) - est, est)\r\n        };\r\n    }\r\n    let est = sqrt(x);\r\n    let minSqrt = sqrt(x - x_);\r\n    let maxSqrt = sqrt(x + x_);\r\n    let err = max(abs(minSqrt - est), abs(maxSqrt - est));\r\n    //err += eps*abs(est + err);\r\n    //err = eps*abs(est + err);\r\n    // approx relative input error\r\n    //let rel = x_/abs(x);\r\n    // propogated error bound\r\n    //let err = est*(sqrt(1 + rel) - 1) + u*abs(est);\r\n    return { est, err };\r\n}\r\nexports.sqrtWithErr = sqrtWithErr;\r\n//# sourceMappingURL=sqrt-with-err.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-float-with-err/sqrt-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/binary-string-to-double.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/binary-string-to-double.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst octets_to_double_1 = __webpack_require__(/*! ./octets-to-double */ \"./node_modules/flo-numerical/node/double-representation/octets-to-double.js\");\r\n/**\r\n * @param str\r\n */\r\nfunction binaryStringToDouble(str) {\r\n    return octets_to_double_1.octetsToDouble(str.match(/.{8}/g).map(binaryStringToInt));\r\n}\r\nexports.binaryStringToDouble = binaryStringToDouble;\r\n/**\r\n * e.g. \"10001000\" -> 136\r\n */\r\nfunction binaryStringToInt(b) {\r\n    return parseInt(b, 2);\r\n}\r\n//# sourceMappingURL=binary-string-to-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/binary-string-to-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/bit-length.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/bit-length.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js\");\r\nconst compress_1 = __webpack_require__(/*! ../double-expansion/compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/double-representation/exponent.js\");\r\nconst sign_1 = __webpack_require__(/*! ../double-expansion/sign */ \"./node_modules/flo-numerical/node/double-expansion/sign.js\");\r\n/**\r\n * Returns the bit-length of the significand of the given number in such a way\r\n * that trailing zeros are not counted.\r\n * @param a A double precision floating point number\r\n */\r\nfunction bitLength(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return get_max_set_bit_1.getHighestSetBit(a) - get_max_set_bit_1.getLowestSetBit(a) + 1;\r\n}\r\nexports.bitLength = bitLength;\r\n/**\r\n * Returns the bit-length of the significand of the given floating point\r\n * expansion in such a way that trailing zeros are not counted.\r\n * * precondition: subnormals not currently supported\r\n * @param a A double precision floating point expansion\r\n */\r\nfunction expBitLength(a) {\r\n    let a_ = compress_1.compress(a);\r\n    if (sign_1.sign(a_) === 0) {\r\n        return 0;\r\n    }\r\n    let msbyte = a_[a_.length - 1];\r\n    let lsbyte = a_[0];\r\n    return exponent_1.exponent(msbyte) - exponent_1.exponent(lsbyte) + (53 - get_max_set_bit_1.getLowestSetBit(lsbyte));\r\n}\r\nexports.expBitLength = expBitLength;\r\n//# sourceMappingURL=bit-length.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/bit-length.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/double-to-binary-string.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/double-to-binary-string.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst double_to_octets_1 = __webpack_require__(/*! ./double-to-octets */ \"./node_modules/flo-numerical/node/double-representation/double-to-octets.js\");\r\nfunction doubleToBinaryString(number) {\r\n    return octetsToBinaryString(double_to_octets_1.doubleToOctets(number));\r\n}\r\nexports.doubleToBinaryString = doubleToBinaryString;\r\n/**\r\n * @param octets The 8 bytes composing a double (msb first)\r\n */\r\nfunction octetsToBinaryString(octets) {\r\n    return octets\r\n        .map(int8ToBinaryString)\r\n        .join('');\r\n}\r\n/**\r\n * intToBinaryString(8) -> \"00001000\"\r\n */\r\nfunction int8ToBinaryString(i) {\r\n    let iStr = i.toString(2);\r\n    for (; iStr.length < 8; iStr = \"0\" + iStr)\r\n        ;\r\n    return iStr;\r\n}\r\n//# sourceMappingURL=double-to-binary-string.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/double-to-binary-string.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/double-to-octets.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/double-to-octets.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the ieee-574 8 bytes composing the given double, starting from the\r\n * sign bit and ending in the lsb of the significand.\r\n * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]\r\n */\r\nfunction doubleToOctets(number) {\r\n    var buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setFloat64(0, number, false);\r\n    return Array.from(new Uint8Array(buffer));\r\n}\r\nexports.doubleToOctets = doubleToOctets;\r\n//# sourceMappingURL=double-to-octets.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/double-to-octets.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/exponent.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/exponent.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_double_1 = __webpack_require__(/*! ./parse-double */ \"./node_modules/flo-numerical/node/double-representation/parse-double.js\");\r\n/**\r\n * Returns the normalized exponent of the given number.\r\n * @param a A double\r\n */\r\nfunction exponent(a) {\r\n    return parse_double_1.parseDouble(a).exponent;\r\n}\r\nexports.exponent = exponent;\r\n//# sourceMappingURL=exponent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/exponent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst significand_1 = __webpack_require__(/*! ./significand */ \"./node_modules/flo-numerical/node/double-representation/significand.js\");\r\n/**\r\n * Returns the lowest set bit of the given value in [1, (2**31)-1],\r\n * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns\r\n * NaN, otherwise if the number is out of range returns a non-finite\r\n * number.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit_(a) {\r\n    return Math.log2(a & -a);\r\n}\r\n/**\r\n * Returns the lowest set bit of the given number's significand (where the lsb\r\n * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or\r\n * NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // Note: the significand includes the hidden bit!\r\n    let s = significand_1.significand(a);\r\n    let len = s.length;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === 0) {\r\n            continue;\r\n        }\r\n        let l = getLowestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\nexports.getLowestSetBit = getLowestSetBit;\r\n/**\r\n * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up\r\n * to 255. If the input number === 0 returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit_(a) {\r\n    return a >= 128 ? 7\r\n        : a >= 64 ? 6\r\n            : a >= 32 ? 5\r\n                : a >= 16 ? 4\r\n                    : a >= 8 ? 3\r\n                        : a >= 4 ? 2\r\n                            : a >= 2 ? 1\r\n                                : a >= 1 ? 0\r\n                                    : NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given double. If no bit is set (input\r\n * === 0 or +/-inf or NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // At this point there must be a highest set bit (always === 52 if the \r\n    // number is not a subnormal.\r\n    let s = significand_1.significand(a);\r\n    let len = s.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let l = getHighestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\nexports.getHighestSetBit = getHighestSetBit;\r\n//# sourceMappingURL=get-max-set-bit.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/is-bit-aligned.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/is-bit-aligned.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/double-representation/exponent.js\");\r\n/**\r\n * Returns true if the given number is bit-aligned in the sense that its a\r\n * multiple of a given power of 2, say e, and such that the number, say a,\r\n * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.\r\n * This essentially means the numbers act somewhat like fixed-point numbers\r\n * which can drastically speed up some geometric algorithms and also reduce\r\n * their complexity.\r\n *\r\n * Visually:\r\n * These numbers (a,b and c) are grid aligned with e === 3 and max\r\n * bitlength === 6:\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|000\r\n *   c -> 00|110111|000\r\n * These are not\r\n *   a -> 01|101100|000\r\n *   b -> 00|000100|000\r\n * These are not\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|100\r\n * These are not\r\n *   a -> 00|101100|100\r\n *   b -> 00|000100|100\r\n * @param as An array of numbers to check\r\n * @param maxBitLength The max allowed bitlength\r\n * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent\r\n */\r\nfunction isBitAligned(a, maxBitLength, gridSpacingExponent) {\r\n    if (a === 0) {\r\n        return true;\r\n    }\r\n    let e = exponent_1.exponent(a);\r\n    let maxSetBit = get_max_set_bit_1.getHighestSetBit(a) - 52 + e;\r\n    let minSetBit = get_max_set_bit_1.getLowestSetBit(a) - 52 + e;\r\n    let minBitBigEnough = minSetBit >= gridSpacingExponent;\r\n    let maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;\r\n    return minBitBigEnough && maxBitSmallEnough;\r\n}\r\nexports.isBitAligned = isBitAligned;\r\n//# sourceMappingURL=is-bit-aligned.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/is-bit-aligned.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/is-valid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/is-valid.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is_adjacent_1 = __webpack_require__(/*! ../double-expansion/is-adjacent */ \"./node_modules/flo-numerical/node/double-expansion/is-adjacent.js\");\r\n/**\r\n * Returns true if the given floating point expansion is non-adjacent and\r\n * components of the expansion are ordered in ascending order by absolute value,\r\n * except that some components may be zero.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf for the\r\n * definition of adjacency.\r\n * Implemented for testing purposes.\r\n * @param x A floating point expansion.\r\n */\r\nfunction isValid(x) {\r\n    for (let i = 1; i < x.length; i++) {\r\n        if (x[i] !== 0 && x[i - 1] !== 0 &&\r\n            Math.abs(x[i - 1]) >= Math.abs(x[i])) {\r\n            //console.log('Not in ascending order.');\r\n            return false;\r\n        }\r\n        if (is_adjacent_1.isAdjacent(x[i - 1], x[i])) {\r\n            //console.log('The expansion has adjacent components.');\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isValid = isValid;\r\n//# sourceMappingURL=is-valid.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/is-valid.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/lsb-exponent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/lsb-exponent.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/double-representation/exponent.js\");\r\n/**\r\n * Returns the true exponent of the lsb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction lsbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = exponent_1.exponent(a);\r\n    return get_max_set_bit_1.getLowestSetBit(a) - 52 + e;\r\n}\r\nexports.lsbExponent = lsbExponent;\r\n//# sourceMappingURL=lsb-exponent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/lsb-exponent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/msb-exponent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/msb-exponent.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./get-max-set-bit */ \"./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js\");\r\nconst exponent_1 = __webpack_require__(/*! ./exponent */ \"./node_modules/flo-numerical/node/double-representation/exponent.js\");\r\n/**\r\n * Returns the true exponent of the msb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction msbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = exponent_1.exponent(a);\r\n    // Will return e for all but subnormal numbers\r\n    return get_max_set_bit_1.getHighestSetBit(a) - 52 + e;\r\n}\r\nexports.msbExponent = msbExponent;\r\n//# sourceMappingURL=msb-exponent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/msb-exponent.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/octets-to-double.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/octets-to-double.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * [64, 94, 221, 47, 26, 159, 190, 119] -> 123.456\r\n */\r\nfunction octetsToDouble(octets) {\r\n    var buffer = new ArrayBuffer(8);\r\n    new Uint8Array(buffer).set(octets);\r\n    return new DataView(buffer).getFloat64(0, false);\r\n}\r\nexports.octetsToDouble = octetsToDouble;\r\n//# sourceMappingURL=octets-to-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/octets-to-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/parse-double.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/parse-double.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst double_to_binary_string_1 = __webpack_require__(/*! ./double-to-binary-string */ \"./node_modules/flo-numerical/node/double-representation/double-to-binary-string.js\");\r\nconst double_to_octets_1 = __webpack_require__(/*! ./double-to-octets */ \"./node_modules/flo-numerical/node/double-representation/double-to-octets.js\");\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double. The returned\r\n * exponent has been normalized (i.e. 1023 ha been subtracted) and the\r\n * significand has the hidden bit added if appropriate.\r\n * See https://github.com/bartaz/ieee754-visualization\r\n */\r\nfunction parseDouble(x) {\r\n    let parts = double_to_octets_1.doubleToOctets(x);\r\n    let p0 = parts[0];\r\n    let p1 = parts[1];\r\n    let sign = p0 >> 7;\r\n    let exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);\r\n    //---- Check for negative / positive zero / denormalized numbers.\r\n    let hiddenMsb = exponent_ === 0 ? 0 : 16;\r\n    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).\r\n    let exponent = exponent_ === 0\r\n        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)\r\n        : exponent_ - 1023;\r\n    //---- Break up the significand into bytes\r\n    let significand = parts.slice(1);\r\n    significand[0] = (p1 & 15) + hiddenMsb;\r\n    return {\r\n        sign,\r\n        exponent,\r\n        significand\r\n    };\r\n}\r\nexports.parseDouble = parseDouble;\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double.\r\n * See https://github.com/bartaz/ieee754-visualization.\r\n * This is a slower version of parseDouble that gives binary string\r\n * representations of the components.\r\n */\r\nfunction parseDoubleDetailed(x) {\r\n    let str = double_to_binary_string_1.doubleToBinaryString(x);\r\n    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)\r\n    let [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);\r\n    let exponent_ = parseInt(exponent, 2);\r\n    let hidden = exponent_ === 0 ? \"0\" : \"1\";\r\n    return {\r\n        full: sign + exponent + hidden + significand,\r\n        sign,\r\n        exponent,\r\n        hidden,\r\n        significand\r\n    };\r\n}\r\nexports.parseDoubleDetailed = parseDoubleDetailed;\r\n//# sourceMappingURL=parse-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/parse-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/double-representation/significand.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/double-representation/significand.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst parse_double_1 = __webpack_require__(/*! ./parse-double */ \"./node_modules/flo-numerical/node/double-representation/parse-double.js\");\r\n/**\r\n * Return the significand of the given double with the hidden bit added (in case\r\n * a is not subnormal or 0, etc.)\r\n * @param a A double\r\n */\r\nfunction significand(a) {\r\n    return parse_double_1.parseDouble(a).significand;\r\n}\r\nexports.significand = significand;\r\n//# sourceMappingURL=significand.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/double-representation/significand.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/index.js":
/*!**************************************************!*\
  !*** ./node_modules/flo-numerical/node/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_min_1 = __webpack_require__(/*! ./quad-precision/q-min */ \"./node_modules/flo-numerical/node/quad-precision/q-min.js\");\r\nexports.qMin = q_min_1.qMin;\r\nconst q_max_1 = __webpack_require__(/*! ./quad-precision/q-max */ \"./node_modules/flo-numerical/node/quad-precision/q-max.js\");\r\nexports.qMax = q_max_1.qMax;\r\nconst e_sqrt_1 = __webpack_require__(/*! ./double-expansion/e-sqrt */ \"./node_modules/flo-numerical/node/double-expansion/e-sqrt.js\");\r\nexports.qSqrt = e_sqrt_1.qSqrt;\r\n//import { dSqrt2 } from './double-expansion/e-sqrt';\r\nconst sqrt_with_err_1 = __webpack_require__(/*! ./double-float-with-err/sqrt-with-err */ \"./node_modules/flo-numerical/node/double-float-with-err/sqrt-with-err.js\");\r\nexports.sqrtWithErr = sqrt_with_err_1.sqrtWithErr;\r\nconst q_abs_1 = __webpack_require__(/*! ./quad-precision/q-abs */ \"./node_modules/flo-numerical/node/quad-precision/q-abs.js\");\r\nexports.qAbs = q_abs_1.qAbs;\r\nconst q_add_double_1 = __webpack_require__(/*! ./quad-precision/q-add-double */ \"./node_modules/flo-numerical/node/quad-precision/q-add-double.js\");\r\nexports.qAddDouble = q_add_double_1.qAddDouble;\r\nconst q_add_quad_1 = __webpack_require__(/*! ./quad-precision/q-add-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-add-quad.js\");\r\nexports.qAddQuad = q_add_quad_1.qAddQuad;\r\nconst q_product_1 = __webpack_require__(/*! ./quad-precision/q-product */ \"./node_modules/flo-numerical/node/quad-precision/q-product.js\");\r\nexports.qProduct = q_product_1.qProduct;\r\nconst q_sum_1 = __webpack_require__(/*! ./quad-precision/q-sum */ \"./node_modules/flo-numerical/node/quad-precision/q-sum.js\");\r\nexports.qSum = q_sum_1.qSum;\r\nconst q_compare_1 = __webpack_require__(/*! ./quad-precision/q-compare */ \"./node_modules/flo-numerical/node/quad-precision/q-compare.js\");\r\nexports.qCompare = q_compare_1.qCompare;\r\nconst q_diff_quad_1 = __webpack_require__(/*! ./quad-precision/q-diff-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js\");\r\nexports.qDiffQuad = q_diff_quad_1.qDiffQuad;\r\nconst q_mult_double_1 = __webpack_require__(/*! ./quad-precision/q-mult-double */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-double.js\");\r\nexports.qMultDouble1 = q_mult_double_1.qMultDouble1;\r\nexports.qMultDouble2 = q_mult_double_1.qMultDouble2;\r\nconst q_mult_by_2_1 = __webpack_require__(/*! ./quad-precision/q-mult-by-2 */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-by-2.js\");\r\nexports.qMultBy2 = q_mult_by_2_1.qMultBy2;\r\nconst q_mult_by_4_1 = __webpack_require__(/*! ./quad-precision/q-mult-by-4 */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-by-4.js\");\r\nexports.qMultBy4 = q_mult_by_4_1.qMultBy4;\r\nconst q_div_by_2_1 = __webpack_require__(/*! ./quad-precision/q-div-by-2 */ \"./node_modules/flo-numerical/node/quad-precision/q-div-by-2.js\");\r\nexports.qDivBy2 = q_div_by_2_1.qDivBy2;\r\nconst q_mult_by_neg_2_1 = __webpack_require__(/*! ./quad-precision/q-mult-by-neg-2 */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-2.js\");\r\nexports.qMultByNeg2 = q_mult_by_neg_2_1.qMultByNeg2;\r\nconst q_mult_by_neg_4_1 = __webpack_require__(/*! ./quad-precision/q-mult-by-neg-4 */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-4.js\");\r\nexports.qMultByNeg4 = q_mult_by_neg_4_1.qMultByNeg4;\r\nconst q_mult_quad_1 = __webpack_require__(/*! ./quad-precision/q-mult-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-quad.js\");\r\nexports.qMultQuad = q_mult_quad_1.qMultQuad;\r\nconst q_div_double_1 = __webpack_require__(/*! ./quad-precision/q-div-double */ \"./node_modules/flo-numerical/node/quad-precision/q-div-double.js\");\r\nexports.qDivDouble = q_div_double_1.qDivDouble;\r\nconst q_div_quad_1 = __webpack_require__(/*! ./quad-precision/q-div-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-div-quad.js\");\r\nexports.qDivQuad = q_div_quad_1.qDivQuad;\r\nconst q_negative_of_1 = __webpack_require__(/*! ./quad-precision/q-negative-of */ \"./node_modules/flo-numerical/node/quad-precision/q-negative-of.js\");\r\nexports.qNegativeOf = q_negative_of_1.qNegativeOf;\r\nconst q_sign_1 = __webpack_require__(/*! ./quad-precision/q-sign */ \"./node_modules/flo-numerical/node/quad-precision/q-sign.js\");\r\nexports.qSign = q_sign_1.qSign;\r\nconst to_bit_length_1 = __webpack_require__(/*! ./double-expansion/to-bit-length */ \"./node_modules/flo-numerical/node/double-expansion/to-bit-length.js\");\r\nexports.toBitlength = to_bit_length_1.toBitlength;\r\nconst expansion_div_1 = __webpack_require__(/*! ./double-expansion/expansion-div */ \"./node_modules/flo-numerical/node/double-expansion/expansion-div.js\");\r\nexports.expansionDiv = expansion_div_1.expansionDiv;\r\nconst compress_1 = __webpack_require__(/*! ./double-expansion/compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\nexports.compress = compress_1.compress;\r\nconst compare_1 = __webpack_require__(/*! ./double-expansion/compare */ \"./node_modules/flo-numerical/node/double-expansion/compare.js\");\r\nexports.compare = compare_1.compare;\r\nconst abs_1 = __webpack_require__(/*! ./double-expansion/abs */ \"./node_modules/flo-numerical/node/double-expansion/abs.js\");\r\nexports.abs = abs_1.abs;\r\nconst estimate_1 = __webpack_require__(/*! ./double-expansion/estimate */ \"./node_modules/flo-numerical/node/double-expansion/estimate.js\");\r\nexports.estimate = estimate_1.estimate;\r\nconst expansion_diff_1 = __webpack_require__(/*! ./double-expansion/expansion-diff */ \"./node_modules/flo-numerical/node/double-expansion/expansion-diff.js\");\r\nexports.expansionDiff = expansion_diff_1.expansionDiff;\r\nconst fast_expansion_sum_1 = __webpack_require__(/*! ./double-expansion/fast-expansion-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-expansion-sum.js\");\r\nexports.fastExpansionSum = fast_expansion_sum_1.fastExpansionSum;\r\nconst fast_two_diff_1 = __webpack_require__(/*! ./double-expansion/fast-two-diff */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-diff.js\");\r\nexports.fastTwoDiff = fast_two_diff_1.fastTwoDiff;\r\nconst fast_two_sum_1 = __webpack_require__(/*! ./double-expansion/fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\nexports.fastTwoSum = fast_two_sum_1.fastTwoSum;\r\nconst grow_expansion_1 = __webpack_require__(/*! ./double-expansion/grow-expansion */ \"./node_modules/flo-numerical/node/double-expansion/grow-expansion.js\");\r\nexports.growExpansion = grow_expansion_1.growExpansion;\r\nconst is_adjacent_1 = __webpack_require__(/*! ./double-expansion/is-adjacent */ \"./node_modules/flo-numerical/node/double-expansion/is-adjacent.js\");\r\nexports.isAdjacent = is_adjacent_1.isAdjacent;\r\nconst is_overlapping_1 = __webpack_require__(/*! ./double-expansion/is-overlapping */ \"./node_modules/flo-numerical/node/double-expansion/is-overlapping.js\");\r\nexports.isOverlapping = is_overlapping_1.isOverlapping;\r\nexports.isNonOverlapping = is_overlapping_1.isNonOverlapping;\r\nexports.isNonOverlappingAll = is_overlapping_1.isNonOverlappingAll;\r\nconst merge_1 = __webpack_require__(/*! ./double-expansion/merge */ \"./node_modules/flo-numerical/node/double-expansion/merge.js\");\r\nexports.merge = merge_1.merge;\r\nconst negative_of_1 = __webpack_require__(/*! ./double-expansion/negative-of */ \"./node_modules/flo-numerical/node/double-expansion/negative-of.js\");\r\nexports.negativeOf = negative_of_1.negativeOf;\r\nconst orient2d_1 = __webpack_require__(/*! ./double-expansion/orient2d */ \"./node_modules/flo-numerical/node/double-expansion/orient2d.js\");\r\nexports.orient2d = orient2d_1.orient2d;\r\nconst scale_expansion_1 = __webpack_require__(/*! ./double-expansion/scale-expansion */ \"./node_modules/flo-numerical/node/double-expansion/scale-expansion.js\");\r\nexports.scaleExpansion = scale_expansion_1.scaleExpansion;\r\nexports.scaleExpansion2 = scale_expansion_1.scaleExpansion2;\r\nconst e_mult_by_2_1 = __webpack_require__(/*! ./double-expansion/e-mult-by-2 */ \"./node_modules/flo-numerical/node/double-expansion/e-mult-by-2.js\");\r\nexports.eMultBy2 = e_mult_by_2_1.eMultBy2;\r\nconst e_mult_by_neg_2_1 = __webpack_require__(/*! ./double-expansion/e-mult-by-neg-2 */ \"./node_modules/flo-numerical/node/double-expansion/e-mult-by-neg-2.js\");\r\nexports.eMultByNeg2 = e_mult_by_neg_2_1.eMultByNeg2;\r\nconst e_div_by_2_1 = __webpack_require__(/*! ./double-expansion/e-div-by-2 */ \"./node_modules/flo-numerical/node/double-expansion/e-div-by-2.js\");\r\nexports.eDivBy2 = e_div_by_2_1.eDivBy2;\r\nconst split_1 = __webpack_require__(/*! ./double-expansion/split */ \"./node_modules/flo-numerical/node/double-expansion/split.js\");\r\nexports.split = split_1.split;\r\nconst two_diff_1 = __webpack_require__(/*! ./double-expansion/two-diff */ \"./node_modules/flo-numerical/node/double-expansion/two-diff.js\");\r\nexports.twoDiff = two_diff_1.twoDiff;\r\nconst two_product_1 = __webpack_require__(/*! ./double-expansion/two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nexports.twoProduct = two_product_1.twoProduct;\r\nconst two_sum_1 = __webpack_require__(/*! ./double-expansion/two-sum */ \"./node_modules/flo-numerical/node/double-expansion/two-sum.js\");\r\nexports.twoSum = two_sum_1.twoSum;\r\nconst reduce_significand_1 = __webpack_require__(/*! ./double-expansion/reduce-significand */ \"./node_modules/flo-numerical/node/double-expansion/reduce-significand.js\");\r\nexports.reduceSignificand = reduce_significand_1.reduceSignificand;\r\nconst expansion_product_1 = __webpack_require__(/*! ./double-expansion/expansion-product */ \"./node_modules/flo-numerical/node/double-expansion/expansion-product.js\");\r\nexports.expansionProduct = expansion_product_1.expansionProduct;\r\nconst parse_double_1 = __webpack_require__(/*! ./double-representation/parse-double */ \"./node_modules/flo-numerical/node/double-representation/parse-double.js\");\r\nexports.parseDouble = parse_double_1.parseDouble;\r\nexports.parseDoubleDetailed = parse_double_1.parseDoubleDetailed;\r\nconst is_bit_aligned_1 = __webpack_require__(/*! ./double-representation/is-bit-aligned */ \"./node_modules/flo-numerical/node/double-representation/is-bit-aligned.js\");\r\nexports.isBitAligned = is_bit_aligned_1.isBitAligned;\r\nconst msb_exponent_1 = __webpack_require__(/*! ./double-representation/msb-exponent */ \"./node_modules/flo-numerical/node/double-representation/msb-exponent.js\");\r\nexports.msbExponent = msb_exponent_1.msbExponent;\r\nconst lsb_exponent_1 = __webpack_require__(/*! ./double-representation/lsb-exponent */ \"./node_modules/flo-numerical/node/double-representation/lsb-exponent.js\");\r\nexports.lsbExponent = lsb_exponent_1.lsbExponent;\r\nconst sign_1 = __webpack_require__(/*! ./double-expansion/sign */ \"./node_modules/flo-numerical/node/double-expansion/sign.js\");\r\nexports.sign = sign_1.sign;\r\nconst bit_length_1 = __webpack_require__(/*! ./double-representation/bit-length */ \"./node_modules/flo-numerical/node/double-representation/bit-length.js\");\r\nexports.bitLength = bit_length_1.bitLength;\r\nconst bit_length_2 = __webpack_require__(/*! ./double-representation/bit-length */ \"./node_modules/flo-numerical/node/double-representation/bit-length.js\");\r\nexports.expBitLength = bit_length_2.expBitLength;\r\nconst calculate_1 = __webpack_require__(/*! ./double-expansion/calculate */ \"./node_modules/flo-numerical/node/double-expansion/calculate.js\");\r\nexports.calculate = calculate_1.calculate;\r\nconst calculate_sum_1 = __webpack_require__(/*! ./double-expansion/calculate-sum */ \"./node_modules/flo-numerical/node/double-expansion/calculate-sum.js\");\r\nexports.calculateSum = calculate_sum_1.calculateSum;\r\nconst calculate_product_1 = __webpack_require__(/*! ./double-expansion/calculate-product */ \"./node_modules/flo-numerical/node/double-expansion/calculate-product.js\");\r\nexports.calculateProduct = calculate_product_1.calculateProduct;\r\nconst exponent_1 = __webpack_require__(/*! ./double-representation/exponent */ \"./node_modules/flo-numerical/node/double-representation/exponent.js\");\r\nexports.exponent = exponent_1.exponent;\r\nconst significand_1 = __webpack_require__(/*! ./double-representation/significand */ \"./node_modules/flo-numerical/node/double-representation/significand.js\");\r\nexports.significand = significand_1.significand;\r\nconst binary_string_to_double_1 = __webpack_require__(/*! ./double-representation/binary-string-to-double */ \"./node_modules/flo-numerical/node/double-representation/binary-string-to-double.js\");\r\nexports.binaryStringToDouble = binary_string_to_double_1.binaryStringToDouble;\r\nconst double_to_binary_string_1 = __webpack_require__(/*! ./double-representation/double-to-binary-string */ \"./node_modules/flo-numerical/node/double-representation/double-to-binary-string.js\");\r\nexports.doubleToBinaryString = double_to_binary_string_1.doubleToBinaryString;\r\nconst double_to_octets_1 = __webpack_require__(/*! ./double-representation/double-to-octets */ \"./node_modules/flo-numerical/node/double-representation/double-to-octets.js\");\r\nexports.doubleToOctets = double_to_octets_1.doubleToOctets;\r\nconst octets_to_double_1 = __webpack_require__(/*! ./double-representation/octets-to-double */ \"./node_modules/flo-numerical/node/double-representation/octets-to-double.js\");\r\nexports.octetsToDouble = octets_to_double_1.octetsToDouble;\r\nconst get_max_set_bit_1 = __webpack_require__(/*! ./double-representation/get-max-set-bit */ \"./node_modules/flo-numerical/node/double-representation/get-max-set-bit.js\");\r\nexports.getHighestSetBit = get_max_set_bit_1.getHighestSetBit;\r\nexports.getLowestSetBit = get_max_set_bit_1.getLowestSetBit;\r\nconst is_valid_1 = __webpack_require__(/*! ./double-representation/is-valid */ \"./node_modules/flo-numerical/node/double-representation/is-valid.js\");\r\nexports.isValid = is_valid_1.isValid;\r\nconst within_1 = __webpack_require__(/*! ./double-expansion/within */ \"./node_modules/flo-numerical/node/double-expansion/within.js\");\r\nexports.within = within_1.within;\r\nconst int_pow_1 = __webpack_require__(/*! ./double-expansion/int-pow */ \"./node_modules/flo-numerical/node/double-expansion/int-pow.js\");\r\nexports.intPow = int_pow_1.intPow;\r\nconst q_div_quad_with_err_1 = __webpack_require__(/*! ./quad-precision-with-error/q-div-quad-with-err */ \"./node_modules/flo-numerical/node/quad-precision-with-error/q-div-quad-with-err.js\");\r\nexports.qDivQuadWithError = q_div_quad_with_err_1.qDivQuadWithError;\r\nconst div_with_err_1 = __webpack_require__(/*! ./double-float-with-err/div-with-err */ \"./node_modules/flo-numerical/node/double-float-with-err/div-with-err.js\");\r\nexports.divWithErr = div_with_err_1.divWithErr;\r\nconst to_quad_1 = __webpack_require__(/*! ./quad-precision/to-quad */ \"./node_modules/flo-numerical/node/quad-precision/to-quad.js\");\r\nexports.toQuad = to_quad_1.toQuad;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision-with-error/q-div-quad-with-err.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision-with-error/q-div-quad-with-err.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_div_quad_1 = __webpack_require__(/*! ../quad-precision/q-div-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-div-quad.js\");\r\nconst abs = Math.abs;\r\nconst eps = Number.EPSILON;\r\nconst u = Number.EPSILON / 2;\r\nconst uu = Math.pow((Number.EPSILON / 2), 2);\r\n/**\r\n * Returns the result of dividing two quad-precision floating point numbers\r\n * together with an absolute error bound where nE and dE are absolute error\r\n * bounds on the input values.\r\n * @param n numerator - a quad-precision float - low part\r\n * @param N numerator - a quad-precision float - high part\r\n * @param d denominator - a quad-precision float - low part\r\n * @param D denominator - a quad-precision float - high part\r\n * @param nE absolute value error bound in numerator\r\n * @param dE absolute value error bound in denominator\r\n */\r\nfunction qDivQuadWithError([n, N], [d, D], nE, dE) {\r\n    // estimate the result of the division\r\n    let est = q_div_quad_1.qDivQuad([n, N], [d, D]);\r\n    let _n = abs(n + N); // absolute value of estimate of n accurate to within 1/2 ulp\r\n    let _d = abs(d + D); // absolute value of estimate of d accurate to within 1/2 ulp\r\n    let δd = u * _d; // the max error in the rounding to _d\r\n    // if the error in the denominator is too high the error can be \r\n    // arbitrarily high\r\n    let minD = _d - δd - dE;\r\n    // maxErr is only valid if minD > 0\r\n    if (minD <= 0) {\r\n        // the error can be arbitrarily high; est is mostly irrelevant\r\n        return { est, err: Number.POSITIVE_INFINITY };\r\n    }\r\n    let err = ((_d * nE + _n * dE) / Math.pow(minD, 2)) + 9 * uu * abs(_n / _d);\r\n    return { est, err };\r\n}\r\nexports.qDivQuadWithError = qDivQuadWithError;\r\n//# sourceMappingURL=q-div-quad-with-err.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision-with-error/q-div-quad-with-err.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-abs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-abs.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the absolute value of the given quad precision floating point number.\r\n * @param a A quad precision floating point number\r\n */\r\nfunction qAbs(f) {\r\n    let [q, Q] = f;\r\n    return (Q < 0) ? [-q, -Q] : f;\r\n}\r\nexports.qAbs = qAbs;\r\n//# sourceMappingURL=q-abs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-abs.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-add-double.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-add-double.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of adding a double to a quad precision floating point\r\n * number.\r\n *\r\n * * relative error bound: 2u^2, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 2u^2, u = 0.5 * Number.EPSILON\r\n * * the error bound is sharp\r\n *\r\n * ALGORITHM 4 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param [xl,xh] a quad precision floating point number\r\n * @param y A double precision floating point number\r\n */\r\nfunction qAddDouble([xl, xh], y) {\r\n    //let [sl,sh] = twoSum(xh, y);\r\n    let sh = xh + y;\r\n    let c = sh - xh;\r\n    let sl = (xh - (sh - c)) + (y - c);\r\n    let v = xl + sl;\r\n    //let [zl,zh] = fastTwoSum(sh,v);\r\n    let zh = sh + v;\r\n    let zl = v - (zh - sh);\r\n    return [zl, zh];\r\n}\r\nexports.qAddDouble = qAddDouble;\r\n//# sourceMappingURL=q-add-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-add-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-add-quad.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-add-quad.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of adding two quad-precision floating point numbers.\r\n *\r\n * * relative error bound: 3u^2 + 13u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n * * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 2.25u^2\r\n *\r\n * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n */\r\nfunction qAddQuad([xl, xh], [yl, yh]) {\r\n    //let [sl,sh] = twoSum(xh,yh);\r\n    let sh = xh + yh;\r\n    let _1 = sh - xh;\r\n    let sl = (xh - (sh - _1)) + (yh - _1);\r\n    //let [tl,th] = twoSum(xl,yl);\r\n    let th = xl + yl;\r\n    let _2 = th - xl;\r\n    let tl = (xl - (th - _2)) + (yl - _2);\r\n    let c = sl + th;\r\n    //let [vl,vh] = fastTwoSum(sh,c)\r\n    let vh = sh + c;\r\n    let vl = c - (vh - sh);\r\n    let w = tl + vl;\r\n    //let [zl,zh] = fastTwoSum(vh,w)\r\n    let zh = vh + w;\r\n    let zl = w - (zh - vh);\r\n    return [zl, zh];\r\n}\r\nexports.qAddQuad = qAddQuad;\r\n//# sourceMappingURL=q-add-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-add-quad.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-compare.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-compare.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_diff_quad_1 = __webpack_require__(/*! ./q-diff-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js\");\r\n/**\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n * @param a a double-double\r\n * @param b another double-double\r\n */\r\nfunction qCompare(a, b) {\r\n    return q_diff_quad_1.qDiffQuad(a, b)[1];\r\n}\r\nexports.qCompare = qCompare;\r\n//# sourceMappingURL=q-compare.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-compare.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of subtracting the second given quad-precision floating\r\n * point number from the first.\r\n *\r\n * * relative error bound: 3u^2 + 13u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n * * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 2.25u^2\r\n *\r\n * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param xl low order double (of x in x - y)\r\n * @param xh hight order double (of x in x - y)\r\n * @param yl low order double (of y in x - y)\r\n * @param yh hight order double (of y in x - y)\r\n */\r\nfunction qDiffQuad([xl, xh], [yl, yh]) {\r\n    //let [sl,sh] = twoSum(xh,yh);\r\n    let sh = xh - yh;\r\n    let _1 = sh - xh;\r\n    let sl = (xh - (sh - _1)) + (-yh - _1);\r\n    //let [tl,th] = twoSum(xl,yl);\r\n    let th = xl - yl;\r\n    let _2 = th - xl;\r\n    let tl = (xl - (th - _2)) + (-yl - _2);\r\n    let c = sl + th;\r\n    //let [vl,vh] = fastTwoSum(sh,c)\r\n    let vh = sh + c;\r\n    let vl = c - (vh - sh);\r\n    let w = tl + vl;\r\n    //let [zl,zh] = fastTwoSum(vh,w)\r\n    let zh = vh + w;\r\n    let zl = w - (zh - vh);\r\n    return [zl, zh];\r\n}\r\nexports.qDiffQuad = qDiffQuad;\r\n//# sourceMappingURL=q-diff-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-div-by-2.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-div-by-2.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of dividing the given double-double by 2.\r\n * @param q\r\n */\r\nfunction qDivBy2([q, Q]) {\r\n    return [q / 2, Q / 2];\r\n}\r\nexports.qDivBy2 = qDivBy2;\r\n//# sourceMappingURL=q-div-by-2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-div-by-2.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-div-double.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-div-double.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ../double-expansion/two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ../double-expansion/fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\n/**\r\n * Returns the result of dividing a quad-precision floating point number by a\r\n * double.\r\n *\r\n * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,\r\n * u = 0.5 * Number.EPSILON\r\n * * the bound is very sharp\r\n *\r\n * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param e a quad-precision floating point number\r\n * @param f a double-precision floating point number\r\n */\r\nfunction qDivDouble([xl, xh], y) {\r\n    let th = xh / y;\r\n    let [πl, πh] = two_product_1.twoProduct(th, y);\r\n    let δh = xh - πh; // exact operation\r\n    let δt = δh - πl; // exact operation\r\n    let δ = δt + xl;\r\n    let tl = δ / y;\r\n    return fast_two_sum_1.fastTwoSum(th, tl);\r\n}\r\nexports.qDivDouble = qDivDouble;\r\n//# sourceMappingURL=q-div-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-div-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-div-quad.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-div-quad.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fast_two_sum_1 = __webpack_require__(/*! ../double-expansion/fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\nconst q_mult_double_1 = __webpack_require__(/*! ./q-mult-double */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-double.js\");\r\n/**\r\n * Returns the result of dividing two quad-precision floating point numbers,\r\n * i.e. returns x/y.\r\n *\r\n * * relative error bound: 15u^2 + 56u^3, i.e. fl(a/b) = (a/b)(1+ϵ),\r\n * where ϵ <= 15u^2 + 56u^3, u = 0.5 * Number.EPSILON\r\n * * the largest error found was 8.465u^2\r\n *\r\n * * ALGORITHM 17 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param e a quad-precision floating point number\r\n * @param f another quad-precision floating point number\r\n */\r\nfunction qDivQuad([xl, xh], [yl, yh]) {\r\n    let th = xh / yh;\r\n    // approximation to th*(yh + yl) using Algorithm 7\r\n    let [rl, rh] = q_mult_double_1.qMultDouble1(th, [yl, yh]);\r\n    let πh = xh - rh; // exact operation\r\n    let δl = xl - rl;\r\n    let δ = πh + δl;\r\n    let tl = δ / yh;\r\n    return fast_two_sum_1.fastTwoSum(th, tl);\r\n}\r\nexports.qDivQuad = qDivQuad;\r\n//# sourceMappingURL=q-div-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-div-quad.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-max.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-max.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_diff_quad_1 = __webpack_require__(/*! ./q-diff-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js\");\r\n/**\r\n * Returns the maximum of a and b.\r\n * @param a a double-double\r\n * @param b another double-double\r\n */\r\nfunction qMax(a, b) {\r\n    let res = q_diff_quad_1.qDiffQuad(a, b)[1];\r\n    return res > 0 ? a : b;\r\n}\r\nexports.qMax = qMax;\r\n//# sourceMappingURL=q-max.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-max.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-min.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-min.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_diff_quad_1 = __webpack_require__(/*! ./q-diff-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-diff-quad.js\");\r\n/**\r\n * Returns the minimum of a and b.\r\n * @param a a double-double\r\n * @param b another double-double\r\n */\r\nfunction qMin(a, b) {\r\n    let res = q_diff_quad_1.qDiffQuad(a, b)[1];\r\n    return res > 0 ? b : a;\r\n}\r\nexports.qMin = qMin;\r\n//# sourceMappingURL=q-min.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-min.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-mult-by-2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-mult-by-2.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of multiplying the given double-double by 2.\r\n * @param q low order double\r\n * @param Q hight order double\r\n */\r\nfunction qMultBy2([q, Q]) {\r\n    return [2 * q, 2 * Q];\r\n}\r\nexports.qMultBy2 = qMultBy2;\r\n//# sourceMappingURL=q-mult-by-2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-mult-by-2.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-mult-by-4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-mult-by-4.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of multiplying the given double-double by 4.\r\n * @param q low order double\r\n * @param Q hight order double\r\n */\r\nfunction qMultBy4([q, Q]) {\r\n    return [4 * q, 4 * Q];\r\n}\r\nexports.qMultBy4 = qMultBy4;\r\n//# sourceMappingURL=q-mult-by-4.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-mult-by-4.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-2.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of multiplying the given double-double by -2.\r\n * @param q low order double\r\n * @param Q hight order double\r\n */\r\nfunction qMultByNeg2([q, Q]) {\r\n    return [-2 * q, -2 * Q];\r\n}\r\nexports.qMultByNeg2 = qMultByNeg2;\r\n//# sourceMappingURL=q-mult-by-neg-2.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-2.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-4.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-4.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the result of multiplying the given double-double by -4.\r\n * @param q low order double\r\n * @param Q hight order double\r\n */\r\nfunction qMultByNeg4([q, Q]) {\r\n    return [-4 * q, -4 * Q];\r\n}\r\nexports.qMultByNeg4 = qMultByNeg4;\r\n//# sourceMappingURL=q-mult-by-neg-4.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-mult-by-neg-4.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-mult-double.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-mult-double.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ../double-expansion/two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ../double-expansion/fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\n/**\r\n * Returns the product of a quad-precision floating point number and a double.\r\n *\r\n * * slower than ALGORITHM 8 (one call to fastTwoSum more) but about 2x more\r\n * accurate\r\n * * relative error bound: 1.5u^2 + 4u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 1.5u^2 + 4u^3, u = 0.5 * Number.EPSILON\r\n * * the bound is very sharp\r\n * * probably prefer qMultDouble2 due to extra speed\r\n *\r\n * * ALGORITHM 7 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param y a double\r\n * @param xl low order double (of x in x*y)\r\n * @param xh hight order double (of x in x*y)\r\n */\r\nfunction qMultDouble1(y, [xl, xh]) {\r\n    let [cl1, ch] = two_product_1.twoProduct(xh, y);\r\n    let cl2 = xl * y;\r\n    let [tl1, th] = fast_two_sum_1.fastTwoSum(ch, cl2);\r\n    let tl2 = tl1 + cl1;\r\n    let [zl, zh] = fast_two_sum_1.fastTwoSum(th, tl2);\r\n    return [zl, zh];\r\n}\r\nexports.qMultDouble1 = qMultDouble1;\r\n/**\r\n * Returns the product of a quad-precision floating point number and a double.\r\n *\r\n * * faster than ALGORITHM 7 (one call to fastTwoSum less) but about 2x less\r\n * accurate\r\n * * relative error bound: 3u^2, i.e. fl(a*b) = (a*b)(1+ϵ),\r\n * where ϵ <= 3u^2, u = 0.5 * Number.EPSILON\r\n * * the bound is sharp\r\n * * probably prefer this algorithm due to extra speed\r\n *\r\n * * ALGORITHM 8 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param y a double\r\n * @param xl low order double (of x in x*y)\r\n * @param xh hight order double (of x in x*y)\r\n */\r\nfunction qMultDouble2(y, [xl, xh]) {\r\n    let [cl1, ch] = two_product_1.twoProduct(xh, y);\r\n    let cl2 = xl * y;\r\n    let cl3 = cl1 + cl2;\r\n    return fast_two_sum_1.fastTwoSum(ch, cl3);\r\n}\r\nexports.qMultDouble2 = qMultDouble2;\r\n//# sourceMappingURL=q-mult-double.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-mult-double.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-mult-quad.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-mult-quad.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst two_product_1 = __webpack_require__(/*! ../double-expansion/two-product */ \"./node_modules/flo-numerical/node/double-expansion/two-product.js\");\r\nconst fast_two_sum_1 = __webpack_require__(/*! ../double-expansion/fast-two-sum */ \"./node_modules/flo-numerical/node/double-expansion/fast-two-sum.js\");\r\n/**\r\n * Returns the product of two quad-precision floating point numbers.\r\n *\r\n * * relative error bound: 7u^2, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON\r\n * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 5u^2\r\n *\r\n * * ALGORITHM 10 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param xl low order double (of x in x*y)\r\n * @param xh hight order double (of x in x*y)\r\n * @param yl low order double (of y in x*y)\r\n * @param yh hight order double (of y in x*y)\r\n */\r\nfunction qMultQuad([xl, xh], [yl, yh]) {\r\n    let [cl1, ch] = two_product_1.twoProduct(xh, yh);\r\n    let tl1 = xh * yl;\r\n    let tl2 = xl * yh;\r\n    let cl2 = tl1 + tl2;\r\n    let cl3 = cl1 + cl2;\r\n    return fast_two_sum_1.fastTwoSum(ch, cl3);\r\n}\r\nexports.qMultQuad = qMultQuad;\r\n//# sourceMappingURL=q-mult-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-mult-quad.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-negative-of.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-negative-of.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the negative of the given quad precision floating point number.\r\n * @param q low order double\r\n * @param Q high order double\r\n */\r\nfunction qNegativeOf([q, Q]) {\r\n    return [-q, -Q];\r\n}\r\nexports.qNegativeOf = qNegativeOf;\r\n//# sourceMappingURL=q-negative-of.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-negative-of.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-product.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-product.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_mult_quad_1 = __webpack_require__(/*! ./q-mult-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-mult-quad.js\");\r\n/**\r\n * Returns the result of multiplying together an array of quad-precision\r\n * floating point numbers naively (i.e. not using pairwise addition to reduce\r\n * error a bit).\r\n *\r\n * * an error bound is given by: (n-1)(1+ϵ),\r\n * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON\r\n */\r\nfunction qProduct(qs) {\r\n    let q = qs[0];\r\n    for (let i = 1; i < qs.length; i++) {\r\n        q = q_mult_quad_1.qMultQuad(q, qs[i]);\r\n    }\r\n    return q;\r\n}\r\nexports.qProduct = qProduct;\r\n//# sourceMappingURL=q-product.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-product.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-sign.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-sign.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the sign of the given quad-precision floating point number.\r\n * * prefer inlining this - it is really only here for reference\r\n */\r\nfunction qSign([q, Q]) {\r\n    return Q;\r\n}\r\nexports.qSign = qSign;\r\n//# sourceMappingURL=q-sign.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-sign.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/q-sum.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/q-sum.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst q_add_quad_1 = __webpack_require__(/*! ./q-add-quad */ \"./node_modules/flo-numerical/node/quad-precision/q-add-quad.js\");\r\n/**\r\n * Returns the result of summing an array of quad-precision floating point\r\n * numbers naively (i.e. not using pairwise addition to reduce error a bit).\r\n *\r\n * * an error bound is given by: (n-1)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n */\r\nfunction qSum(qs) {\r\n    let q = qs[0];\r\n    for (let i = 1; i < qs.length; i++) {\r\n        q = q_add_quad_1.qAddQuad(q, qs[i]);\r\n    }\r\n    return q;\r\n}\r\nexports.qSum = qSum;\r\n//# sourceMappingURL=q-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/q-sum.js?");

/***/ }),

/***/ "./node_modules/flo-numerical/node/quad-precision/to-quad.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-numerical/node/quad-precision/to-quad.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst compress_1 = __webpack_require__(/*! ../double-expansion/compress */ \"./node_modules/flo-numerical/node/double-expansion/compress.js\");\r\n/**\r\n * Returns the result of converting a floating point expansion to a\r\n * double-double (quad).\r\n */\r\nfunction toQuad(e) {\r\n    e = compress_1.compress(e);\r\n    let len = e.length;\r\n    if (len === 2) {\r\n        return e; // already a quad\r\n    }\r\n    else if (len === 1) {\r\n        return [0, e[0]];\r\n    }\r\n    else {\r\n        return [e[len - 2], e[len - 1]];\r\n    }\r\n}\r\nexports.toQuad = toQuad;\r\n//# sourceMappingURL=to-quad.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-numerical/node/quad-precision/to-quad.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/abs-coeff.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/abs-coeff.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the polynomial with all coeffients made positive of the given\r\n * polynomial\r\n */\r\nfunction absCoeff(p) {\r\n    let p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(Math.abs(p[i]));\r\n    }\r\n    return p_;\r\n}\r\nexports.absCoeff = absCoeff;\r\n//# sourceMappingURL=abs-coeff.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/abs-coeff.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/add.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/add.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ./remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate result of adding two polynomials.\r\n * @param p1 a polynomial\r\n * @param p2 another polynomial\r\n * @example\r\n * add([1,2,3],[3,4]); //=> [1,5,7]\r\n */\r\nfunction add(p1, p2) {\r\n    // Initialize result array  \r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let Δd = d1 - d2;\r\n    let Δd1 = Δd < 0 ? +Δd : 0;\r\n    let Δd2 = Δd > 0 ? -Δd : 0;\r\n    let d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let c1 = p1[i + Δd1] || 0;\r\n        let c2 = p2[i + Δd2] || 0;\r\n        result.push(c1 + c2);\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return remove_leading_zeros_1.removeLeadingZeros(result);\r\n}\r\nexports.add = add;\r\n/**\r\n * Returns the exact result of adding two polynomials.\r\n * @param p1 a polynomial with floating point expansion coefficients\r\n * @param p2 another polynomial with floating point expansion coefficients\r\n * @example\r\n * add([[1],[2],[3]],[[3],[4]]); //=> [[1],[5],[7]]\r\n */\r\nfunction addExact(p1, p2) {\r\n    // Initialize result array  \r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let Δd = d1 - d2;\r\n    let Δd1 = Δd < 0 ? +Δd : 0;\r\n    let Δd2 = Δd > 0 ? -Δd : 0;\r\n    let d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let c1 = p1[i + Δd1] || [0];\r\n        let c2 = p2[i + Δd2] || [0];\r\n        result.push(flo_numerical_1.fastExpansionSum(c1, c2));\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return remove_leading_zeros_1.expRemoveLeadingZeros(result);\r\n}\r\nexports.addExact = addExact;\r\n//# sourceMappingURL=add.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/add.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/degree.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/degree.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the degree of the polynomial.\r\n * @param p a polynomial\r\n * @example\r\n * degree([9,8,7,6,5,4,3,2,1]); //=> 8\r\n */\r\nfunction degree(p) {\r\n    return p.length - 1;\r\n}\r\nexports.degree = degree;\r\n//# sourceMappingURL=degree.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/degree.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/equal.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/equal.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns true if two polynomials are exactly equal by comparing coefficients.\r\n * @param p1 a polynomial\r\n * @param p2 another polynomial\r\n * @example\r\n * equal([1,2,3,4], [1,2,3,4]);   //=> true\r\n * equal([1,2,3,4], [1,2,3,4,5]); //=> false\r\n */\r\nfunction equal(p1, p2) {\r\n    if (p1.length !== p2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < p1.length; i++) {\r\n        if (p1[i] !== p2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.equal = equal;\r\n/**\r\n * Returns true if two polynomials are exactly equal by comparing coefficients.\r\n * @param p1 a polynomial with coefficients given as floatin point expansions\r\n * @param p2 another polynomial\r\n * @example\r\n * equal([[1],[2],[3],[4]], [[1],[2],[3],[4]]);   //=> true\r\n * equal([[1],[2],[3],[4]], [[1],[2],[3],[4],[5]]); //=> false\r\n */\r\nfunction expEqual(p1, p2) {\r\n    if (p1.length !== p2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < p1.length; i++) {\r\n        if (flo_numerical_1.compare(p1[i], p2[i]) !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.expEqual = expEqual;\r\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/equal.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/invert.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/invert.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Inverts the given polynomial by reversing the order of the\r\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\r\n * @param p a polynomial\r\n * @example\r\n * invert([3,2,-5]);  // => [-5,2,3]\r\n */\r\nfunction invert(p) {\r\n    return p.slice().reverse();\r\n}\r\nexports.invert = invert;\r\n/**\r\n * Inverts the given polynomial by reversing the order of the\r\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\r\n * @param p a polynomial\r\n * @example\r\n * invert([3,2,-5]);  // => [[-5],[2],[3]]\r\n */\r\nfunction expInvert(p) {\r\n    return p.slice().reverse();\r\n}\r\nexports.expInvert = expInvert;\r\n//# sourceMappingURL=invert.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/invert.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/is-const-multiple-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/is-const-multiple-of.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns true if a is an exact constant multiple of b or b of a.\r\n * @param a a polynomial\r\n * @param b another polynomial\r\n */\r\nfunction isConstMultipleOf(a, b) {\r\n    /** leading coefficient of a */\r\n    let lcA = a[0];\r\n    /** leading coefficient of b */\r\n    let lcB = b[0];\r\n    // If either polynomial is zero\r\n    if (flo_numerical_1.sign(lcA) === 0 || flo_numerical_1.sign(lcB) === 0) {\r\n        return true;\r\n    }\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    let multiplier;\r\n    let cmpAB = flo_numerical_1.compare(lcA, lcB);\r\n    if (cmpAB === 0) {\r\n        multiplier = [1];\r\n    }\r\n    else {\r\n        if (cmpAB < 0) {\r\n            [a, b] = [b, a];\r\n            [lcA, lcB] = [lcB, lcA];\r\n        }\r\n        multiplier = flo_numerical_1.expansionDiv(lcA, lcB, 0);\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n        let v = flo_numerical_1.expansionProduct(multiplier, b[i]);\r\n        //console.log(v, a[i])\r\n        if (flo_numerical_1.compare(v, a[i]) !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isConstMultipleOf = isConstMultipleOf;\r\n//# sourceMappingURL=is-const-multiple-of.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/is-const-multiple-of.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/is-const.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/is-const.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns true if the given polynomial is the zero polynomial\r\n * @param a a polynomial\r\n */\r\nfunction expIsConst(a) {\r\n    return a.length <= 1;\r\n}\r\nexports.expIsConst = expIsConst;\r\n//# sourceMappingURL=is-const.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/is-const.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/is-zero.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/is-zero.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns true if the given polynomial is the zero polynomial\r\n * @param a a polynomial\r\n */\r\nfunction expIsZero(a) {\r\n    return a.length === 0 || (a.length === 1 && flo_numerical_1.sign(a[0]) === 0);\r\n}\r\nexports.expIsZero = expIsZero;\r\n//# sourceMappingURL=is-zero.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/is-zero.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/multiply-by-const.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/multiply-by-const.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ./remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Multiplies a polynomial by a constant.\r\n * @param c the constant\r\n * @param p the polynomial\r\n * @example\r\n * multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\r\n */\r\nfunction multiplyByConst(c, p) {\r\n    if (c === 0) {\r\n        return [];\r\n    }\r\n    let d = p.length;\r\n    let result = [];\r\n    for (let i = 0; i < d; i++) {\r\n        result.push(c * p[i]);\r\n    }\r\n    // We have to clip due to possible floating point underflow\r\n    return remove_leading_zeros_1.removeLeadingZeros(result);\r\n}\r\nexports.multiplyByConst = multiplyByConst;\r\n/**\r\n * Multiplies a polynomial by a constant.\r\n * @param c the constant\r\n * @param p the polynomial\r\n * @example\r\n * multiplyByConst([0.25], [[3],[2],[1]]); //=> [[0.75], [0.5], [0.25]]\r\n */\r\nfunction expMultiplyByConst(c, p) {\r\n    if (flo_numerical_1.sign(c) === 0) {\r\n        return [[0]];\r\n    }\r\n    let d = p.length - 1;\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        result.push(flo_numerical_1.expansionProduct(c, p[i]));\r\n    }\r\n    return result;\r\n}\r\nexports.expMultiplyByConst = expMultiplyByConst;\r\n//# sourceMappingURL=multiply-by-const.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/multiply-by-const.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/multiply.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/multiply.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ./remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate result of multiplying 2 polynomials.\r\n * * See polynomial arithmetic https://en.wikipedia.org/wiki/Polynomial_arithmetic\r\n * * See polynomial multiplication https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\r\n * * See polynomial multiplication http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\r\n * @param p1 a polynomial.\r\n * @param p2 another polynomial.\r\n * @example\r\n * multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n */\r\nfunction multiply(p1, p2) {\r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let d = d1 + d2;\r\n    let result = new Array(d + 1).fill(0);\r\n    for (let i = 0; i < d1 + 1; i++) {\r\n        for (let j = 0; j < d2 + 1; j++) {\r\n            result[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);\r\n        }\r\n    }\r\n    return remove_leading_zeros_1.removeLeadingZeros(result);\r\n}\r\nexports.multiply = multiply;\r\n/**\r\n * Returns the exact result of multiplying 1 or more polynomials.\r\n * * See polynomial arithmetic https://en.wikipedia.org/wiki/Polynomial_arithmetic\r\n * * See polynomial multiplication https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\r\n * * See polynomial multiplication http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\r\n * @param p1 a polynomial.\r\n * @param p2 another polynomial.\r\n * @example\r\n * multiply([[1],[2],[3]], [[2],[5],[3],[5]]); //=> [[2], [9], [19], [26], [19], [15]]\r\n */\r\nfunction multiplyExact_(p1, p2) {\r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let d = d1 + d2;\r\n    let result = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i < d1 + 1; i++) {\r\n        for (let j = 0; j < d2 + 1; j++) {\r\n            result[d - (i + j)] = flo_numerical_1.fastExpansionSum(result[d - (i + j)], flo_numerical_1.expansionProduct(p1[d1 - i], p2[d2 - j]));\r\n        }\r\n    }\r\n    return remove_leading_zeros_1.expRemoveLeadingZeros(result);\r\n}\r\n/**\r\n * Returns the exact result of multiplying 1 or more polynomials.\r\n * * See polynomial arithmetic https://en.wikipedia.org/wiki/Polynomial_arithmetic\r\n * * See polynomial multiplication https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\r\n * * See polynomial multiplication http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\r\n * @param p1 a polynomial.\r\n * @param p2 another polynomial.\r\n * @example\r\n * multiply([[1],[2],[3]], [[2],[5],[3],[5]]); //=> [[2], [9], [19], [26], [19], [15]]\r\n */\r\nfunction multiplyExact(ps) {\r\n    if (ps.length === 1) {\r\n        return ps[0];\r\n    }\r\n    let p = ps[0];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        p = multiplyExact_(p, ps[i]);\r\n    }\r\n    return p;\r\n}\r\nexports.multiplyExact = multiplyExact;\r\n//# sourceMappingURL=multiply.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/multiply.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/negate.js":
/*!****************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/negate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst multiply_by_const_1 = __webpack_require__(/*! ./multiply-by-const */ \"./node_modules/flo-poly/node/basic/multiply-by-const.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the negative of the given polynomial (p -> -p).\r\n * @param p a polynomial\r\n * @example\r\n * negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n */\r\nfunction negate(p) {\r\n    return multiply_by_const_1.multiplyByConst(-1, p);\r\n}\r\nexports.negate = negate;\r\n/**\r\n * Returns the negative of the given polynomial (p -> -p).\r\n * @param p a polynomial\r\n * @example\r\n * expNegate([[0.1], [-0.2]]); //=> [[-0.1], [0.2]]\r\n */\r\nfunction expNegate(p) {\r\n    let result = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        result.push(flo_numerical_1.negativeOf(p[i]));\r\n    }\r\n    return result;\r\n}\r\nexports.expNegate = expNegate;\r\n//# sourceMappingURL=negate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/negate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/remove-leading-zeros.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/remove-leading-zeros.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst p_inf_norm_1 = __webpack_require__(/*! ../norm/p-inf-norm */ \"./node_modules/flo-poly/node/norm/p-inf-norm.js\");\r\n/**\r\n * If the highest power coefficient is 0 then removeLeadingZeros can be called\r\n * to remove all such highest terms so that the array is a valid presentation of\r\n * a polynomial.\r\n * @param p The polynomial to be clipped.\r\n * @example\r\n * removeLeadingZeros([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * removeLeadingZeros([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\r\nfunction removeLeadingZeros(p) {\r\n    return p[0] !== 0 ? p : removeLeadingZeros(p.slice(1));\r\n}\r\nexports.removeLeadingZeros = removeLeadingZeros;\r\n/**\r\n * If the highest power coefficient is 0 then clip can be called to remove all\r\n * such highest terms so that the array is a valid presentation of a polynomial.\r\n * @param p The polynomial to be clipped.\r\n * @example\r\n * expRemoveLeadingZeros([[1e-18], [1e-10], [1e-1]]); //=> [[1e-18], [1e-10], [1e-1]]\r\n * expRemoveLeadingZeros([[0], [1e-10], [1e-1]]); //=> [[1e-10], [1e-1]]\r\n */\r\nfunction expRemoveLeadingZeros(p) {\r\n    return p.length <= 1 || flo_numerical_1.sign(p[0]) !== 0\r\n        ? p :\r\n        expRemoveLeadingZeros(p.slice(1));\r\n}\r\nexports.expRemoveLeadingZeros = expRemoveLeadingZeros;\r\n/**\r\n * If the highest power coefficient is small in the sense that the highest power\r\n * term has a negligible contribution (compared to the other terms) at x = 1\r\n * then this function can be called to remove all such highest terms. A\r\n * contribution of less than Number.EPSILON of the highest coefficient will be\r\n * considered negligible by default.\r\n * @param p the polynomial to be clipped.\r\n * @param δ the optional contribution tolerence else Number.EPSILON will be used\r\n * by default.\r\n * @example\r\n * approxRemoveLeadingZeros([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5]\r\n * approxRemoveLeadingZeros([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\r\nfunction approxRemoveLeadingZeros(p, δ = Number.EPSILON) {\r\n    let c = p_inf_norm_1.pInfNorm(p);\r\n    if (c === 0) {\r\n        return [0];\r\n    }\r\n    if (Math.abs(p[0]) > δ * c) {\r\n        return p;\r\n    }\r\n    let p_ = p.slice(1);\r\n    while (Math.abs(p_[0]) < δ * c) {\r\n        p_ = p_.slice(1);\r\n    }\r\n    return approxRemoveLeadingZeros(p_, δ);\r\n}\r\nexports.approxRemoveLeadingZeros = approxRemoveLeadingZeros;\r\n/**\r\n * Like expRemoveLeadingZeros, but useful when underflow might have occured\r\n * since this function will remove all leading zeros < 2.2250738585072014e−308\r\n * which is the smallest non-subnormal float.\r\n * @param p\r\n * @param δ\r\n */\r\nfunction expApproxRemoveLeadingZeros(p) {\r\n    /** the smallest non-subnormal float */\r\n    let DELTA = 2.2250738585072014e-308;\r\n    let lc = Math.abs(flo_numerical_1.estimate(p[0])); // estimate of the leading coefficient\r\n    if (p.length === 0 || (p.length === 1 && lc <= DELTA)) {\r\n        return [[0]];\r\n    }\r\n    if (lc > DELTA) {\r\n        return p;\r\n    }\r\n    let p_ = p.slice(1);\r\n    while (p_.length > 0 && Math.abs(flo_numerical_1.estimate(p_[0])) < DELTA) {\r\n        p_ = p_.slice(1);\r\n    }\r\n    if (p_.length === 0) {\r\n        return [[0]];\r\n    }\r\n    return expApproxRemoveLeadingZeros(p_);\r\n}\r\nexports.expApproxRemoveLeadingZeros = expApproxRemoveLeadingZeros;\r\n//# sourceMappingURL=remove-leading-zeros.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/remove-leading-zeros.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/subtract.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/subtract.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ./remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns an approximate result of subtracting the second polynomial from first (p1 - p2).\r\n * @param p1 the polynomial from which will be subtracted\r\n * @param p2 the polynomial that will be subtracted\r\n * @example\r\n * subtract([2,3],[4,4]); //=> [-2, -1]\r\n */\r\nfunction subtract(p1, p2) {\r\n    // Initialize result array  \r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let Δd = d1 - d2;\r\n    let Δd1 = 0;\r\n    let Δd2 = 0;\r\n    if (Δd > 0) {\r\n        Δd2 = -Δd;\r\n    }\r\n    else if (Δd < 0) {\r\n        Δd1 = +Δd;\r\n    }\r\n    let d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let c1 = p1[i + Δd1] || 0;\r\n        let c2 = p2[i + Δd2] || 0;\r\n        result.push(c1 - c2);\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return remove_leading_zeros_1.removeLeadingZeros(result);\r\n}\r\nexports.subtract = subtract;\r\n/**\r\n * Returns the exact result of subtracting the second polynomial from first (p1 - p2).\r\n * @param p1 the polynomial from which will be subtracted\r\n * @param p2 the polynomial that will be subtracted\r\n * @example\r\n * subtract([[2],[3]],[[4],[4]]); //=> [[-2], [-1]]\r\n */\r\nfunction subtractExact(p1, p2) {\r\n    // Initialize result array  \r\n    let d1 = p1.length - 1;\r\n    let d2 = p2.length - 1;\r\n    let Δd = d1 - d2;\r\n    let Δd1 = 0;\r\n    let Δd2 = 0;\r\n    if (Δd > 0) {\r\n        Δd2 = -Δd;\r\n    }\r\n    else if (Δd < 0) {\r\n        Δd1 = +Δd;\r\n    }\r\n    let d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    let result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let c1 = p1[i + Δd1] || [0];\r\n        let c2 = p2[i + Δd2] || [0];\r\n        result.push(flo_numerical_1.expansionDiff(c1, c2));\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return remove_leading_zeros_1.expRemoveLeadingZeros(result);\r\n}\r\nexports.subtractExact = subtractExact;\r\n//# sourceMappingURL=subtract.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/subtract.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/basic/to-cas-str.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-poly/node/basic/to-cas-str.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns a string representing the given polynomial that is readable by a\r\n * human or a CAS (Computer Algebra System).\r\n * @param p a polynomial\r\n * @example\r\n * toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n */\r\nfunction toCasStr(p) {\r\n    let d = p.length - 1;\r\n    let str = '';\r\n    for (let i = 0; i < d + 1; i++) {\r\n        let v = Array.isArray(p[i]) ? flo_numerical_1.estimate(p[i]) : p[i];\r\n        let cStr = numberToString(Math.abs(v));\r\n        cStr = (v >= 0 ? ' + ' : ' - ') + cStr;\r\n        if (i === d) {\r\n            str += cStr;\r\n        }\r\n        else if (i === d - 1) {\r\n            str += cStr + '*x';\r\n        }\r\n        else {\r\n            str += cStr + '*x^' + (d - i).toString();\r\n        }\r\n    }\r\n    return str;\r\n}\r\nexports.toCasStr = toCasStr;\r\n/** from https://stackoverflow.com/a/46545519/2010061 */\r\nfunction numberToString(num) {\r\n    let numStr = String(num);\r\n    if (Math.abs(num) < 1.0) {\r\n        let e = parseInt(num.toString().split('e-')[1]);\r\n        if (e) {\r\n            let negative = num < 0;\r\n            if (negative)\r\n                num *= -1;\r\n            num *= Math.pow(10, e - 1);\r\n            numStr = '0.' + (new Array(e)).join('0') + num.toString().substring(2);\r\n            if (negative)\r\n                numStr = \"-\" + numStr;\r\n        }\r\n    }\r\n    else {\r\n        let e = parseInt(num.toString().split('+')[1]);\r\n        if (e > 20) {\r\n            e -= 20;\r\n            num /= Math.pow(10, e);\r\n            numStr = num.toString() + (new Array(e + 1)).join('0');\r\n        }\r\n    }\r\n    return numStr;\r\n}\r\n//# sourceMappingURL=to-cas-str.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/basic/to-cas-str.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/calculus/differentiate.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-poly/node/calculus/differentiate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst gamma_1 = __webpack_require__(/*! ../error-analysis/gamma */ \"./node_modules/flo-poly/node/error-analysis/gamma.js\");\r\nconst abs = Math.abs;\r\n/**\r\n * Returns the approximate result of differentiating the given polynomial.\r\n * @param p a polynomial\r\n * @example\r\n * differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\r\nfunction differentiate(p) {\r\n    let result = [];\r\n    let d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push((d - i) * p[i]);\r\n    }\r\n    return result;\r\n}\r\nexports.differentiate = differentiate;\r\n/**\r\n * Returns the result of differentiating the given polynomial in quad precision.\r\n * @param p a polynomial\r\n * @example\r\n * differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\r\nfunction differentiateQuad(p) {\r\n    let result = [];\r\n    let d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push(flo_numerical_1.qMultDouble2((d - i), p[i]));\r\n    }\r\n    return result;\r\n}\r\nexports.differentiateQuad = differentiateQuad;\r\n/**\r\n * * precondition: max degree of p === 9\r\n * @param p a quad precision polynomial\r\n * @param pE\r\n */\r\nfunction differentiateQuadWithError({ p, pE }) {\r\n    let dp = [];\r\n    let dpE = [];\r\n    let d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        let deg = d - i;\r\n        let c = flo_numerical_1.qMultDouble2(deg, p[i]);\r\n        dp.push(c);\r\n        // if 1,2,4 or 8, etc. then no additional error occurs on multiply\r\n        // if 3,5,7 or 9, etc. then additional error occurs\r\n        // deg is a power of 2 <=> (deg & deg-1) === 0\r\n        let extraErr = (deg & deg - 1) === 0 ? 0 : gamma_1.γγ3;\r\n        let $c = flo_numerical_1.estimate(c);\r\n        dpE.push(\r\n        //deg * (pE[i] + Math.abs($c)*extraErr)\r\n        deg * pE[i] + abs($c) * extraErr);\r\n    }\r\n    return { p: dp, pE: dpE };\r\n}\r\nexports.differentiateQuadWithError = differentiateQuadWithError;\r\n/**\r\n * Returns the exact result of differentiating the given polynomial.\r\n * @param p a polynomial\r\n * @example\r\n * differentiate([[5], [4], [3], [2], [1]]); //=> [[20], [12], [6], [2]]\r\n */\r\nfunction differentiateExact(p) {\r\n    let result = [];\r\n    let d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push(flo_numerical_1.scaleExpansion(p[i], d - i));\r\n    }\r\n    return result;\r\n}\r\nexports.differentiateExact = differentiateExact;\r\n//# sourceMappingURL=differentiate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/calculus/differentiate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/change-variables/change-variables-dilate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-poly/node/change-variables/change-variables-dilate.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate result of performing a change of variables of the form: p(x) <- p(ax).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param a\r\n * @example\r\n * changeVariablesDilate([1,2,7], 3); //=> [9, 6, 7]\r\n */\r\nfunction changeVariablesDilate(p, a) {\r\n    // We let the coefficients of p(ax) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = 0;\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = t[i][j] * p[d - j];\r\n            res[d - i] += acc;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesDilate = changeVariablesDilate;\r\n/**\r\n * Returns the exact result of performing a change of variables of the form: p(x) <- p(ax).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param a\r\n * @example\r\n * changeVariables([[1],[2],[7]], [3]); //=> [[9], [6], [7]]\r\n */\r\nfunction changeVariablesDilateExactExp(p, a) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = [0];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = flo_numerical_1.expansionProduct(a, t[i - 1][j - 1]);\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = flo_numerical_1.expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = flo_numerical_1.fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesDilateExactExp = changeVariablesDilateExactExp;\r\n/**\r\n * Returns the exact result of performing a change of variables of the form: p(x) <- p(ax).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param a\r\n * @example\r\n * changeVariables([[1],[2],[7]], 3); //=> [[9], [6], [7]]\r\n */\r\nfunction changeVariablesDilateExact(p, a) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = [0];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = flo_numerical_1.scaleExpansion2(a, t[i - 1][j - 1]);\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = flo_numerical_1.expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = flo_numerical_1.fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesDilateExact = changeVariablesDilateExact;\r\n//# sourceMappingURL=change-variables-dilate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/change-variables/change-variables-dilate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/change-variables/change-variables-linear.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-poly/node/change-variables/change-variables-linear.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate result of performing a change of variables of the form: p(x) <- p(ax + b).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param a\r\n * @param b\r\n * @example\r\n * changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\r\n */\r\nfunction changeVariablesLinear(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \r\n    // code below. \r\n    // d_i is calculated as d = T*c, where c are the original \r\n    // coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = t[i][j] * p[d - j];\r\n            res[d - i] += acc;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesLinear = changeVariablesLinear;\r\n/**\r\n * Returns the exact result of performing a change of variables of the form: p(x) <- p(ax + b).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param a\r\n * @param b\r\n * @example\r\n * changeVariables([[1],[2],[7]], [3], [4]); //=> [[9], [30], [31]]\r\n */\r\nfunction changeVariablesLinearExactExp(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = flo_numerical_1.expansionProduct(b, t[0][j - 1]);\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = flo_numerical_1.fastExpansionSum(flo_numerical_1.expansionProduct(b, t[i][j - 1]), flo_numerical_1.expansionProduct(a, t[i - 1][j - 1]));\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = flo_numerical_1.expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = flo_numerical_1.fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesLinearExactExp = changeVariablesLinearExactExp;\r\n/**\r\n * Returns the exact result of performing a change of variables of the form: p(x) <- p(ax + b).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param a\r\n * @param b\r\n * @example\r\n * changeVariables([[1],[2],[7]], 3, 4); //=> [[9], [30], [31]]\r\n */\r\nfunction changeVariablesLinearExact(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = flo_numerical_1.scaleExpansion2(b, t[0][j - 1]);\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion2(b, t[i][j - 1]), flo_numerical_1.scaleExpansion2(a, t[i - 1][j - 1]));\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = flo_numerical_1.expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = flo_numerical_1.fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesLinearExact = changeVariablesLinearExact;\r\n//# sourceMappingURL=change-variables-linear.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/change-variables/change-variables-linear.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/change-variables/change-variables-translate-x.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/change-variables/change-variables-translate-x.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate result of performing a change of variables of the form: p(x) <- p(x + b).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param b\r\n * @example\r\n * changeVariablesTranslateX([1,2,7], 3); //=> [1, 8, 22]\r\n */\r\nfunction changeVariablesTranslateX(p, b) {\r\n    // We let the coefficients of p(x + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = t[i][j] * p[d - j];\r\n            res[d - i] += acc;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesTranslateX = changeVariablesTranslateX;\r\n/**\r\n * Returns the exact result of performing a change of variables of the form: p(x) <- p(x + b).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param b\r\n */\r\nfunction changeVariablesTranslateXExact(p, b) {\r\n    // We let the coefficients of p(x + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = flo_numerical_1.scaleExpansion2(b, t[0][j - 1]);\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = flo_numerical_1.fastExpansionSum(flo_numerical_1.scaleExpansion2(b, t[i][j - 1]), t[i - 1][j - 1]);\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = flo_numerical_1.expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = flo_numerical_1.fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesTranslateXExact = changeVariablesTranslateXExact;\r\n/**\r\n * Returns the exact result of performing a change of variables of the form: p(x) <- p(x + b).\r\n * See this stackoverflow question http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\r\n * @param p a polynomial\r\n * @param b\r\n */\r\nfunction changeVariablesTranslateXExactExp(p, b) {\r\n    // We let the coefficients of p(x + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    let d = p.length - 1;\r\n    // Initialize a zero matrix\r\n    let t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = flo_numerical_1.expansionProduct(b, t[0][j - 1]);\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = flo_numerical_1.fastExpansionSum(flo_numerical_1.expansionProduct(b, t[i][j - 1]), t[i - 1][j - 1]);\r\n        }\r\n    }\r\n    // Multiply\r\n    let res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            let acc = flo_numerical_1.expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = flo_numerical_1.fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.changeVariablesTranslateXExactExp = changeVariablesTranslateXExactExp;\r\n//# sourceMappingURL=change-variables-translate-x.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/change-variables/change-variables-translate-x.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/change-variables/reflect-about-y-axis.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/change-variables/reflect-about-y-axis.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the result of reflecting the given polynomial about the Y-axis, i.e.\r\n * perform the change of variables: p(x) <- p(-x).\r\n * @param p a polynomial to reflect\r\n * @example\r\n * reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n */\r\nfunction reflectAboutYAxis(p) {\r\n    let d = p.length - 1;\r\n    let result = p.slice();\r\n    for (let i = 0; i < d + 1; i++) {\r\n        if (i % 2) {\r\n            result[i] = -result[i];\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.reflectAboutYAxis = reflectAboutYAxis;\r\n/**\r\n * Returns the result of reflecting the given polynomial about the Y-axis, i.e.\r\n * perform the change of variables: p(x) <- p(-x).\r\n * @param p a polynomial to reflect\r\n * @example\r\n * expReflectAboutYAxis([[5],[4],[3],[2],[1]]); //=> [[5], [-4], [3], [-2], [1]]\r\n */\r\nfunction expReflectAboutYAxis(p) {\r\n    let d = p.length - 1;\r\n    let result = p.slice();\r\n    for (let i = 0; i < d + 1; i++) {\r\n        if (i % 2) {\r\n            result[i] = flo_numerical_1.negativeOf(result[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.expReflectAboutYAxis = expReflectAboutYAxis;\r\n//# sourceMappingURL=reflect-about-y-axis.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/change-variables/reflect-about-y-axis.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/debug/debug.js":
/*!***************************************************!*\
  !*** ./node_modules/flo-poly/node/debug/debug.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst draw_elem_1 = __webpack_require__(/*! ./draw-elem/draw-elem */ \"./node_modules/flo-poly/node/debug/draw-elem/draw-elem.js\");\r\nclass PolyDebug {\r\n    /**\r\n     * @param config - configuration settings.\r\n     * @param fs - some useful functions.\r\n     * @private\r\n     */\r\n    constructor(g) {\r\n        this.g = g;\r\n        //-----------------------------------------------\r\n        // Generated by debug object for later inspection\r\n        //-----------------------------------------------\r\n        this.generated = {\r\n            elems: {\r\n                testPoint: [],\r\n            }\r\n        };\r\n        this.fs = {\r\n            drawElem: draw_elem_1.drawElemFunctions,\r\n        };\r\n    }\r\n}\r\nexports.PolyDebug = PolyDebug;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/debug/debug.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/debug/draw-elem/draw-elem.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-poly/node/debug/draw-elem/draw-elem.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_draw_1 = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\r\nfunction testPoint(g, p) {\r\n    let $elems = flo_draw_1.drawFs.crossHair(g, p, 'red thin5 nofill', 0.1);\r\n    return $elems;\r\n}\r\nlet drawElemFunctions = {\r\n    testPoint\r\n};\r\nexports.drawElemFunctions = drawElemFunctions;\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/debug/draw-elem/draw-elem.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/error-analysis/condition-number.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-poly/node/error-analysis/condition-number.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst abs_coeff_1 = __webpack_require__(/*! ../basic/abs-coeff */ \"./node_modules/flo-poly/node/basic/abs-coeff.js\");\r\nconst evaluate_exact_1 = __webpack_require__(/*! ../evaluate/evaluate-exact */ \"./node_modules/flo-poly/node/evaluate/evaluate-exact.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns an accurate estimate of the condition number of the given polynomial.\r\n * * for testing purposes\r\n * @param p a polynomial\r\n */\r\nfunction conditionNumber(p, x) {\r\n    let pN = abs_coeff_1.absCoeff(p).map(x => [x]);\r\n    let pD = p.map(x => [x]);\r\n    let N = evaluate_exact_1.evaluateExact(pN, [x]);\r\n    let D = evaluate_exact_1.evaluateExact(pD, [x]);\r\n    return Math.abs(flo_numerical_1.estimate(N) / flo_numerical_1.estimate(D));\r\n}\r\nexports.conditionNumber = conditionNumber;\r\n//# sourceMappingURL=condition-number.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/error-analysis/condition-number.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/error-analysis/gamma.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-poly/node/error-analysis/gamma.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst u = Number.EPSILON / 2;\r\nconst uu = Math.pow((Number.EPSILON / 2), 2);\r\n/**\r\n * The canonical floating point error function, γ.\r\n * see e.g. https://hal.archives-ouvertes.fr/hal-00285603/document\r\n *\r\n * * γ is multiplied by (1+u) since it is calculated in floating point so we\r\n * must ensure it is bigger than the real value.\r\n * @param k the parameter\r\n */\r\nfunction γ(n) {\r\n    let nu = n * u;\r\n    return nu / (1 - nu);\r\n}\r\nexports.γ = γ;\r\nfunction γγ(n) {\r\n    let nuu = n * uu;\r\n    return nuu / (1 - nuu);\r\n}\r\nexports.γγ = γγ;\r\nconst γ1 = γ(1);\r\nexports.γ1 = γ1;\r\nconst γ2 = γ(2);\r\nexports.γ2 = γ2;\r\nconst γ3 = γ(3);\r\nexports.γ3 = γ3;\r\nconst γ4 = γ(4);\r\nexports.γ4 = γ4;\r\nconst γ5 = γ(5);\r\nexports.γ5 = γ5;\r\nconst γ6 = γ(6);\r\nexports.γ6 = γ6;\r\nconst γ7 = γ(7);\r\nexports.γ7 = γ7;\r\nconst γ8 = γ(8);\r\nexports.γ8 = γ8;\r\nconst γ9 = γ(9);\r\nexports.γ9 = γ9;\r\nconst γ10 = γ(10);\r\nexports.γ10 = γ10;\r\nconst γ11 = γ(11);\r\nexports.γ11 = γ11;\r\nconst γ12 = γ(12);\r\nexports.γ12 = γ12;\r\nconst γ13 = γ(13);\r\nexports.γ13 = γ13;\r\nconst γ14 = γ(14);\r\nexports.γ14 = γ14;\r\nconst γ25 = γ(25);\r\nconst γ39 = γ(39);\r\nconst γγ1 = γγ(1);\r\nexports.γγ1 = γγ1;\r\nconst γγ2 = γγ(2);\r\nexports.γγ2 = γγ2;\r\nconst γγ3 = γγ(3);\r\nexports.γγ3 = γγ3;\r\nconst γγ4 = γγ(4);\r\nexports.γγ4 = γγ4;\r\nconst γγ5 = γγ(5);\r\nexports.γγ5 = γγ5;\r\nconst γγ6 = γγ(6);\r\nexports.γγ6 = γγ6;\r\nconst γγ7 = γγ(7);\r\nexports.γγ7 = γγ7;\r\nconst γγ8 = γγ(8);\r\nexports.γγ8 = γγ8;\r\nconst γγ9 = γγ(9);\r\nexports.γγ9 = γγ9;\r\nconst γγ10 = γγ(10);\r\nexports.γγ10 = γγ10;\r\nconst γγ11 = γγ(11);\r\nexports.γγ11 = γγ11;\r\nconst γγ12 = γγ(12);\r\nexports.γγ12 = γγ12;\r\nconst γγ13 = γγ(13);\r\nexports.γγ13 = γγ13;\r\nconst γγ14 = γγ(14);\r\nexports.γγ14 = γγ14;\r\n//# sourceMappingURL=gamma.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/error-analysis/gamma.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/euclidean-division/euclidean-division.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/euclidean-division/euclidean-division.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst degree_1 = __webpack_require__(/*! ../basic/degree */ \"./node_modules/flo-poly/node/basic/degree.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst exp_elevate_degree_1 = __webpack_require__(/*! ./exp-elevate-degree */ \"./node_modules/flo-poly/node/euclidean-division/exp-elevate-degree.js\");\r\nconst add_1 = __webpack_require__(/*! ../basic/add */ \"./node_modules/flo-poly/node/basic/add.js\");\r\nconst multiply_1 = __webpack_require__(/*! ../basic/multiply */ \"./node_modules/flo-poly/node/basic/multiply.js\");\r\nconst subtract_1 = __webpack_require__(/*! ../basic/subtract */ \"./node_modules/flo-poly/node/basic/subtract.js\");\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ../basic/remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\n/**\r\n * Returns the Euclidean remainder.\r\n *\r\n * Performs Euclidean (i.e. long) division on the two given polynomials, a/b,\r\n * and returns r in the formula a = bq + r, where degree(r) < degree(b). q is\r\n * called the quotient and r the remainder.\r\n *\r\n * A precondition is that b !== [0], i.e. unequal to the zero polynomial.\r\n * see https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences\r\n * @param a the polynomial a in the formula a = bq + r\r\n * @param b the polynomial b in the formula a = bq + r\r\n */\r\nfunction rem(a, b) {\r\n    let q = [];\r\n    let d = degree_1.degree(b);\r\n    let c = b[0];\r\n    let r = a;\r\n    while (true) {\r\n        let deg = degree_1.degree(r) - d;\r\n        // The division below is guaranteed to be exact\r\n        let s = [flo_numerical_1.expansionDiv(r[0], c, 0)];\r\n        s = exp_elevate_degree_1.expElevateDegree(s, deg);\r\n        q = add_1.addExact(q, s);\r\n        let m = multiply_1.multiplyExact([s, b]);\r\n        let n = subtract_1.subtractExact(r, m);\r\n        r = remove_leading_zeros_1.expApproxRemoveLeadingZeros(n);\r\n        if (deg <= 0) {\r\n            return { q, r };\r\n        }\r\n    }\r\n}\r\nexports.rem = rem;\r\n//# sourceMappingURL=euclidean-division.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/euclidean-division/euclidean-division.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/euclidean-division/exp-elevate-degree.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/euclidean-division/exp-elevate-degree.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction expElevateDegree(p, deg) {\r\n    let p_ = p.slice();\r\n    for (let i = 0; i < deg; i++) {\r\n        p_.push([0]);\r\n    }\r\n    return p_;\r\n}\r\nexports.expElevateDegree = expElevateDegree;\r\n//# sourceMappingURL=exp-elevate-degree.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/euclidean-division/exp-elevate-degree.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/abs-horner.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/abs-horner.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst abs = Math.abs;\r\n/**\r\n * Returns the approximate result of evaluating a univariate polynomial using\r\n * Horner's method and where the absolute value of each coefficient is taken.\r\n */\r\nfunction AbsHorner(p, x) {\r\n    let q = abs(p[0]);\r\n    for (let i = 1; i < p.length; i++) {\r\n        q = q * x + abs(p[i]);\r\n    }\r\n    return q;\r\n}\r\nexports.AbsHorner = AbsHorner;\r\n//# sourceMappingURL=abs-horner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/abs-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/comp-horner-is-faithful.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/comp-horner-is-faithful.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eft_horner_1 = __webpack_require__(/*! ./eft-horner */ \"./node_modules/flo-poly/node/evaluate/eft-horner.js\");\r\nconst horner_sum_1 = __webpack_require__(/*! ./horner-sum */ \"./node_modules/flo-poly/node/evaluate/horner-sum.js\");\r\nconst horner_abs_sum_1 = __webpack_require__(/*! ./horner-abs-sum */ \"./node_modules/flo-poly/node/evaluate/horner-abs-sum.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst gammas_1 = __webpack_require__(/*! ./gammas */ \"./node_modules/flo-poly/node/evaluate/gammas.js\");\r\nlet u = Number.EPSILON;\r\n/**\r\n * Returns the result of evaluating a univariate polynomial using once compensated\r\n * Horner's method, including a dynamic check for faithfull rounding and a\r\n * certified running error bound.\r\n *\r\n * @param p a polynomial\r\n * @param x the value at which to evaluate the polynomial\r\n */\r\nfunction compHornerIsFaithful(p, x) {\r\n    let n = p.length - 1;\r\n    let { r̂, pπ, pσ } = eft_horner_1.EFTHorner(p, x);\r\n    let ĉ = horner_sum_1.HornerSum(pπ, pσ, x);\r\n    let [e, r̄] = flo_numerical_1.twoSum(r̂, ĉ);\r\n    let b̂ = horner_abs_sum_1.HornerAbsSum(pπ, pσ, Math.abs(x));\r\n    let α̂ = (gammas_1.γs[2 * n - 1] * b̂) / ((1 - 2 * (n + 1) * u));\r\n    let β̂ = (α̂ + Math.abs(e)) / (1 - 2 * u);\r\n    return {\r\n        isFaithful: α̂ < (u / 2) * Math.abs(r̄),\r\n        errBound: β̂,\r\n        r̄\r\n    };\r\n}\r\nexports.compHornerIsFaithful = compHornerIsFaithful;\r\n//# sourceMappingURL=comp-horner-is-faithful.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/comp-horner-is-faithful.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/comp-horner-k.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/comp-horner-k.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sum_k_1 = __webpack_require__(/*! ./sum-k */ \"./node_modules/flo-poly/node/evaluate/sum-k.js\");\r\nconst eft_horner_k_1 = __webpack_require__(/*! ./eft-horner.k */ \"./node_modules/flo-poly/node/evaluate/eft-horner.k.js\");\r\nconst horner_1 = __webpack_require__(/*! ./horner */ \"./node_modules/flo-poly/node/evaluate/horner.js\");\r\n/**\r\n * see https://hal.archives-ouvertes.fr/hal-00285603/document\r\n *\r\n * For K-times compensated with K <= 4 this is the fastest known method, but\r\n * grows exponentially with K.\r\n * @param p\r\n * @param x\r\n * @param K\r\n */\r\nfunction CompHornerK(p, x, K) {\r\n    K = Math.min(p.length - 1, K);\r\n    let { hs, ps } = eft_horner_k_1.EFTHornerK(p, x, K);\r\n    let leafStart = Math.pow(2, (K - 1)); // cardinality and start of the leaves\r\n    for (let i = 0; i < leafStart; i++) {\r\n        hs.push(horner_1.Horner(ps[leafStart + i], x));\r\n    }\r\n    let r̄ = sum_k_1.SumK(hs, K);\r\n    return r̄;\r\n}\r\nexports.CompHornerK = CompHornerK;\r\n//# sourceMappingURL=comp-horner-k.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/comp-horner-k.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/comp-horner.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/comp-horner.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eft_horner_1 = __webpack_require__(/*! ./eft-horner */ \"./node_modules/flo-poly/node/evaluate/eft-horner.js\");\r\nconst horner_sum_1 = __webpack_require__(/*! ./horner-sum */ \"./node_modules/flo-poly/node/evaluate/horner-sum.js\");\r\n/**\r\n * Returns a result of evaluating a univariate polynomial using once compensated\r\n * Horner's method.\r\n *\r\n * see https://hal.archives-ouvertes.fr/hal-00107222/document\r\n * (Faithful Polynomial Evaluation with Compensated Horner Algorithm)\r\n * Philippe Langlois, Nicolas Louvet. Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f\r\n *\r\n * See https://en.wikipedia.org/wiki/Horner%27s_method\r\n * @param p a polynomial\r\n * @param x the value at which to evaluate the polynomial\r\n */\r\nfunction compHorner(p, x) {\r\n    let { r̂, pπ, pσ } = eft_horner_1.EFTHorner(p, x);\r\n    let ĉ = horner_sum_1.HornerSum(pπ, pσ, x);\r\n    return r̂ + ĉ;\r\n}\r\nexports.compHorner = compHorner;\r\n//# sourceMappingURL=comp-horner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/comp-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/eft-horner.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/eft-horner.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns an EFT (error free transformation) for the Horner evaluation of a\r\n * polymial at a specified x.\r\n * see https://hal.archives-ouvertes.fr/hal-00107222/document\r\n * (Faithful Polynomial Evaluation with Compensated Horner Algorithm)\r\n * Philippe Langlois, Nicolas Louvet. Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f\r\n */\r\nfunction EFTHorner(p, x) {\r\n    let pπ = []; // A polynomial containing part of the error\r\n    let pσ = []; // Another polynomial containing part of the error\r\n    let σ;\r\n    let r̂ = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        let [π, pi] = flo_numerical_1.twoProduct(r̂, x); // TODO - unroll all critical twoProduct and twoSum and fastTwoSums\r\n        [σ, r̂] = flo_numerical_1.twoSum(pi, p[i]);\r\n        // inlined\r\n        //r̂ = pi + p[i]; let bv = r̂ - pi; σ = (pi - (x-bv)) + (p[i]-bv);\r\n        pπ.push(π);\r\n        pσ.push(σ);\r\n    }\r\n    return { r̂, pπ, pσ };\r\n}\r\nexports.EFTHorner = EFTHorner;\r\n//# sourceMappingURL=eft-horner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/eft-horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/eft-horner.k.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/eft-horner.k.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eft_horner_1 = __webpack_require__(/*! ./eft-horner */ \"./node_modules/flo-poly/node/evaluate/eft-horner.js\");\r\nfunction EFTHornerK(p, x, K) {\r\n    let ps = [p];\r\n    let hs = [];\r\n    let card = (Math.pow(2, K)) - 1; // size of the tree, i.e. cardinality of the nodes\r\n    for (let i = 0; i < card; i++) {\r\n        let { r̂, pπ, pσ } = eft_horner_1.EFTHorner(ps[i], x);\r\n        hs.push(r̂);\r\n        ps.push(pπ);\r\n        ps.push(pσ);\r\n    }\r\n    return { hs, ps: ps.slice(Math.pow(2, (K - 1))) };\r\n}\r\nexports.EFTHornerK = EFTHornerK;\r\n//# sourceMappingURL=eft-horner.k.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/eft-horner.k.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eft_horner_1 = __webpack_require__(/*! ./eft-horner */ \"./node_modules/flo-poly/node/evaluate/eft-horner.js\");\r\nconst horner_with_running_error_1 = __webpack_require__(/*! ./horner-with-running-error */ \"./node_modules/flo-poly/node/evaluate/horner-with-running-error.js\");\r\nconst horner_1 = __webpack_require__(/*! ./horner */ \"./node_modules/flo-poly/node/evaluate/horner.js\");\r\nconst abs_horner_1 = __webpack_require__(/*! ./abs-horner */ \"./node_modules/flo-poly/node/evaluate/abs-horner.js\");\r\nconst gamma_1 = __webpack_require__(/*! ../error-analysis/gamma */ \"./node_modules/flo-poly/node/error-analysis/gamma.js\");\r\nconst abs = Math.abs;\r\n/**\r\n * Returns the result of evaluating the given polynomial at x such that the sign\r\n * is correct when positive or negative and not decidable when the sign is 0.\r\n * * if zero is returned then the result was too close to 0 to evaluate accurately.\r\n * @param p a multi-polynomial, ordered by most significant 'coefficients' first\r\n * @param pE an error polynomial - all coefficients must be positive\r\n * @param x an evaluation point\r\n * @param multiplier the error needs to be a multiple of this number smaller\r\n * than the evaluated value, otherwise zero is returned\r\n */\r\nfunction evalK1MultiWithErrBounds(p, pE, x, multiplier = 1) {\r\n    // first do a fast evaluation\r\n    let [r, e1] = horner_with_running_error_1.hornerWithRunningError(p[0], x);\r\n    let e2 = gamma_1.γ2 * abs_horner_1.AbsHorner(p[0], x); // the error due to not considering p[1]\r\n    let E = horner_1.Horner(pE, x); // error due to imprecision in coefficients\r\n    //let ee = e1+e2+maxE; // in difficult cases maxE can be larger than e1+e2\r\n    let ee = e1 + e2 + E; // in difficult cases maxE can be larger than e1+e2\r\n    if (ee * multiplier < abs(r)) {\r\n        // we are within bounds\r\n        return { r̂: r, e: ee };\r\n    }\r\n    // error is too large - do a more precise evaluation\r\n    let { r̂, pπ, pσ } = eft_horner_1.EFTHorner(p[0], x);\r\n    let [C1, c1] = horner_with_running_error_1.hornerWithRunningError(pπ, x);\r\n    let [C2, c2] = horner_with_running_error_1.hornerWithRunningError(pσ, x);\r\n    let [C3, c3] = horner_with_running_error_1.hornerWithRunningError(p[1], x);\r\n    let e = (c1 + c2 + c3) + E; // typically: c1,c2 < c3 < E\r\n    r̂ = (C1 + C2 + C3) + r̂; // typically: C1,C2 < C3 < r̂ and (C1 + C2 + C3 < r̂)\r\n    e += gamma_1.γ1 * r̂;\r\n    if (e * multiplier < abs(r̂)) {\r\n        return { r̂, e };\r\n    }\r\n    // error is still too large to return the correct sign (if multiplier === 1)\r\n    return { r̂: 0, e };\r\n}\r\nexports.evalK1MultiWithErrBounds = evalK1MultiWithErrBounds;\r\n//# sourceMappingURL=eval-k-multi-with-err-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/evaluate-at-0.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/evaluate-at-0.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the exact result of evaluating the given polynomial at 0 - it\r\n * is much faster than at an arbitrary point.\r\n * @param p a polynomial\r\n * @example\r\n * evaluateAt0([3,2,99]); //=> 99\r\n * evaluateAt0([[3],[2],[99]]); //=> [99]\r\n */\r\nfunction evaluateAt0(p) {\r\n    return p[p.length - 1];\r\n}\r\nexports.evaluateAt0 = evaluateAt0;\r\n/**\r\n * Returns the exact result of evaluating the given polynomial at 0 - it\r\n * is much faster than at an arbitrary point.\r\n * @param p a polynomial\r\n * @example\r\n * evaluateAt0([3,2,99]); //=> 99\r\n * evaluateAt0([[3],[2],[99]]); //=> [99]\r\n */\r\nfunction expEvaluateAt0(p) {\r\n    return p[p.length - 1];\r\n}\r\nexports.expEvaluateAt0 = expEvaluateAt0;\r\n//# sourceMappingURL=evaluate-at-0.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/evaluate-at-0.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/evaluate-at-1.js":
/*!**************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/evaluate-at-1.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the approximate result of evaluating the given polynomial at 1 - it\r\n * is much faster than at an arbitrary point.\r\n * @param p a polynomial\r\n */\r\nfunction evaluateAt1(p) {\r\n    let res = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        res += p[i];\r\n    }\r\n    return res;\r\n}\r\nexports.evaluateAt1 = evaluateAt1;\r\n/**\r\n * Returns the exact result of evaluating the given polynomial at 1 - it\r\n * is much faster than at an arbitrary point.\r\n * @param p a polynomial\r\n */\r\nfunction expEvaluateAt1(p) {\r\n    let res = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        res = flo_numerical_1.fastExpansionSum(res, p[i]);\r\n    }\r\n    return res;\r\n}\r\nexports.expEvaluateAt1 = expEvaluateAt1;\r\n//# sourceMappingURL=evaluate-at-1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/evaluate-at-1.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/evaluate-exact.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/evaluate-exact.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the exact (bar underflow/overflow) result of evaluating a univariate\r\n * polynomial using Horner's method.\r\n * @param p\r\n * @param a\r\n */\r\nfunction evaluateExact(p, a) {\r\n    if (p.length === 0) {\r\n        return [0];\r\n    }\r\n    let result = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        result = flo_numerical_1.fastExpansionSum(p[i], flo_numerical_1.expansionProduct(result, a));\r\n    }\r\n    return result;\r\n}\r\nexports.evaluateExact = evaluateExact;\r\n//# sourceMappingURL=evaluate-exact.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/evaluate-exact.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/evaluate.js":
/*!*********************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/evaluate.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Returns the approximate result of evaluating a univariate polynomial using\r\n * Horner's method.\r\n *\r\n * This function is curried (see examples below).\r\n *\r\n * See https://en.wikipedia.org/wiki/Horner%27s_method\r\n * @param p a polynomial\r\n * @param a the value at which to evaluate the polynomial.\r\n * @example\r\n * let ev = evaluate([3,2,1]);\r\n * ev(1); // => 6\r\n * ev(2); // => 17\r\n *\r\n * evaluate([3,2,1], 1); // => 6\r\n * evaluate([3,2,1], 2); // => 17\r\n *\r\n * evaluate([3,2,1])(1); // => 6\r\n * evaluate([3,2,1])(2); // => 17\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction evaluate(p, a) {\r\n    function f(a) {\r\n        if (p.length === 0) {\r\n            return 0;\r\n        }\r\n        let result = p[0];\r\n        for (let i = 1; i < p.length; i++) {\r\n            result = p[i] + result * a;\r\n        }\r\n        return result;\r\n    }\r\n    // Curry the function\r\n    return a === undefined ? f : f(a);\r\n}\r\nexports.evaluate = evaluate;\r\n//# sourceMappingURL=evaluate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/evaluate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/gammas.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/gammas.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nlet u = Number.EPSILON / 2;\r\n// pre-calculate standard error bound units\r\nlet γs = [];\r\nexports.γs = γs;\r\nγs.push(0);\r\nfor (let i = 1; i < 50; i++) {\r\n    // we multuply by 1+u since the calculation for γ itself is approximate\r\n    γs.push((1 + u) * (i * u / (1 - i * u)));\r\n}\r\n//# sourceMappingURL=gammas.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/gammas.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/horner-abs-sum.js":
/*!***************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/horner-abs-sum.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @param p1\r\n * @param p2\r\n */\r\nfunction HornerAbsSum(p1, p2, x) {\r\n    let q = Math.abs(p1[0] + p2[0]);\r\n    for (let i = 1; i < p1.length; i++) {\r\n        q = Math.abs(p1[i] + p2[i]) + q * x;\r\n    }\r\n    return q;\r\n}\r\nexports.HornerAbsSum = HornerAbsSum;\r\n//# sourceMappingURL=horner-abs-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/horner-abs-sum.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/horner-error-bound.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/horner-error-bound.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst max_abs_coeff_poly_eval_1 = __webpack_require__(/*! ./max-abs-coeff-poly-eval */ \"./node_modules/flo-poly/node/evaluate/max-abs-coeff-poly-eval.js\");\r\nconst gamma_1 = __webpack_require__(/*! ../error-analysis/gamma */ \"./node_modules/flo-poly/node/error-analysis/gamma.js\");\r\n/**\r\n * Classic rule of thumb error bound when using Horner's method to evaluate\r\n * polynomials.\r\n * see for instance compensated horner evaluation http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\"\r\n * @param p The polynomial\r\n * @param x Value at which polynomial is evaluated.\r\n */\r\nfunction hornerErrorBound(p, x) {\r\n    let n = p.length;\r\n    return gamma_1.γ(2 * n) * max_abs_coeff_poly_eval_1.maxAbsCoeffPolyEval(p, x);\r\n}\r\nexports.hornerErrorBound = hornerErrorBound;\r\n//# sourceMappingURL=horner-error-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/horner-error-bound.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/horner-exact.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/horner-exact.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the exact result of evaluating a univariate polynomial using\r\n * Horner's method.\r\n */\r\n// TODO - could possibly made faster using EFTs on the polynomial\r\nfunction HornerExact(p, x) {\r\n    //console.log('qqq')\r\n    //let q = p[0].slice(); \r\n    let q = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        q = flo_numerical_1.fastExpansionSum(p[i], flo_numerical_1.scaleExpansion(q, x));\r\n    }\r\n    //return q[q.length-1];\r\n    return flo_numerical_1.estimate(q);\r\n}\r\nexports.HornerExact = HornerExact;\r\n//# sourceMappingURL=horner-exact.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/horner-exact.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/horner-sum.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/horner-sum.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @param p1\r\n * @param p2\r\n */\r\nfunction HornerSum(p1, p2, a) {\r\n    let result = p1[0] + p2[0];\r\n    for (let i = 1; i < p1.length; i++) {\r\n        result = p1[i] + p2[i] + result * a;\r\n    }\r\n    return result;\r\n}\r\nexports.HornerSum = HornerSum;\r\n//# sourceMappingURL=horner-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/horner-sum.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/horner-with-running-error.js":
/*!**************************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/horner-with-running-error.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst abs = Math.abs;\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns the result of evaluating a polyniomial at a point x, including a\r\n * running error bound.\r\n * * see page 95 (at bottom) of Higham 2002 http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf\r\n *\r\n * @param p\r\n * @param x\r\n */\r\nfunction hornerWithRunningError(p, x) {\r\n    let r̂ = p[0];\r\n    let e = abs(r̂) / 2;\r\n    for (let i = 1; i < p.length; i++) {\r\n        r̂ = r̂ * x + p[i];\r\n        e = e * abs(x) + abs(r̂);\r\n    }\r\n    e = u * (2 * e - abs(r̂));\r\n    return [r̂, e];\r\n}\r\nexports.hornerWithRunningError = hornerWithRunningError;\r\n//# sourceMappingURL=horner-with-running-error.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/horner-with-running-error.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/horner.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/horner.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns the approximate result of evaluating a univariate polynomial using\r\n * Horner's method.\r\n */\r\nfunction Horner(p, x) {\r\n    let q = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        q = q * x + p[i];\r\n    }\r\n    return q;\r\n}\r\nexports.Horner = Horner;\r\n//# sourceMappingURL=horner.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/horner.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/max-abs-coeff-poly-eval.js":
/*!************************************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/max-abs-coeff-poly-eval.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst abs_coeff_1 = __webpack_require__(/*! ../basic/abs-coeff */ \"./node_modules/flo-poly/node/basic/abs-coeff.js\");\r\nconst horner_1 = __webpack_require__(/*! ./horner */ \"./node_modules/flo-poly/node/evaluate/horner.js\");\r\nconst gamma_1 = __webpack_require__(/*! ../error-analysis/gamma */ \"./node_modules/flo-poly/node/error-analysis/gamma.js\");\r\n/**\r\n * Returns an upper bound of evaluating the given polynomial (using Horner's\r\n * Algorithm) where all coefficients are made positive.\r\n * @param p a polynomial\r\n * @param x an evaluation point\r\n */\r\nfunction maxAbsCoeffPolyEval(p, x) {\r\n    p = abs_coeff_1.absCoeff(p);\r\n    return horner_1.Horner(p, Math.abs(x)) * (1 + gamma_1.γ1);\r\n}\r\nexports.maxAbsCoeffPolyEval = maxAbsCoeffPolyEval;\r\n//# sourceMappingURL=max-abs-coeff-poly-eval.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/max-abs-coeff-poly-eval.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/sum-k.js":
/*!******************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/sum-k.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vec_sum_1 = __webpack_require__(/*! ./vec-sum */ \"./node_modules/flo-poly/node/evaluate/vec-sum.js\");\r\n/**\r\n * see http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf\r\n * @param x\r\n * @param K\r\n */\r\nfunction SumK(p, K) {\r\n    for (let i = 1; i < K; i++) {\r\n        p = vec_sum_1.vecSum(p);\r\n    }\r\n    let res = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        res += p[i];\r\n    }\r\n    return res;\r\n}\r\nexports.SumK = SumK;\r\n//# sourceMappingURL=sum-k.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/sum-k.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/evaluate/vec-sum.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-poly/node/evaluate/vec-sum.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * see http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf\r\n * @param x\r\n * @param K\r\n */\r\nfunction vecSum(p_) {\r\n    let p = p_.slice();\r\n    for (let i = 1; i < p.length; i++) {\r\n        [p[i - 1], p[i]] = flo_numerical_1.twoSum(p[i], p[i - 1]);\r\n    }\r\n    return p;\r\n}\r\nexports.vecSum = vecSum;\r\n//# sourceMappingURL=vec-sum.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/evaluate/vec-sum.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/gcd/gcd-prs/gcd-prs.js":
/*!***********************************************************!*\
  !*** ./node_modules/flo-poly/node/gcd/gcd-prs/gcd-prs.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst subresultant_pseudo_remainder_sequence_1 = __webpack_require__(/*! ../../remainder-sequences/subresultant-pseudo-remainder-sequence */ \"./node_modules/flo-poly/node/remainder-sequences/subresultant-pseudo-remainder-sequence.js\");\r\nconst is_zero_1 = __webpack_require__(/*! ../../basic/is-zero */ \"./node_modules/flo-poly/node/basic/is-zero.js\");\r\n/**\r\n * Returns the gcd of the two given polynomials using Pseudo Remainder\r\n * Sequences (PRSs).\r\n * @param a a polynomial\r\n * @param b another polynomial\r\n */\r\nfunction gcdExact(a, b) {\r\n    let isZeroA = is_zero_1.expIsZero(a);\r\n    let isZeroB = is_zero_1.expIsZero(b);\r\n    if (isZeroA) {\r\n        return b;\r\n    }\r\n    else if (isZeroB) {\r\n        return a;\r\n    }\r\n    let seq = subresultant_pseudo_remainder_sequence_1.subresultantPseudoRemainderSequence(a, b, false);\r\n    return seq[seq.length - 1];\r\n}\r\nexports.gcdExact = gcdExact;\r\n//# sourceMappingURL=gcd-prs.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/gcd/gcd-prs/gcd-prs.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/flo-poly/node/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst equal_1 = __webpack_require__(/*! ./basic/equal */ \"./node_modules/flo-poly/node/basic/equal.js\");\r\nexports.equal = equal_1.equal;\r\nconst add_1 = __webpack_require__(/*! ./basic/add */ \"./node_modules/flo-poly/node/basic/add.js\");\r\nexports.add = add_1.add;\r\nconst subtract_1 = __webpack_require__(/*! ./basic/subtract */ \"./node_modules/flo-poly/node/basic/subtract.js\");\r\nexports.subtract = subtract_1.subtract;\r\nconst multiply_by_const_1 = __webpack_require__(/*! ./basic/multiply-by-const */ \"./node_modules/flo-poly/node/basic/multiply-by-const.js\");\r\nexports.multiplyByConst = multiply_by_const_1.multiplyByConst;\r\nconst negate_1 = __webpack_require__(/*! ./basic/negate */ \"./node_modules/flo-poly/node/basic/negate.js\");\r\nexports.negate = negate_1.negate;\r\nconst differentiate_1 = __webpack_require__(/*! ./calculus/differentiate */ \"./node_modules/flo-poly/node/calculus/differentiate.js\");\r\nexports.differentiate = differentiate_1.differentiate;\r\nconst multiply_1 = __webpack_require__(/*! ./basic/multiply */ \"./node_modules/flo-poly/node/basic/multiply.js\");\r\nexports.multiply = multiply_1.multiply;\r\nconst degree_1 = __webpack_require__(/*! ./basic/degree */ \"./node_modules/flo-poly/node/basic/degree.js\");\r\nexports.degree = degree_1.degree;\r\nconst gcd_prs_1 = __webpack_require__(/*! ./gcd/gcd-prs/gcd-prs */ \"./node_modules/flo-poly/node/gcd/gcd-prs/gcd-prs.js\");\r\nexports.gcdExact = gcd_prs_1.gcdExact;\r\nconst evaluate_1 = __webpack_require__(/*! ./evaluate/evaluate */ \"./node_modules/flo-poly/node/evaluate/evaluate.js\");\r\nexports.evaluate = evaluate_1.evaluate;\r\nconst evaluate_exact_1 = __webpack_require__(/*! ./evaluate/evaluate-exact */ \"./node_modules/flo-poly/node/evaluate/evaluate-exact.js\");\r\nexports.evaluateExact = evaluate_exact_1.evaluateExact;\r\nconst horner_1 = __webpack_require__(/*! ./evaluate/horner */ \"./node_modules/flo-poly/node/evaluate/horner.js\");\r\nexports.Horner = horner_1.Horner;\r\nconst comp_horner_1 = __webpack_require__(/*! ./evaluate/comp-horner */ \"./node_modules/flo-poly/node/evaluate/comp-horner.js\");\r\nexports.compHorner = comp_horner_1.compHorner;\r\nconst comp_horner_is_faithful_1 = __webpack_require__(/*! ./evaluate/comp-horner-is-faithful */ \"./node_modules/flo-poly/node/evaluate/comp-horner-is-faithful.js\");\r\nexports.compHornerIsFaithful = comp_horner_is_faithful_1.compHornerIsFaithful;\r\nconst is_const_multiple_of_1 = __webpack_require__(/*! ./basic/is-const-multiple-of */ \"./node_modules/flo-poly/node/basic/is-const-multiple-of.js\");\r\nexports.isConstMultipleOf = is_const_multiple_of_1.isConstMultipleOf;\r\nconst sum_k_1 = __webpack_require__(/*! ./evaluate/sum-k */ \"./node_modules/flo-poly/node/evaluate/sum-k.js\");\r\nexports.SumK = sum_k_1.SumK;\r\nconst comp_horner_k_1 = __webpack_require__(/*! ./evaluate/comp-horner-k */ \"./node_modules/flo-poly/node/evaluate/comp-horner-k.js\");\r\nexports.CompHornerK = comp_horner_k_1.CompHornerK;\r\nconst evaluate_at_0_1 = __webpack_require__(/*! ./evaluate/evaluate-at-0 */ \"./node_modules/flo-poly/node/evaluate/evaluate-at-0.js\");\r\nexports.evaluateAt0 = evaluate_at_0_1.evaluateAt0;\r\nconst sign_changes_1 = __webpack_require__(/*! ./roots/descartes/sign-changes */ \"./node_modules/flo-poly/node/roots/descartes/sign-changes.js\");\r\nexports.signChanges = sign_changes_1.signChanges;\r\nconst invert_1 = __webpack_require__(/*! ./basic/invert */ \"./node_modules/flo-poly/node/basic/invert.js\");\r\nexports.invert = invert_1.invert;\r\nconst change_variables_linear_1 = __webpack_require__(/*! ./change-variables/change-variables-linear */ \"./node_modules/flo-poly/node/change-variables/change-variables-linear.js\");\r\nexports.changeVariablesLinear = change_variables_linear_1.changeVariablesLinear;\r\nexports.changeVariablesLinearExactExp = change_variables_linear_1.changeVariablesLinearExactExp;\r\nexports.changeVariablesLinearExact = change_variables_linear_1.changeVariablesLinearExact;\r\nconst change_variables_translate_x_1 = __webpack_require__(/*! ./change-variables/change-variables-translate-x */ \"./node_modules/flo-poly/node/change-variables/change-variables-translate-x.js\");\r\nexports.changeVariablesTranslateX = change_variables_translate_x_1.changeVariablesTranslateX;\r\nexports.changeVariablesTranslateXExactExp = change_variables_translate_x_1.changeVariablesTranslateXExactExp;\r\nexports.changeVariablesTranslateXExact = change_variables_translate_x_1.changeVariablesTranslateXExact;\r\nconst change_variables_dilate_1 = __webpack_require__(/*! ./change-variables/change-variables-dilate */ \"./node_modules/flo-poly/node/change-variables/change-variables-dilate.js\");\r\nexports.changeVariablesDilate = change_variables_dilate_1.changeVariablesDilate;\r\nexports.changeVariablesDilateExactExp = change_variables_dilate_1.changeVariablesDilateExactExp;\r\nexports.changeVariablesDilateExact = change_variables_dilate_1.changeVariablesDilateExact;\r\nconst reflect_about_y_axis_1 = __webpack_require__(/*! ./change-variables/reflect-about-y-axis */ \"./node_modules/flo-poly/node/change-variables/reflect-about-y-axis.js\");\r\nexports.reflectAboutYAxis = reflect_about_y_axis_1.reflectAboutYAxis;\r\nconst sturm_chain_1 = __webpack_require__(/*! ./remainder-sequences/sturm-chain */ \"./node_modules/flo-poly/node/remainder-sequences/sturm-chain.js\");\r\nexports.sturmChain = sturm_chain_1.sturmChain;\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ./basic/remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\nexports.removeLeadingZeros = remove_leading_zeros_1.removeLeadingZeros;\r\nexports.approxRemoveLeadingZeros = remove_leading_zeros_1.approxRemoveLeadingZeros;\r\nexports.expRemoveLeadingZeros = remove_leading_zeros_1.expRemoveLeadingZeros;\r\nconst deflate_1 = __webpack_require__(/*! ./roots/deflate */ \"./node_modules/flo-poly/node/roots/deflate.js\");\r\nexports.deflate = deflate_1.deflate;\r\nexports.deflateQuad = deflate_1.deflateQuad;\r\nconst p_inf_norm_1 = __webpack_require__(/*! ./norm/p-inf-norm */ \"./node_modules/flo-poly/node/norm/p-inf-norm.js\");\r\nexports.pInfNorm = p_inf_norm_1.pInfNorm;\r\nconst to_cas_str_1 = __webpack_require__(/*! ./basic/to-cas-str */ \"./node_modules/flo-poly/node/basic/to-cas-str.js\");\r\nexports.toCasStr = to_cas_str_1.toCasStr;\r\nconst quadratic_roots_1 = __webpack_require__(/*! ./roots/quadratic-roots */ \"./node_modules/flo-poly/node/roots/quadratic-roots.js\");\r\nexports.quadraticRoots = quadratic_roots_1.quadraticRoots;\r\nconst num_roots_1 = __webpack_require__(/*! ./roots/descartes/num-roots */ \"./node_modules/flo-poly/node/roots/descartes/num-roots.js\");\r\nexports.numRootsInRange = num_roots_1.numRootsInRange;\r\nexports.numRootsInRangeExact = num_roots_1.numRootsInRangeExact;\r\nconst brent_1 = __webpack_require__(/*! ./roots/standard/brent */ \"./node_modules/flo-poly/node/roots/standard/brent.js\");\r\nexports.brent = brent_1.brent;\r\nconst bisection_1 = __webpack_require__(/*! ./roots/standard/bisection */ \"./node_modules/flo-poly/node/roots/standard/bisection.js\");\r\nexports.bisection = bisection_1.bisection;\r\nconst root_bounds_lmq_1 = __webpack_require__(/*! ./roots/root-bounds/root-bounds-lmq */ \"./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js\");\r\nexports.positiveRootUpperBound_LMQ = root_bounds_lmq_1.positiveRootUpperBound_LMQ;\r\nexports.positiveRootLowerBound_LMQ = root_bounds_lmq_1.positiveRootLowerBound_LMQ;\r\nexports.negativeRootUpperBound_LMQ = root_bounds_lmq_1.negativeRootUpperBound_LMQ;\r\nexports.negativeRootLowerBound_LMQ = root_bounds_lmq_1.negativeRootLowerBound_LMQ;\r\nconst root_magnitude_upper_bound_fujiwara_1 = __webpack_require__(/*! ./roots/root-bounds/root-magnitude-upper-bound-fujiwara */ \"./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js\");\r\nexports.rootMagnitudeUpperBound_fujiwara = root_magnitude_upper_bound_fujiwara_1.rootMagnitudeUpperBound_fujiwara;\r\nconst root_magnitude_upper_bound_rouche_1 = __webpack_require__(/*! ./roots/root-bounds/root-magnitude-upper-bound-rouche */ \"./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js\");\r\nexports.rootMagnitudeUpperBound_rouche = root_magnitude_upper_bound_rouche_1.rootMagnitudeUpperBound_rouche;\r\nconst all_roots_1 = __webpack_require__(/*! ./roots/standard/all-roots */ \"./node_modules/flo-poly/node/roots/standard/all-roots.js\");\r\nexports.allRoots = all_roots_1.allRoots;\r\nconst all_roots_multi_with_err_bounds_1 = __webpack_require__(/*! ./roots/multi-with-err-bound/all-roots-multi-with-err-bounds */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/all-roots-multi-with-err-bounds.js\");\r\nexports.allRootsMultiWithErrBounds = all_roots_multi_with_err_bounds_1.allRootsMultiWithErrBounds;\r\nconst refine_k1_1 = __webpack_require__(/*! ./roots/multi-with-err-bound/refine-k1 */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-k1.js\");\r\nexports.refineK1 = refine_k1_1.refineK1;\r\nconst random_1 = __webpack_require__(/*! ./random/random */ \"./node_modules/flo-poly/node/random/random.js\");\r\nexports.flatRoots = random_1.flatRoots;\r\nexports.flatRootsArr = random_1.flatRootsArr;\r\nexports.flatCoefficients = random_1.flatCoefficients;\r\nexports.flatCoefficientsArr = random_1.flatCoefficientsArr;\r\nexports.predictiveRandom = random_1.predictiveRandom;\r\nconst horner_error_bound_1 = __webpack_require__(/*! ./evaluate/horner-error-bound */ \"./node_modules/flo-poly/node/evaluate/horner-error-bound.js\");\r\nexports.hornerErrorBound = horner_error_bound_1.hornerErrorBound;\r\nconst horner_exact_1 = __webpack_require__(/*! ./evaluate/horner-exact */ \"./node_modules/flo-poly/node/evaluate/horner-exact.js\");\r\nexports.HornerExact = horner_exact_1.HornerExact;\r\nconst horner_with_running_error_1 = __webpack_require__(/*! ./evaluate/horner-with-running-error */ \"./node_modules/flo-poly/node/evaluate/horner-with-running-error.js\");\r\nexports.hornerWithRunningError = horner_with_running_error_1.hornerWithRunningError;\r\nconst max_abs_coeff_poly_eval_1 = __webpack_require__(/*! ./evaluate/max-abs-coeff-poly-eval */ \"./node_modules/flo-poly/node/evaluate/max-abs-coeff-poly-eval.js\");\r\nexports.maxAbsCoeffPolyEval = max_abs_coeff_poly_eval_1.maxAbsCoeffPolyEval;\r\nconst from_roots_1 = __webpack_require__(/*! ./roots/from-roots */ \"./node_modules/flo-poly/node/roots/from-roots.js\");\r\nexports.fromRoots = from_roots_1.fromRoots;\r\nconst condition_number_1 = __webpack_require__(/*! ./error-analysis/condition-number */ \"./node_modules/flo-poly/node/error-analysis/condition-number.js\");\r\nexports.conditionNumber = condition_number_1.conditionNumber;\r\nconst scale_float_to_int_1 = __webpack_require__(/*! ./scale-to-int/scale-float-to-int */ \"./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js\");\r\nexports.scaleFloatToInt = scale_float_to_int_1.scaleFloatToInt;\r\nconst scale_floats_to_ints_1 = __webpack_require__(/*! ./scale-to-int/scale-floats-to-ints */ \"./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js\");\r\nexports.scaleFloatsToInts = scale_floats_to_ints_1.scaleFloatsToInts;\r\nconst scale_poly_to_ints_1 = __webpack_require__(/*! ./scale-to-int/scale-poly-to-ints */ \"./node_modules/flo-poly/node/scale-to-int/scale-poly-to-ints.js\");\r\nexports.scalePolyToIntsExp = scale_poly_to_ints_1.scalePolyToIntsExp;\r\nconst eval_k_multi_with_err_bounds_1 = __webpack_require__(/*! ./evaluate/eval-k-multi-with-err-bounds */ \"./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js\");\r\nexports.evalK1MultiWithErrBounds = eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ \"./node_modules/flo-poly/node/debug/debug.js\");\r\nexports.PolyDebug = debug_1.PolyDebug;\r\nconst root_interval_1 = __webpack_require__(/*! ./roots/multi-with-err-bound/root-interval */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval.js\");\r\nexports.createRootExact = root_interval_1.createRootExact;\r\nexports.mid = root_interval_1.mid;\r\nconst root_interval_to_exp_1 = __webpack_require__(/*! ./roots/multi-with-err-bound/root-interval-to-exp */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval-to-exp.js\");\r\nexports.rootIntervalToExp = root_interval_to_exp_1.rootIntervalToExp;\r\nconst refine_multi_with_err_bounds_1 = __webpack_require__(/*! ./roots/multi-with-err-bound/refine-multi-with-err-bounds */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-multi-with-err-bounds.js\");\r\nexports.refineMultiWithErrBounds = refine_multi_with_err_bounds_1.refineMultiWithErrBounds;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/norm/p-inf-norm.js":
/*!*******************************************************!*\
  !*** ./node_modules/flo-poly/node/norm/p-inf-norm.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the p-infinity norm, i.e. the maximum magnitude absolute value within\r\n * the given array of coefficients.\r\n */\r\nfunction pInfNorm(p) {\r\n    let max = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        let v = Math.abs(p[i]);\r\n        if (v > max) {\r\n            max = v;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nexports.pInfNorm = pInfNorm;\r\n/**\r\n * Returns the absolute value of the highest coefficient of the polynomial.\r\n * @param p a polynomial.\r\n */\r\nfunction expPInfNorm(p) {\r\n    let max = [0];\r\n    for (let i = 0; i < p.length; i++) {\r\n        let v = flo_numerical_1.abs(p[i]);\r\n        if (flo_numerical_1.compare(v, max) > 0) {\r\n            max = v;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n//# sourceMappingURL=p-inf-norm.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/norm/p-inf-norm.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/random/random.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-poly/node/random/random.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst from_roots_1 = __webpack_require__(/*! ../roots/from-roots */ \"./node_modules/flo-poly/node/roots/from-roots.js\");\r\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\r\nconst SEED = 123456789;\r\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\r\nconst RANGE = 4294967296;\r\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n * @private\r\n * @param f\r\n */\r\nfunction createArrFunction(f) {\r\n    return function (n, d, a, b, seed = SEED, odds = 0) {\r\n        let res = [];\r\n        for (let i = 0; i < n; i++) {\r\n            let v = f(d, a, b, seed, odds);\r\n            let p = v.p;\r\n            seed = v.seed;\r\n            res.push(p);\r\n        }\r\n        return res;\r\n    };\r\n}\r\n/**\r\n * Generates an array of random polynomials with parameters as specified\r\n * by flatRoots. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to\r\n * improve testability.\r\n * @memberof Random\r\n * @param n - The number of polynomials to generate.\r\n * @param d - The degree of the polynomials\r\n * @param a - The lower bound of the distribution - defaults\r\n * to 0\r\n * @param b - The upper bound of the distribution - defaults\r\n * to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @example\r\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n */\r\nlet flatRootsArr = createArrFunction(flatRoots);\r\nexports.flatRootsArr = flatRootsArr;\r\n/**\r\n * Generates and returns an array of random polynomials as specified by\r\n * flatCoefficients. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to\r\n * improve testability.\r\n *\r\n * @memberof Random\r\n * @param n The number of polynomials to generate.\r\n * @param d The degree of the polynomials\r\n * @param a The lower bound of the distribution - defaults to 0\r\n * @param b The upper bound of the distribution - defaults to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @example\r\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n */\r\nlet flatCoefficientsArr = createArrFunction(flatCoefficients);\r\nexports.flatCoefficientsArr = flatCoefficientsArr;\r\n/**\r\n * Returns a quasi-random number to be used as the next input to this function.\r\n * See https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\r\n * @private\r\n * @param seed\r\n */\r\nfunction predictiveRandom(seed) {\r\n    const a = 134775813;\r\n    return (a * seed + 1) % RANGE;\r\n}\r\nexports.predictiveRandom = predictiveRandom;\r\n/**\r\n * Generates a random array of numbers picked from a bounded flat\r\n * distribution (i.e. a rectangular distribution) with specified odds of\r\n * duplication of consecutive values.\r\n *\r\n * @ignore\r\n * @param n - The number of values to generate.\r\n * @param a - The lower bound of the distribution - defaults\r\n * to 0\r\n * @param b - The upper bound of the distribution - defaults\r\n * to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n */\r\nfunction randomArray(n, a, b, seed = SEED, odds = 0) {\r\n    let vs = [];\r\n    for (let i = 0; i < n; i++) {\r\n        seed = predictiveRandom(seed);\r\n        let v = ((seed / RANGE) * (b - a)) + a;\r\n        seed = push(seed, vs, v, odds);\r\n    }\r\n    vs = vs.slice(0, n);\r\n    return { vs, seed };\r\n}\r\n/**\r\n * Helper function that will add more numbers to the passed array - modifies the\r\n * values parameter.\r\n * @private\r\n * @param seed\r\n * @param values - An existing array of values - will be modified!\r\n * @param x - The number that will be added (possibly multiple times)\r\n * @param odds - The odds that the number will be added again (recursively).\r\n */\r\nfunction push(seed, values, x, odds) {\r\n    seed = predictiveRandom(seed);\r\n    values.push(x);\r\n    if ((seed / RANGE) < odds) {\r\n        seed = push(seed, values, x, odds);\r\n    }\r\n    return seed;\r\n}\r\n/**\r\n * Generates a random polynomial with roots picked from a bounded flat\r\n * distribution (i.e. a rectangular distribution) with specified odds of\r\n * duplication of consecutive values. Note that the resulting polynomial\r\n * won't have any complex roots.\r\n * @memberof Random\r\n * @param d - The degree of the polynomials\r\n * @param a - The lower bound of the distribution - defaults\r\n * to 0\r\n * @param b - The upper bound of the distribution - defaults\r\n * to 1\r\n * @param seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @example\r\n * FloPoly.Random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n */\r\nfunction flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\r\n    let randArr = randomArray(d, a, b, seed, odds);\r\n    seed = randArr.seed;\r\n    let p = from_roots_1.fromRoots(randArr.vs);\r\n    return { p, seed };\r\n}\r\nexports.flatRoots = flatRoots;\r\n/**\r\n * Generates a random polynomial with coefficients picked from a bounded\r\n * flat distribution (i.e. a rectangular distribution).\r\n * @memberof Random\r\n * @param d - The degree of the polynomials\r\n * @param a - The lower bound of the distribution - defaults to -1\r\n * @param b - The upper bound of the distribution - defaults to 1\r\n * @param seed - A seed value for generating random values (so that the results\r\n * are reproducable)\r\n * @example\r\n * FloPoly.Random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n */\r\nfunction flatCoefficients(d, a = -1, b = +1, seed = SEED) {\r\n    a = (a === undefined) ? -1 : a;\r\n    b = (b === undefined) ? +1 : b;\r\n    seed = (seed === undefined) ? SEED : seed;\r\n    let randArr = randomArray(d, a, b, seed);\r\n    seed = randArr.seed;\r\n    let p = randArr.vs;\r\n    return { p, seed };\r\n}\r\nexports.flatCoefficients = flatCoefficients;\r\n//# sourceMappingURL=random.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/random/random.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/remainder-sequences/pseudo-remainder.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/remainder-sequences/pseudo-remainder.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst degree_1 = __webpack_require__(/*! ../basic/degree */ \"./node_modules/flo-poly/node/basic/degree.js\");\r\nconst multiply_by_const_1 = __webpack_require__(/*! ../basic/multiply-by-const */ \"./node_modules/flo-poly/node/basic/multiply-by-const.js\");\r\nconst euclidean_division_1 = __webpack_require__(/*! ../euclidean-division/euclidean-division */ \"./node_modules/flo-poly/node/euclidean-division/euclidean-division.js\");\r\n/**\r\n * Returns the trivial pseudo-remainder, i.e. with α === 1.\r\n *\r\n * The result could be in-exact in the presence of underflow.\r\n *\r\n * Performs Euclidean (i.e. long) division on the two given polynomials, a/b,\r\n * where a is first multiplied by leadingCoeff(b)^(deg(a)-deg(b)+1) so we can\r\n * guarantee exact divisions. Returns r in the formula a = bq + r, where\r\n * degree(r) < degree(b). q is called the quotient and r the remainder.\r\n *\r\n * A precondition is that b !== [0], i.e. unequal to the zero polynomial.\r\n * see https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences\r\n * @param a the polynomial a in the formula a = bq + r\r\n * @param b the polynomial b in the formula a = bq + r\r\n * @param positiveMultiplier if set then the multiplier leadingCoeff(b)^(deg(a)-deg(b)+1)\r\n * will be modified to abs(leadingCoeff(b)^(deg(a)-deg(b)+1))\r\n */\r\nfunction prem(a, b, positiveMultiplier = false) {\r\n    // change to pseudo-remainder, i.e. not simply r = a; this allows the \r\n    // remainders to stay in 'Z'\r\n    // let m = leadingCoeff(b)^(deg(a)-deg(b)+1)\r\n    let exponent = degree_1.degree(a) - degree_1.degree(b) + 1;\r\n    let m = b[0];\r\n    for (let i = 1; i < exponent; i++) {\r\n        m = flo_numerical_1.expansionProduct(m, b[0]);\r\n    }\r\n    m = positiveMultiplier ? flo_numerical_1.abs(m) : m;\r\n    let a_ = multiply_by_const_1.expMultiplyByConst(m, a);\r\n    return euclidean_division_1.rem(a_, b);\r\n}\r\nexports.prem = prem;\r\n//# sourceMappingURL=pseudo-remainder.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/remainder-sequences/pseudo-remainder.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/remainder-sequences/sturm-chain.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-poly/node/remainder-sequences/sturm-chain.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst differentiate_1 = __webpack_require__(/*! ../calculus/differentiate */ \"./node_modules/flo-poly/node/calculus/differentiate.js\");\r\nconst multiply_1 = __webpack_require__(/*! ../basic/multiply */ \"./node_modules/flo-poly/node/basic/multiply.js\");\r\nconst multiply_by_const_1 = __webpack_require__(/*! ../basic/multiply-by-const */ \"./node_modules/flo-poly/node/basic/multiply-by-const.js\");\r\nconst subtract_1 = __webpack_require__(/*! ../basic/subtract */ \"./node_modules/flo-poly/node/basic/subtract.js\");\r\nconst subresultant_pseudo_remainder_sequence_1 = __webpack_require__(/*! ./subresultant-pseudo-remainder-sequence */ \"./node_modules/flo-poly/node/remainder-sequences/subresultant-pseudo-remainder-sequence.js\");\r\n/**\r\n * Returns an exact Sturm chain for the given polynomial using pseudo remainders.\r\n * * https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * * https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences\r\n * @param p a polynomial\r\n * @example\r\n * sturmChain([[-3],[4],[2],[-2]]);\r\n */\r\nfunction sturmChainExact(p) {\r\n    let dp = differentiate_1.differentiateExact(p);\r\n    return subresultant_pseudo_remainder_sequence_1.subresultantPseudoRemainderSequence(p, dp, true);\r\n}\r\nexports.sturmChainExact = sturmChainExact;\r\n/**\r\n * Returns an approximate Sturm chain for the given polynomial.\r\n * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * @param p a polynomial\r\n * @example\r\n * sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\r\n */\r\nfunction sturmChain(p) {\r\n    /**\r\n     * Returns the negative of the remainder when dividing the first\r\n     * polynomial (the dividend) by the second (the divisor) provided\r\n     * that deg(p1) - deg(p2) === 1.\r\n     * @private\r\n     * @param p1 The first polynomial (dividend)\r\n     * @param p2 The second polynomial (divisor)\r\n     * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n     */\r\n    function negRemainder(p1, p2) {\r\n        let a = p1[1] / p1[0] - p2[1] / p2[0];\r\n        let b = p1[0] / p2[0];\r\n        let p3 = multiply_1.multiply(multiply_by_const_1.multiplyByConst(b, p2), [1, a]);\r\n        return subtract_1.subtract(p3, p1);\r\n    }\r\n    let m = []; // Sturm chain\r\n    m.push(p);\r\n    m.push(differentiate_1.differentiate(p));\r\n    let i = 1;\r\n    while (m[i].length - 1 > 0) {\r\n        let pnext = negRemainder(m[i - 1], m[i]);\r\n        // If the polynomial degree was not reduced due to roundoff\r\n        // such that the first 1 or more terms are very small.\r\n        while (m[i].length - pnext.length < 1) {\r\n            pnext.shift();\r\n        }\r\n        m.push(pnext);\r\n        i++;\r\n    }\r\n    return m;\r\n}\r\nexports.sturmChain = sturmChain;\r\n//# sourceMappingURL=sturm-chain.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/remainder-sequences/sturm-chain.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/remainder-sequences/subresultant-pseudo-remainder-sequence.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/remainder-sequences/subresultant-pseudo-remainder-sequence.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst pseudo_remainder_1 = __webpack_require__(/*! ./pseudo-remainder */ \"./node_modules/flo-poly/node/remainder-sequences/pseudo-remainder.js\");\r\nconst is_zero_1 = __webpack_require__(/*! ../basic/is-zero */ \"./node_modules/flo-poly/node/basic/is-zero.js\");\r\nconst degree_1 = __webpack_require__(/*! ../basic/degree */ \"./node_modules/flo-poly/node/basic/degree.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst is_const_1 = __webpack_require__(/*! ../basic/is-const */ \"./node_modules/flo-poly/node/basic/is-const.js\");\r\n/**\r\n * Returns the subresultant pseudo remainder sequence of a/b.\r\n * see \"The subresultant polynomial remainder sequence algorithm\" by Ruiyuan (Ronnie) Chen, p.10\r\n * https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf\r\n * @param f a polynomial\r\n * @param g another polynomial\r\n * @param sturm if set to true then calculate a Sturm sequence instead\r\n */\r\nfunction subresultantPseudoRemainderSequence(f, g, sturm) {\r\n    let r = [f, g]; // Initialize the PRS\r\n    let d = [degree_1.degree(f), degree_1.degree(g)];\r\n    let a = [[1]]; // a_1 === 1\r\n    let c = [[1]]; // c_1 === 1\r\n    let i = 2;\r\n    while (true) {\r\n        a.push(r[i - 1][0]); // leading coefficient of r[i-1]\r\n        let d_ = d[i - 2] - d[i - 1];\r\n        let sgn = sturm\r\n            ? -1\r\n            : (d_ + 1) % 2 === 0 ? +1 : -1;\r\n        let D = flo_numerical_1.expansionProduct(a[i - 2], flo_numerical_1.intPow(c[i - 2], d_));\r\n        let exp = -d_ + 1;\r\n        let cTerm1 = flo_numerical_1.intPow(a[i - 1], d_);\r\n        let cTerm2 = flo_numerical_1.intPow(c[i - 2], Math.abs(exp));\r\n        // TODO - surely exp >= 1 ??\r\n        c.push(exp < 0\r\n            ? flo_numerical_1.expansionDiv(cTerm1, cTerm2, 0)\r\n            : flo_numerical_1.expansionProduct(cTerm1, cTerm2));\r\n        let r_ = pseudo_remainder_1.prem(r[i - 2], r[i - 1], sturm).r\r\n            .map(coeff => flo_numerical_1.expansionDiv(coeff, D, 0));\r\n        r_ = sgn > 0 ? r_ : r_.map(flo_numerical_1.negativeOf);\r\n        d.push(degree_1.degree(r_));\r\n        if (is_zero_1.expIsZero(r_)) {\r\n            return r;\r\n        }\r\n        r.push(r_);\r\n        if (is_const_1.expIsConst(r_)) {\r\n            // the remainder is a constant so the next remainder will be 0 anyway\r\n            return r;\r\n        }\r\n        i++;\r\n    }\r\n}\r\nexports.subresultantPseudoRemainderSequence = subresultantPseudoRemainderSequence;\r\n//# sourceMappingURL=subresultant-pseudo-remainder-sequence.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/remainder-sequences/subresultant-pseudo-remainder-sequence.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/deflate.js":
/*!*****************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/deflate.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst qmd = flo_numerical_1.qMultDouble2;\r\nconst qaq = flo_numerical_1.qAddQuad;\r\n/**\r\n * Deflates the given polynomial approximately by removing a factor (x - r),\r\n * where r is a root of the polynomial.\r\n * @param p a polynomial\r\n * @param root a root of the polynomial.\r\n * @example\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\r\n * deflate([1, -5, 8, -4], 2); //=> [1, -3, 2]\r\n * deflate([1, -3, 2], 2);     //=> [1,-1]\r\n * deflate([1, -1], 1);        //=> [1]\r\n */\r\nfunction deflate(p, root) {\r\n    let d = p.length - 1;\r\n    let bs = [p[0]];\r\n    for (let i = 1; i < d; i++) {\r\n        bs.push(p[i] + root * bs[i - 1]);\r\n    }\r\n    return bs;\r\n}\r\nexports.deflate = deflate;\r\nfunction deflateQuad(p, root) {\r\n    let d = p.length - 1;\r\n    let bs = [p[0]];\r\n    for (let i = 1; i < d; i++) {\r\n        bs.push(qaq(p[i], qmd(root, bs[i - 1])));\r\n    }\r\n    return bs;\r\n}\r\nexports.deflateQuad = deflateQuad;\r\n//# sourceMappingURL=deflate.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/deflate.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/descartes/num-roots.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/descartes/num-roots.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sturm_chain_1 = __webpack_require__(/*! ../../remainder-sequences/sturm-chain */ \"./node_modules/flo-poly/node/remainder-sequences/sturm-chain.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ../../evaluate/evaluate */ \"./node_modules/flo-poly/node/evaluate/evaluate.js\");\r\nconst evaluate_exact_1 = __webpack_require__(/*! ../../evaluate/evaluate-exact */ \"./node_modules/flo-poly/node/evaluate/evaluate-exact.js\");\r\nconst sign_changes_1 = __webpack_require__(/*! ./sign-changes */ \"./node_modules/flo-poly/node/roots/descartes/sign-changes.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst degree_1 = __webpack_require__(/*! ../../basic/degree */ \"./node_modules/flo-poly/node/basic/degree.js\");\r\nconst evaluate_at_1_1 = __webpack_require__(/*! ../../evaluate/evaluate-at-1 */ \"./node_modules/flo-poly/node/evaluate/evaluate-at-1.js\");\r\n/**\r\n * Returns the approximate number of *distinct* real roots in the interval (a,b) of the\r\n * given polynomial.\r\n * @param p a polynomial\r\n * @param a a lower bound\r\n * @param b an upper bound\r\n * @example\r\n * let p = [1, 1, -64, 236, -240];\r\n * numRootsInRange(p,-20,-11); //=> 0\r\n * numRootsInRange(p,-11,-9);  //=> 1\r\n * numRootsInRange(p,-11,3.5); //=> 3\r\n * numRootsInRange(p,-11,5);   //=> 4\r\n */\r\nfunction numRootsInRange(p, a, b) {\r\n    let ps = sturm_chain_1.sturmChain(p);\r\n    let as = ps.map(p => evaluate_1.evaluate(p, a));\r\n    let bs = ps.map(p => evaluate_1.evaluate(p, b));\r\n    return sign_changes_1.signChanges(as) - sign_changes_1.signChanges(bs);\r\n}\r\nexports.numRootsInRange = numRootsInRange;\r\n/**\r\n * Returns the exact number of *distinct* real roots in the interval (a,b) of the\r\n * given polynomial.\r\n * * From Wikipedia: In the case of a non-square-free polynomial, if neither a nor b is a multiple root of p, then V(a) − V(b) is the number of distinct real roots of P.\r\n * @param p a polynomial\r\n * @param a a lower bound\r\n * @param b an upper bound\r\n * @example\r\n * let p = [[1], [1], [-64], [236], [-240]];\r\n * numRootsInRangeExact(p,-20,-11); //=> 0\r\n * numRootsInRangeExact(p,-11,-9);  //=> 1\r\n * numRootsInRangeExact(p,-11,3.5); //=> 3\r\n * numRootsInRangeExact(p,-11,5);   //=> 4\r\n */\r\nfunction numRootsInRangeExact(p, a, b) {\r\n    let ps = sturm_chain_1.sturmChainExact(p);\r\n    let as = ps.map(p => evaluate_exact_1.evaluateExact(p, a));\r\n    let bs = ps.map(p => evaluate_exact_1.evaluateExact(p, b));\r\n    return sign_changes_1.expSignChanges(as) - sign_changes_1.expSignChanges(bs);\r\n}\r\nexports.numRootsInRangeExact = numRootsInRangeExact;\r\n/**\r\n * Returns the exact number of *distinct* real roots in the interval (-∞,+∞) of the\r\n * given polynomial.\r\n * * From Wikipedia: In the case of a non-square-free polynomial, if neither a nor b is a multiple root of p, then V(a) − V(b) is the number of distinct real roots of P.\r\n * @param p a polynomial\r\n * @param a a lower bound\r\n * @param b an upper bound\r\n * @example\r\n * let p = [[1], [1], [-64], [236], [-240]];\r\n * numRootsExact(p); //=> 4\r\n */\r\nfunction numRootsExact(p) {\r\n    let ps = sturm_chain_1.sturmChainExact(p);\r\n    let as = ps.map(p => degree_1.degree(p) % 2 === 0 ? flo_numerical_1.sign(p[0]) : -flo_numerical_1.sign(p[0]));\r\n    let bs = ps.map(p => flo_numerical_1.sign(p[0]));\r\n    return sign_changes_1.signChanges(as) - sign_changes_1.signChanges(bs);\r\n}\r\nexports.numRootsExact = numRootsExact;\r\n/**\r\n * Returns the exact number of *distinct* real roots in the interval (0,1) of the\r\n * given polynomial.\r\n * @param p a polynomial\r\n * @param a a lower bound\r\n * @param b an upper bound\r\n */\r\nfunction numRootsIn01Exact(p) {\r\n    let ps = sturm_chain_1.sturmChainExact(p);\r\n    let as = ps.map(p => p[p.length - 1]); // evaluate at 0\r\n    let bs = ps.map(p => evaluate_at_1_1.expEvaluateAt1(p)); // evaluate at 1\r\n    return sign_changes_1.expSignChanges(as) - sign_changes_1.expSignChanges(bs);\r\n}\r\nexports.numRootsIn01Exact = numRootsIn01Exact;\r\n//# sourceMappingURL=num-roots.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/descartes/num-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/descartes/sign-changes.js":
/*!********************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/descartes/sign-changes.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst sgn = Math.sign;\r\n/**\r\n * Returns the number of sign changes in the polynomial coefficents\r\n * when ordered in descending order; zeros are ignored.\r\n *\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable\r\n * exponent, then the number of positive roots of the polynomial is\r\n * either equal to the number of sign differences between consecutive\r\n * nonzero coefficients, or is less than it by an even number. Multiple\r\n * roots of the same value are counted separately.\"\r\n *\r\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * @param p a polynomial\r\n * @example\r\n * signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n */\r\nfunction signChanges(p) {\r\n    let d = p.length - 1;\r\n    let result = 0;\r\n    let prevSign = sgn(p[0]);\r\n    for (let i = 1; i < d + 1; i++) {\r\n        let sign = sgn(p[i]);\r\n        if (sign !== prevSign && sign !== 0) {\r\n            result++;\r\n            prevSign = sign;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.signChanges = signChanges;\r\n/**\r\n * Returns the number of sign changes in the polynomial coefficents\r\n * when ordered in descending order; zeros are ignored.\r\n *\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable\r\n * exponent, then the number of positive roots of the polynomial is\r\n * either equal to the number of sign differences between consecutive\r\n * nonzero coefficients, or is less than it by an even number. Multiple\r\n * roots of the same value are counted separately.\"\r\n *\r\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * @param p a polynomial\r\n * @example\r\n * signChanges([[1],[2],[-3],[0],[0],[3],[-1]]); //=> 3\r\n */\r\nfunction expSignChanges(p) {\r\n    let d = p.length - 1;\r\n    let result = 0;\r\n    let prevSign = sgn(flo_numerical_1.sign(p[0]));\r\n    for (let i = 1; i < d + 1; i++) {\r\n        let sign_ = sgn(flo_numerical_1.sign(p[i]));\r\n        if (sign_ !== prevSign && sign_ !== 0) {\r\n            result++;\r\n            prevSign = sign_;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.expSignChanges = expSignChanges;\r\n//# sourceMappingURL=sign-changes.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/descartes/sign-changes.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/from-roots.js":
/*!********************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/from-roots.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst multiply_1 = __webpack_require__(/*! ../basic/multiply */ \"./node_modules/flo-poly/node/basic/multiply.js\");\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Constructs a polynomial from the given roots by multiplying out the\r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\r\n * will not have any complex roots.\r\n *\r\n * Mostly provided for testing purposes. Note that the real roots of the\r\n * constructed polynomial may not be exactly the same as the roots that\r\n * the polynomial has been constructed from due to floating-point\r\n * round-off.\r\n *\r\n * @param roots - The roots\r\n * @example\r\n * fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed.\r\n * allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n */\r\nfunction fromRoots(roots) {\r\n    let p = [1];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        p = multiply_1.multiply(p, [1, -roots[i]]);\r\n    }\r\n    return p;\r\n}\r\nexports.fromRoots = fromRoots;\r\n/**\r\n * Constructs a polynomial from the given roots by multiplying out the\r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\r\n * will not have any complex roots.\r\n *\r\n * Mostly provided for testing purposes.\r\n *\r\n * @param roots the roots\r\n */\r\nfunction fromRootsExact(roots) {\r\n    let p = [[1]];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        p = multiply_1.multiplyExact([p, [[1], [-roots[i]]]]);\r\n    }\r\n    return p.map(flo_numerical_1.compress);\r\n}\r\nexports.fromRootsExact = fromRootsExact;\r\n//# sourceMappingURL=from-roots.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/from-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/all-roots-multi-with-err-bounds.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/all-roots-multi-with-err-bounds.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst differentiate_1 = __webpack_require__(/*! ../../calculus/differentiate */ \"./node_modules/flo-poly/node/calculus/differentiate.js\");\r\nconst eval_k_multi_with_err_bounds_1 = __webpack_require__(/*! ../../evaluate/eval-k-multi-with-err-bounds */ \"./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js\");\r\nconst horner_exact_1 = __webpack_require__(/*! ../../evaluate/horner-exact */ \"./node_modules/flo-poly/node/evaluate/horner-exact.js\");\r\nconst transpose_poly_1 = __webpack_require__(/*! ./transpose-poly */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/transpose-poly.js\");\r\nconst eval_adaptive_1 = __webpack_require__(/*! ./eval-adaptive */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/eval-adaptive.js\");\r\nconst refine_multi_with_err_bounds_1 = __webpack_require__(/*! ./refine-multi-with-err-bounds */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-multi-with-err-bounds.js\");\r\nconst abs = Math.abs;\r\n/**\r\n * Finds and returns all root intervals within [0,1] of a given polynomial,\r\n * including their multiplicities (see points below).\r\n * * **precondition** interval must be a subset of [0,1]\r\n * * specialized for the interval [0,1]\r\n * * multiplicities are positive integers - in extremely rare cases a\r\n * multiplicity may be an even number higher than the one returned\r\n * * the returned intervals are of max width 2*Number.EPSILON; if an interval\r\n * is of higher width then it contains multiple roots; the max width\r\n * * the highest degree coefficient of the input polynomial's exact value should\r\n * be !== 0\r\n * @param p a polynomial with quad-precision coefficients.\r\n * @param pE error bound polynomial (given as absolute errors on each coefficient)\r\n * @param lb lower limit of root values to be returned - defaults to 0\r\n * @param ub upper limit of root values to be returned - defaults to 1\r\n * @param getPsExact a function returning the exact polynomial and its\r\n * derivatives if required when the error bounds are too high during calculation\r\n */\r\nfunction allRootsMultiWithErrBounds(p, pE, getPsExact = undefined, lb = 0, ub = 1) {\r\n    let δ = 2 * Number.EPSILON;\r\n    //let lb = 0;\r\n    //let ub = 1;\r\n    let psExact = { ps: undefined };\r\n    if (!getPsExact) {\r\n        getPsExact = () => {\r\n            let poly = p;\r\n            let psExact = [poly];\r\n            while (poly.length > 1) {\r\n                poly = differentiate_1.differentiateExact(psExact[psExact.length - 1]);\r\n                psExact.push(poly);\r\n            }\r\n            return psExact;\r\n        };\r\n    }\r\n    let p_ = transpose_poly_1.transposePoly(p);\r\n    /** evaluation at lb */\r\n    let LB = 0;\r\n    /** evaluation at ub */\r\n    let UB = 0;\r\n    let bCount;\r\n    let exact;\r\n    bCount = 0;\r\n    exact = false;\r\n    do {\r\n        LB = exact\r\n            ? horner_exact_1.HornerExact(psExact.ps[0], lb)\r\n            : eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds(p_, pE, lb).r̂;\r\n        if (LB === 0) {\r\n            bCount++;\r\n            // the max bCount is imperically selected for max performance\r\n            if (bCount >= 3 && !exact) {\r\n                exact = true;\r\n                psExact.ps = psExact.ps || getPsExact();\r\n                continue;\r\n            }\r\n            lb -= δ;\r\n        }\r\n    } while (LB === 0);\r\n    bCount = 0;\r\n    exact = false;\r\n    do {\r\n        UB = exact\r\n            ? horner_exact_1.HornerExact(psExact.ps[0], ub)\r\n            : eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds(p_, pE, ub).r̂;\r\n        if (UB === 0) {\r\n            bCount++;\r\n            if (bCount >= 3 && !exact) { // the max bCount is imperically selected for max performance\r\n                exact = true;\r\n                psExact.ps = psExact.ps || getPsExact();\r\n                continue;\r\n            }\r\n            ub += δ;\r\n        }\r\n    } while (UB === 0);\r\n    let ps = [{ p, pE }];\r\n    for (let i = 0; i < p.length - 1; i++) {\r\n        ps.push(differentiate_1.differentiateQuadWithError(ps[i]));\r\n    }\r\n    //console.log(ps)\r\n    let rs = [];\r\n    let deg = p.length - 1;\r\n    let maxDp_ = abs(ps[deg].p[0][1]); // abs value of last derivative msb\r\n    let maxDp; // only used after second iteration\r\n    for (let i = 1; i < p.length; i++) {\r\n        let { p, pE } = ps[deg - i];\r\n        let p_ = transpose_poly_1.transposePoly(p);\r\n        rs = getRootsWithin(p_, pE, rs, δ, deg - i);\r\n        maxDp = maxDp_;\r\n        maxDp_ = 0;\r\n        let p0 = p_[0];\r\n        for (let j = 0; j < p.length; j++) {\r\n            maxDp_ += abs(p0[j]);\r\n        }\r\n    }\r\n    return rs;\r\n    // START OF FUNCTION getRootsWithin - it has been 'inlined' to take \r\n    // advantage of the closure so that bounds can be adjusted easier and so\r\n    // we don't have to pass a lot of values\r\n    // All cases:\r\n    // ----------\r\n    // Note: [_a,a_] denotes a micro-interval, whereas [b_,_a], [a_,_b] denotes a\r\n    // normal interval.\r\n    // Note: In all iterations we check [_a,a_] and [a_,_b]. In the final\r\n    // iteration we check [_b,b_], then we've checked all intervals.\r\n    // \r\n    // ⇑ represents +pos (above x-axis) and ⇓ represents -neg\r\n    // (the symmetric cases also applies where + and - are interchanged)\r\n    // ? means does not matter\r\n    // -----------------------------------------------------------------\r\n    // CASE 1A:\r\n    // _A⇑ | A_⇑ | _B⇑\r\n    //  - [_a,a_] → \r\n    //    - _a === a_\r\n    //        ? no root \r\n    //        : A_/_A close enough to zero ? close even root : no roots\r\n    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)\r\n    // CASE 1B:\r\n    // _A⇑ | A_⇑ | _B⇓  \r\n    //  - [_a,a_] → \r\n    //    - _a === a_\r\n    //        ? no root \r\n    //        : A_/_A close enough to zero ? close even root : no roots\r\n    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)\r\n    // CASE 2A:\r\n    // _A⇑ | A_⇓ | _B⇑\r\n    //  - [_a,a_] → odd root(s)\r\n    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)\r\n    // CASE 2B:\r\n    // _A⇑ | A_⇓ | _B⇓\r\n    //  - [_a,a_] → odd root(s)\r\n    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)\r\n    // CASE 3A: \r\n    // A_0 | A_? | _B? | B_?  \r\n    // CASE 3B: \r\n    // A_? | A_0 | _B? | B_?  \r\n    /**\r\n     * Finds all roots of the given polynomial within the given intervals.\r\n     * * **precondition** intervals should be disjoint, i.e endpoints are not allowed\r\n     * to be equal - it must be that a_ !== _b\r\n     * * **precondition** the curve must be monotone increasing or decreasing between\r\n     * b_ and _a AND a_ and _b\r\n     * * **precondition** the value at the lower bound (LB) and upper bound (UB)\r\n     * must !== 0\r\n     * @param p\r\n     * @param is the micro-intervals\r\n     */\r\n    function getRootsWithin(p, pE, is, δ, diffCount) {\r\n        let roots = [];\r\n        // If there are no micro-intervals then check the interval between lb and ub.\r\n        let LB = eval_adaptive_1.evalAdaptive(p, pE, lb, psExact, getPsExact, diffCount);\r\n        if (!is.length) {\r\n            // close even root not possible\r\n            let UB = eval_adaptive_1.evalAdaptive(p, pE, ub, psExact, getPsExact, diffCount);\r\n            if (LB * UB >= 0) {\r\n                return [];\r\n            }\r\n            let [tS, tE] = refine_multi_with_err_bounds_1.refineMultiWithErrBounds(p, pE, lb, ub, LB, UB, psExact, getPsExact, diffCount, δ);\r\n            return [{ tS, tE /*, tM: (tE + tS)/2*/, multiplicity: 1 }];\r\n        }\r\n        //---- First check from lb to the left side of the first micro-interval.\r\n        let _a = is[0].tS;\r\n        let _A = eval_adaptive_1.evalAdaptive(p, pE, _a, psExact, getPsExact, diffCount);\r\n        if (LB * _A > 0) {\r\n            // no roots possible (curve is monotone increasing or decreasing)\r\n        }\r\n        else if (LB * _A < 0) {\r\n            // recall LB must !== 0 as a precondition\r\n            let [tS, tE] = refine_multi_with_err_bounds_1.refineMultiWithErrBounds(p, pE, lb, _a, LB, _A, psExact, getPsExact, diffCount, δ);\r\n            roots.push({ tS, tE /*, tM: (tE + tS)/2*/, multiplicity: 1 });\r\n        } //else {\r\n        // _A === 0\r\n        // no roots possible in [lb,_a]\r\n        //}\r\n        let a_ = lb;\r\n        let A_ = LB;\r\n        let _b = _a;\r\n        let _B = _A;\r\n        for (let i = 0; i < is.length; i++) {\r\n            let i_ = is[i + 1]; // right micro-interval\r\n            let a = is[i];\r\n            _a = _b;\r\n            a_ = is[i].tE;\r\n            _b = i_ ? i_.tS : ub;\r\n            let B_ = A_;\r\n            _A = _B;\r\n            A_ = eval_adaptive_1.evalAdaptive(p, pE, a_, psExact, getPsExact, diffCount);\r\n            _B = eval_adaptive_1.evalAdaptive(p, pE, _b, psExact, getPsExact, diffCount);\r\n            /** if we must check for even roots */\r\n            let checkEvenAA = false;\r\n            if (_A * A_ > 0) {\r\n                //---- CASE 1: _A⇑ | A_⇑   OR   _A⇓ | A_⇓\r\n                //console.log('CASE 1');\r\n                if (A_ * _B > 0) {\r\n                    //---- CASE 1A: _A⇑ | A_⇑ | _B⇑   OR   _A⇓ | A_⇓ | _B⇓\r\n                    //console.log('CASE 1A');\r\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\r\n                        checkEvenAA = true;\r\n                    }\r\n                    // [a_,_b] → no root\r\n                }\r\n                else if (A_ * _B < 0) {\r\n                    //---- CASE 1B: _A⇑ | A_⇑ | _B⇓   OR   _A⇓ | A_⇓ | _B⇑\r\n                    //console.log('CASE 1B');\r\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\r\n                        checkEvenAA = true;\r\n                    }\r\n                    // [a_,_b] → single root (curve is monotone increasing or decreasing)\r\n                    let [tS, tE] = refine_multi_with_err_bounds_1.refineMultiWithErrBounds(p, pE, a_, _b, A_, _B, psExact, getPsExact, diffCount, δ);\r\n                    roots.push({ tS, tE /*, tM: (tE + tS)/2*/, multiplicity: 1 });\r\n                }\r\n                else { // _B === 0\r\n                    //---- CASE 1C: _A⇑ | A_⇑ | _B0   OR   _A⇓ | A_⇓ | _B0\r\n                    //console.log('CASE 1C');\r\n                    //console.log(_B);\r\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\r\n                        checkEvenAA = true;\r\n                    }\r\n                    // [a_,_b] → no root\r\n                }\r\n            }\r\n            else if (_A * A_ < 0) {\r\n                //---- CASE 2 _A⇑ | A_⇓   OR   _A⇓ | A_⇑\r\n                //console.log('CASE 2');\r\n                // - [_a,a_] → odd root(s)\r\n                roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: 3 });\r\n                if (A_ * _B < 0) {\r\n                    //---- CASE 2A: _A⇑ | A_⇓ | _B⇑   OR   _A⇓ | A_⇑ | _B⇓\r\n                    //console.log('CASE 2A');\r\n                    // [a_,_b] → single root\r\n                    let [tS, tE] = refine_multi_with_err_bounds_1.refineMultiWithErrBounds(p, pE, a_, _b, A_, _B, psExact, getPsExact, diffCount, δ);\r\n                    roots.push({ tS, tE /*, tM: (tE + tS)/2*/, multiplicity: 1 });\r\n                }\r\n                else if (A_ * _B > 0) {\r\n                    //---- CASE 2B: _A⇑ | A_⇓ | _B⇓   OR   _A⇓ | A_⇑ | _B⇑\r\n                    //console.log('CASE 2B');\r\n                    // [a_,_b] → no roots\r\n                }\r\n                else { // _B === 0\r\n                    //console.log('CASE 2C');\r\n                    // [a_,_b] → no roots\r\n                }\r\n            }\r\n            else if (A_ === 0) {\r\n                //---- CASE 3A A_0\r\n                //console.log('CASE 3A');\r\n                // [_a,a_] → rational root at a_\r\n                // There cannot be a root between a_ and _b since _B !== 0\r\n                if ( /*_a === a_ ||*/_A === 0) {\r\n                    // multiple rational root at a_ OR both _A and A_ is 0\r\n                    // so update multiplicity parity\r\n                    roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: a.multiplicity + 1 });\r\n                }\r\n                else {\r\n                    // now _A and _B are both !== 0\r\n                    if (_A * _B > 0) {\r\n                        roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: 2 });\r\n                    }\r\n                    else {\r\n                        roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: 3 });\r\n                    }\r\n                }\r\n            }\r\n            else { // _A === 0\r\n                //---- CASE 3B _A0\r\n                //console.log('CASE 3B');\r\n                // A_ !== 0 here and _a !== a_\r\n                // [_a,a_] → rational root at _a\r\n                if (A_ * _B < 0) {\r\n                    // [a_,_b] → single root\r\n                    let [tS, tE] = refine_multi_with_err_bounds_1.refineMultiWithErrBounds(p, pE, a_, _b, A_, _B, psExact, getPsExact, diffCount, δ);\r\n                    roots.push({ tS, tE /*, tM: (tE + tS)/2*/, multiplicity: 1 });\r\n                }\r\n                else if (A_ * _B > 0) {\r\n                    // [a_,_b] → no roots\r\n                }\r\n                // - [_a,a_] → \r\n                // B_ and A_ are both !== 0\r\n                if (B_ * A_ > 0) {\r\n                    roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: 2 });\r\n                }\r\n                else {\r\n                    roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: 3 });\r\n                }\r\n            }\r\n            // Check for double roots\r\n            //if (_A * A_ > 0 && _a !== a_) {\r\n            if (checkEvenAA) {\r\n                //console.log('checking even');\r\n                let AMinMax = A_ > 0 ? Math.min(_A, A_) : Math.max(_A, A_);\r\n                let dMax = maxDp * (2 * δ);\r\n                let yShift = A_ > 0 ? -dMax * 2 * δ : dMax * 2 * δ;\r\n                let y = AMinMax + yShift;\r\n                //console.log(maxDp);\r\n                if (y * A_ < 0) {\r\n                    // possible even multiplicity  root\r\n                    //console.log('possible even multiplicty root: ', _a, a_);\r\n                    // The below multiplicity can really be any multiple of 2\r\n                    roots.push({ tS: a.tS, tE: a.tE /*, tM: a.tM*/, multiplicity: 2 });\r\n                }\r\n            }\r\n        }\r\n        //---- Combine the root intervals if they are adjacent (they cannot overlap)\r\n        for (let i = 0; i < roots.length - 1; i++) {\r\n            let r = roots[i];\r\n            let r_ = roots[i + 1];\r\n            if (r.tE === r_.tS) {\r\n                return joinRoots(roots);\r\n            }\r\n        }\r\n        return roots;\r\n    }\r\n}\r\nexports.allRootsMultiWithErrBounds = allRootsMultiWithErrBounds;\r\n// TODO - doc plus test joinRoots\r\nfunction joinRoots(rs) {\r\n    let newRs = [];\r\n    let r = rs[0];\r\n    // make a clone of the first interval\r\n    let curR = { tS: r.tS, tE: r.tE /*, tM: r.tM*/, multiplicity: r.multiplicity };\r\n    for (let i = 0; i < rs.length - 1; i++) {\r\n        let r = rs[i];\r\n        let r_ = rs[i + 1];\r\n        if (r.tE !== r_.tS) {\r\n            // they don't stick together\r\n            newRs.push(curR);\r\n            // make a clone of the next interval\r\n            curR = { tS: r_.tS, tE: r_.tE /*, tM: r_.tM*/, multiplicity: r_.multiplicity };\r\n        }\r\n        else {\r\n            // they stick together - expand\r\n            curR.tE = r_.tE;\r\n            curR.multiplicity = r.multiplicity + r_.multiplicity;\r\n        }\r\n    }\r\n    newRs.push(curR);\r\n    console.log('joined');\r\n    return newRs;\r\n}\r\n//# sourceMappingURL=all-roots-multi-with-err-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/all-roots-multi-with-err-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/eval-adaptive.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/eval-adaptive.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eval_k_multi_with_err_bounds_1 = __webpack_require__(/*! ../../evaluate/eval-k-multi-with-err-bounds */ \"./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js\");\r\nconst horner_exact_1 = __webpack_require__(/*! ../../evaluate/horner-exact */ \"./node_modules/flo-poly/node/evaluate/horner-exact.js\");\r\nfunction evalAdaptive(p, pE, x, psExact, getPsExact, diffCount) {\r\n    let r = eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds(p, pE, x, 4).r̂;\r\n    if (r === 0) {\r\n        // condition number is too high - request higher precision\r\n        psExact.ps = psExact.ps || getPsExact();\r\n        return horner_exact_1.HornerExact(psExact.ps[diffCount], x);\r\n    }\r\n    return r;\r\n}\r\nexports.evalAdaptive = evalAdaptive;\r\n//# sourceMappingURL=eval-adaptive.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/eval-adaptive.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-k1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-k1.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst change_variables_linear_1 = __webpack_require__(/*! ../../change-variables/change-variables-linear */ \"./node_modules/flo-poly/node/change-variables/change-variables-linear.js\");\r\nconst differentiate_1 = __webpack_require__(/*! ../../calculus/differentiate */ \"./node_modules/flo-poly/node/calculus/differentiate.js\");\r\nconst all_roots_multi_with_err_bounds_1 = __webpack_require__(/*! ./all-roots-multi-with-err-bounds */ \"./node_modules/flo-poly/node/roots/multi-with-err-bound/all-roots-multi-with-err-bounds.js\");\r\nconst eps = Number.EPSILON;\r\n/**\r\n * Returns once compensated root(s).\r\n * * **precondition** the root has multiplicity === 1\r\n  * @param tS Start of root interval - there is assumed exactly 1 root from tS\r\n * to tS + 4 ulps.\r\n * @param getPsExact function returning psExact\r\n */\r\nfunction refineK1(tS, getPsExact) {\r\n    // TODO - change to getPExact everywhere - dont always need all derivatives\r\n    let psExact = getPsExact();\r\n    let pExact = psExact[0];\r\n    // 1/(4*Number.EPSILON) since the original root(s) are 4*Number.EPSILON 'accurate'\r\n    let scale = 4 * Number.EPSILON;\r\n    // Translate the polynomial such that the root is within 4 eps from 0, then\r\n    // scale it such that the roots stay < 1, i.e. is in [0,1]\r\n    let pExactK1 = change_variables_linear_1.changeVariablesLinearExact(pExact, scale, tS);\r\n    // reduce the polynomial to quad precision for faster root finding\r\n    let pQuadK1 = pExactK1.map(flo_numerical_1.toQuad);\r\n    // update the quad precision error bound - it is simply the error in \r\n    // rounding the exact coefficients to quad precision\r\n    let errBoundK1 = pQuadK1.map(c => eps * eps * c[1]);\r\n    let getPsExactK1 = () => {\r\n        let polyK1 = pExactK1;\r\n        let psExactK1 = [polyK1];\r\n        while (polyK1.length > 1) {\r\n            polyK1 = differentiate_1.differentiateExact(psExactK1[psExactK1.length - 1]);\r\n            psExactK1.push(polyK1);\r\n        }\r\n        return psExactK1;\r\n    };\r\n    let _risLo = all_roots_multi_with_err_bounds_1.allRootsMultiWithErrBounds(pQuadK1, errBoundK1, getPsExactK1);\r\n    let ris = [];\r\n    for (let riLo of _risLo) {\r\n        ris.push({\r\n            tS: flo_numerical_1.twoSum(tS, riLo.tS * 4 * Number.EPSILON),\r\n            tE: flo_numerical_1.twoSum(tS, riLo.tE * 4 * Number.EPSILON),\r\n            multiplicity: riLo.multiplicity\r\n        });\r\n    }\r\n    return ris;\r\n    /*\r\n    let risLo = allRootsMultiWithErrBounds(pQuadK1, errBoundK1, getPsExactK1);\r\n\r\n    let rLoS = risLo[0].tS * 4*Number.EPSILON;\r\n    let rLoE = risLo[0].tE * 4*Number.EPSILON;\r\n\r\n    let r: RootIntervalExp = {\r\n        tS: twoSum(tS,rLoS),\r\n        tE: twoSum(tS,rLoE),\r\n        multiplicity: 1\r\n    }\r\n\r\n    return [r];\r\n    */\r\n}\r\nexports.refineK1 = refineK1;\r\n//# sourceMappingURL=refine-k1.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-k1.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-multi-with-err-bounds.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-multi-with-err-bounds.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst eval_k_multi_with_err_bounds_1 = __webpack_require__(/*! ../../evaluate/eval-k-multi-with-err-bounds */ \"./node_modules/flo-poly/node/evaluate/eval-k-multi-with-err-bounds.js\");\r\nconst horner_exact_1 = __webpack_require__(/*! ../../evaluate/horner-exact */ \"./node_modules/flo-poly/node/evaluate/horner-exact.js\");\r\nlet eps = Number.EPSILON;\r\nlet abs = Math.abs;\r\n//(window as any).qcount = 0;\r\n//(window as any).qtot = 0;\r\n/**\r\n * Exact, original Brent Dekker Method - modified slightly to allow for error\r\n * bounds.\r\n * * returns a refined bound of max width 2*Number.EPSILON\r\n * * see https://people.sc.fsu.edu/~jburkardt/cpp_src/brent/brent.cpp\r\n * @param p\r\n * @param pE\r\n * @param a\r\n * @param b\r\n * @param fa\r\n * @param fb\r\n * @param psExact\r\n * @param getPsExact\r\n * @param diffCount\r\n */\r\nfunction refineMultiWithErrBounds(p, pE, lb, ub, fa, fb, psExact, getPsExact, diffCount, δ = 2 * eps) {\r\n    // Precondition: fa, fb !== 0\r\n    // from the c++ implementation\r\n    // double c;\r\n    // double d;\r\n    // double e;\r\n    // double fa;      --> given as input\r\n    // double fb;      --> given as input\r\n    // double fc;\r\n    // double m;\r\n    // double macheps; --> u\r\n    // double p;\r\n    // double q;\r\n    // double r;\r\n    // double s;\r\n    // double sa;      --> a\r\n    // double sb;      --> b\r\n    // double tol;     --> fixed as Number.EPSILON (eps)\r\n    /** true if we need to do precise evaluations, i.e. we are too close to a\r\n     * very tough root. */\r\n    let exact = false;\r\n    //---- Make local copies of a and b.\r\n    let a = lb;\r\n    let b = ub;\r\n    let c = a;\r\n    let fc = fa;\r\n    let e = b - a;\r\n    let d = e;\r\n    let q = 0;\r\n    while (true) {\r\n        if (abs(fc) < abs(fb)) {\r\n            a = b;\r\n            b = c;\r\n            c = a;\r\n            fa = fb;\r\n            fb = fc;\r\n            fc = fa;\r\n        }\r\n        // Original c++ code had the line below but with us t === 0 and b is \r\n        // taken as 1 and 2.0 * macheps is taken as 2*u === Number.EPSILON (eps)\r\n        // or can also be taken as 4*u === 2*Number.EPSILON (2*eps)\r\n        //tol = 2.0 * macheps * abs ( b ) + t;\r\n        let m = 0.5 * (c - b);\r\n        //if (abs(m) <= δ || fb === 0) {\r\n        // modified from the original since we dont need the fb === 0 check here\r\n        if (abs(m) <= δ) {\r\n            //(window as any).qcount++;\r\n            //(window as any).qtot += q;\r\n            //console.log('a', Math.abs(b-c))\r\n            return b < c ? [b, c] : [c, b];\r\n        }\r\n        q++;\r\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\r\n            e = m;\r\n            d = e;\r\n        }\r\n        else {\r\n            let s = fb / fa;\r\n            let p;\r\n            let q;\r\n            if (a === c) {\r\n                p = 2 * m * s;\r\n                q = 1 - s;\r\n            }\r\n            else {\r\n                q = fa / fc;\r\n                let r = fb / fc;\r\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\r\n                q = (q - 1) * (r - 1) * (s - 1);\r\n            }\r\n            if (0 < p) {\r\n                q = -q;\r\n            }\r\n            else {\r\n                p = -p;\r\n            }\r\n            s = e;\r\n            e = d;\r\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\r\n                d = p / q;\r\n            }\r\n            else {\r\n                e = m;\r\n                d = e;\r\n            }\r\n        }\r\n        a = b;\r\n        fa = fb;\r\n        if (δ < abs(d)) {\r\n            b = b + d;\r\n        }\r\n        else if (0 < m) {\r\n            b = b + δ;\r\n        }\r\n        else {\r\n            //b = b - eps;\r\n            b = b - δ;\r\n        }\r\n        fb = exact\r\n            ? horner_exact_1.HornerExact(psExact.ps[diffCount], b)\r\n            : eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds(p, pE, b).r̂;\r\n        if (fb === 0) {\r\n            // Since evalK1MultiWithErrBounds is approximate the zero result\r\n            // cannot be fully trusted at this point.\r\n            // if we are already doing exact evaluations this is an exact root\r\n            if (exact) {\r\n                //(window as any).qcount++;\r\n                //(window as any).qtot += q;\r\n                //console.log('b', 0)\r\n                return [b, b];\r\n            }\r\n            // We need to calculate δ/2 to the left and right of b to get \r\n            // results that should usually be !== 0. \r\n            // It is a pre-filter. If the result === 0 we need to sharpen the\r\n            // ability of the evaluation by somehow reducing the error bound\r\n            let sL = Math.max(lb, b - δ); // dont overstep bounds\r\n            let sR = Math.min(ub, b + δ); // dont overstep bounds\r\n            // Note: sR - sL <= 2*δ provided lb, ub are in [-1..1] - usually \r\n            // (when sL === s - δ and sR === s + δ) sR - sL === 2*δ. Also δ > 0\r\n            let fsL = eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds(p, pE, sL).r̂;\r\n            let fsR = eval_k_multi_with_err_bounds_1.evalK1MultiWithErrBounds(p, pE, sR).r̂;\r\n            // if the evaluation method is strong enough return the result\r\n            if (fsL * fsR !== 0) {\r\n                //(window as any).qcount++;\r\n                //(window as any).qtot += q;\r\n                //console.log('c', sR-sL)\r\n                return [sL, sR];\r\n            }\r\n            // At this point either fsL or fsR === 0 so we need to sharpen the\r\n            // evaluation method\r\n            exact = true;\r\n            // get and cache the exact polynomial (we cache this since getting\r\n            // the exact polynomial takes about 15 times more time than getting\r\n            // the quad polynomial and we very rarely expect to get to this \r\n            // point)\r\n            psExact.ps = psExact.ps || getPsExact();\r\n            fb = horner_exact_1.HornerExact(psExact.ps[diffCount], b);\r\n            // if the exact evaluation returns 0 we have an exact root\r\n            if (fb === 0) {\r\n                //(window as any).qcount++;\r\n                //(window as any).qtot += q;\r\n                console.log('d', 0);\r\n                return [b, b];\r\n            }\r\n            // else we've got a new value for fb and from here on we use exact\r\n            // evaluations\r\n        }\r\n        if ((0 < fb && 0 < fc) || (fb <= 0 && fc <= 0)) {\r\n            c = a;\r\n            fc = fa;\r\n            e = b - a;\r\n            d = e;\r\n        }\r\n    }\r\n}\r\nexports.refineMultiWithErrBounds = refineMultiWithErrBounds;\r\n//# sourceMappingURL=refine-multi-with-err-bounds.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/refine-multi-with-err-bounds.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval-to-exp.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval-to-exp.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Converts a double precision root interval to a quad precision one (without)\r\n * @param ri a root interval\r\n */\r\nfunction rootIntervalToExp(ri) {\r\n    return {\r\n        tS: [0, ri.tS],\r\n        tE: [0, ri.tE],\r\n        multiplicity: ri.multiplicity\r\n    };\r\n}\r\nexports.rootIntervalToExp = rootIntervalToExp;\r\n//# sourceMappingURL=root-interval-to-exp.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval-to-exp.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction createRootExact(t) {\r\n    return { tS: t, tE: t /*, tM: t*/, multiplicity: 1 };\r\n}\r\nexports.createRootExact = createRootExact;\r\nfunction mid(ri) {\r\n    return (ri.tS + ri.tE) / 2;\r\n}\r\nexports.mid = mid;\r\n//# sourceMappingURL=root-interval.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/root-interval.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/multi-with-err-bound/transpose-poly.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/multi-with-err-bound/transpose-poly.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Transposes the given polynomial coefficients into multiple polynomials.\r\n * @param p\r\n */\r\nfunction transposePoly(p) {\r\n    // transpose the polynomial coefficients into multiple polynomials\r\n    let len = p[0].length;\r\n    let p_ = [];\r\n    for (let i = 0; i < len; i++) {\r\n        let _p = [];\r\n        for (let j = 0; j < p.length; j++) {\r\n            _p.push(p[j][len - (i + 1)]); // from highest to lowest\r\n        }\r\n        p_.push(_p);\r\n    }\r\n    return p_;\r\n}\r\nexports.transposePoly = transposePoly;\r\n//# sourceMappingURL=transpose-poly.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/multi-with-err-bound/transpose-poly.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/quadratic-roots.js":
/*!*************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/quadratic-roots.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Floating-point-stably calculates and returns the ordered quadratic\r\n * roots of the given quadratic polynomial.\r\n *\r\n * This function is included only because it might be slightly faster\r\n * than calling allRoots due to allRoots first checking if the\r\n * polynomial is quadratic and checking if the roots are within the\r\n * given range.\r\n * @param p the quadratic polynomial\r\n * @example\r\n * quadraticRoots([1, -3, 2]); //=> [1,2]\r\n */\r\nfunction quadraticRoots(p) {\r\n    let [a, b, c] = p;\r\n    let D = b * b - 4 * a * c;\r\n    if (D < 0) {\r\n        // No real roots;\r\n        return [];\r\n    }\r\n    if (D === 0) {\r\n        return [-b / (2 * a)];\r\n    }\r\n    D = Math.sqrt(D);\r\n    let root1;\r\n    let root2;\r\n    if (b >= 0) {\r\n        root1 = (-b - D) / (2 * a);\r\n        root2 = (2 * c) / (-b - D);\r\n    }\r\n    else {\r\n        root1 = (2 * c) / (-b + D);\r\n        root2 = (-b + D) / (2 * a);\r\n    }\r\n    if (root1 < root2) {\r\n        return [root1, root2];\r\n    }\r\n    return [root2, root1];\r\n}\r\nexports.quadraticRoots = quadraticRoots;\r\n//# sourceMappingURL=quadratic-roots.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/quadratic-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js":
/*!************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst reflect_about_y_axis_1 = __webpack_require__(/*! ../../change-variables/reflect-about-y-axis */ \"./node_modules/flo-poly/node/change-variables/reflect-about-y-axis.js\");\r\n/**\r\n * Returns a function that returns a negative root bound given a function that\r\n * returns a positive root bound.\r\n * @param positiveBoundFunction\r\n */\r\nfunction positiveToNegativeBound(positiveBoundFunction) {\r\n    return (p) => {\r\n        return -positiveBoundFunction(reflect_about_y_axis_1.reflectAboutYAxis(p));\r\n    };\r\n}\r\nexports.positiveToNegativeBound = positiveToNegativeBound;\r\n//# sourceMappingURL=positive-to-negative-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst negate_1 = __webpack_require__(/*! ../../basic/negate */ \"./node_modules/flo-poly/node/basic/negate.js\");\r\nconst upper_to_lower_bound_1 = __webpack_require__(/*! ./upper-to-lower-bound */ \"./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js\");\r\nconst positive_to_negative_bound_1 = __webpack_require__(/*! ./positive-to-negative-bound */ \"./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js\");\r\nconst POWERS = [\r\n    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,\r\n    65536, 131072, 262144, 524288, 1048576, 2097152\r\n];\r\n/**\r\n * Returns an upper bound for the positive real roots of the given\r\n * polynomial.\r\n *\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * @param p a polynomial\r\n * @example\r\n * positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\r\n * positiveRootUpperBound_LMQ([2,3]);           //=> 0\r\n * positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\r\nfunction positiveRootUpperBound_LMQ(p) {\r\n    let deg = p.length - 1;\r\n    if (deg < 1) {\r\n        return 0;\r\n    }\r\n    if (p[0] < 0) {\r\n        p = negate_1.negate(p);\r\n    }\r\n    let timesUsed = [];\r\n    for (let i = 0; i < deg; i++) {\r\n        timesUsed.push(1);\r\n    }\r\n    let ub = 0;\r\n    for (let m = 0; m <= deg; m++) {\r\n        if (p[m] >= 0) {\r\n            continue;\r\n        }\r\n        let tempub = Number.POSITIVE_INFINITY;\r\n        let any = false;\r\n        for (let k = 0; k < m; k++) {\r\n            if (p[k] <= 0) {\r\n                continue;\r\n            }\r\n            // Table lookup is about 70% faster but both are\r\n            // extemely fast anyway. \r\n            // Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\r\n            let pow = timesUsed[k];\r\n            let powres;\r\n            if (pow > 20) {\r\n                powres = Math.pow(2, pow);\r\n            }\r\n            else {\r\n                powres = POWERS[pow];\r\n            }\r\n            let temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\r\n            timesUsed[k]++;\r\n            if (tempub > temp) {\r\n                tempub = temp;\r\n            }\r\n            any = true;\r\n        }\r\n        if (any && ub < tempub)\r\n            ub = tempub;\r\n    }\r\n    return ub;\r\n}\r\nexports.positiveRootUpperBound_LMQ = positiveRootUpperBound_LMQ;\r\n/** Returns a positive lower bound of the roots of the given polynomial */\r\nlet positiveRootLowerBound_LMQ = upper_to_lower_bound_1.upperToLowerBound(positiveRootUpperBound_LMQ);\r\nexports.positiveRootLowerBound_LMQ = positiveRootLowerBound_LMQ;\r\n/**\r\n * Returns a negative upper (upper here means further from zero) bound of the\r\n * roots of the given polynomial .\r\n */\r\nlet negativeRootUpperBound_LMQ = positive_to_negative_bound_1.positiveToNegativeBound(positiveRootUpperBound_LMQ);\r\nexports.negativeRootUpperBound_LMQ = negativeRootUpperBound_LMQ;\r\n/**\r\n * Returns a negative lower (lower here means closer to zero) bound of the roots\r\n * of the given polynomial.\r\n */\r\nlet negativeRootLowerBound_LMQ = upper_to_lower_bound_1.upperToLowerBound(negativeRootUpperBound_LMQ);\r\nexports.negativeRootLowerBound_LMQ = negativeRootLowerBound_LMQ;\r\n//# sourceMappingURL=root-bounds-lmq.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * of the given polynomial using the near-optimal Fujiwara bound. Note\r\n * that the bound includes complex roots. The bound is tight but slow\r\n * due to usage of Math.pow().\r\n * See https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\r\n * @param p ahe polynomial.\r\n * @example\r\n * rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n */\r\nfunction rootMagnitudeUpperBound_fujiwara(p) {\r\n    let d = p.length - 1;\r\n    let an = p[0];\r\n    let bs = [];\r\n    for (let i = 1; i < d; i++) {\r\n        let b = Math.pow(Math.abs(p[i] / an), 1 / i);\r\n        bs.push(b);\r\n    }\r\n    bs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\r\n    return 2 * Math.max.apply(undefined, bs);\r\n}\r\nexports.rootMagnitudeUpperBound_fujiwara = rootMagnitudeUpperBound_fujiwara;\r\n//# sourceMappingURL=root-magnitude-upper-bound-fujiwara.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst p_inf_norm_1 = __webpack_require__(/*! ../../norm/p-inf-norm */ \"./node_modules/flo-poly/node/norm/p-inf-norm.js\");\r\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * (including complex roots) of the given polynomial using Rouche's Theorem with\r\n * k = n.\r\n *\r\n * This function is fast but the bound is not tight.\r\n * @param p a polynomial.\r\n */\r\nfunction rootMagnitudeUpperBound_rouche(p) {\r\n    return 1 + (p_inf_norm_1.pInfNorm(p.slice(1)) / p[0]);\r\n}\r\nexports.rootMagnitudeUpperBound_rouche = rootMagnitudeUpperBound_rouche;\r\n//# sourceMappingURL=root-magnitude-upper-bound-rouche.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst invert_1 = __webpack_require__(/*! ../../basic/invert */ \"./node_modules/flo-poly/node/basic/invert.js\");\r\n/**\r\n * Returns a function that returns a positive lower root bound given a function\r\n * that returns a positive upper root bound.\r\n * @param positiveUpperBoundFunction\r\n */\r\nfunction upperToLowerBound(positiveUpperBoundFunction) {\r\n    return (p) => {\r\n        let result = 1 / positiveUpperBoundFunction(invert_1.invert(p));\r\n        //console.log('upper to lower', result);\r\n        return result;\r\n    };\r\n}\r\nexports.upperToLowerBound = upperToLowerBound;\r\n//# sourceMappingURL=upper-to-lower-bound.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/standard/all-roots.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/standard/all-roots.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst brent_1 = __webpack_require__(/*! ./brent */ \"./node_modules/flo-poly/node/roots/standard/brent.js\");\r\nconst quadratic_roots_1 = __webpack_require__(/*! ../quadratic-roots */ \"./node_modules/flo-poly/node/roots/quadratic-roots.js\");\r\nconst root_bounds_lmq_1 = __webpack_require__(/*! ../root-bounds/root-bounds-lmq */ \"./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js\");\r\nconst remove_leading_zeros_1 = __webpack_require__(/*! ../../basic/remove-leading-zeros */ \"./node_modules/flo-poly/node/basic/remove-leading-zeros.js\");\r\nconst differentiate_1 = __webpack_require__(/*! ../../calculus/differentiate */ \"./node_modules/flo-poly/node/calculus/differentiate.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ../../evaluate/evaluate */ \"./node_modules/flo-poly/node/evaluate/evaluate.js\");\r\n/**\r\n * Finds an approximation to the real roots (or those within a range) of the\r\n * input polynomial.\r\n *\r\n * Multiple roots of even order that is close together may be missed.\r\n * @param p a polynomial\r\n * @param a lower limit of root values to be returned - defaults to -∞\r\n * @param b upper limit of root values to be returned - defaults to +∞\r\n * @example\r\n * allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4]\r\n */\r\nfunction allRoots(p, a = Number.NEGATIVE_INFINITY, b = Number.POSITIVE_INFINITY) {\r\n    p = remove_leading_zeros_1.removeLeadingZeros(p);\r\n    let d = p.length - 1;\r\n    let rangeFilter = inRange(a, b);\r\n    if (d === 2) {\r\n        return quadratic_roots_1.quadraticRoots(p)\r\n            .filter(rangeFilter);\r\n    }\r\n    else if (d >= 2) {\r\n        let lowerBound = a === Number.NEGATIVE_INFINITY\r\n            ? root_bounds_lmq_1.negativeRootUpperBound_LMQ(p)\r\n            : a;\r\n        let upperBound = b === Number.POSITIVE_INFINITY\r\n            ? root_bounds_lmq_1.positiveRootUpperBound_LMQ(p)\r\n            : b;\r\n        // If the roots of the differentiated polynomial is out of range \r\n        // then the roots of the polynomial itself will also be out of \r\n        // range.\r\n        let dp = differentiate_1.differentiate(p);\r\n        let roots = allRoots(dp, lowerBound, upperBound)\r\n            .filter(rangeFilter);\r\n        if (roots[0] !== lowerBound) {\r\n            // For code coverage to cover the 'else' case we would need\r\n            // to find a case where the lower bound actually matches the\r\n            // root which would be very rare - needs further \r\n            // investigation.\r\n            // Not an actual root.\r\n            roots.unshift(lowerBound);\r\n        }\r\n        if (roots[roots.length - 1] !== upperBound) {\r\n            // Not an actual root.\r\n            roots.push(upperBound);\r\n        }\r\n        return rootsWithin(p, roots);\r\n    }\r\n    else if (d === 1) {\r\n        // Less likely so put near bottom (micro optimization)\r\n        return [-p[1] / p[0]]\r\n            .filter(rangeFilter);\r\n    }\r\n    else if (d === 0) {\r\n        return []; // y = c -> no roots\t\r\n    }\r\n    // Least likely so put at bottom (micro optimization)\r\n    // d === -1\r\n    // y = 0 -> infinite number of roots\r\n    return [];\r\n}\r\nexports.allRoots = allRoots;\r\n/**\r\n * Returns a function that returns true if x is in the range [a,b].\r\n * @param a\r\n * @param b\r\n * @private\r\n */\r\nfunction inRange(a, b) {\r\n    return x => x >= a && x <= b;\r\n}\r\n/**\r\n * Finds all roots of the given polynomial within the given intervals.\r\n * @private\r\n * @param p\r\n * @param intervals\r\n */\r\nfunction rootsWithin(p, intervals) {\r\n    let roots = [];\r\n    let peval = evaluate_1.evaluate(p);\r\n    let prevRoot;\r\n    let a = intervals[0];\r\n    for (let i = 1; i < intervals.length; i++) {\r\n        let root;\r\n        let b = intervals[i];\r\n        let evA = peval(a);\r\n        let evB = peval(b);\r\n        let k = evA * evB;\r\n        if (k === 0) {\r\n            if (evA === 0) {\r\n                root = a;\r\n            }\r\n            else if (evB === 0 && i === intervals.length - 1) {\r\n                root = b;\r\n            }\r\n        }\r\n        else if (evA * evB < 0) {\r\n            root = brent_1.brent(peval, a, b);\r\n        }\r\n        // Add root if it exists and suppress exact duplicates\r\n        if (root !== undefined && root !== prevRoot) {\r\n            roots.push(root);\r\n            prevRoot = root;\r\n        }\r\n        a = b;\r\n    }\r\n    return roots;\r\n}\r\n//# sourceMappingURL=all-roots.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/standard/all-roots.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/standard/bisection.js":
/*!****************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/standard/bisection.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Searches an interval (a,b) for a root (i.e. zero) of the\r\n * given function with respect to its first argument using the Bisection\r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed.\r\n *\r\n * Note: This function has no advantages above the Brent method except\r\n * for its simpler implementation and can be much slower. Use brent\r\n * instead.\r\n * @param f the function for which the root is sought.\r\n * @param a the lower limit of the search interval.\r\n * @param b the upper limit of the search interval.\r\n * @example\r\n * let p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = evaluate(p);\r\n * bisection(f,2.2,3.8); //=> 3\r\n * bisection(f,2.2,3.1); //=> 3.0000000000000044\r\n */\r\nfunction bisection(f, a, b) {\r\n    if (a === b) {\r\n        // Presumably the root is already found.\r\n        return a;\r\n    }\r\n    else if (b < a) {\r\n        [a, b] = [b, a]; // Swap a and b \r\n    }\r\n    let fa = f(a);\r\n    let fb = f(b);\r\n    if (fa === 0) {\r\n        return a;\r\n    }\r\n    if (fb === 0) {\r\n        return b;\r\n    }\r\n    if (fa * fb > 0) {\r\n        // Root is not bracketed - this is a precondition.\r\n        throw new Error('Root not bracketed');\r\n    }\r\n    while (true) {\r\n        let c = a + (b - a) / 2; // Take midpoint\r\n        let fc = f(c);\r\n        if (fc === 0) {\r\n            return c;\r\n        }\r\n        if (fa * fc < 0) {\r\n            b = c;\r\n        }\r\n        else {\r\n            a = c;\r\n        }\r\n        // We don't add Number.EPSILON in the line below because we want\r\n        // accuracy to improve even below 1.\r\n        let δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\r\n        if (Math.abs(a - b) <= δ) {\r\n            return b;\r\n        }\r\n    }\r\n}\r\nexports.bisection = bisection;\r\n//# sourceMappingURL=bisection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/standard/bisection.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/roots/standard/brent.js":
/*!************************************************************!*\
  !*** ./node_modules/flo-poly/node/roots/standard/brent.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Searches an interval (a,b) for a root (i.e. zero) of the\r\n * given function with respect to its first argument using the Brent's\r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed.\r\n *\r\n * Brent's Method is an excellent root-finding choice since:\r\n * * guaranteed to converge (unlike the Newton and other so-called\r\n * single-point methods),\r\n * * converges in a reasonable number of iterations even for highly contrived\r\n * functions (unlike Dekker's Method) and\r\n * * nearly always converges fast, i.e. super-linearly (unlike the Secant and\r\n * Regula-Falsi methods).\r\n *\r\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\r\n * after each iteration where b is the max of the current 2 best\r\n * guesses.\r\n *\r\n * See https://en.wikipedia.org/wiki/Brent%27s_method\r\n * See Brent (page 47) https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\r\n * @param f the function for which the root is sought.\r\n * @param a the lower limit of the search interval.\r\n * @param b the upper limit of the search interval.\r\n * @example\r\n * let p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = evaluate(p);\r\n * brent(f,2.2,3.8); //=> 3.000000000000003\r\n * brent(f,2.2,3.1); //=> 3.000000000000001\r\n */\r\nfunction brent(f, a, b) {\r\n    if (a === b) {\r\n        // Presumably the root is already found.\r\n        return a;\r\n    }\r\n    // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \r\n    let fa = f(a);\r\n    let fb = f(b);\r\n    if (fa * fb > 0) {\r\n        // Root is not bracketed - this is a precondition.\r\n        throw new Error('Root not bracketed');\r\n    }\r\n    let c; // Value of previous guess - set to a initially \r\n    if (Math.abs(fa) < Math.abs(fb)) {\r\n        // Swap a,b\r\n        c = a;\r\n        a = b;\r\n        b = c;\r\n        // Swap fa,fb\r\n        let temp = fa;\r\n        fa = fb;\r\n        fb = temp;\r\n    }\r\n    c = a;\r\n    let mflag = true;\r\n    let d; // Value of guess before previous guess\r\n    while (true) {\r\n        let δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\r\n        let fc = f(c);\r\n        // Calculate provisional interpolation value\r\n        let s;\r\n        if (fa !== fc && fb !== fc) {\r\n            // 3 points available - inverse quadratic interpolation\r\n            let fac = fa - fc;\r\n            let fab = fa - fb;\r\n            let fbc = fb - fc;\r\n            // The below has been multiplied out to speed up the algorithm.\r\n            /*s = ((a * fb * fc) / ( fab * fac)) +\r\n                  ((b * fa * fc) / (-fab * fbc)) +\r\n                  ((c * fa * fb) / ( fac * fbc));*/\r\n            s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\r\n        }\r\n        else {\r\n            // only 2 points available - secant method\r\n            s = b - (fb * ((b - a) / (fb - fa)));\r\n        }\r\n        let t1 = (3 * a + b) / 4;\r\n        let b_c = Math.abs(b - c);\r\n        let s_b = Math.abs(s - b);\r\n        let c_d = Math.abs(c - d); // c_d will not be used on first iteration\r\n        if ((!( // condition 1\r\n        (s > t1 && s < b) ||\r\n            (s < t1 && s > b))) ||\r\n            (mflag && (\r\n            // condition 2\r\n            (s_b >= b_c / 2) ||\r\n                // condition 4\r\n                (b_c < δ))) ||\r\n            (!mflag && (\r\n            // condition 3\r\n            (s_b >= c_d / 2) ||\r\n                // condition 5\r\n                (c_d < δ)))) {\r\n            // Bisection\r\n            s = (a + b) / 2;\r\n            mflag = true;\r\n        }\r\n        else {\r\n            mflag = false;\r\n        }\r\n        let fs = f(s);\r\n        d = c;\r\n        c = b;\r\n        if (fa * fs < 0) {\r\n            b = s;\r\n        }\r\n        else {\r\n            a = s;\r\n        }\r\n        if (Math.abs(fa) < Math.abs(fb)) {\r\n            // Swap a,b\r\n            let temp = a;\r\n            a = b;\r\n            b = temp;\r\n        }\r\n        if (fb === 0) {\r\n            return b;\r\n        }\r\n        if (fs === 0) {\r\n            return s;\r\n        }\r\n        if (Math.abs(a - b) <= δ) {\r\n            return b;\r\n        }\r\n        fa = f(a);\r\n        fb = f(b);\r\n    }\r\n}\r\nexports.brent = brent;\r\n//# sourceMappingURL=brent.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/roots/standard/brent.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the result of scaling the given float by a power of two such that\r\n * it becomes an integer - the smallest such integer is returned.\r\n * @param a a floating point number\r\n */\r\nfunction scaleFloatToInt(a) {\r\n    return a * Math.pow(2, (-flo_numerical_1.exponent(a) + flo_numerical_1.bitLength(a) - 1));\r\n}\r\nexports.scaleFloatToInt = scaleFloatToInt;\r\n//# sourceMappingURL=scale-float-to-int.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the result of scaling the given floats by a power of two such that\r\n * all floats become integers - can be used to scale floating point expansions\r\n * and polynomials\r\n * @param a a floating point number\r\n */\r\nfunction scaleFloatsToInts(as) {\r\n    let e = -1024;\r\n    for (let i = 0; i < as.length; i++) {\r\n        let a = as[i];\r\n        let scaleFactor = -flo_numerical_1.exponent(a) + flo_numerical_1.bitLength(a) - 1;\r\n        if (scaleFactor > e) {\r\n            e = scaleFactor;\r\n        }\r\n    }\r\n    return as.map(a => a * Math.pow(2, e));\r\n}\r\nexports.scaleFloatsToInts = scaleFloatsToInts;\r\n//# sourceMappingURL=scale-floats-to-ints.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js?");

/***/ }),

/***/ "./node_modules/flo-poly/node/scale-to-int/scale-poly-to-ints.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flo-poly/node/scale-to-int/scale-poly-to-ints.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\n/**\r\n * Returns the result of scaling the given floats by a power of two such that\r\n * all floats become integers - can be used to scale floating point expansions\r\n * and polynomials\r\n * @param a a floating point number\r\n */\r\nfunction scalePolyToIntsExp(p) {\r\n    let e = -1024;\r\n    for (let i = 0; i < p.length; i++) {\r\n        let c = p[i];\r\n        for (let j = 0; j < c.length; j++) {\r\n            let a = c[j];\r\n            let scaleFactor = -flo_numerical_1.exponent(a) + flo_numerical_1.bitLength(a) - 1;\r\n            if (scaleFactor > e) {\r\n                e = scaleFactor;\r\n            }\r\n        }\r\n    }\r\n    return p.map(c => c.map(a => a * Math.pow(2, e)));\r\n}\r\nexports.scalePolyToIntsExp = scalePolyToIntsExp;\r\n//# sourceMappingURL=scale-poly-to-ints.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-poly/node/scale-to-int/scale-poly-to-ints.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/index.js":
/*!*************************************************!*\
  !*** ./node_modules/flo-vector2d/node/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flo_numerical_1 = __webpack_require__(/*! flo-numerical */ \"./node_modules/flo-numerical/node/index.js\");\r\nconst line_line_intersection_1 = __webpack_require__(/*! ./line-line-intersection */ \"./node_modules/flo-vector2d/node/line-line-intersection.js\");\r\nexports.lineLineIntersection = line_line_intersection_1.lineLineIntersection;\r\n/**\r\n* Creates a transformation function that operates on multiple points from the\r\n* given arity two function.\r\n* @private\r\n*/\r\nfunction mapCurry2(f) {\r\n    function g(t, us) {\r\n        let h = f(t);\r\n        let hUs = (us) => us.map(h);\r\n        // Curry the function\r\n        return us === undefined ? hUs : hUs(us);\r\n    }\r\n    return g;\r\n}\r\n/**\r\n* Creates a transformation function that operates on multiple points from the\r\n* given arity 3 curried function (keeping the first two parameters uncurried).\r\n* @private\r\n*/\r\nfunction specialMapCurry(f) {\r\n    function g(s, t, us) {\r\n        let h = f(s, t);\r\n        let hUs = (us) => us.map(h);\r\n        // Curry the function\r\n        return us === undefined ? hUs : hUs(us);\r\n    }\r\n    return g;\r\n}\r\n/**\r\n * Returns the dot (inner) product between two 2-vectors.\r\n * @param a the first vector\r\n * @param b the second vector\r\n */\r\nfunction dot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n}\r\nexports.dot = dot;\r\n/**\r\n * Returns the cross product signed magnitude between two 2-vectors.\r\n * @param a - The first vector\r\n * @param b - The second vector\r\n */\r\nfunction cross(a, b) {\r\n    return a[0] * b[1] - a[1] * b[0];\r\n}\r\nexports.cross = cross;\r\n/**\r\n * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\r\n * ccw < 0, and colinear if ccw === 0 because ccw is a determinant that gives\r\n * twice the signed area of the triangle formed by the points a, b and c.\r\n * @param a The first point\r\n * @param b The second point\r\n * @param c The third point\r\n */\r\nfunction ccw(a, b, c) {\r\n    return flo_numerical_1.orient2d(a, b, c);\r\n}\r\nexports.ccw = ccw;\r\n/**\r\n* Returns the point where two line segments intersect or undefined if they\r\n* don't intersect or if they intersect at infinitely many points.\r\n* See Geometric primitves http://algs4.cs.princeton.edu/91primitives\r\n* @param ab The first line\r\n* @param cd The second line\r\n*/\r\nfunction segSegIntersection(ab, cd) {\r\n    let [a, b] = ab;\r\n    let [c, d] = cd;\r\n    let [a0, a1] = a;\r\n    let [b0, b1] = b;\r\n    let [c0, c1] = c;\r\n    let [d0, d1] = d;\r\n    //let denom  = (b[0] - a[0])*(d[1] - c[1]) - (b[1] - a[1])*(d[0] - c[0]);\r\n    let denom = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b0, a0), flo_numerical_1.twoDiff(d1, c1)), flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b1, a1), flo_numerical_1.twoDiff(d0, c0)));\r\n    //let rNumer = (a[1] - c[1])*(d[0] - c[0]) - (a[0] - c[0])*(d[1] - c[1]);\r\n    let rNumer = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a1, c1), flo_numerical_1.twoDiff(d0, c0)), flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a0, c0), flo_numerical_1.twoDiff(d1, c1)));\r\n    //let sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]); \r\n    let sNumer = flo_numerical_1.expansionDiff(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a1, c1), flo_numerical_1.twoDiff(b0, a0)), flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(a0, c0), flo_numerical_1.twoDiff(b1, a1)));\r\n    if (denom[denom.length - 1] === 0) {\r\n        // parallel\r\n        if (rNumer[rNumer.length - 1] === 0) {\r\n            // collinear\r\n            // TODO Check if x-projections and y-projections intersect\r\n            // and return the line of intersection if they do.\r\n            return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n    //let r = rNumer / denom;\r\n    //let s = sNumer / denom;\r\n    // if (0 <= r && r <= 1 && 0 <= s && s <= 1)\r\n    if (flo_numerical_1.sign(rNumer) * flo_numerical_1.sign(denom) >= 0 && flo_numerical_1.compare(flo_numerical_1.abs(denom), flo_numerical_1.abs(rNumer)) >= 0 &&\r\n        flo_numerical_1.sign(sNumer) * flo_numerical_1.sign(denom) >= 0 && flo_numerical_1.compare(flo_numerical_1.abs(denom), flo_numerical_1.abs(sNumer)) >= 0) {\r\n        let r = flo_numerical_1.estimate(rNumer) / flo_numerical_1.estimate(denom);\r\n        //return [a0 + r*(b0 - a0), a1 + r*(b1 - a1)];\r\n        return [\r\n            flo_numerical_1.estimate(flo_numerical_1.twoSum(flo_numerical_1.estimate(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b0, a0), rNumer)) / flo_numerical_1.estimate(denom), a0)),\r\n            flo_numerical_1.estimate(flo_numerical_1.twoSum(flo_numerical_1.estimate(flo_numerical_1.expansionProduct(flo_numerical_1.twoDiff(b1, a1), rNumer)) / flo_numerical_1.estimate(denom), a1))\r\n        ];\r\n    }\r\n    return undefined;\r\n}\r\nexports.segSegIntersection = segSegIntersection;\r\n/**\r\n * Returns true if the two given 2d line segments intersect, false otherwise.\r\n *\r\n * Robust: uses exact adaptive floating point arithmetic.\r\n *\r\n * @param a A line segment\r\n * @param b Another line segment\r\n */\r\nfunction doesSegSegIntersect(a, b) {\r\n    if ((flo_numerical_1.orient2d(a[0], a[1], b[0]) * flo_numerical_1.orient2d(a[0], a[1], b[1])) > 0) {\r\n        return false;\r\n    }\r\n    if ((flo_numerical_1.orient2d(b[0], b[1], a[0]) * flo_numerical_1.orient2d(b[0], b[1], a[1])) > 0) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.doesSegSegIntersect = doesSegSegIntersect;\r\n/**\r\n* Returns the squared distance between two 2d points.\r\n* @param p1 A point\r\n* @param p2 Another point\r\n*/\r\nfunction squaredDistanceBetween(p1, p2) {\r\n    let x = p2[0] - p1[0];\r\n    let y = p2[1] - p1[1];\r\n    return x * x + y * y;\r\n}\r\nexports.squaredDistanceBetween = squaredDistanceBetween;\r\n/**\r\n* Returns a scaled version of the given 2-vector.\r\n* @param p - A vector\r\n* @param factor - A scale factor\r\n*/\r\nfunction scale(p, factor) {\r\n    return [p[0] * factor, p[1] * factor];\r\n}\r\nexports.scale = scale;\r\n/**\r\n* Returns the given 2-vector reversed.\r\n* @param p - A vector\r\n*/\r\nfunction reverse(p) {\r\n    return [-p[0], -p[1]];\r\n}\r\nexports.reverse = reverse;\r\n/**\r\n* Returns the given 2-vector scaled to a length of one.\r\n* @param p - A vector\r\n*/\r\nfunction toUnitVector(p) {\r\n    let scaleFactor = 1 / (Math.sqrt(p[0] * p[0] + p[1] * p[1]));\r\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\r\n}\r\nexports.toUnitVector = toUnitVector;\r\n/**\r\n* Returns the given 2-vector scaled to the given length.\r\n* @param p - A vector\r\n* @param length - The length to scale to\r\n*/\r\nfunction toLength(p, length) {\r\n    let scaleFactor = length / len(p);\r\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\r\n}\r\nexports.toLength = toLength;\r\n/**\r\n* Returns the second 2-vector minus the first.\r\n* @param p1 - The first vector\r\n* @param p2 - The second vector\r\n*/\r\nfunction fromTo(p1, p2) {\r\n    return [p2[0] - p1[0], p2[1] - p1[1]];\r\n}\r\nexports.fromTo = fromTo;\r\n/**\r\n* Performs linear interpolation between two 2d points and returns the resultant point.\r\n* @param p1 - The first point.\r\n* @param p2 - The second point.\r\n* @param t - The interpolation fraction (often in [0,1]).\r\n*/\r\nfunction interpolate(p1, p2, t) {\r\n    return [\r\n        p1[0] + (p2[0] - p1[0]) * t,\r\n        p1[1] + (p2[1] - p1[1]) * t\r\n    ];\r\n}\r\nexports.interpolate = interpolate;\r\n/**\r\n* Returns the mean of two 2d points.\r\n* @param ps - The two points\r\n*/\r\nfunction mean(ps) {\r\n    let p1 = ps[0];\r\n    let p2 = ps[1];\r\n    return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\r\n}\r\nexports.mean = mean;\r\n/**\r\n* Returns the distance between two 2d points.\r\n* @param p1 - A point.\r\n* @param p2 - Another point.\r\n*/\r\nfunction distanceBetween(p1, p2) {\r\n    return Math.sqrt(squaredDistanceBetween(p1, p2));\r\n}\r\nexports.distanceBetween = distanceBetween;\r\n/**\r\n* Returns the length of the given 2-vector.\r\n* @param p A 2d vector\r\n*/\r\nfunction len(p) {\r\n    return Math.sqrt(p[0] * p[0] + p[1] * p[1]);\r\n}\r\nexports.len = len;\r\n/**\r\n* Returns the squared length of the given 2-vector.\r\n* @param p - A vector\r\n*/\r\nfunction lengthSquared(v) {\r\n    return v[0] * v[0] + v[1] * v[1];\r\n}\r\nexports.lengthSquared = lengthSquared;\r\n/**\r\n* Returns the Manhattan distance between two 2d points.\r\n* @param p1 - A point.\r\n* @param p2 - Another point.\r\n*/\r\nfunction manhattanDistanceBetween(p1, p2) {\r\n    return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\r\n}\r\nexports.manhattanDistanceBetween = manhattanDistanceBetween;\r\n/**\r\n* Returns the Manhattan length of the given 2-vector.\r\n* @param p - A vector\r\n*/\r\nfunction manhattanLength(p) {\r\n    return Math.abs(p[0]) + Math.abs(p[1]);\r\n}\r\nexports.manhattanLength = manhattanLength;\r\n/**\r\n* <p>\r\n* Returns the distance between the given point and line.\r\n* </p>\r\n* <p>\r\n* See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\r\n* this Wikipedia article</a>\r\n* </p>\r\n* @param p - A point\r\n* @param l - A line\r\n*/\r\nfunction distanceBetweenPointAndLine(p, l) {\r\n    let [x0, y0] = p;\r\n    let [[x1, y1], [x2, y2]] = l;\r\n    let y = y2 - y1;\r\n    let x = x2 - x1;\r\n    let a = (y * x0 - x * y0 + x2 * y1 - y2 * x1);\r\n    let b = Math.sqrt(x * x + y * y);\r\n    return Math.abs(a / b);\r\n}\r\nexports.distanceBetweenPointAndLine = distanceBetweenPointAndLine;\r\n/**\r\n* Returns the squared distance between the given point and line segment.\r\n* @param p - A point\r\n* @param l - A line\r\n*/\r\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\r\n    const sqDst = squaredDistanceBetween;\r\n    let v = l[0];\r\n    let w = l[1];\r\n    let l2 = sqDst(v, w);\r\n    if (l2 == 0) {\r\n        return sqDst(p, v);\r\n    }\r\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\r\n    t = Math.max(0, Math.min(1, t));\r\n    let d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\r\n    return d2;\r\n}\r\nexports.squaredDistanceBetweenPointAndLineSegment = squaredDistanceBetweenPointAndLineSegment;\r\n/**\r\n* Returns the circumcenter of the given 2d triangle.\r\n* @param triangle\r\n*/\r\nfunction circumCenter(triangle) {\r\n    // See wikipedia\r\n    let p1 = triangle[0];\r\n    let p2 = triangle[1];\r\n    let p3 = triangle[2];\r\n    const sqLen = lengthSquared;\r\n    let Sx = 0.5 * det3([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\r\n    let Sy = 0.5 * det3([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\r\n    let a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\r\n    /*\r\n    let b = det3(\r\n            [p1[0], p1[1], sqLen(p1)],\r\n            [p2[0], p2[1], sqLen(p2)],\r\n            [p3[0], p3[1], sqLen(p3)]\r\n    );\r\n    */\r\n    return [Sx / a, Sy / a];\r\n}\r\nexports.circumCenter = circumCenter;\r\n/**\r\n* <p>\r\n* Returns the incenter of the given triangle.\r\n* </p>\r\n* <p>\r\n* See Wikipedia - https://en.wikipedia.org/wiki/Incenter\r\n* </p>\r\n* @param triangle\r\n*/\r\nfunction inCenter(triangle) {\r\n    const dst = distanceBetween;\r\n    let p1 = triangle[0];\r\n    let p2 = triangle[1];\r\n    let p3 = triangle[2];\r\n    let l1 = dst(p2, p3);\r\n    let l2 = dst(p1, p3);\r\n    let l3 = dst(p1, p2);\r\n    let lengthSum = l1 + l2 + l3;\r\n    return [\r\n        (l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum,\r\n        (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum\r\n    ];\r\n}\r\nexports.inCenter = inCenter;\r\n/**\r\n* Returns the centroid of the given polygon, e.g. triangle. The polygon\r\n* must be simple, i.e. not self-intersecting.\r\n* @param polygon_\r\n*/\r\nfunction centroid(polygon) {\r\n    let polygon_ = [];\r\n    if (polygon.length === 1) {\r\n        return polygon[0];\r\n    }\r\n    // remove duplicate points\r\n    let prevP = polygon[polygon.length - 1];\r\n    for (let i = 0; i < polygon.length; i++) {\r\n        let [_x, _y] = prevP;\r\n        let [x, y] = polygon[i];\r\n        prevP = [x, y];\r\n        if (x !== _x || y !== _y) {\r\n            polygon_.push([x, y]);\r\n        }\r\n    }\r\n    if (polygon_.length === 2) {\r\n        let p1 = polygon_[0];\r\n        let p2 = polygon_[1];\r\n        let x = p1[0] + p2[0];\r\n        let y = p1[1] + p2[1];\r\n        return [x / 2, y / 2];\r\n    }\r\n    if (polygon_.length === 3) {\r\n        let p1 = polygon_[0];\r\n        let p2 = polygon_[1];\r\n        let p3 = polygon_[2];\r\n        let x = p1[0] + p2[0] + p3[0];\r\n        let y = p1[1] + p2[1] + p3[1];\r\n        return [x / 3, y / 3];\r\n    }\r\n    // polygon.length assumed > 3 and assumed to be non-self-intersecting\r\n    // See wikipedia\r\n    // First calculate the area, A, of the polygon\r\n    let A = 0;\r\n    for (let i = 0; i < polygon_.length; i++) {\r\n        let p0 = polygon_[i];\r\n        let p1 = (i === polygon_.length - 1)\r\n            ? polygon_[0]\r\n            : polygon_[i + 1];\r\n        A = A + (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    A = A / 2;\r\n    let C = [0, 0];\r\n    for (let i = 0; i < polygon_.length; i++) {\r\n        let p0 = polygon_[i];\r\n        let p1 = (i === polygon_.length - 1)\r\n            ? polygon_[0]\r\n            : polygon_[i + 1];\r\n        C[0] = C[0] + (p0[0] + p1[0]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n        C[1] = C[1] + (p0[1] + p1[1]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    return [C[0] / (6 * A), C[1] / (6 * A)];\r\n}\r\nexports.centroid = centroid;\r\n/**\r\n* Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\r\n* @ignore\r\n* @param x - A 2d vector\r\n* @param y - Another 2d vector\r\n* @param z - Another 2d vector\r\n*/\r\nfunction det3(x, y, z) {\r\n    return (x[0] * (y[1] * z[2] - y[2] * z[1])) -\r\n        (x[1] * (y[0] * z[2] - y[2] * z[0])) +\r\n        (x[2] * (y[0] * z[1] - y[1] * z[0]));\r\n}\r\nexports.det3 = det3;\r\nfunction translate(a, b) {\r\n    function f(b) {\r\n        return [a[0] + b[0], a[1] + b[1]];\r\n    }\r\n    // Curry the function\r\n    return b === undefined ? f : f(b);\r\n}\r\nexports.translate = translate;\r\n/**\r\n* Return the given 2d points translated by the given 2d vector. This\r\n* function is curried.\r\n* @param v\r\n* @param ps\r\n*/\r\nlet translatePs = mapCurry2(translate);\r\nexports.translatePs = translatePs;\r\n/**\r\n* Return the given 2d points translated by the given 2d vector. This function\r\n* is curried.\r\n* @param sinθ\r\n* @param cosθ\r\n* @param ps\r\n*/\r\nlet rotatePs = specialMapCurry(rotate);\r\nexports.rotatePs = rotatePs;\r\nfunction rotate(sinθ, cosθ, p) {\r\n    let a = translatePs([1, 2]);\r\n    function rotateByθ(p) {\r\n        return [\r\n            p[0] * cosθ - p[1] * sinθ,\r\n            p[0] * sinθ + p[1] * cosθ\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? rotateByθ : rotateByθ(p);\r\n}\r\nexports.rotate = rotate;\r\n/**\r\n* Returns true if two 2-vectors are identical (by value), false otherwise.\r\n* @param a - A 2d vector\r\n* @param b - Another 2d vector\r\n*/\r\nfunction equal(a, b) {\r\n    return (a[0] === b[0] && a[1] === b[1]);\r\n}\r\nexports.equal = equal;\r\n/**\r\n* Returns a anti-clockwise rotated version of the given 2-vector given the\r\n* sine and cosine of the angle.\r\n* @param p - A 2d vector\r\n* @param sinθ\r\n* @param cosθ\r\n*/\r\nfunction reverseRotate(sinθ, cosθ, p) {\r\n    return [\r\n        +p[0] * cosθ + p[1] * sinθ,\r\n        -p[0] * sinθ + p[1] * cosθ\r\n    ];\r\n}\r\nexports.reverseRotate = reverseRotate;\r\n/**\r\n* Returns a 90 degrees rotated version of the given 2-vector.\r\n* @param p - A 2d vector\r\n*/\r\nfunction rotate90Degrees(p) {\r\n    return [-p[1], p[0]];\r\n}\r\nexports.rotate90Degrees = rotate90Degrees;\r\n/**\r\n* Returns a negative 90 degrees rotated version of the given 2-vector.\r\n* @param p - A 2d vector\r\n*/\r\nfunction rotateNeg90Degrees(p) {\r\n    return [p[1], -p[0]];\r\n}\r\nexports.rotateNeg90Degrees = rotateNeg90Degrees;\r\n/**\r\n * Returns the closest point to the array of 2d points or if the array is empty\r\n * returns undefined.\r\n * @param p\r\n * @param ps\r\n */\r\nfunction getClosestTo(p, ps) {\r\n    let closestPoint = undefined;\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let q = ps[i];\r\n        let d = squaredDistanceBetween(p, q);\r\n        if (d < closestDistance) {\r\n            closestPoint = q;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestPoint;\r\n}\r\nexports.getClosestTo = getClosestTo;\r\n/**\r\n * Returns the closest point to the array of 2d points by providing a distance\r\n * function. If the given array is empty, returns undefined.\r\n * @param p\r\n * @param ps\r\n * @param f a function that takes the object and returns a point in order to\r\n * apply the Euclidian distance.\r\n */\r\nfunction getObjClosestTo(p, ps, f) {\r\n    let closestObj = undefined; // Closest Point\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let o = ps[i];\r\n        let d = squaredDistanceBetween(p, f(o));\r\n        if (d < closestDistance) {\r\n            closestObj = o;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestObj;\r\n}\r\nexports.getObjClosestTo = getObjClosestTo;\r\n/**\r\n* Returns an array of points by applying a translation and then rotation to\r\n* the given points.\r\n* @param v - The translation vector\r\n* @param sinθ\r\n* @param cosθ\r\n* @param ps - The input points\r\n**/\r\nfunction translateThenRotatePs(v, sinθ, cosθ, ps) {\r\n    const f = translate(v);\r\n    return ps.map(p => rotate(sinθ, cosθ, f(p)));\r\n}\r\nexports.translateThenRotatePs = translateThenRotatePs;\r\n/**\r\n* Returns an array of points by applying a rotation and then translation to\r\n* the given points.\r\n* @param sinθ\r\n* @param cosθ\r\n* @param v - The translation vector\r\n* @param ps - The input points\r\n**/\r\nfunction rotateThenTranslatePs(sinθ, cosθ, v, ps) {\r\n    return ps.map(p => translate(v, rotate(sinθ, cosθ, p)));\r\n}\r\nexports.rotateThenTranslatePs = rotateThenTranslatePs;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-vector2d/node/index.js?");

/***/ }),

/***/ "./node_modules/flo-vector2d/node/line-line-intersection.js":
/*!******************************************************************!*\
  !*** ./node_modules/flo-vector2d/node/line-line-intersection.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or undefined if they don't intersect or are the same line.\r\n * see Wikipedia https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\r\n * @param l1 A line\r\n * @param l2 Another line\r\n */\r\nfunction lineLineIntersection(l1, l2) {\r\n    let [[x1, y1], [x2, y2]] = l1;\r\n    let [[x3, y3], [x4, y4]] = l2;\r\n    let x1_ = x2 - x1;\r\n    let y1_ = y2 - y1;\r\n    let x2_ = x4 - x3;\r\n    let y2_ = y4 - y3;\r\n    let denom = x2_ * y1_ - y2_ * x1_;\r\n    if (denom === 0) {\r\n        // parallel\r\n        return undefined;\r\n    }\r\n    let b = ((y3 - y1) * x1_ - (x3 - x1) * y1_) / denom;\r\n    return [\r\n        x3 + b * x2_,\r\n        y3 + b * y2_\r\n    ];\r\n}\r\nexports.lineLineIntersection = lineLineIntersection;\r\n//# sourceMappingURL=line-line-intersection.js.map\n\n//# sourceURL=webpack:///./node_modules/flo-vector2d/node/line-line-intersection.js?");

/***/ })

/******/ });